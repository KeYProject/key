# This files contains representation of taclets, which are accepted and revised.
# Date: Fri Jul 21 14:53:13 CEST 2023

== abortJavaCardTransactionAPI (abortJavaCardTransactionAPI) =========================================
abortJavaCardTransactionAPI {
\find(==>#allmodal ( (modal operator))\[{ ..
  #jcsystemType.#abortTransaction()@#jcsystemType;
... }\] (post))
\replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #abortJavaCardTransaction;
... }\] (post)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== abortJavaCardTransactionBox (abortJavaCardTransaction) =========================================
abortJavaCardTransactionBox {
\find(==>box_transaction\[{ ..
  #abortJavaCardTransaction;
... }\] (post))
\replacewith([]==>[update-application(elem-update(heap)(anon(savedHeap,allObjects(java.lang.Object::<transactionConditionallyUpdated>),heap)),box(post))]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== abortJavaCardTransactionDiamond (abortJavaCardTransaction) =========================================
abortJavaCardTransactionDiamond {
\find(==>diamond_transaction\[{ ..
  #abortJavaCardTransaction;
... }\] (post))
\replacewith([]==>[update-application(elem-update(heap)(anon(savedHeap,allObjects(java.lang.Object::<transactionConditionallyUpdated>),heap)),diamond(post))]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== accDefinition (accDefinition) =========================================
accDefinition {
\find(acc(h,s,o,o2))
\varcond(\notFreeIn(fv (variable), o2 (deltaObject term)), \notFreeIn(fv (variable), o (java.lang.Object term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(fv (variable), h (Heap term)))
\replacewith(and(and(not(equals(o,null)),not(equals(o2,null))),exists{fv (variable)}(and(elementOf(o,fv,s),equals(deltaObject::select(h,o,fv),o2))))) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== acosIsNaN (acosIsNaN) =========================================
acosIsNaN {
\find(acosDouble(arg))
\add [imp(or(or(doubleIsNaN(arg),ltDouble(arg,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))),gtDouble(arg,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),doubleIsNaN(acosDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== acosRange (acosRange) =========================================
acosRange {
\find(acosDouble(arg))
\add [imp(and(geqDouble(arg,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),leqDouble(arg,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),and(geqDouble(acosDouble(arg),DFP(0(#))),leqDouble(acosDouble(arg),DFP(8(4(8(5(4(0(2(5(5(6(5(6(6(5(2(4(1(6(4(#)))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== activeUseAddition (activeUse) =========================================
activeUseAddition {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left + #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left + #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseBitwiseAnd (activeUse) =========================================
activeUseBitwiseAnd {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left & #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left & #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseBitwiseNegation (activeUse) =========================================
activeUseBitwiseNegation {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = ~#left;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = ~#left;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseBitwiseOr (activeUse) =========================================
activeUseBitwiseOr {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left | #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left | #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseBitwiseXOr (activeUse) =========================================
activeUseBitwiseXOr {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left ^ #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left ^ #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseByteCast (activeUse) =========================================
activeUseByteCast {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = (byte) #seShortIntLong;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = (byte) #seShortIntLong;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseCharCast (activeUse) =========================================
activeUseCharCast {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = (char) #seByteShortIntLong;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = (char) #seByteShortIntLong;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseDivision (activeUse) =========================================
activeUseDivision {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left / #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left / #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseIntCast (activeUse) =========================================
activeUseIntCast {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = (int) #seLong;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = (int) #seLong;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseModulo (activeUse) =========================================
activeUseModulo {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left % #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left % #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseMultiplication (activeUse) =========================================
activeUseMultiplication {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left * #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left * #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseShiftLeft (activeUse) =========================================
activeUseShiftLeft {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left << #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left << #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseShiftRight (activeUse) =========================================
activeUseShiftRight {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left >> #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left >> #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseShortCast (activeUse) =========================================
activeUseShortCast {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = (short) #seIntLong;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = (short) #seIntLong;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseStaticFieldReadAccess (activeUse) =========================================
activeUseStaticFieldReadAccess {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #sv;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = @(#sv);
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseStaticFieldReadAccess2 (activeUse) =========================================
activeUseStaticFieldReadAccess2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #v.#sv;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = @(#sv);
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseStaticFieldWriteAccess (activeUse) =========================================
activeUseStaticFieldWriteAccess {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseStaticFieldWriteAccess2 (activeUse) =========================================
activeUseStaticFieldWriteAccess2 {
\find(#allmodal ( (modal operator))\[{ ..
  #v.#sv = #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseStaticFieldWriteAccess3 (activeUse) =========================================
activeUseStaticFieldWriteAccess3 {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #arr[#idx];
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #arr[#idx];
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseStaticFieldWriteAccess4 (activeUse) =========================================
activeUseStaticFieldWriteAccess4 {
\find(#allmodal ( (modal operator))\[{ ..
  #v.#sv = #arr[#idx];
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #arr[#idx];
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseStaticFieldWriteAccess5 (activeUse) =========================================
activeUseStaticFieldWriteAccess5 {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #v1.#a;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#a (program Variable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#a) #v0 = #v1.#a;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseStaticFieldWriteAccess6 (activeUse) =========================================
activeUseStaticFieldWriteAccess6 {
\find(#allmodal ( (modal operator))\[{ ..
  #v.#sv = #v1.#a;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#a (program Variable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#a) #v0 = #v1.#a;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseSubtraction (activeUse) =========================================
activeUseSubtraction {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left - #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left - #right;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseUnaryMinus (activeUse) =========================================
activeUseUnaryMinus {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = -#left;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = -#left;
  @(#sv) = #v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== activeUseUnsignedShiftRight (activeUse) =========================================
activeUseUnsignedShiftRight {
\find(#allmodal ( (modal operator))\[{ ..
  #sv = #left >>> #right;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#sv) #v0 = #left >>> #right;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== add_eq (add_eq) =========================================
add_eq {
\find(equals(i0,i1))
\replacewith(equals(add(i,i0),add(i,i1))) 

Choices: true}
-----------------------------------------------------
== add_eq_back (add_eq_back) =========================================
add_eq_back {
\find(equals(add(i1,i),add(i1,i0)))
\replacewith(equals(i,i0)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_eq_back_2 (add_eq_back) =========================================
add_eq_back_2 {
\find(equals(add(i,i1),add(i0,i1)))
\replacewith(equals(i,i0)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_eq_back_2_fst_comm (add_eq_back) =========================================
add_eq_back_2_fst_comm {
\find(equals(add(i1,i),add(i0,i1)))
\replacewith(equals(i,i0)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_eq_back_3 (add_eq_back) =========================================
add_eq_back_3 {
\find(equals(i1,add(i1,i0)))
\replacewith(equals(Z(0(#)),i0)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_equations (add_equations) =========================================
add_equations {
\assumes ([equals(i,i0)]==>[]) 
\find(equals(j,j0)==>)
\add [equals(add(i,j),add(i0,j0))]==>[] 

Choices: true}
-----------------------------------------------------
== add_equations_right (add_equations_right) =========================================
add_equations_right {
\assumes ([equals(i,i0)]==>[]) 
\find(==>equals(j,j0))
\add []==>[equals(add(i,j),add(i0,j0))] 

Choices: true}
-----------------------------------------------------
== add_greater (add_greater) =========================================
add_greater {
\find(gt(i,i0))
\replacewith(gt(add(i1,i),add(i1,i0))) 

Choices: true}
-----------------------------------------------------
== add_greatereq (add_greatereq) =========================================
add_greatereq {
\find(geq(i,i0))
\replacewith(geq(add(i1,i),add(i1,i0))) 

Choices: true}
-----------------------------------------------------
== add_less (add_less) =========================================
add_less {
\find(lt(i,i0))
\replacewith(lt(add(i1,i),add(i1,i0))) 

Choices: true}
-----------------------------------------------------
== add_less_back (add_less_back) =========================================
add_less_back {
\find(lt(add(i1,i),add(i1,i0)))
\replacewith(lt(i,i0)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_less_back_zero_1 (add_less_back) =========================================
add_less_back_zero_1 {
\find(lt(i,add(i,i1)))
\replacewith(lt(Z(0(#)),i1)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_less_back_zero_1_comm (add_less_back) =========================================
add_less_back_zero_1_comm {
\find(lt(i,add(i1,i)))
\replacewith(lt(Z(0(#)),i1)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_less_back_zero_2 (add_less_back) =========================================
add_less_back_zero_2 {
\find(lt(add(i,i1),i))
\replacewith(lt(i1,Z(0(#)))) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_less_back_zero_2_comm (add_less_back) =========================================
add_less_back_zero_2_comm {
\find(lt(add(i1,i),i))
\replacewith(lt(i1,Z(0(#)))) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_lesseq (add_lesseq) =========================================
add_lesseq {
\find(leq(i,i0))
\replacewith(leq(add(i1,i),add(i1,i0))) 

Choices: true}
-----------------------------------------------------
== add_literals (add_literals) =========================================
add_literals {
\find(add(Z(iz),Z(jz)))
\replacewith(#add(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== add_non_neg_square (add_non_neg_square) =========================================
add_non_neg_square {
\add [geq(mul(squareFac,squareFac),Z(0(#)))]==>[] 
\heuristics(inEqSimp_nonNegSquares, inEqSimp_special_nonLin)
Choices: true}
-----------------------------------------------------
== add_sub_elim_left (add_sub_elim_left) =========================================
add_sub_elim_left {
\find(add(neg(i),i))
\replacewith(Z(0(#))) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_sub_elim_right (add_sub_elim_right) =========================================
add_sub_elim_right {
\find(add(i,neg(i)))
\replacewith(Z(0(#))) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== add_sub_step (add_sub_step) =========================================
add_sub_step {
\find(add(neg(i),neg(i0)))
\replacewith(neg(add(i,i0))) 

Choices: true}
-----------------------------------------------------
== add_two_inequations_1 (add_two_inequations_1) =========================================
add_two_inequations_1 {
\assumes ([lt(i,i0)]==>[]) 
\find(lt(j,j0)==>)
\add [lt(add(i,j),add(i0,j0))]==>[] 

Choices: true}
-----------------------------------------------------
== add_two_inequations_2 (add_two_inequations_2) =========================================
add_two_inequations_2 {
\assumes ([leq(i,i0)]==>[]) 
\find(leq(j,j0)==>)
\add [leq(add(i,j),add(i0,j0))]==>[] 

Choices: true}
-----------------------------------------------------
== add_zero_left (add_zero_left) =========================================
add_zero_left {
\find(add(Z(0(#)),i))
\replacewith(i) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== add_zero_right (add_zero_right) =========================================
add_zero_right {
\find(add(i,Z(0(#))))
\replacewith(i) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== addition_associative (addition_associative) =========================================
addition_associative {
\find(add(add(i0,i1),add(j0,j1)))
\replacewith(add(add(j0,i1),add(i0,j1))) 

Choices: true}
-----------------------------------------------------
== allFieldsEq (allFieldsEq) =========================================
allFieldsEq {
\find(equals(allFields(o1),allFields(o2)))
\replacewith(equals(o1,o2)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== allFieldsSubsetOf (allFieldsSubsetOf) =========================================
allFieldsSubsetOf {
\assumes ([subset(allFields(o),s)]==>[]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== allFieldsUnfold (allFieldsAssignment) =========================================
allFieldsUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \all_fields(#nseObj);
... }\] (post))
\varcond(\new(#vObjNew (program Variable), \typeof(#nseObj (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseObj) #vObjNew = #nseObj;
  #v = \all_fields(#vObjNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== allLeft (allLeft) =========================================
allLeft {
\find(all{u (variable)}(b)==>)
\add [subst{u (variable)}(t,b)]==>[] 
\heuristics(gamma)
Choices: true}
-----------------------------------------------------
== allLeftHide (allLeftHide) =========================================
allLeftHide {
\find(all{u (variable)}(b)==>)
\addrules [insert_hidden {
\add [all{u (variable)}(b)]==>[] 

Choices: true}] \replacewith([subst{u (variable)}(t,b)]==>[]) 
\heuristics(gamma_destructive)
Choices: true}
-----------------------------------------------------
== allObjectsAssignment (allObjectsAssignment) =========================================
allObjectsAssignment {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \all_objects(#eObj.#a);
... }\] (post))
\replacewith(update-application(elem-update(#v (program Variable))(allObjects(#memberPVToField(#a))),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== allRight (allRight) =========================================
allRight {
\find(==>all{u (variable)}(b))
\replacewith([]==>[subst{u (variable)}(sk,b)]) 
\heuristics(delta)
Choices: true}
-----------------------------------------------------
== all_bool (all_bool) =========================================
all_bool {
\find(all{x (variable)}(c))
\replacewith(and(subst{x (variable)}(FALSE,c),subst{x (variable)}(TRUE,c))) 
\heuristics(boolean_cases)
Choices: true}
-----------------------------------------------------
== all_pull_out0 (all_pull_out0) =========================================
all_pull_out0 {
\find(and(all{u (variable)}(b),c))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(and(b,c))) 
\heuristics(pullOutQuantifierAll)
Choices: true}
-----------------------------------------------------
== all_pull_out1 (all_pull_out1) =========================================
all_pull_out1 {
\find(and(c,all{u (variable)}(b)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(and(c,b))) 
\heuristics(pullOutQuantifierAll)
Choices: true}
-----------------------------------------------------
== all_pull_out2 (all_pull_out2) =========================================
all_pull_out2 {
\find(or(all{u (variable)}(b),c))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(or(b,c))) 
\heuristics(pullOutQuantifierAll)
Choices: true}
-----------------------------------------------------
== all_pull_out3 (all_pull_out3) =========================================
all_pull_out3 {
\find(or(c,all{u (variable)}(b)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(or(c,b))) 
\heuristics(pullOutQuantifierAll)
Choices: true}
-----------------------------------------------------
== all_pull_out4 (all_pull_out4) =========================================
all_pull_out4 {
\find(and(all{u (variable)}(b),all{u2 (variable)}(c)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(and(b,subst{u2 (variable)}(u,c)))) 
\heuristics(pullOutQuantifierUnifying, pullOutQuantifierAll)
Choices: true}
-----------------------------------------------------
== all_unused (all_unused) =========================================
all_unused {
\find(all{u (variable)}(b))
\varcond(\notFreeIn(u (variable), b (formula)))
\replacewith(b) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== allocateInstance (allocateInstance) =========================================
allocateInstance {
\find(==>#allmodal ( (modal operator))\[{ ..
  #lhs = #t.#allocate()@#t;
... }\] (post))
\varcond(\hasSort(#t2 (program Type), alphaObj), )
\add [and(and(not(equals(#lhs,null)),imp(wellFormed(heap),equals(boolean::select(heap,#lhs,java.lang.Object::<created>),FALSE))),equals(alphaObj::exactInstance(#lhs),TRUE))]==>[] \replacewith([]==>[update-application(elem-update(heap)(create(heap,#lhs)),#allmodal(post))]) 
\heuristics(method_expand)
Choices: (programRules:Java & permissions:off)}
-----------------------------------------------------
== allocateInstanceWithLength (allocateInstanceWithLength) =========================================
allocateInstanceWithLength {
\find(==>#allmodal ( (modal operator))\[{ ..
  #lhs = #t.#allocate(#len)@#t;
... }\] (post))
\varcond(\hasSort(#t2 (program Type), alphaObj), )
\add [and(and(not(equals(#lhs,null)),imp(wellFormed(heap),and(equals(boolean::select(heap,#lhs,java.lang.Object::<created>),FALSE),equals(length(#lhs),#len)))),equals(alphaObj::exactInstance(#lhs),TRUE))]==>[] \replacewith([]==>[update-application(elem-update(heap)(store(store(create(heap,#lhs),#lhs,java.lang.Object::<transient>,Z(0(#))),#lhs,java.lang.Object::<transactionConditionallyUpdated>,FALSE)),#allmodal(post))]) 
\heuristics(method_expand)
Choices: (programRules:Java & permissions:off)}
-----------------------------------------------------
== altAxiom (altAxiom) =========================================
altAxiom {
\find(match(alt(rexp1,rexp2),string))
\replacewith(or(match(rexp1,string),match(rexp2,string))) 
\heuristics(simplify)
Choices: Strings:on}
-----------------------------------------------------
== andJIntDef (andJIntDef) =========================================
andJIntDef {
\find(andJint(left,right))
\replacewith(moduloInt(binaryAnd(left,right))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== andLeft (andLeft) =========================================
andLeft {
\find(and(b,c)==>)
\replacewith([b,c]==>[]) 
\heuristics(alpha)
Choices: true}
-----------------------------------------------------
== andRight (andRight) =========================================
andRight {
\find(==>and(b,c))
\replacewith([]==>[c]) ;
\replacewith([]==>[b]) 
\heuristics(beta)
Choices: true}
-----------------------------------------------------
== applyEq (applyEq) =========================================
applyEq {
\assumes ([equals(s,t1)]==>[]) 
\find(s)
\sameUpdateLevel\replacewith(t1) 
\heuristics(apply_select_eq, apply_equations)
Choices: true}
-----------------------------------------------------
== applyEqReverse (applyEqReverse) =========================================
applyEqReverse {
\assumes ([equals(s,t1)]==>[]) 
\find(t1)
\sameUpdateLevel\replacewith(s) 
\heuristics(apply_auxiliary_eq)
Choices: true}
-----------------------------------------------------
== applyEqRigid (applyEq) =========================================
applyEqRigid {
\assumes ([equals(sr,tr1)]==>[]) 
\find(sr)
\replacewith(tr1) 
\heuristics(apply_equations)
Choices: true}
-----------------------------------------------------
== applyEq_and_gen0 (applyEq_and_gen0) =========================================
applyEq_and_gen0 {
\find(and(equals(applyEqLeft,applyEqOther),equals(applyEqLeft,applyEqRight)))
\replacewith(and(equals(applyEqRight,applyEqOther),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_gen1 (applyEq_and_gen1) =========================================
applyEq_and_gen1 {
\find(and(and(b,equals(applyEqLeft,applyEqOther)),equals(applyEqLeft,applyEqRight)))
\replacewith(and(and(b,equals(applyEqRight,applyEqOther)),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_gen2 (applyEq_and_gen2) =========================================
applyEq_and_gen2 {
\find(and(not(equals(applyEqLeft,applyEqOther)),equals(applyEqLeft,applyEqRight)))
\replacewith(and(not(equals(applyEqRight,applyEqOther)),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_gen3 (applyEq_and_gen3) =========================================
applyEq_and_gen3 {
\find(and(and(b,not(equals(applyEqLeft,applyEqOther))),equals(applyEqLeft,applyEqRight)))
\replacewith(and(and(b,not(equals(applyEqRight,applyEqOther))),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_int0 (applyEq_and_int0) =========================================
applyEq_and_int0 {
\find(and(geq(applyEqLeft,applyEqOther),equals(applyEqLeft,applyEqRight)))
\replacewith(and(geq(applyEqRight,applyEqOther),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_int1 (applyEq_and_int1) =========================================
applyEq_and_int1 {
\find(and(and(b,geq(applyEqLeft,applyEqOther)),equals(applyEqLeft,applyEqRight)))
\replacewith(and(and(b,geq(applyEqRight,applyEqOther)),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_int2 (applyEq_and_int2) =========================================
applyEq_and_int2 {
\find(and(leq(applyEqLeft,applyEqOther),equals(applyEqLeft,applyEqRight)))
\replacewith(and(leq(applyEqRight,applyEqOther),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_int3 (applyEq_and_int3) =========================================
applyEq_and_int3 {
\find(and(and(b,leq(applyEqLeft,applyEqOther)),equals(applyEqLeft,applyEqRight)))
\replacewith(and(and(b,leq(applyEqRight,applyEqOther)),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_int4 (applyEq_and_int4) =========================================
applyEq_and_int4 {
\find(and(equals(applyEqLeft,applyEqRight),geq(applyEqLeft,applyEqOther)))
\replacewith(and(equals(applyEqLeft,applyEqRight),geq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_int5 (applyEq_and_int5) =========================================
applyEq_and_int5 {
\find(and(and(b,equals(applyEqLeft,applyEqRight)),geq(applyEqLeft,applyEqOther)))
\replacewith(and(and(b,equals(applyEqLeft,applyEqRight)),geq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_int6 (applyEq_and_int6) =========================================
applyEq_and_int6 {
\find(and(equals(applyEqLeft,applyEqRight),leq(applyEqLeft,applyEqOther)))
\replacewith(and(equals(applyEqLeft,applyEqRight),leq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_and_int7 (applyEq_and_int7) =========================================
applyEq_and_int7 {
\find(and(and(b,equals(applyEqLeft,applyEqRight)),leq(applyEqLeft,applyEqOther)))
\replacewith(and(and(b,equals(applyEqLeft,applyEqRight)),leq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_gen0 (applyEq_or_gen0) =========================================
applyEq_or_gen0 {
\find(or(equals(applyEqLeft,applyEqOther),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(equals(applyEqRight,applyEqOther),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_gen1 (applyEq_or_gen1) =========================================
applyEq_or_gen1 {
\find(or(or(b,equals(applyEqLeft,applyEqOther)),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(or(b,equals(applyEqRight,applyEqOther)),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_gen2 (applyEq_or_gen2) =========================================
applyEq_or_gen2 {
\find(or(not(equals(applyEqLeft,applyEqOther)),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(not(equals(applyEqRight,applyEqOther)),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_gen3 (applyEq_or_gen3) =========================================
applyEq_or_gen3 {
\find(or(or(b,not(equals(applyEqLeft,applyEqOther))),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(or(b,not(equals(applyEqRight,applyEqOther))),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_int0 (applyEq_or_int0) =========================================
applyEq_or_int0 {
\find(or(geq(applyEqLeft,applyEqOther),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(geq(applyEqRight,applyEqOther),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_int1 (applyEq_or_int1) =========================================
applyEq_or_int1 {
\find(or(or(b,geq(applyEqLeft,applyEqOther)),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(or(b,geq(applyEqRight,applyEqOther)),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_int2 (applyEq_or_int2) =========================================
applyEq_or_int2 {
\find(or(leq(applyEqLeft,applyEqOther),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(leq(applyEqRight,applyEqOther),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_int3 (applyEq_or_int3) =========================================
applyEq_or_int3 {
\find(or(or(b,leq(applyEqLeft,applyEqOther)),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(or(b,leq(applyEqRight,applyEqOther)),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_int4 (applyEq_or_int4) =========================================
applyEq_or_int4 {
\find(or(not(equals(applyEqLeft,applyEqRight)),geq(applyEqLeft,applyEqOther)))
\replacewith(or(not(equals(applyEqLeft,applyEqRight)),geq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_int5 (applyEq_or_int5) =========================================
applyEq_or_int5 {
\find(or(or(b,not(equals(applyEqLeft,applyEqRight))),geq(applyEqLeft,applyEqOther)))
\replacewith(or(or(b,not(equals(applyEqLeft,applyEqRight))),geq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_int6 (applyEq_or_int6) =========================================
applyEq_or_int6 {
\find(or(not(equals(applyEqLeft,applyEqRight)),leq(applyEqLeft,applyEqOther)))
\replacewith(or(not(equals(applyEqLeft,applyEqRight)),leq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyEq_or_int7 (applyEq_or_int7) =========================================
applyEq_or_int7 {
\find(or(or(b,not(equals(applyEqLeft,applyEqRight))),leq(applyEqLeft,applyEqOther)))
\replacewith(or(or(b,not(equals(applyEqLeft,applyEqRight))),leq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: true}
-----------------------------------------------------
== applyOnElementary (applyOnElementary) =========================================
applyOnElementary {
\find(update-application(u,elem-update(#pv (program Variable))(t)))
\replacewith(elem-update(#pv (program Variable))(update-application(u,t))) 
\heuristics(update_apply_on_update)
Choices: true}
-----------------------------------------------------
== applyOnPV (applyOnPV) =========================================
applyOnPV {
\find(update-application(elem-update(#pv (program Variable))(t),#pv))
\replacewith(t) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== applyOnParallel (applyOnParallel) =========================================
applyOnParallel {
\find(update-application(u,parallel-upd(u2,u3)))
\replacewith(parallel-upd(update-application(u,u2),update-application(u,u3))) 
\heuristics(update_apply_on_update)
Choices: true}
-----------------------------------------------------
== applyOnRigidFormula (applyOnRigidFormula) =========================================
applyOnRigidFormula {
\find(update-application(u,phi))
\varcond(\applyUpdateOnRigid(u (update), phi (formula), result (formula)), )
\replacewith(result) 
\heuristics(update_apply)
Choices: true}
-----------------------------------------------------
== applyOnRigidTerm (applyOnRigidTerm) =========================================
applyOnRigidTerm {
\find(update-application(u,t))
\varcond(\applyUpdateOnRigid(u (update), t (any term), result (any term)), )
\replacewith(result) 
\heuristics(update_apply)
Choices: true}
-----------------------------------------------------
== applyOnSkip (applyOnSkip) =========================================
applyOnSkip {
\find(update-application(u,skip))
\replacewith(skip) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== applySkip1 (applySkip1) =========================================
applySkip1 {
\find(update-application(skip,t))
\replacewith(t) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== applySkip2 (applySkip2) =========================================
applySkip2 {
\find(update-application(skip,phi))
\replacewith(phi) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== applySkip3 (applySkip3) =========================================
applySkip3 {
\find(update-application(skip,u))
\replacewith(u) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== apply_eq_boolean (apply_eq_boolean) =========================================
apply_eq_boolean {
\assumes ([]==>[equals(bo,TRUE)]) 
\find(bo)
\sameUpdateLevel\replacewith(FALSE) 
\heuristics(apply_equations)
Choices: true}
-----------------------------------------------------
== apply_eq_boolean_2 (apply_eq_boolean) =========================================
apply_eq_boolean_2 {
\assumes ([]==>[equals(bo,FALSE)]) 
\find(bo)
\sameUpdateLevel\replacewith(TRUE) 
\heuristics(apply_equations)
Choices: true}
-----------------------------------------------------
== apply_eq_boolean_rigid (apply_eq_boolean) =========================================
apply_eq_boolean_rigid {
\assumes ([]==>[equals(br,TRUE)]) 
\find(br)
\replacewith(FALSE) 
\heuristics(apply_equations)
Choices: true}
-----------------------------------------------------
== apply_eq_boolean_rigid_2 (apply_eq_boolean) =========================================
apply_eq_boolean_rigid_2 {
\assumes ([]==>[equals(br,FALSE)]) 
\find(br)
\replacewith(TRUE) 
\heuristics(apply_equations)
Choices: true}
-----------------------------------------------------
== apply_eq_monomials (apply_eq_monomials) =========================================
apply_eq_monomials {
\assumes ([equals(applyEqDivisor,i0)]==>[]) 
\find(applyEqDividend)
\sameUpdateLevel\replacewith(add(mul(#divideMonomials(applyEqDividend,applyEqDivisor),add(i0,mul(applyEqDivisor,Z(neglit(1(#)))))),applyEqDividend)) 
\heuristics(notHumanReadable, apply_equations, polySimp_applyEq)
Choices: true}
-----------------------------------------------------
== apply_eq_monomials_rigid (apply_eq_monomials_rigid) =========================================
apply_eq_monomials_rigid {
\assumes ([equals(applyEqDivisorr,i0r)]==>[]) 
\find(applyEqDividend)
\replacewith(add(mul(#divideMonomials(applyEqDividend,applyEqDivisorr),add(i0r,mul(applyEqDivisorr,Z(neglit(1(#)))))),applyEqDividend)) 
\heuristics(notHumanReadable, apply_equations, polySimp_applyEqRigid)
Choices: true}
-----------------------------------------------------
== apply_eq_pseudo_eq (apply_eq_pseudo_eq) =========================================
apply_eq_pseudo_eq {
\assumes ([equals(mul(aePseudoLeft,aePseudoLeftCoeff),aePseudoRight)]==>[]) 
\find(equals(aePseudoTargetLeft,aePseudoTargetRight))
\sameUpdateLevel\replacewith(if-then-else(and(equals(aePseudoTargetLeft,mul(aePseudoLeft,aePseudoTargetFactor)),not(equals(aePseudoLeftCoeff,Z(0(#))))),equals(mul(aePseudoRight,aePseudoTargetFactor),mul(aePseudoTargetRight,aePseudoLeftCoeff)),equals(aePseudoTargetLeft,aePseudoTargetRight))) 
\heuristics(notHumanReadable, notHumanReadable, polySimp_applyEqPseudo, polySimp_leftNonUnit)
Choices: true}
-----------------------------------------------------
== apply_eq_pseudo_geq (apply_eq_pseudo_geq) =========================================
apply_eq_pseudo_geq {
\assumes ([equals(mul(aePseudoLeft,aePseudoLeftCoeff),aePseudoRight)]==>[]) 
\find(geq(aePseudoTargetLeft,aePseudoTargetRight))
\sameUpdateLevel\replacewith(if-then-else(and(equals(aePseudoTargetLeft,mul(aePseudoLeft,aePseudoTargetFactor)),gt(aePseudoLeftCoeff,Z(0(#)))),geq(mul(aePseudoRight,aePseudoTargetFactor),mul(aePseudoTargetRight,aePseudoLeftCoeff)),geq(aePseudoTargetLeft,aePseudoTargetRight))) 
\heuristics(notHumanReadable, polySimp_applyEqPseudo, polySimp_leftNonUnit)
Choices: true}
-----------------------------------------------------
== apply_eq_pseudo_leq (apply_eq_pseudo_leq) =========================================
apply_eq_pseudo_leq {
\assumes ([equals(mul(aePseudoLeft,aePseudoLeftCoeff),aePseudoRight)]==>[]) 
\find(leq(aePseudoTargetLeft,aePseudoTargetRight))
\sameUpdateLevel\replacewith(if-then-else(and(equals(aePseudoTargetLeft,mul(aePseudoLeft,aePseudoTargetFactor)),gt(aePseudoLeftCoeff,Z(0(#)))),leq(mul(aePseudoRight,aePseudoTargetFactor),mul(aePseudoTargetRight,aePseudoLeftCoeff)),leq(aePseudoTargetLeft,aePseudoTargetRight))) 
\heuristics(notHumanReadable, polySimp_applyEqPseudo, polySimp_leftNonUnit)
Choices: true}
-----------------------------------------------------
== apply_subst (apply_subst) =========================================
apply_subst {
\find(subst{u (variable)}(t,target))
\replacewith(subst{u (variable)}(t,target)) 
\heuristics(try_apply_subst)
Choices: true}
-----------------------------------------------------
== apply_subst_for (apply_subst) =========================================
apply_subst_for {
\find(subst{u (variable)}(t,phi))
\replacewith(subst{u (variable)}(t,phi)) 
\heuristics(try_apply_subst)
Choices: true}
-----------------------------------------------------
== array2seqDef (array2seqDef) =========================================
array2seqDef {
\find(array2seq(h,a))
\varcond(\notFreeIn(u (variable), h (Heap term)), \notFreeIn(u (variable), a (java.lang.Object term)))
\replacewith(seqDef{u (variable)}(Z(0(#)),length(a),any::select(h,a,arr(u)))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== arrayCreation (arrayCreation) =========================================
arrayCreation {
\find(#normal ( (modal operator))\[{ ..
  #lhs = #na;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#na (program ArrayCreation))))
\replacewith(#normal ( (modal operator))\[{ ..
  #typeof(#na) #v0;
  init-array-creation(#na)
  #lhs = #v0;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== arrayCreationWithInitializers (arrayCreationWithInitializers) =========================================
arrayCreationWithInitializers {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #arrayinitializer;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#lhs) #v0;
  init-array-creation(#arrayinitializer)
  #lhs = #v0;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== arrayInitialisation (arrayInitialisation) =========================================
arrayInitialisation {
\find(#allmodal ( (modal operator))\[{ ..
  for (int #v = #se; #v < this.#length; #v++)
    this[#v] = #lit;
... }\] (post))
\replacewith(update-application(elem-update(heap)(memset(heap,arrayRange(#a,#se,sub(length(#a),Z(1(#)))),#lit)),#allmodal(post))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== arrayLengthIsAShort (arrayLengthIsAShort) =========================================
arrayLengthIsAShort {
\find(length(o))
\sameUpdateLevel\add [inShort(length(o))]==>[] 
\heuristics(inReachableStateImplication)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== arrayLengthNotNegative (arrayLengthNotNegative) =========================================
arrayLengthNotNegative {
\find(length(o))
\sameUpdateLevel\add [geq(length(o),Z(0(#)))]==>[] 
\heuristics(inReachableStateImplication)
Choices: programRules:Java}
-----------------------------------------------------
== array_post_declaration (array_post_declaration) =========================================
array_post_declaration {
\find(#allmodal ( (modal operator))\[{ ..
  #arraypost
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  array-post-declaration(#arraypost)
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== array_self_reference (array_self_reference) =========================================
array_self_reference {
\assumes ([wellFormed(heapSV)]==>[equals(array,null)]) 
\find(arrayStoreValid(array,G::select(heapSV,array,arr(idx))))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== array_self_reference_eq (array_self_reference_eq) =========================================
array_self_reference_eq {
\assumes ([wellFormed(heapSV),equals(G::select(heapSV,array,arr(idx)),EQ)]==>[equals(array,null)]) 
\find(arrayStoreValid(array,EQ))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== array_store_known_dynamic_array_type (known dynamic array type) =========================================
array_store_known_dynamic_array_type {
\assumes ([equals(J::exactInstance(array),TRUE)]==>[]) 
\find(arrayStoreValid(array,obj))
\sameUpdateLevel\varcond(\isReference[non_null]( J ), )
\replacewith(or(equals(obj,null),equals(#arrayBaseInstanceOf(J::exactInstance(array),obj),TRUE))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== asinIsNaN (asinIsNaN) =========================================
asinIsNaN {
\find(asinDouble(arg))
\add [imp(or(or(doubleIsNaN(arg),ltDouble(arg,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))),gtDouble(arg,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),doubleIsNaN(asinDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== asineIsZero (asineIsZero) =========================================
asineIsZero {
\find(asinDouble(arg))
\add [imp(equals(arg,DFP(0(#))),equals(asinDouble(arg),DFP(0(#))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== asineRange (asineRange) =========================================
asineRange {
\find(asinDouble(arg))
\add [imp(and(geqDouble(arg,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),leqDouble(arg,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),and(geqDouble(asinDouble(arg),negDouble(DFP(2(5(3(5(7(6(4(2(9(6(5(0(3(5(7(9(0(6(4(#)))))))))))))))))))))),leqDouble(asinDouble(arg),DFP(2(5(3(5(7(6(4(2(9(6(5(0(3(5(7(9(0(6(4(#)))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== assertSafe (assert) =========================================
assertSafe {
\find(==>#allmodal ( (modal operator))\[{ ..
  assert #e1;
... }\] (b))
\varcond(\new(#condition (program Variable), \typeof(#e1 (program Expression))), \not \containsAssignment( #e1 ), )
\add [equals(oldHeap,heap)]==>[] \replacewith([]==>[\[{
  method-frame (#ex) {
    #typeof(#e1) #condition = #e1;
  }
}\] (all{f (variable)}(all{o (variable)}(or(and(not(equals(o,null)),equals(boolean::select(oldHeap,o,java.lang.Object::<created>),FALSE)),equals(any::select(oldHeap,o,f),any::select(heap,o,f))))))]) ;
\replacewith([]==>[\<{
  method-frame (#ex) {
    #condition = #e1;
  }
}\> (equals(#condition,TRUE))]) ;
\replacewith([]==>[#allmodal(b)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & assertions:safe)}
-----------------------------------------------------
== assertSafeWithMessage (assert) =========================================
assertSafeWithMessage {
\find(==>#allmodal ( (modal operator))\[{ ..
  assert #e1 : #e2;
... }\] (b))
\varcond(\new(#message (program Variable), \typeof(#e2 (program Expression))), \new(#condition (program Variable), \typeof(#e1 (program Expression))), \not \containsAssignment( #e1 ), \not \containsAssignment( #e2 ), )
\add [equals(oldHeap,heap)]==>[] \replacewith([]==>[\[{
  method-frame (#ex) {
    #typeof(#e1) #condition = #e1;
    #typeof(#e2) #message = #e2;
  }
}\] (all{f (variable)}(all{o (variable)}(or(and(not(equals(o,null)),equals(boolean::select(oldHeap,o,java.lang.Object::<created>),FALSE)),equals(any::select(oldHeap,o,f),any::select(heap,o,f))))))]) ;
\replacewith([]==>[\<{
  method-frame (#ex) {
    #typeof(#e1) #condition = #e1;
    #typeof(#e2) #message = #e2;
  }
}\> (equals(#condition,TRUE))]) ;
\replacewith([]==>[#allmodal(b)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & assertions:safe)}
-----------------------------------------------------
== assignment (assignment) =========================================
assignment {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = #se;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(#se),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentAdditionBigint1 (addition) =========================================
assignmentAdditionBigint1 {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = #seBigint + #seAny;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(add(#seBigint,#seAny)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== assignmentAdditionBigint2 (addition) =========================================
assignmentAdditionBigint2 {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = #seAny + #seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(add(#seAny,#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== assignmentAdditionDouble (addition) =========================================
assignmentAdditionDouble {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 + #seDouble1;
... }\] (post))
\varcond(\not\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentAdditionDoubleStrictFP (addition) =========================================
assignmentAdditionDoubleStrictFP {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 + #seDouble1;
... }\] (post))
\varcond(\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(addDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeDoubleAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentAdditionFloat (addition) =========================================
assignmentAdditionFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 + #seFloat1;
... }\] (post))
\varcond(\not\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentAdditionFloatStrictFP (addition) =========================================
assignmentAdditionFloatStrictFP {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 + #seFloat1;
... }\] (post))
\varcond(\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(addFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentAdditionInt (addition) =========================================
assignmentAdditionInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 + #seCharByteShortInt1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddInt(#seCharByteShortInt0,#seCharByteShortInt1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentAdditionLong (addition) =========================================
assignmentAdditionLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt + #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddLong(#seCharByteShortInt,#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentAdditionLong2 (addition) =========================================
assignmentAdditionLong2 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong + #seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddLong(#seLong,#seCharByteShortInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentAdditionLong3 (addition) =========================================
assignmentAdditionLong3 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 + #seLong1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseAndInt (bitwiseAnd) =========================================
assignmentBitwiseAndInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 & #seCharByteShortInt1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseAndInt(#seCharByteShortInt0,#seCharByteShortInt1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseAndLong (bitwiseAnd) =========================================
assignmentBitwiseAndLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt & #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseAndLong(#seCharByteShortInt,#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseAndLong2 (bitwiseAnd) =========================================
assignmentBitwiseAndLong2 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong & #seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseAndLong(#seLong,#seCharByteShortInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseAndLong3 (bitwiseAnd) =========================================
assignmentBitwiseAndLong3 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 & #seLong1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseAndLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseOrInt (bitwiseOr) =========================================
assignmentBitwiseOrInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 | #seCharByteShortInt1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseOrInt(#seCharByteShortInt0,#seCharByteShortInt1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseOrLong (bitwiseOr) =========================================
assignmentBitwiseOrLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt | #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseOrLong(#seCharByteShortInt,#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseOrLong2 (bitwiseOr) =========================================
assignmentBitwiseOrLong2 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong | #seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseOrLong(#seLong,#seCharByteShortInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseOrLong3 (bitwiseOr) =========================================
assignmentBitwiseOrLong3 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 | #seLong1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseOrLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseXOrInt (bitwiseXOr) =========================================
assignmentBitwiseXOrInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 ^ #seCharByteShortInt1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseXOrInt(#seCharByteShortInt0,#seCharByteShortInt1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseXOrLong (bitwiseXOr) =========================================
assignmentBitwiseXOrLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt ^ #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseXOrLong(#seCharByteShortInt,#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseXOrLong2 (bitwiseXOr) =========================================
assignmentBitwiseXOrLong2 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong ^ #seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseXOrLong(#seLong,#seCharByteShortInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentBitwiseXOrLong3 (bitwiseXOr) =========================================
assignmentBitwiseXOrLong3 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 ^ #seLong1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseXOrLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentDivisionBigint1 (division) =========================================
assignmentDivisionBigint1 {
\find(==>#allmodal ( (modal operator))\[{ ..
  #loc = #seBigint / #seAny;
... }\] (post))
\replacewith([]==>[not(equals(#seAny,Z(0(#))))]) ;
\replacewith([]==>[update-application(elem-update(#loc (program Variable))(div(#seBigint,#seAny)),#allmodal(post))]) 
\heuristics(executeIntegerAssignment)
Choices: ((programRules:Java & bigint:on) & runtimeExceptions:ban)}
-----------------------------------------------------
== assignmentDivisionBigint2 (division) =========================================
assignmentDivisionBigint2 {
\find(==>#allmodal ( (modal operator))\[{ ..
  #loc = #seAny / #seBigint;
... }\] (post))
\replacewith([]==>[not(equals(#seBigint,Z(0(#))))]) ;
\replacewith([]==>[update-application(elem-update(#loc (program Variable))(div(#seAny,#seBigint)),#allmodal(post))]) 
\heuristics(executeIntegerAssignment)
Choices: ((programRules:Java & bigint:on) & runtimeExceptions:ban)}
-----------------------------------------------------
== assignmentDivisionDouble (division) =========================================
assignmentDivisionDouble {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 / #seDouble1;
... }\] (post))
\varcond(\not\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(javaDivDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentDivisionDoubleStrictFP (division) =========================================
assignmentDivisionDoubleStrictFP {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 / #seDouble1;
... }\] (post))
\varcond(\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(divDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeDoubleAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentDivisionFloat (division) =========================================
assignmentDivisionFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 / #seFloat1;
... }\] (post))
\varcond(\not\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(javaDivFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentDivisionFloatStrictFP (division) =========================================
assignmentDivisionFloatStrictFP {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 / #seFloat1;
... }\] (post))
\varcond(\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(divFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentDivisionInt (division) =========================================
assignmentDivisionInt {
\find(==>#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 / #seCharByteShortInt1;
... }\] (post))
\replacewith([]==>[not(equals(#seCharByteShortInt1,Z(0(#))))]) ;
\replacewith([]==>[update-application(elem-update(#loc (program Variable))(javaDivInt(#seCharByteShortInt0,#seCharByteShortInt1)),#normalassign(post))]) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignmentDivisionLong (division) =========================================
assignmentDivisionLong {
\find(==>#normalassign ( (modal operator))\[{ ..
  #loc = #se / #seLong;
... }\] (post))
\replacewith([]==>[not(equals(#seLong,Z(0(#))))]) ;
\replacewith([]==>[update-application(elem-update(#loc (program Variable))(javaDivLong(#se,#seLong)),#normalassign(post))]) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignmentDivisionLong2 (division) =========================================
assignmentDivisionLong2 {
\find(==>#normalassign ( (modal operator))\[{ ..
  #loc = #seLong / #seCharByteShortInt;
... }\] (post))
\replacewith([]==>[not(equals(#seCharByteShortInt,Z(0(#))))]) ;
\replacewith([]==>[update-application(elem-update(#loc (program Variable))(javaDivLong(#seLong,#seCharByteShortInt)),#normalassign(post))]) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignmentModDouble (mod) =========================================
assignmentModDouble {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 % #seDouble1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaModDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentModFloat (mod) =========================================
assignmentModFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 % #seFloat1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaModFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentModulo (modulo) =========================================
assignmentModulo {
\find(==>#normalassign ( (modal operator))\[{ ..
  #loc = #se0 % #se1;
... }\] (post))
\replacewith([]==>[not(equals(#se1,Z(0(#))))]) ;
\replacewith([]==>[update-application(elem-update(#loc (program Variable))(javaMod(#se0,#se1)),#normalassign(post))]) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignmentModuloBigint1 (modulo) =========================================
assignmentModuloBigint1 {
\find(==>#allmodal ( (modal operator))\[{ ..
  #loc = #seBigint % #seAny;
... }\] (post))
\replacewith([]==>[not(equals(#seAny,Z(0(#))))]) ;
\replacewith([]==>[update-application(elem-update(#loc (program Variable))(mod(#seBigint,#seAny)),#allmodal(post))]) 
\heuristics(executeIntegerAssignment)
Choices: ((programRules:Java & bigint:on) & runtimeExceptions:ban)}
-----------------------------------------------------
== assignmentModuloBigint2 (modulo) =========================================
assignmentModuloBigint2 {
\find(==>#allmodal ( (modal operator))\[{ ..
  #loc = #seAny % #seBigint;
... }\] (post))
\replacewith([]==>[not(equals(#seBigint,Z(0(#))))]) ;
\replacewith([]==>[update-application(elem-update(#loc (program Variable))(mod(#seAny,#seBigint)),#allmodal(post))]) 
\heuristics(executeIntegerAssignment)
Choices: ((programRules:Java & bigint:on) & runtimeExceptions:ban)}
-----------------------------------------------------
== assignmentMultiplicationBigint1 (multiplication) =========================================
assignmentMultiplicationBigint1 {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = #seBigint * #seAny;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(mul(#seBigint,#seAny)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== assignmentMultiplicationBigint2 (multiplication) =========================================
assignmentMultiplicationBigint2 {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = #seAny * #seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(mul(#seAny,#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== assignmentMultiplicationDouble (multiplication) =========================================
assignmentMultiplicationDouble {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 * #seDouble1;
... }\] (post))
\varcond(\not\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(javaMulDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentMultiplicationDoubleStrictFP (multiplication) =========================================
assignmentMultiplicationDoubleStrictFP {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 * #seDouble1;
... }\] (post))
\varcond(\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(mulDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeDoubleAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentMultiplicationFloat (multiplication) =========================================
assignmentMultiplicationFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 * #seFloat1;
... }\] (post))
\varcond(\not\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(javaMulFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentMultiplicationFloatStrictFP (multiplication) =========================================
assignmentMultiplicationFloatStrictFP {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 * #seFloat1;
... }\] (post))
\varcond(\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(mulFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentMultiplicationInt (multiplication) =========================================
assignmentMultiplicationInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 * #seCharByteShortInt1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaMulInt(#seCharByteShortInt0,#seCharByteShortInt1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentMultiplicationLong (multiplication) =========================================
assignmentMultiplicationLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt * #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaMulLong(#seCharByteShortInt,#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentMultiplicationLong2 (multiplication) =========================================
assignmentMultiplicationLong2 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong * #seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaMulLong(#seLong,#seCharByteShortInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentMultiplicationLong3 (multiplication) =========================================
assignmentMultiplicationLong3 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 * #seLong1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaMulLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentShiftLeftInt (shift) =========================================
assignmentShiftLeftInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 << #se;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaShiftLeftInt(#seCharByteShortInt0,#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentShiftLeftLong (shift) =========================================
assignmentShiftLeftLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 << #se;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaShiftLeftLong(#seLong0,#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentShiftRightInt (shift) =========================================
assignmentShiftRightInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 >> #se;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaShiftRightInt(#seCharByteShortInt0,#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentShiftRightLong (shift) =========================================
assignmentShiftRightLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 >> #se;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaShiftRightLong(#seLong0,#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentSubtractionBigint1 (subtraction) =========================================
assignmentSubtractionBigint1 {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = #seBigint - #seAny;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(sub(#seBigint,#seAny)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== assignmentSubtractionBigint2 (subtraction) =========================================
assignmentSubtractionBigint2 {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = #seAny - #seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(sub(#seAny,#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== assignmentSubtractionDouble (subtraction) =========================================
assignmentSubtractionDouble {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 - #seDouble1;
... }\] (post))
\varcond(\not\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(javaSubDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentSubtractionDoubleStrictFP (subtraction) =========================================
assignmentSubtractionDoubleStrictFP {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble0 - #seDouble1;
... }\] (post))
\varcond(\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(subDouble(#seDouble0,#seDouble1)),#normalassign(post))) 
\heuristics(executeDoubleAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentSubtractionFloat (subtraction) =========================================
assignmentSubtractionFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 - #seFloat1;
... }\] (post))
\varcond(\not\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(javaSubFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentSubtractionFloatStrictFP (subtraction) =========================================
assignmentSubtractionFloatStrictFP {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat0 - #seFloat1;
... }\] (post))
\varcond(\isStrictFp, )
\replacewith(update-application(elem-update(#loc (program Variable))(subFloat(#seFloat0,#seFloat1)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentSubtractionInt (subtraction) =========================================
assignmentSubtractionInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 - #seCharByteShortInt1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaSubInt(#seCharByteShortInt0,#seCharByteShortInt1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentSubtractionLong (subtraction) =========================================
assignmentSubtractionLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt - #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaSubLong(#seCharByteShortInt,#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentSubtractionLong2 (subtraction) =========================================
assignmentSubtractionLong2 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong - #seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaSubLong(#seLong,#seCharByteShortInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentSubtractionLong3 (subtraction) =========================================
assignmentSubtractionLong3 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 - #seLong1;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaSubLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentUnsignedShiftRightInt (shift) =========================================
assignmentUnsignedShiftRightInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt0 >>> #se;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaUnsignedShiftRightInt(#seCharByteShortInt0,#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignmentUnsignedShiftRightLong (shift) =========================================
assignmentUnsignedShiftRightLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong0 >>> #se;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaUnsignedShiftRightLong(#seLong0,#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== assignment_array2 (assignment_array2) =========================================
assignment_array2 {
\find(==>#allmodal ( (modal operator))\[{ ..
  #v = #v0[#se];
... }\] (post))
\varcond(\hasSort(\elemSort(#v0 (program Variable)), G), )
\add [and(not(equals(#v0,null)),or(leq(length(#v0),#se),lt(#se,Z(0(#)))))]==>[] \replacewith([]==>[false]) ;
\add [equals(#v0,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(#v (program Variable))(G::select(heap,#v0,arr(#se))),#allmodal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignment_read_attribute (assignment_read_attribute) =========================================
assignment_read_attribute {
\find(==>#allmodal ( (modal operator))\[{ ..
  #v0 = #v.#a;
... }\] (post))
\varcond( \not \static(#a (program Variable)),  \not \isArrayLength(#a (program Variable)), \not\isModelField(#a (program Variable)), \hasSort(#a (program Variable), G), \not\isThisReference (#v (program Variable)), )
\add [equals(#v,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(#v0 (program Variable))(G::select(heap,#v,#memberPVToField(#a))),#allmodal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignment_read_attribute_this (assignment_read_attribute_this) =========================================
assignment_read_attribute_this {
\find(==>#allmodal ( (modal operator))\[{ ..
  #v0 = #v.#a;
... }\] (post))
\varcond( \not \static(#a (program Variable)),  \not \isArrayLength(#a (program Variable)), \not\isModelField(#a (program Variable)), \hasSort(#a (program Variable), G), \isThisReference (#v (program Variable)), )
\replacewith([]==>[update-application(elem-update(#v0 (program Variable))(G::select(heap,#v,#memberPVToField(#a))),#allmodal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignment_read_length (assignment_read_length) =========================================
assignment_read_length {
\find(==>#allmodal ( (modal operator))\[{ ..
  #v0 = #v.#length;
... }\] (post))
\varcond(\not\isThisReference (#v (program Variable)), )
\add [equals(#v,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(#v0 (program Variable))(length(#v)),#allmodal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignment_read_length_this (assignment_read_length_this) =========================================
assignment_read_length_this {
\find(#allmodal ( (modal operator))\[{ ..
  #v0 = #v.#length;
... }\] (post))
\sameUpdateLevel\varcond(\isThisReference (#v (program Variable)), )
\replacewith(update-application(elem-update(#v0 (program Variable))(length(#v)),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== assignment_read_static_attribute (assignment_read_static_attribute) =========================================
assignment_read_static_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  #v0 = @(#sv);
... }\] (post))
\sameUpdateLevel\varcond(\hasSort(#sv (program StaticVariable), G), )
\replacewith(update-application(elem-update(#v0 (program Variable))(G::select(heap,null,#memberPVToField(#sv))),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== assignment_read_static_attribute_with_variable_prefix (assignment) =========================================
assignment_read_static_attribute_with_variable_prefix {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = @(#v.#sv);
... }\] (post))
\varcond(\hasSort(#sv (program StaticVariable), G), )
\replacewith(update-application(elem-update(#loc (program Variable))(G::select(heap,#v,#memberPVToField(#sv))),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== assignment_to_primitive_array_component (assignment_to_primitive_array_component) =========================================
assignment_to_primitive_array_component {
\find(==>#normal ( (modal operator))\[{ ..
  #v[#se] = #se0;
... }\] (post))
\varcond( \not \isReferenceArray(#v (program Variable)), )
\add [and(not(equals(#v,null)),or(leq(length(#v),#se),lt(#se,Z(0(#)))))]==>[] \replacewith([]==>[false]) ;
\add [equals(#v,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(heap)(store(heap,#v,arr(#se),#se0)),#normal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignment_to_primitive_array_component_transaction (assignment_to_primitive_array_component) =========================================
assignment_to_primitive_array_component_transaction {
\find(==>#transaction ( (modal operator))\[{ ..
  #v[#se] = #se0;
... }\] (post))
\varcond( \not \isReferenceArray(#v (program Variable)), )
\add [and(not(equals(#v,null)),or(leq(length(#v),#se),lt(#se,Z(0(#)))))]==>[] \replacewith([]==>[false]) ;
\add [equals(#v,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(heap)(store(heap,#v,arr(#se),#se0)),update-application(elem-update(savedHeap)(if-then-else(equals(int::select(heap,#v,java.lang.Object::<transient>),Z(0(#))),store(savedHeap,#v,java.lang.Object::<transactionConditionallyUpdated>,TRUE),if-then-else(equals(boolean::select(savedHeap,#v,java.lang.Object::<transactionConditionallyUpdated>),FALSE),store(savedHeap,#v,arr(#se),#se0),savedHeap))),#transaction(post)))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: ((programRules:Java & runtimeExceptions:ban) & JavaCard:on)}
-----------------------------------------------------
== assignment_to_reference_array_component (assignment_to_reference_array_component) =========================================
assignment_to_reference_array_component {
\find(==>#normal ( (modal operator))\[{ ..
  #v[#se] = #se0;
... }\] (post))
\varcond(\isReferenceArray(#v (program Variable)), )
\add [and(and(and(not(equals(#v,null)),lt(#se,length(#v))),geq(#se,Z(0(#)))),not(arrayStoreValid(#v,#se0)))]==>[] \replacewith([]==>[false]) ;
\add [and(not(equals(#v,null)),or(leq(length(#v),#se),lt(#se,Z(0(#)))))]==>[] \replacewith([]==>[false]) ;
\add [equals(#v,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(heap)(store(heap,#v,arr(#se),#se0)),#normal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignment_to_reference_array_component_transaction (assignment_to_reference_array_component) =========================================
assignment_to_reference_array_component_transaction {
\find(==>#transaction ( (modal operator))\[{ ..
  #v[#se] = #se0;
... }\] (post))
\varcond(\isReferenceArray(#v (program Variable)), )
\add [and(and(and(not(equals(#v,null)),lt(#se,length(#v))),geq(#se,Z(0(#)))),not(arrayStoreValid(#v,#se0)))]==>[] \replacewith([]==>[false]) ;
\add [and(not(equals(#v,null)),or(leq(length(#v),#se),lt(#se,Z(0(#)))))]==>[] \replacewith([]==>[false]) ;
\add [equals(#v,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(heap)(store(heap,#v,arr(#se),#se0)),update-application(elem-update(savedHeap)(if-then-else(equals(int::select(heap,#v,java.lang.Object::<transient>),Z(0(#))),store(savedHeap,#v,java.lang.Object::<transactionConditionallyUpdated>,TRUE),if-then-else(equals(boolean::select(savedHeap,#v,java.lang.Object::<transactionConditionallyUpdated>),FALSE),store(savedHeap,#v,arr(#se),#se0),savedHeap))),#transaction(post)))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: ((programRules:Java & runtimeExceptions:ban) & JavaCard:on)}
-----------------------------------------------------
== assignment_write_array_this_access_normalassign (assignment) =========================================
assignment_write_array_this_access_normalassign {
\find(#allmodal ( (modal operator))\[{ ..
  this[#se] = #se0;
... }\] (post))
\replacewith(imp(and(lt(#se,length(#v)),lt(Z(neglit(1(#))),#se)),update-application(elem-update(heap)(store(heap,#v,arr(#se),#se0)),#allmodal(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & permissions:off)}
-----------------------------------------------------
== assignment_write_attribute (assignment) =========================================
assignment_write_attribute {
\find(==>#allmodal ( (modal operator))\[{ ..
  #v.#a = #se;
... }\] (post))
\varcond( \not \static(#a (program Variable)), \not\isThisReference (#v (program Variable)), )
\add [equals(#v,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(heap)(store(heap,#v,#memberPVToField(#a),#se)),#allmodal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignment_write_attribute_this (assignmentThis) =========================================
assignment_write_attribute_this {
\find(==>#allmodal ( (modal operator))\[{ ..
  #v.#a = #se;
... }\] (post))
\varcond( \not \static(#a (program Variable)), \isThisReference (#v (program Variable)), )
\replacewith([]==>[update-application(elem-update(heap)(store(heap,#v,#memberPVToField(#a),#se)),#allmodal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== assignment_write_static_attribute (assignment) =========================================
assignment_write_static_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  @(#sv) = #se;
... }\] (post))
\replacewith(update-application(elem-update(heap)(store(heap,null,#memberPVToField(#sv),#se)),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== assignment_write_static_attribute_with_variable_prefix (active_attribute_access) =========================================
assignment_write_static_attribute_with_variable_prefix {
\find(#allmodal ( (modal operator))\[{ ..
  @(#v.#sv) = #se;
... }\] (post))
\replacewith(update-application(elem-update(heap)(store(heap,#v,#memberPVToField(#sv),#se)),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== associativeLawIntersect (associativeLawIntersect) =========================================
associativeLawIntersect {
\find(intersect(s1,intersect(s2,s3)))
\replacewith(intersect(intersect(s1,s2),s3)) 
\heuristics(conjNormalForm)
Choices: programRules:Java}
-----------------------------------------------------
== associativeLawUnion (associativeLawUnion) =========================================
associativeLawUnion {
\find(union(s1,union(s2,s3)))
\replacewith(union(union(s1,s2),s3)) 
\heuristics(conjNormalForm)
Choices: programRules:Java}
-----------------------------------------------------
== atan2IsNaN (atan2IsNaN) =========================================
atan2IsNaN {
\find(atan2Double(arg1,arg2))
\add [imp(or(doubleIsNaN(arg1),doubleIsNaN(arg2)),doubleIsNaN(atan2Double(arg1,arg2)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== atan2Range (atan2Range) =========================================
atan2Range {
\find(atan2Double(arg1,arg2))
\add [imp(and(not(doubleIsNaN(arg1)),not(doubleIsNaN(arg2))),and(geqDouble(atan2Double(arg1,arg2),negDouble(DFP(8(4(8(5(4(0(2(5(5(6(5(6(6(5(2(4(1(6(4(#)))))))))))))))))))))),leqDouble(atan2Double(arg1,arg2),DFP(8(4(8(5(4(0(2(5(5(6(5(6(6(5(2(4(1(6(4(#)))))))))))))))))))))))]==>[] 

Choices: true}
-----------------------------------------------------
== atanIsNaN (atanIsNaN) =========================================
atanIsNaN {
\find(atanDouble(arg))
\add [imp(doubleIsNaN(arg),doubleIsNaN(atanDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== atanIsZero (atanIsZero) =========================================
atanIsZero {
\find(atanDouble(arg))
\add [imp(equals(arg,DFP(0(#))),equals(atanDouble(arg),DFP(0(#))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== atanRange (atanRange) =========================================
atanRange {
\find(atanDouble(arg))
\add [imp(not(doubleIsNaN(arg)),and(geqDouble(atanDouble(arg),negDouble(DFP(2(5(3(5(7(6(4(2(9(6(5(0(3(5(7(9(0(6(4(#)))))))))))))))))))))),leqDouble(atanDouble(arg),DFP(2(5(3(5(7(6(4(2(9(6(5(0(3(5(7(9(0(6(4(#)))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== autoInductGEQ_Lemma_1 (auto_induction_lemma) =========================================
autoInductGEQ_Lemma_1 {
\find(==>and(all{uSub (variable)}(imp(leq(t,uSub),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(leq(t,uSub),b))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,b),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGEQ_Lemma_2 (auto_induction_lemma) =========================================
autoInductGEQ_Lemma_2 {
\find(==>and(all{uSub (variable)}(or(gt(t,uSub),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(leq(t,uSub),b))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,b),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGEQ_Lemma_3 (auto_induction_lemma) =========================================
autoInductGEQ_Lemma_3 {
\find(==>and(all{uSub (variable)}(or(lt(uSub,t),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(leq(t,uSub),b))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,b),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGEQ_Lemma_5 (auto_induction_lemma) =========================================
autoInductGEQ_Lemma_5 {
\find(==>and(all{uSub (variable)}(or(or(gt(t,uSub),psi),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(leq(t,uSub),or(psi,b)))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,or(psi,b)),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGEQ_Lemma_6 (auto_induction_lemma) =========================================
autoInductGEQ_Lemma_6 {
\find(==>and(all{uSub (variable)}(or(or(lt(uSub,t),psi),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(leq(t,uSub),or(psi,b)))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,or(psi,b)),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGT_Lemma_1 (auto_induction_lemma) =========================================
autoInductGT_Lemma_1 {
\find(==>and(all{uSub (variable)}(imp(lt(t,uSub),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(lt(t,uSub),b))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),b),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGT_Lemma_2 (auto_induction_lemma) =========================================
autoInductGT_Lemma_2 {
\find(==>and(all{uSub (variable)}(or(geq(t,uSub),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(lt(t,uSub),b))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),b),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGT_Lemma_3 (auto_induction_lemma) =========================================
autoInductGT_Lemma_3 {
\find(==>and(all{uSub (variable)}(or(leq(uSub,t),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(lt(t,uSub),b))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),b),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGT_Lemma_5 (auto_induction_lemma) =========================================
autoInductGT_Lemma_5 {
\find(==>and(all{uSub (variable)}(or(or(geq(t,uSub),psi),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(lt(t,uSub),or(psi,b)))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),or(psi,b)),true)]) 
\heuristics(auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInductGT_Lemma_6 (auto_induction_lemma) =========================================
autoInductGT_Lemma_6 {
\find(==>and(all{uSub (variable)}(or(or(leq(uSub,t),psi),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(lt(t,uSub),or(psi,b)))]==>[phi]) ;
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),or(psi,b)),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== autoInduct_Lemma (autoInduct_Lemma) =========================================
autoInduct_Lemma {
\find(==>and(all{uSub (variable)}(b),phi))
\replacewith([all{uSub (variable)}(b)]==>[phi]) ;
\replacewith([]==>[imp(and(leq(sk,Z(0(#))),subst{uSub (variable)}(sk,b)),subst{uSub (variable)}(sub(sk,Z(1(#))),b))]) ;
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(sk,b)),subst{uSub (variable)}(add(sk,Z(1(#))),b))]) ;
\replacewith([]==>[subst{uSub (variable)}(Z(0(#)),b)]) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geqZero (auto_induction) =========================================
auto_int_induction_geqZero {
\find(==>all{uSub (variable)}(b))
\replacewith([]==>[imp(and(leq(sk,Z(0(#))),subst{uSub (variable)}(sk,b)),subst{uSub (variable)}(sub(sk,Z(1(#))),b))]) ;
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(sk,b)),subst{uSub (variable)}(add(sk,Z(1(#))),b))]) ;
\replacewith([]==>[subst{uSub (variable)}(Z(0(#)),b)]) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geqZeroLeft (auto_induction) =========================================
auto_int_induction_geqZeroLeft {
\find(exists{uSub (variable)}(b)==>)
\replacewith([]==>[imp(and(leq(sk,Z(0(#))),subst{uSub (variable)}(sk,not(b))),subst{uSub (variable)}(sub(sk,Z(1(#))),not(b)))]) ;
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(sk,not(b))),subst{uSub (variable)}(add(sk,Z(1(#))),not(b)))]) ;
\replacewith([]==>[subst{uSub (variable)}(Z(0(#)),not(b))]) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geq_1 (auto_induction) =========================================
auto_int_induction_geq_1 {
\find(==>all{uSub (variable)}(imp(leq(t,uSub),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,b),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geq_2 (auto_induction) =========================================
auto_int_induction_geq_2 {
\find(==>all{uSub (variable)}(or(gt(t,uSub),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,b),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geq_3 (auto_induction) =========================================
auto_int_induction_geq_3 {
\find(==>all{uSub (variable)}(or(lt(uSub,t),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,b),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geq_5 (auto_induction) =========================================
auto_int_induction_geq_5 {
\find(==>all{uSub (variable)}(or(or(gt(t,uSub),psi),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,or(psi,b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geq_6 (auto_induction) =========================================
auto_int_induction_geq_6 {
\find(==>all{uSub (variable)}(or(or(lt(uSub,t),psi),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,or(psi,b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geq_Left1 (auto_induction) =========================================
auto_int_induction_geq_Left1 {
\find(exists{uSub (variable)}(and(leq(t,uSub),b))==>)
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),not(b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),not(b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,not(b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_geq_Left2 (auto_induction) =========================================
auto_int_induction_geq_Left2 {
\find(exists{uSub (variable)}(and(geq(uSub,t),b))==>)
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(add(t,sk),not(b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),not(b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(t,not(b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_gt_1 (auto_induction) =========================================
auto_int_induction_gt_1 {
\find(==>all{uSub (variable)}(imp(lt(t,uSub),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),b),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_gt_2 (auto_induction) =========================================
auto_int_induction_gt_2 {
\find(==>all{uSub (variable)}(or(geq(t,uSub),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),b),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_gt_3 (auto_induction) =========================================
auto_int_induction_gt_3 {
\find(==>all{uSub (variable)}(or(leq(uSub,t),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),b)),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),b),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),b),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_gt_5 (auto_induction) =========================================
auto_int_induction_gt_5 {
\find(==>all{uSub (variable)}(or(or(geq(t,uSub),psi),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),or(psi,b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_gt_6 (auto_induction) =========================================
auto_int_induction_gt_6 {
\find(==>all{uSub (variable)}(or(or(leq(uSub,t),psi),b)))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),or(psi,b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_gt_Left1 (auto_induction) =========================================
auto_int_induction_gt_Left1 {
\find(exists{uSub (variable)}(and(lt(t,uSub),b))==>)
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),not(b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),not(b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),not(b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== auto_int_induction_gt_Left2 (auto_induction) =========================================
auto_int_induction_gt_Left2 {
\find(exists{uSub (variable)}(and(gt(uSub,t),b))==>)
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==>[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),not(b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),not(b)),true))]) ;
\replacewith([]==>[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),not(b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== beginJavaCardTransactionAPI (beginJavaCardTransactionAPI) =========================================
beginJavaCardTransactionAPI {
\find(==>#allmodal ( (modal operator))\[{ ..
  #jcsystemType.#beginTransaction()@#jcsystemType;
... }\] (post))
\replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #beginJavaCardTransaction;
... }\] (post)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== beginJavaCardTransactionBox (beginJavaCardTransaction) =========================================
beginJavaCardTransactionBox {
\find(==>\[{ ..
  #beginJavaCardTransaction;
... }\] (post))
\replacewith([]==>[update-application(elem-update(savedHeap)(heap),box_transaction(post))]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== beginJavaCardTransactionDiamond (beginJavaCardTransaction) =========================================
beginJavaCardTransactionDiamond {
\find(==>\<{ ..
  #beginJavaCardTransaction;
... }\> (post))
\replacewith([]==>[update-application(elem-update(savedHeap)(heap),diamond_transaction(post))]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== binaryAndOne (binaryAndOne) =========================================
binaryAndOne {
\find(binaryAnd(left,Z(1(#))))
\replacewith(if-then-else(equals(mod(left,Z(2(#))),Z(0(#))),Z(0(#)),Z(1(#)))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== binaryAndSymm (binaryAndSymm) =========================================
binaryAndSymm {
\find(binaryAnd(left,right))
\replacewith(binaryAnd(right,left)) 

Choices: true}
-----------------------------------------------------
== binaryAndZeroLeft (binaryAndZeroLeft) =========================================
binaryAndZeroLeft {
\find(binaryAnd(Z(0(#)),right))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== binaryAndZeroRight (binaryAndZeroRight) =========================================
binaryAndZeroRight {
\find(binaryAnd(left,Z(0(#))))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== binaryAnd_literals (binary_AND) =========================================
binaryAnd_literals {
\find(binaryAnd(Z(iz),Z(jz)))
\replacewith(#BinaryAnd(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== binaryOrGte (binaryOrGte) =========================================
binaryOrGte {
\find(binaryOr(left,right))
\sameUpdateLevel\add [imp(and(geq(left,Z(0(#))),geq(right,Z(0(#)))),and(and(geq(binaryOr(left,right),left),geq(binaryOr(left,right),right)),leq(binaryOr(left,right),mul(Z(2(#)),if-then-else(gt(left,right),left,right)))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== binaryOrInInt (binaryOrInInt) =========================================
binaryOrInInt {
\find(binaryOr(left,right))
\sameUpdateLevel\add [imp(and(inRangeInt(left),inRangeInt(right)),inRangeInt(binaryOr(left,right)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== binaryOrNeutralLeft (binaryOrNeutralLeft) =========================================
binaryOrNeutralLeft {
\find(binaryOr(Z(0(#)),right))
\replacewith(right) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== binaryOrNeutralRight (binaryOrNeutralRight) =========================================
binaryOrNeutralRight {
\find(binaryOr(left,Z(0(#))))
\replacewith(left) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== binaryOrSign (binaryOrSign) =========================================
binaryOrSign {
\find(binaryOr(left,right))
\sameUpdateLevel\add [geq(mul(if-then-else(and(geq(left,Z(0(#))),geq(right,Z(0(#)))),Z(1(#)),Z(neglit(1(#)))),binaryOr(left,right)),Z(0(#)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== binaryOr_literals (binary_OR) =========================================
binaryOr_literals {
\find(binaryOr(Z(iz),Z(jz)))
\replacewith(#BinaryOr(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== binaryXOr_literals (binary_XOR) =========================================
binaryXOr_literals {
\find(binaryXOr(Z(iz),Z(jz)))
\replacewith(#BinaryXOr(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== bitwiseNegateJIntDefinition (bitwiseNegateDefinition) =========================================
bitwiseNegateJIntDefinition {
\find(bitwiseNegateJint(i))
\replacewith(sub(neg(i),Z(1(#)))) 
\heuristics(javaIntegerSemantics)
Choices: true}
-----------------------------------------------------
== bitwiseNegateJlongDefinition (bitwiseNegateDefinition) =========================================
bitwiseNegateJlongDefinition {
\find(bitwiseNegateJlong(i))
\replacewith(sub(neg(i),Z(1(#)))) 
\heuristics(javaIntegerSemantics)
Choices: true}
-----------------------------------------------------
== bitwiseNegationInt (invertBits) =========================================
bitwiseNegationInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = ~#seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseNegateInt(#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== bitwiseNegationLong (invertBits) =========================================
bitwiseNegationLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = ~#se;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseNegateLong(#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== blockBreak (blockBreak) =========================================
blockBreak {
\find(#allmodal ( (modal operator))\[{ ..
  {
    break;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  break;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockBreakLabel (blockBreakLabel) =========================================
blockBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  #lb0:
  {
    break;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  do-break(#lb0:
  break;)
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockBreakLabeled (blockBreakLabeled) =========================================
blockBreakLabeled {
\find(#allmodal ( (modal operator))\[{ ..
  {
    break;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  break;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockBreakNoLabel (blockBreakNoLabel) =========================================
blockBreakNoLabel {
\find(#allmodal ( (modal operator))\[{ ..
  {
    break;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  break;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockContinue (blockContinue) =========================================
blockContinue {
\find(#allmodal ( (modal operator))\[{ ..
  {
    continue;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  continue;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockContinueLabeled (blockContinueLabeled) =========================================
blockContinueLabeled {
\find(#allmodal ( (modal operator))\[{ ..
  {
    continue;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  continue;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockEmpty (blockEmpty) =========================================
blockEmpty {
\find(#allmodal ( (modal operator))\[{ ..
  {}
... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockEmptyLabel (blockEmpty) =========================================
blockEmptyLabel {
\find(#allmodal ( (modal operator))\[{ ..
  #lb:
  {}
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {}
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockReturn (blockReturn) =========================================
blockReturn {
\find(#allmodal ( (modal operator))\[{ ..
  {
    return #se;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  return #se;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockReturnLabel1 (blockReturn (remove label)) =========================================
blockReturnLabel1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lb:
  return #se;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  return #se;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockReturnLabel2 (blockReturn (remove label)) =========================================
blockReturnLabel2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lb:
  {
    return #se;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  return #se;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockReturnNoValue (blockReturn) =========================================
blockReturnNoValue {
\find(#allmodal ( (modal operator))\[{ ..
  {
    return;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  return;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== blockThrow (blockThrow) =========================================
blockThrow {
\find(#allmodal ( (modal operator))\[{ ..
  {
    throw #e;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  throw #e;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== boolean_equal (boolean_equal) =========================================
boolean_equal {
\find(equals(bo,bo))
\replacewith(true) 
\heuristics(concrete, simplify_boolean)
Choices: true}
-----------------------------------------------------
== boolean_equal_2 (boolean_equal) =========================================
boolean_equal_2 {
\find(equiv(equals(b1,TRUE),equals(b2,TRUE)))
\replacewith(equals(b1,b2)) 
\heuristics(concrete, simplify_boolean)
Choices: true}
-----------------------------------------------------
== boolean_false_commute (boolean commute) =========================================
boolean_false_commute {
\find(equals(FALSE,bo))
\replacewith(equals(bo,FALSE)) 
\heuristics(simplify_boolean)
Choices: true}
-----------------------------------------------------
== boolean_not_equal_1 (boolean_not_equal) =========================================
boolean_not_equal_1 {
\find(equals(TRUE,FALSE))
\replacewith(false) 
\heuristics(concrete, simplify_boolean)
Choices: true}
-----------------------------------------------------
== boolean_not_equal_2 (boolean_not_equal) =========================================
boolean_not_equal_2 {
\find(equals(FALSE,TRUE))
\replacewith(false) 
\heuristics(concrete, simplify_boolean)
Choices: true}
-----------------------------------------------------
== boolean_true_commute (boolean commute) =========================================
boolean_true_commute {
\find(equals(TRUE,bo))
\replacewith(equals(bo,TRUE)) 
\heuristics(simplify_boolean)
Choices: true}
-----------------------------------------------------
== boxToDiamond (boxToDiamond) =========================================
boxToDiamond {
\find(\[{ ..
  #s
... }\] (post))
\replacewith(not(\<{ ..
  #s
... }\> (not(post)))) 
\heuristics(boxDiamondConv)
Choices: programRules:Java}
-----------------------------------------------------
== boxToDiamondTransaction (boxToDiamond) =========================================
boxToDiamondTransaction {
\find(box_transaction\[{ ..
  #s
... }\] (post))
\replacewith(not(diamond_transaction\[{ ..
  #s
... }\] (not(post)))) 
\heuristics(boxDiamondConv)
Choices: programRules:Java}
-----------------------------------------------------
== box_and_left (box_and_left) =========================================
box_and_left {
\find(#box ( (modal operator))\[{ ..
  #s
... }\] (and(post,post1))==>)
\replacewith([and(#box ( (modal operator))\[{ ..
  #s
... }\] (post),#box ( (modal operator))\[{ ..
  #s
... }\] (post1))]==>[]) 

Choices: programRules:Java}
-----------------------------------------------------
== box_and_right (box_and_right) =========================================
box_and_right {
\find(==>#box ( (modal operator))\[{ ..
  #s
... }\] (and(post,post1)))
\replacewith([]==>[#box ( (modal operator))\[{ ..
  #s
... }\] (post1)]) ;
\replacewith([]==>[#box ( (modal operator))\[{ ..
  #s
... }\] (post)]) 

Choices: programRules:Java}
-----------------------------------------------------
== box_or_left (box_or_left) =========================================
box_or_left {
\find(#box ( (modal operator))\[{ ..
  #s
... }\] (or(post,post1))==>)
\replacewith([or(#box ( (modal operator))\[{ ..
  #s
... }\] (post),#box ( (modal operator))\[{ ..
  #s
... }\] (post1))]==>[]) 

Choices: programRules:Java}
-----------------------------------------------------
== box_or_right (box_or_right) =========================================
box_or_right {
\find(==>#box ( (modal operator))\[{ ..
  #s
... }\] (or(post,post1)))
\replacewith([]==>[or(#box ( (modal operator))\[{ ..
  #s
... }\] (post),#box ( (modal operator))\[{ ..
  #s
... }\] (post1))]) 

Choices: programRules:Java}
-----------------------------------------------------
== box_true (box_true) =========================================
box_true {
\find(#box ( (modal operator))\[{ ..
  #s
... }\] (true))
\replacewith(true) 
\heuristics(modal_tautology)
Choices: programRules:Java}
-----------------------------------------------------
== bprod_all_positive (bprod_all_positive) =========================================
bprod_all_positive {
\find(bprod{uSub (variable)}(i0,i1,t1))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [imp(all{uSub (variable)}(imp(and(leq(i0,uSub),lt(uSub,i1)),geq(t1,Z(0(#))))),geq(bprod{uSub (variable)}(i0,i1,t1),Z(0(#))))]==>[] 

Choices: (integerSimplificationRules:full & sequences:on)}
-----------------------------------------------------
== bprod_commutative_associative (bprod_commutative_associative) =========================================
bprod_commutative_associative {
\find(bprod{uSub (variable)}(i0,i2,mul(t,t2)))
\varcond(\notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(i0,i2,t),bprod{uSub1 (variable)}(i0,i2,subst{uSub (variable)}(uSub1,t2)))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_empty (bprod_empty) =========================================
bprod_empty {
\find(bprod{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(1(#))) ;
\add []==>[leq(i1,i0)] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_equal_one_right (bprod_equal_one_right) =========================================
bprod_equal_one_right {
\find(==>equals(bprod{uSub (variable)}(i0,i2,t),Z(1(#))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add []==>[all{uSub (variable)}(subst{uSub (variable)}(uSub,imp(and(geq(uSub,i0),lt(uSub,i2)),equals(t,Z(1(#))))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_equal_zero_right (bprod_equal_zero_right) =========================================
bprod_equal_zero_right {
\find(==>equals(bprod{uSub (variable)}(i0,i2,t),Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add []==>[exists{uSub (variable)}(subst{uSub (variable)}(uSub,and(and(geq(uSub,i0),lt(uSub,i2)),equals(t,Z(0(#))))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_find (bprod_find) =========================================
bprod_find {
\find(bprod{uSub (variable)}(low,high,t))
\varcond(\notFreeIn(uSub (variable), high (int term)), \notFreeIn(uSub (variable), middle (int term)), \notFreeIn(uSub (variable), low (int term)))
\replacewith(if-then-else(and(leq(low,middle),leq(middle,high)),mul(bprod{uSub (variable)}(low,middle,t),bprod{uSub (variable)}(middle,high,t)),bprod{uSub (variable)}(low,high,t))) 
\heuristics(triggered, comprehension_split)
Choices: integerSimplificationRules:full
\trigger{middle (int term)} bprod{uSub (variable)}(low,middle,t) \avoid leq(middle,low), geq(middle,high)}
-----------------------------------------------------
== bprod_induction_lower (bprod_induction_lower) =========================================
bprod_induction_lower {
\find(bprod{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(add(i0,Z(1(#))),i2,t),if-then-else(lt(i0,i2),subst{uSub (variable)}(i0,t),Z(1(#))))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_induction_lower_concrete (bprod_induction_lower_concrete) =========================================
bprod_induction_lower_concrete {
\find(bprod{uSub (variable)}(add(Z(neglit(1(#))),i0),i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(i0,i2,t),if-then-else(lt(add(Z(neglit(1(#))),i0),i2),subst{uSub (variable)}(add(Z(neglit(1(#))),i0),t),Z(1(#))))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_induction_upper (bprod_induction_upper) =========================================
bprod_induction_upper {
\find(bprod{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(i0,sub(i2,Z(1(#))),t),if-then-else(lt(i0,i2),subst{uSub (variable)}(sub(i2,Z(1(#))),t),Z(1(#))))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_induction_upper_concrete (bprod_induction_upper_concrete) =========================================
bprod_induction_upper_concrete {
\find(bprod{uSub (variable)}(i0,add(Z(1(#)),i2),t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(i0,i2,t),if-then-else(leq(i0,i2),subst{uSub (variable)}(i2,t),Z(1(#))))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_invert_index (bprod_invert_index) =========================================
bprod_invert_index {
\find(bprod{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bprod{uSub1 (variable)}(neg(i1),neg(i0),subst{uSub (variable)}(neg(uSub1),t))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_invert_index_concrete (bprod_invert_index_concrete) =========================================
bprod_invert_index_concrete {
\find(bprod{uSub (variable)}(mul(i0,Z(neglit(1(#)))),mul(i1,Z(neglit(1(#)))),t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bprod{uSub1 (variable)}(i1,i0,subst{uSub (variable)}(neg(uSub1),t))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_lower_equals_upper (bprod_lower_equals_upper) =========================================
bprod_lower_equals_upper {
\find(bprod{uSub (variable)}(i0,i0,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_one (bprod_one) =========================================
bprod_one {
\find(bprod{uSub (variable)}(i0,i1,Z(1(#))))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_one_factor (bprod_one_factor) =========================================
bprod_one_factor {
\find(bprod{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(equals(add(i0,Z(1(#))),i1),subst{uSub (variable)}(i0,t),bprod{uSub (variable)}(i0,i1,t))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_one_factor_concrete1 (bprod_one_factor_concrete1) =========================================
bprod_one_factor_concrete1 {
\find(bprod{uSub (variable)}(i0,add(Z(1(#)),i0),t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(subst{uSub (variable)}(i0,t)) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_one_factor_concrete2 (bprod_one_factor_concrete2) =========================================
bprod_one_factor_concrete2 {
\find(bprod{uSub (variable)}(add(Z(neglit(1(#))),i0),i0,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(subst{uSub (variable)}(add(Z(neglit(1(#))),i0),t)) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_shift_index (bprod_shift_index) =========================================
bprod_shift_index {
\find(bprod{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bprod{uSub1 (variable)}(Z(0(#)),sub(i1,i0),subst{uSub (variable)}(add(uSub1,i0),t))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bprod_split (bprod_split) =========================================
bprod_split {
\find(bprod{uSub (variable)}(i0,i1,t1))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(and(leq(i0,middle),leq(middle,i1)),mul(bprod{uSub (variable)}(i0,middle,t1),bprod{uSub (variable)}(middle,i1,t1)),bprod{uSub (variable)}(i0,i1,t1))) 

Choices: (integerSimplificationRules:full & sequences:on)}
-----------------------------------------------------
== bprod_zero (bprod_zero) =========================================
bprod_zero {
\find(bprod{uSub (variable)}(i0,i1,Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(lt(i0,i1),Z(0(#)),Z(1(#)))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== break (break) =========================================
break {
\find(#allmodal ( (modal operator))\[{ ..
  #lb0:
  break;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  do-break(#lb0:
  break;)
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== bsum_add (bsum_add) =========================================
bsum_add {
\find(add(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i2,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(if-then-else(lt(i0,i2),i0,i2),if-then-else(gt(i1,i3),i1,i3),subst{uSub2 (variable)}(uSub1,add(if-then-else(and(leq(i0,uSub1),lt(uSub1,i1)),t1,Z(0(#))),if-then-else(and(leq(i2,uSub1),lt(uSub1,i3)),t2,Z(0(#))))))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_add_concrete (bsum_add_concrete) =========================================
bsum_add_concrete {
\find(add(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i1,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(i0,i3,subst{uSub2 (variable)}(uSub1,if-then-else(lt(uSub1,i1),t1,t2)))) ;
\add []==>[and(leq(i0,i1),leq(i1,i3))] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_commutative_associative (bsum_commutative_associative) =========================================
bsum_commutative_associative {
\find(bsum{uSub (variable)}(i0,i2,add(t,t2)))
\varcond(\notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(i0,i2,t),bsum{uSub1 (variable)}(i0,i2,subst{uSub (variable)}(uSub1,t2)))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_def (bsum_def) =========================================
bsum_def {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(lt(i0,i1),add(bsum{uSub (variable)}(i0,sub(i1,Z(1(#))),t),subst{uSub (variable)}(sub(i1,Z(1(#))),t)),Z(0(#)))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_distributive (bsum_distributive) =========================================
bsum_distributive {
\find(bsum{uSub (variable)}(i0,i2,mul(t,t1)))
\varcond(\notFreeIn(uSub (variable), t1 (int term)), \notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bsum{uSub (variable)}(i0,i2,t),t1)) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_empty (bsum_empty) =========================================
bsum_empty {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(0(#))) ;
\add []==>[leq(i1,i0)] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_equal_except_one_index (bsum_equal_except_one_index) =========================================
bsum_equal_except_one_index {
\find(==>equals(bsum{uSub1 (variable)}(i0,i1,t1),add(bsum{uSub2 (variable)}(i0,i1,t2),t)))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), index (int term)), \notFreeIn(uSub1 (variable), index (int term)), \notFreeIn(uSub2 (variable), t (int term)), \notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==>[equals(t,sub(subst{uSub1 (variable)}(index,t1),subst{uSub2 (variable)}(index,t2)))] ;
\add []==>[and(and(leq(i0,index),lt(index,i1)),all{uSub1 (variable)}(imp(and(and(geq(uSub1,i0),lt(uSub1,i1)),not(equals(uSub1,index))),equals(t1,subst{uSub2 (variable)}(uSub1,t2)))))] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_equal_split1 (bsum_equal_split1) =========================================
bsum_equal_split1 {
\find(==>equals(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i0,i2,t2)))
\varcond(\notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==>[and(and(leq(i0,i1),leq(i0,i2)),if-then-else(lt(i1,i2),equals(bsum{uSub1 (variable)}(i0,i1,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),bsum{uSub2 (variable)}(i1,i2,t2)),equals(bsum{uSub1 (variable)}(i2,i1,t1),bsum{uSub2 (variable)}(i0,i2,sub(t2,subst{uSub1 (variable)}(uSub2,t1))))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_equal_split2 (bsum_equal_split2) =========================================
bsum_equal_split2 {
\assumes ([equals(bsum{uSub1 (variable)}(i0,i1,t1),i)]==>[]) 
\find(==>equals(bsum{uSub2 (variable)}(i0,i2,t2),i))
\varcond(\notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==>[and(and(leq(i0,i1),leq(i0,i2)),if-then-else(lt(i2,i1),equals(bsum{uSub1 (variable)}(i2,i1,t1),bsum{uSub2 (variable)}(i0,i2,sub(t2,subst{uSub1 (variable)}(uSub2,t1)))),equals(bsum{uSub1 (variable)}(i0,i1,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),bsum{uSub2 (variable)}(i1,i2,t2))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_equal_split3 (bsum_equal_split3) =========================================
bsum_equal_split3 {
\find(==>equals(bsum{uSub1 (variable)}(i1,i0,t1),bsum{uSub2 (variable)}(i2,i0,t2)))
\varcond(\notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==>[and(and(leq(i1,i0),leq(i2,i0)),if-then-else(lt(i1,i2),equals(bsum{uSub1 (variable)}(i1,i2,t1),bsum{uSub2 (variable)}(i2,i0,sub(t2,subst{uSub1 (variable)}(uSub2,t1)))),equals(bsum{uSub1 (variable)}(i1,i0,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),bsum{uSub2 (variable)}(i2,i1,t2))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_equal_split4 (bsum_equal_split4) =========================================
bsum_equal_split4 {
\assumes ([equals(bsum{uSub1 (variable)}(i1,i0,t1),i)]==>[]) 
\find(==>equals(bsum{uSub2 (variable)}(i2,i0,t2),i))
\varcond(\notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==>[and(and(leq(i1,i0),leq(i2,i0)),if-then-else(lt(i2,i1),equals(bsum{uSub1 (variable)}(i1,i0,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),bsum{uSub2 (variable)}(i2,i1,t2)),equals(bsum{uSub1 (variable)}(i1,i2,t1),bsum{uSub2 (variable)}(i2,i0,sub(t2,subst{uSub1 (variable)}(uSub2,t1))))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_lower (bsum_induction_lower) =========================================
bsum_induction_lower {
\find(bsum{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(add(i0,Z(1(#))),i2,t),if-then-else(lt(i0,i2),subst{uSub (variable)}(i0,t),Z(0(#))))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_lower2 (bsum_induction_lower2) =========================================
bsum_induction_lower2 {
\find(bsum{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(sub(bsum{uSub (variable)}(sub(i0,Z(1(#))),i2,t),if-then-else(lt(sub(i0,Z(1(#))),i2),subst{uSub (variable)}(sub(i0,Z(1(#))),t),Z(0(#))))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_lower2_concrete (bsum_induction_lower2_concrete) =========================================
bsum_induction_lower2_concrete {
\find(bsum{uSub (variable)}(add(Z(1(#)),i0),i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(sub(bsum{uSub (variable)}(i0,i2,t),if-then-else(lt(i0,i2),subst{uSub (variable)}(i0,t),Z(0(#))))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_lower_concrete (bsum_induction_lower_concrete) =========================================
bsum_induction_lower_concrete {
\find(bsum{uSub (variable)}(add(Z(neglit(1(#))),i0),i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(i0,i2,t),if-then-else(lt(add(Z(neglit(1(#))),i0),i2),subst{uSub (variable)}(add(Z(neglit(1(#))),i0),t),Z(0(#))))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_upper (bsum_induction_upper) =========================================
bsum_induction_upper {
\find(bsum{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(i0,sub(i2,Z(1(#))),t),if-then-else(lt(i0,i2),subst{uSub (variable)}(sub(i2,Z(1(#))),t),Z(0(#))))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_upper2 (bsum_induction_upper2) =========================================
bsum_induction_upper2 {
\find(bsum{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(sub(bsum{uSub (variable)}(i0,add(i2,Z(1(#))),t),if-then-else(lt(i0,add(i2,Z(1(#)))),subst{uSub (variable)}(i2,t),Z(0(#))))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_upper2_concrete (bsum_induction_upper2_concrete) =========================================
bsum_induction_upper2_concrete {
\find(bsum{uSub (variable)}(i0,add(Z(neglit(1(#))),i2),t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(sub(bsum{uSub (variable)}(i0,i2,t),if-then-else(lt(i0,i2),subst{uSub (variable)}(sub(i2,Z(1(#))),t),Z(0(#))))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_upper_concrete (bsum_induction_upper_concrete) =========================================
bsum_induction_upper_concrete {
\find(bsum{uSub (variable)}(i0,add(Z(1(#)),i2),t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(i0,i2,t),if-then-else(leq(i0,i2),subst{uSub (variable)}(i2,t),Z(0(#))))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_induction_upper_concrete_2 (bsum_induction_upper_concrete_2) =========================================
bsum_induction_upper_concrete_2 {
\find(bsum{uSub (variable)}(Z(iz),Z(jz),t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(Z(iz),sub(Z(jz),Z(1(#))),t),if-then-else(leq(Z(iz),sub(Z(jz),Z(1(#)))),subst{uSub (variable)}(sub(Z(jz),Z(1(#))),t),Z(0(#))))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_invert_index (bsum_invert_index) =========================================
bsum_invert_index {
\find(bsum{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(neg(i1),neg(i0),subst{uSub (variable)}(neg(uSub1),t))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_invert_index_concrete (bsum_invert_index_concrete) =========================================
bsum_invert_index_concrete {
\find(bsum{uSub (variable)}(mul(i0,Z(neglit(1(#)))),mul(i1,Z(neglit(1(#)))),t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(i1,i0,subst{uSub (variable)}(neg(uSub1),t))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_less_same_index (bsum_less_same_index) =========================================
bsum_less_same_index {
\find(==>lt(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i0,i1,t2)))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==>[and(all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),leq(t1,subst{uSub2 (variable)}(uSub1,t2)))),exists{uSub1 (variable)}(and(and(geq(uSub1,i0),lt(uSub1,i1)),lt(t1,subst{uSub2 (variable)}(uSub1,t2)))))] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_lower_bound (bsum_lower_bound) =========================================
bsum_lower_bound {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), j (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [imp(all{uSub (variable)}(imp(and(geq(uSub,i0),lt(uSub,i1)),geq(t,j))),geq(bsum{uSub (variable)}(i0,i1,t),if-then-else(gt(sub(i1,i0),Z(0(#))),mul(sub(i1,i0),j),Z(0(#)))))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_lower_equals_upper (bsum_lower_equals_upper) =========================================
bsum_lower_equals_upper {
\find(bsum{uSub (variable)}(i0,i0,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_bounds (bsum_num_of_bounds) =========================================
bsum_num_of_bounds {
\find(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#)))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [leq(Z(0(#)),bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#))))),imp(leq(i0,i2),leq(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#)))),sub(i2,i0)))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_bounds2 (bsum_num_of_bounds2) =========================================
bsum_num_of_bounds2 {
\find(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#)))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [leq(Z(0(#)),bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#))))),imp(leq(i0,i2),leq(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#)))),sub(i2,i0)))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_gt0 (bsum_num_of_gt0) =========================================
bsum_num_of_gt0 {
\find(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#)))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [imp(gt(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#)))),Z(0(#))),exists{uSub (variable)}(and(and(leq(i0,uSub),lt(uSub,i2)),phi)))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_gt0_alt (bsum_num_of_gt0_alt) =========================================
bsum_num_of_gt0_alt {
\find(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#)))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [imp(gt(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#)))),Z(0(#))),exists{uSub (variable)}(and(and(leq(i0,uSub),lt(uSub,i2)),not(phi))))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_is_max (bsum_num_of_is_max) =========================================
bsum_num_of_is_max {
\find(equals(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#)))),sub(i2,i0))==>)
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [all{uSub (variable)}(imp(and(geq(uSub,i0),lt(uSub,i2)),phi))]==>[] 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_is_max2 (bsum_num_of_is_max2) =========================================
bsum_num_of_is_max2 {
\assumes ([gt(i2,i0)]==>[]) 
\find(all{uSub (variable)}(imp(and(geq(uSub,i0),lt(uSub,i2)),phi))==>)
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [equals(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#)))),sub(i2,i0))]==>[] 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_is_max3 (bsum_num_of_is_max3) =========================================
bsum_num_of_is_max3 {
\find(equals(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#)))),sub(i2,i0))==>)
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [all{uSub (variable)}(imp(and(geq(uSub,i0),lt(uSub,i2)),not(phi)))]==>[] 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_is_max4 (bsum_num_of_is_max4) =========================================
bsum_num_of_is_max4 {
\assumes ([gt(i2,i0)]==>[]) 
\find(all{uSub (variable)}(imp(and(geq(uSub,i0),lt(uSub,i2)),not(phi)))==>)
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [equals(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#)))),sub(i2,i0))]==>[] 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_lt_max (bsum_num_of_lt_max) =========================================
bsum_num_of_lt_max {
\assumes ([and(gt(i2,i0),geq(i0,Z(0(#))))]==>[]) 
\find(lt(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#)))),sub(i2,i0))==>)
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [exists{uSub (variable)}(and(and(geq(uSub,i0),lt(uSub,i2)),not(phi)))]==>[] 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_lt_max2 (bsum_num_of_lt_max2) =========================================
bsum_num_of_lt_max2 {
\assumes ([and(gt(i2,i0),geq(i0,Z(0(#))))]==>[]) 
\find(exists{uSub (variable)}(and(and(geq(uSub,i0),lt(uSub,i2)),not(phi)))==>)
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [lt(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(1(#)),Z(0(#)))),sub(i2,i0))]==>[] 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_lt_max3 (bsum_num_of_lt_max3) =========================================
bsum_num_of_lt_max3 {
\assumes ([and(gt(i2,i0),geq(i0,Z(0(#))))]==>[]) 
\find(lt(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#)))),sub(i2,i0))==>)
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [exists{uSub (variable)}(and(and(geq(uSub,i0),lt(uSub,i2)),phi))]==>[] 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_num_of_lt_max4 (bsum_num_of_lt_max4) =========================================
bsum_num_of_lt_max4 {
\assumes ([and(gt(i2,i0),geq(i0,Z(0(#))))]==>[]) 
\find(exists{uSub (variable)}(and(and(geq(uSub,i0),lt(uSub,i2)),phi))==>)
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [lt(bsum{uSub (variable)}(i0,i2,if-then-else(phi,Z(0(#)),Z(1(#)))),sub(i2,i0))]==>[] 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_one_summand (bsum_one_summand) =========================================
bsum_one_summand {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(equals(add(i0,Z(1(#))),i1),subst{uSub (variable)}(i0,t),bsum{uSub (variable)}(i0,i1,t))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_one_summand_concrete1 (bsum_one_summand_concrete1) =========================================
bsum_one_summand_concrete1 {
\find(bsum{uSub (variable)}(i0,add(Z(1(#)),i0),t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(subst{uSub (variable)}(i0,t)) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_one_summand_concrete2 (bsum_one_summand_concrete2) =========================================
bsum_one_summand_concrete2 {
\find(bsum{uSub (variable)}(add(Z(neglit(1(#))),i0),i0,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(subst{uSub (variable)}(add(Z(neglit(1(#))),i0),t)) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_positive (bsum_positive) =========================================
bsum_positive {
\find(==>geq(bsum{uSub (variable)}(i0,i1,t),Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add []==>[all{uSub (variable)}(imp(and(geq(uSub,i0),lt(uSub,i1)),geq(t,Z(0(#)))))] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_positive1 (bsum_positive1) =========================================
bsum_positive1 {
\find(bsum{uSub (variable)}(i0,i1,if-then-else(b,Z(1(#)),Z(0(#)))))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [geq(bsum{uSub (variable)}(i0,i1,if-then-else(b,Z(1(#)),Z(0(#)))),Z(0(#)))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_positive2 (bsum_positive2) =========================================
bsum_positive2 {
\find(bsum{uSub (variable)}(i0,i1,if-then-else(b,Z(0(#)),Z(1(#)))))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [geq(bsum{uSub (variable)}(i0,i1,if-then-else(b,Z(0(#)),Z(1(#)))),Z(0(#)))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_positive_lower_bound_element (bsum_positive_lower_bound_element) =========================================
bsum_positive_lower_bound_element {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), index (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [leq(subst{uSub (variable)}(index,t),bsum{uSub (variable)}(i0,i1,t))]==>[] ;
\add []==>[and(and(all{uSub (variable)}(imp(and(and(geq(uSub,i0),lt(uSub,i1)),not(equals(uSub,index))),geq(t,Z(0(#))))),leq(i0,index)),lt(index,i1))] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_same_summand (bsum_same_summand) =========================================
bsum_same_summand {
\find(bsum{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub (variable), t (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(geq(i1,i0),mul(t,sub(i1,i0)),Z(0(#)))) 
\heuristics(simplify)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_shift_index (bsum_shift_index) =========================================
bsum_shift_index {
\find(bsum{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(Z(0(#)),sub(i1,i0),subst{uSub (variable)}(add(uSub1,i0),t))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_split (bsum_split) =========================================
bsum_split {
\find(bsum{uSub (variable)}(low,high,t))
\varcond(\notFreeIn(uSub (variable), high (int term)), \notFreeIn(uSub (variable), middle (int term)), \notFreeIn(uSub (variable), low (int term)))
\replacewith(if-then-else(and(leq(low,middle),leq(middle,high)),add(bsum{uSub (variable)}(low,middle,t),bsum{uSub (variable)}(middle,high,t)),bsum{uSub (variable)}(low,high,t))) 
\heuristics(triggered, comprehension_split)
Choices: integerSimplificationRules:full
\trigger{middle (int term)} bsum{uSub (variable)}(low,middle,t) \avoid leq(middle,low), geq(middle,high)}
-----------------------------------------------------
== bsum_split_in_three (bsum_split_in_three) =========================================
bsum_split_in_three {
\find(bsum{uSub (variable)}(i0,i2,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub (variable), i1 (int term)))
\replacewith(add(add(bsum{uSub (variable)}(i0,i1,t),subst{uSub (variable)}(i1,t)),bsum{uSub1 (variable)}(add(i1,Z(1(#))),i2,subst{uSub (variable)}(uSub1,t)))) ;
\add []==>[and(leq(i0,i1),lt(i1,i2))] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_sub_same_index (bsum_sub_same_index) =========================================
bsum_sub_same_index {
\find(sub(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i0,i1,t2)))
\sameUpdateLevel\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add [equals(bsum{uSub1 (variable)}(i0,i1,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),sub(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i0,i1,t2)))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_upper_bound (bsum_upper_bound) =========================================
bsum_upper_bound {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), j (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [imp(all{uSub (variable)}(imp(and(geq(uSub,i0),lt(uSub,i1)),leq(t,j))),leq(bsum{uSub (variable)}(i0,i1,t),if-then-else(gt(sub(i1,i0),Z(0(#))),mul(sub(i1,i0),j),Z(0(#)))))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_zero (bsum_zero) =========================================
bsum_zero {
\find(bsum{uSub (variable)}(i0,i1,Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== bsum_zero_right (bsum_zero_right) =========================================
bsum_zero_right {
\find(==>equals(bsum{uSub (variable)}(i0,i2,t),Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add []==>[all{uSub (variable)}(subst{uSub (variable)}(uSub,imp(and(geq(uSub,i0),lt(uSub,i2)),equals(t,Z(0(#))))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== cancel_equation (cancel_equation) =========================================
cancel_equation {
\find(equals(mul(eqLeft,Fac),mul(eqRight,Fac)))
\add []==>[not(equals(Fac,Z(0(#))))] ;
\replacewith(equals(eqLeft,eqRight)) 
\heuristics(simplify_enlarging)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== cancel_gtNeg (cancel_gtNeg) =========================================
cancel_gtNeg {
\assumes ([lt(Fac,Z(0(#)))]==>[]) 
\find(lt(Less,More)==>)
\add [gt(mul(Less,Fac),mul(More,Fac))]==>[] 

Choices: true}
-----------------------------------------------------
== cancel_gtPos (cancel_gtPos) =========================================
cancel_gtPos {
\assumes ([gt(Fac,Z(0(#)))]==>[]) 
\find(lt(Less,More)==>)
\add [lt(mul(Less,Fac),mul(More,Fac))]==>[] 

Choices: true}
-----------------------------------------------------
== case_distinction_l (case_distinction) =========================================
case_distinction_l {
\find(b==>)
\addrules [to_false {
\find(b==>)
\replacewith([false]==>[]) 
\heuristics(simplify)
Choices: true}] ;
\addrules [to_true {
\find(b==>)
\replacewith([true]==>[]) 
\heuristics(simplify)
Choices: true}] 

Choices: true}
-----------------------------------------------------
== case_distinction_r (case_distinction) =========================================
case_distinction_r {
\find(==>b)
\addrules [to_false {
\find(==>b)
\replacewith([]==>[false]) 
\heuristics(simplify)
Choices: true}] ;
\addrules [to_true {
\find(==>b)
\replacewith([]==>[true]) 
\heuristics(simplify)
Choices: true}] 

Choices: true}
-----------------------------------------------------
== castAdd (narrow type) =========================================
castAdd {
\assumes ([equals(CSub::instance(strictCTerm2),TRUE)]==>[]) 
\find(strictCTerm2)
\sameUpdateLevel\replacewith(CSub::cast(strictCTerm2)) 

Choices: true}
-----------------------------------------------------
== castAdd2 (castAdd) =========================================
castAdd2 {
\assumes ([equals(cs,gt)]==>[]) 
\find(gt)
\sameUpdateLevel\varcond(\strict\sub(C, G), )
\replacewith(C::cast(gt)) 

Choices: true}
-----------------------------------------------------
== castDel (castDel) =========================================
castDel {
\find(C::cast(castedTerm))
\replacewith(castedTerm) 
\heuristics(cast_deletion, simplify)
Choices: true}
-----------------------------------------------------
== castDel2 (castDel) =========================================
castDel2 {
\assumes ([equals(cs,gt)]==>[]) 
\find(C::cast(gt))
\sameUpdateLevel\replacewith(cs) 

Choices: true}
-----------------------------------------------------
== castLongToFloatAddition2 (float addition) =========================================
castLongToFloatAddition2 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat + #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddFloat(#seFloat,float::cast(#seLong))),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== castToBoolean (castToBoolean) =========================================
castToBoolean {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (boolean) #exBool;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #exBool;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== castTrueImpliesOriginalTrue (castTrueImpliesOriginalTrue) =========================================
castTrueImpliesOriginalTrue {
\assumes ([equals(boolean::select(h,o,f),TRUE)]==>[]) 
\find(==>equals(any::select(h,o,f),TRUE))
\replacewith([]==>[true]) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== castType (castType) =========================================
castType {
\assumes ([equals(H::instance(C::cast(s)),TRUE)]==>[]) 
\find(equals(CSub::instance(s),TRUE)==>)
\replacewith([equals(H::instance(s),TRUE)]==>[]) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== castType2 (castType) =========================================
castType2 {
\assumes ([]==>[equals(H::instance(C::cast(s)),TRUE)]) 
\find(equals(CSub::instance(s),TRUE)==>)
\replacewith([]==>[equals(H::instance(s),TRUE)]) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== castedGetAny (castedGetAny) =========================================
castedGetAny {
\find(beta::cast(any::seqGet(seq,idx)))
\replacewith(beta::seqGet(seq,idx)) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== charLiteral_to_int (charLiteral_to_int) =========================================
charLiteral_to_int {
\find(C(iz))
\replacewith(Z(iz)) 
\heuristics(charLiteral_to_intLiteral)
Choices: true}
-----------------------------------------------------
== close (close) =========================================
close {
\assumes ([b]==>[]) 
\find(==>b)
\closegoal\heuristics(closure)
Choices: true}
-----------------------------------------------------
== closeAntec (close) =========================================
closeAntec {
\assumes ([]==>[b]) 
\find(b==>)
\closegoal
Choices: true}
-----------------------------------------------------
== closeFalse (closeFalse) =========================================
closeFalse {
\find(false==>)
\closegoal\heuristics(closure)
Choices: true}
-----------------------------------------------------
== closeTrue (closeTrue) =========================================
closeTrue {
\find(==>true)
\closegoal\heuristics(closure)
Choices: true}
-----------------------------------------------------
== closeType (closeType) =========================================
closeType {
\assumes ([]==>[equals(G::instance(t1),TRUE)]) 
\find(equals(GSub::instance(t1),TRUE)==>)
\closegoal\heuristics(closure)
Choices: true}
-----------------------------------------------------
== closeTypeSwitched (closeType) =========================================
closeTypeSwitched {
\assumes ([equals(GSub::instance(t1),TRUE)]==>[]) 
\find(==>equals(G::instance(t1),TRUE))
\closegoal\heuristics(closure)
Choices: true}
-----------------------------------------------------
== close_by_lt_leq (close_by_lt_leq) =========================================
close_by_lt_leq {
\assumes ([lt(i,j)]==>[]) 
\find(==>leq(add(i,Z(1(#))),j))
\replacewith([]==>[true]) 

Choices: true}
-----------------------------------------------------
== cnf_eqv (cnf_eqv) =========================================
cnf_eqv {
\find(equiv(phi,psi))
\replacewith(and(or(phi,not(psi)),or(not(phi),psi))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: true}
-----------------------------------------------------
== cnf_rightDist (cnf_rightDist) =========================================
cnf_rightDist {
\find(or(distLeft,and(distRight0,distRight1)))
\replacewith(and(or(distLeft,distRight0),or(distRight1,distLeft))) 
\heuristics(cnf_dist, conjNormalForm)
Choices: true}
-----------------------------------------------------
== collect_same_terms_1 (collect_same_terms) =========================================
collect_same_terms_1 {
\find(add(mul(i,j),mul(i,j)))
\replacewith(mul(Z(2(#)),mul(i,j))) 

Choices: true}
-----------------------------------------------------
== collect_same_terms_2 (collect_same_terms) =========================================
collect_same_terms_2 {
\find(add(add(mul(i,j),mul(i0,i1)),add(mul(i,j),mul(j0,j1))))
\replacewith(add(mul(Z(2(#)),mul(i,j)),add(mul(i0,i1),mul(j0,j1)))) 

Choices: true}
-----------------------------------------------------
== collect_same_terms_3 (collect_same_terms) =========================================
collect_same_terms_3 {
\find(add(add(neg(mul(i,j)),mul(i0,i1)),add(neg(mul(i,j)),mul(j0,j1))))
\replacewith(add(neg(mul(Z(2(#)),mul(i,j))),add(mul(i0,i1),mul(j0,j1)))) 

Choices: true}
-----------------------------------------------------
== commitJavaCardTransactionAPI (commitJavaCardTransactionAPI) =========================================
commitJavaCardTransactionAPI {
\find(==>#allmodal ( (modal operator))\[{ ..
  #jcsystemType.#commitTransaction()@#jcsystemType;
... }\] (post))
\replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #commitJavaCardTransaction;
... }\] (post)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== commitJavaCardTransactionBox (commitJavaCardTransaction) =========================================
commitJavaCardTransactionBox {
\find(==>box_transaction\[{ ..
  #commitJavaCardTransaction;
... }\] (post))
\replacewith([]==>[box(post)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== commitJavaCardTransactionDiamond (commitJavaCardTransaction) =========================================
commitJavaCardTransactionDiamond {
\find(==>diamond_transaction\[{ ..
  #commitJavaCardTransaction;
... }\] (post))
\replacewith([]==>[diamond(post)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== commuteDisjoint (commuteDisjoint) =========================================
commuteDisjoint {
\find(disjoint(commLeft,commRight))
\replacewith(disjoint(commRight,commLeft)) 
\heuristics(cnf_setComm)
Choices: programRules:Java}
-----------------------------------------------------
== commuteIntersection (commuteIntersection) =========================================
commuteIntersection {
\find(intersect(commLeft,commRight))
\replacewith(intersect(commRight,commLeft)) 
\heuristics(cnf_setComm)
Choices: programRules:Java}
-----------------------------------------------------
== commuteIntersection_2 (commuteIntersection_2) =========================================
commuteIntersection_2 {
\find(intersect(intersect(s,commLeft),commRight))
\replacewith(intersect(intersect(s,commRight),commLeft)) 
\heuristics(cnf_setComm)
Choices: programRules:Java}
-----------------------------------------------------
== commuteUnion (commuteUnion) =========================================
commuteUnion {
\find(union(commLeft,commRight))
\replacewith(union(commRight,commLeft)) 
\heuristics(cnf_setComm)
Choices: programRules:Java}
-----------------------------------------------------
== commuteUnion_2 (commuteUnion_2) =========================================
commuteUnion_2 {
\find(union(union(s,commLeft),commRight))
\replacewith(union(union(s,commRight),commLeft)) 
\heuristics(cnf_setComm)
Choices: programRules:Java}
-----------------------------------------------------
== commute_and (commute_and) =========================================
commute_and {
\find(and(commLeft,commRight))
\replacewith(and(commRight,commLeft)) 
\heuristics(cnf_andComm, conjNormalForm)
Choices: true}
-----------------------------------------------------
== commute_and_2 (commute_and_2) =========================================
commute_and_2 {
\find(and(and(commResidue,commLeft),commRight))
\replacewith(and(and(commResidue,commRight),commLeft)) 
\heuristics(cnf_andComm, conjNormalForm)
Choices: true}
-----------------------------------------------------
== commute_or (commute_or) =========================================
commute_or {
\find(or(commLeft,commRight))
\replacewith(or(commRight,commLeft)) 
\heuristics(cnf_orComm, conjNormalForm)
Choices: true}
-----------------------------------------------------
== commute_or_2 (commute_or_2) =========================================
commute_or_2 {
\find(or(or(commResidue,commLeft),commRight))
\replacewith(or(or(commResidue,commRight),commLeft)) 
\heuristics(cnf_orComm, conjNormalForm)
Choices: true}
-----------------------------------------------------
== compound_addition_1 (addition) =========================================
compound_addition_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse + #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v + #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_addition_2 (addition) =========================================
compound_addition_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e + #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 + #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_1_new (assignment_negation) =========================================
compound_assignment_1_new {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = !#seBool;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool,TRUE),FALSE,TRUE)),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_2 (compound_assignment) =========================================
compound_assignment_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = !#nseBool;
... }\] (post))
\varcond(\new(#v (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #v = #nseBool;
  #lhs = !#v;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_3_mixed (compound_assignment) =========================================
compound_assignment_3_mixed {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nseBool0 && #seBool1;
... }\] (post))
\varcond(\new(#v0 (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #v0 = #nseBool0;
  #lhs = #v0 && #seBool1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_3_nonsimple (compound_assignment) =========================================
compound_assignment_3_nonsimple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #exBool0 && #nseBool1;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (!#exBool0) #lhs = false;
  else #lhs = #nseBool1;
... }\] (post)) 
\heuristics(split_if, simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_3_simple (assignment_and) =========================================
compound_assignment_3_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seBool0 && #seBool1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool0,TRUE),if-then-else(equals(#seBool1,TRUE),TRUE,FALSE),FALSE)),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_4_nonsimple (compound_assignment) =========================================
compound_assignment_4_nonsimple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nseBool0 & #exBool1;
... }\] (post))
\varcond(\new(#v1 (program Variable), (type, sort): (boolean,boolean)), \new(#v0 (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #v0 = #nseBool0;
  boolean #v1 = #exBool1;
  #lhs = #v0 & #v1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_4_simple (assignment_and) =========================================
compound_assignment_4_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seBool0 & #seBool1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool0,TRUE),if-then-else(equals(#seBool1,TRUE),TRUE,FALSE),FALSE)),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_5_mixed (compound_assignment) =========================================
compound_assignment_5_mixed {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nseBool0 || #seBool1;
... }\] (post))
\varcond(\new(#v0 (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #v0 = #nseBool0;
  #lhs = #v0 || #seBool1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_5_nonsimple (compound_assignment) =========================================
compound_assignment_5_nonsimple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #exBool0 || #nseBool1;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (#exBool0) #lhs = true;
  else #lhs = #nseBool1;
... }\] (post)) 
\heuristics(split_if, simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_5_simple (assignment_or) =========================================
compound_assignment_5_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seBool0 || #seBool1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool0,TRUE),TRUE,if-then-else(equals(#seBool1,TRUE),TRUE,FALSE))),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_6_nonsimple (compound_assignment) =========================================
compound_assignment_6_nonsimple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nseBool0 | #exBool1;
... }\] (post))
\varcond(\new(#v1 (program Variable), (type, sort): (boolean,boolean)), \new(#v0 (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #v0 = #nseBool0;
  boolean #v1 = #exBool1;
  #lhs = #v0 | #v1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_6_simple (assignment_or) =========================================
compound_assignment_6_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seBool0 | #seBool1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool0,TRUE),TRUE,if-then-else(equals(#seBool1,TRUE),TRUE,FALSE))),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_and (compound_assignment_op_and) =========================================
compound_assignment_op_and {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs &= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs & (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_and_array (compound_assignment_op_and_array) =========================================
compound_assignment_op_and_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] &= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] & #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_and_attr (compound_assignment_op_and_attr) =========================================
compound_assignment_op_and_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute &= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute &
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_div (compound_assignment_op_div) =========================================
compound_assignment_op_div {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs /= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs / (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_div_array (compound_assignment_op_div_array) =========================================
compound_assignment_op_div_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] /= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] / #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_div_attr (compound_assignment_op_div_attr) =========================================
compound_assignment_op_div_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute /= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute /
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_minus (compound_assignment_op_minus) =========================================
compound_assignment_op_minus {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs -= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs - (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_minus_array (compound_assignment_op_minus_array) =========================================
compound_assignment_op_minus_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] -= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] - #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_minus_attr (compound_assignment_op_minus_attr) =========================================
compound_assignment_op_minus_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute -= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute -
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_mod (compound_assignment_op_mod) =========================================
compound_assignment_op_mod {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs %= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs % (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_mod_array (compound_assignment_op_mod_array) =========================================
compound_assignment_op_mod_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] %= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] % #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_mod_attr (compound_assignment_op_mod_attr) =========================================
compound_assignment_op_mod_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute %= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute %
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_mul (compound_assignment_op_mul) =========================================
compound_assignment_op_mul {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs *= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs * (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_mul_array (compound_assignment_op_mul_array) =========================================
compound_assignment_op_mul_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] *= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] * #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_mul_attr (compound_assignment_op_mul_attr) =========================================
compound_assignment_op_mul_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute *= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute *
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_or (compound_assignment_op_or) =========================================
compound_assignment_op_or {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs |= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs | (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_or_array (compound_assignment_op_or_array) =========================================
compound_assignment_op_or_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] |= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] | #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_or_attr (compound_assignment_op_or_attr) =========================================
compound_assignment_op_or_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute |= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute |
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_plus (compound_assignment_op_plus) =========================================
compound_assignment_op_plus {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs += #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs + (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_plus_array (compound_assignment_op_plus_array) =========================================
compound_assignment_op_plus_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] += #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] + #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_plus_attr (compound_assignment_op_plus_attr) =========================================
compound_assignment_op_plus_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute += #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute +
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_shiftleft (compound_assignment_op_shiftleft) =========================================
compound_assignment_op_shiftleft {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs <<= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs << (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_shiftleft_array (compound_assignment_op_shiftleft_array) =========================================
compound_assignment_op_shiftleft_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] <<= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] << #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_shiftleft_attr (compound_assignment_op_shiftleft_attr) =========================================
compound_assignment_op_shiftleft_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute <<= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute <<
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_shiftright (compound_assignment_op_shiftright) =========================================
compound_assignment_op_shiftright {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs >>= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs >> (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_shiftright_array (compound_assignment_op_shiftright_array) =========================================
compound_assignment_op_shiftright_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] >>= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] >> #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_shiftright_attr (compound_assignment_op_shiftright_attr) =========================================
compound_assignment_op_shiftright_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute >>= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute >>
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_unsigned_shiftright (compound_assignment_op_unsigned_shiftright) =========================================
compound_assignment_op_unsigned_shiftright {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs >>>= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs >>> (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_unsigned_shiftright_array (compound_assignment_op_unsigned_shiftright_array) =========================================
compound_assignment_op_unsigned_shiftright_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] >>>= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] >>> #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_unsigned_shiftright_attr (compound_assignment_op_unsigned_shiftright_attr) =========================================
compound_assignment_op_unsigned_shiftright_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute >>>= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute >>>
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_xor (compound_assignment_op_xor) =========================================
compound_assignment_op_xor {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs ^= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = (#typeof(#lhs)) (#lhs ^ (#e));
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_xor_array (compound_assignment_op_xor_array) =========================================
compound_assignment_op_xor_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e0[#e] ^= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] ^ #e1);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_op_xor_attr (compound_assignment_op_xor_attr) =========================================
compound_assignment_op_xor_attr {
\find(#allmodal ( (modal operator))\[{ ..
  #e0.#attribute ^= #e;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v = #e0;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute ^
                                           #e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_xor_nonsimple (compound_assignment) =========================================
compound_assignment_xor_nonsimple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nseBool0 ^ #exBool1;
... }\] (post))
\varcond(\new(#v1 (program Variable), (type, sort): (boolean,boolean)), \new(#v0 (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #v0 = #nseBool0;
  boolean #v1 = #exBool1;
  #lhs = #v0 ^ #v1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_assignment_xor_simple (assignment_xor) =========================================
compound_assignment_xor_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seBool0 ^ #seBool1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool0,#seBool1),FALSE,TRUE)),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_binary_AND_1 (binary_AND) =========================================
compound_binary_AND_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse & #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v & #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_binary_AND_2 (binary_AND) =========================================
compound_binary_AND_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e & #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 & #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_binary_OR_1 (binary_OR) =========================================
compound_binary_OR_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse | #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v | #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_binary_OR_2 (binary_OR) =========================================
compound_binary_OR_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e | #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 | #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_binary_XOR_1 (binary_XOR) =========================================
compound_binary_XOR_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse ^ #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v ^ #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_binary_XOR_2 (binary_XOR) =========================================
compound_binary_XOR_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e ^ #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 ^ #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_binary_neg (compound_binary_neg) =========================================
compound_binary_neg {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = ~#nse;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0 = #nse;
  #lhs = ~#v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_byte_cast_expression (cast) =========================================
compound_byte_cast_expression {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (byte) #nse;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = (byte) #v;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_division_1 (division) =========================================
compound_division_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse / #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v / #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_division_2 (division) =========================================
compound_division_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e / #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 / #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_double_cast_expression (cast) =========================================
compound_double_cast_expression {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (double) #nse;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#normalassign ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #loc = (double) #v;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_equality_comparison_1 (equality) =========================================
compound_equality_comparison_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse0 == #se;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse0 (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse0) #v0 = #nse0;
  #lhs = #v0 == #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_equality_comparison_2 (equality) =========================================
compound_equality_comparison_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e == #nse0;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse0) #v1 = #nse0;
  #lhs = #v0 == #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_float_cast_expression (cast) =========================================
compound_float_cast_expression {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (float) #nse;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#normalassign ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #loc = (float) #v;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_greater_equal_than_comparison_1 (greater_or_equal) =========================================
compound_greater_equal_than_comparison_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse0 >= #se;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse0 (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse0) #v0 = #nse0;
  #lhs = #v0 >= #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_greater_equal_than_comparison_2 (greater_or_equal) =========================================
compound_greater_equal_than_comparison_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e >= #nse0;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse0) #v1 = #nse0;
  #lhs = #v0 >= #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_greater_than_comparison_1 (greater_than) =========================================
compound_greater_than_comparison_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse0 > #se;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse0 (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse0) #v0 = #nse0;
  #lhs = #v0 > #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_greater_than_comparison_2 (greater_than) =========================================
compound_greater_than_comparison_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e > #nse0;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse0) #v1 = #nse0;
  #lhs = #v0 > #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_inequality_comparison_1 (inequality) =========================================
compound_inequality_comparison_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse0 != #se;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse0 (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse0) #v0 = #nse0;
  #lhs = #v0 != #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_inequality_comparison_2 (inequality) =========================================
compound_inequality_comparison_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e != #nse0;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse0) #v1 = #nse0;
  #lhs = #v0 != #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_int_cast_expression (cast) =========================================
compound_int_cast_expression {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (int) #nse;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = (int) #v;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_invert_bits (invert_bits) =========================================
compound_invert_bits {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = ~#nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v1 = #nse;
  #lhs = ~#v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_less_equal_than_comparison_1 (less_or_equal) =========================================
compound_less_equal_than_comparison_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse0 <= #se;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse0 (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse0) #v0 = #nse0;
  #lhs = #v0 <= #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_less_equal_than_comparison_2 (less_or_equal) =========================================
compound_less_equal_than_comparison_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e <= #nse0;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse0) #v1 = #nse0;
  #lhs = #v0 <= #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_less_than_comparison_1 (less_than) =========================================
compound_less_than_comparison_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse0 < #se;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse0 (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse0) #v0 = #nse0;
  #lhs = #v0 < #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_less_than_comparison_2 (less_than) =========================================
compound_less_than_comparison_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e < #nse0;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse0) #v1 = #nse0;
  #lhs = #v0 < #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_long_cast_expression (cast) =========================================
compound_long_cast_expression {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (long) #nse;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = (long) #v;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_modulo_1 (modulo) =========================================
compound_modulo_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse % #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v % #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_modulo_2 (modulo) =========================================
compound_modulo_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e % #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 % #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_multiplication_1 (multiplication) =========================================
compound_multiplication_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse * #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v * #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_multiplication_2 (multiplication) =========================================
compound_multiplication_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e * #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 * #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_reference_cast_expression (cast) =========================================
compound_reference_cast_expression {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (#npit) #nse;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = (#npit) #v;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_reference_cast_expression_primitive (cast) =========================================
compound_reference_cast_expression_primitive {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (#pit) #nse;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = (#pit) #v;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_shiftleft_1 (shift) =========================================
compound_shiftleft_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse << #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v << #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_shiftleft_2 (shift) =========================================
compound_shiftleft_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e << #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 << #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_shiftright_1 (shift) =========================================
compound_shiftright_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse >> #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v >> #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_shiftright_2 (shift) =========================================
compound_shiftright_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e >> #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 >> #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_short_cast_expression (cast) =========================================
compound_short_cast_expression {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (short) #nse;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = (short) #v;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_subtraction_1 (subtraction) =========================================
compound_subtraction_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse - #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v - #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_subtraction_2 (subtraction) =========================================
compound_subtraction_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e - #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 - #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_unary_minus_eval (compound_unary_minus_eval) =========================================
compound_unary_minus_eval {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = -#nse;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0 = #nse;
  #lhs = -#v0;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== compound_unary_plus_assignment (compound_unary_plus_assignment) =========================================
compound_unary_plus_assignment {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = +#e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #e;
... }\] (post)) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== compound_unsigned_shiftright_1 (shift) =========================================
compound_unsigned_shiftright_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse >>> #se;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v = #nse;
  #lhs = #v >>> #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== compound_unsigned_shiftright_2 (shift) =========================================
compound_unsigned_shiftright_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e >>> #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v0 = #e;
  #typeof(#nse) #v1 = #nse;
  #lhs = #v0 >>> #v1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== concatRepeatContraction3 (concatRepeatContraction3) =========================================
concatRepeatContraction3 {
\find(regExConcat(repeat(rexp,nTimes),regEx(seqEmpty)))
\replacewith(repeat(rexp,nTimes)) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== concatRepeatContraction3Sym (concatRepeatContraction3Sym) =========================================
concatRepeatContraction3Sym {
\find(regExConcat(regEx(seqEmpty),repeat(rexp,nTimes)))
\replacewith(repeat(rexp,nTimes)) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== concrete_and_1 (concrete_and_1) =========================================
concrete_and_1 {
\find(and(true,b))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_and_2 (concrete_and_2) =========================================
concrete_and_2 {
\find(and(false,b))
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_and_3 (concrete_and_3) =========================================
concrete_and_3 {
\find(and(b,true))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_and_4 (concrete_and_4) =========================================
concrete_and_4 {
\find(and(b,false))
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_eq_1 (concrete_eq_1) =========================================
concrete_eq_1 {
\find(equiv(true,b))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_eq_2 (concrete_eq_2) =========================================
concrete_eq_2 {
\find(equiv(false,b))
\replacewith(not(b)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_eq_3 (concrete_eq_3) =========================================
concrete_eq_3 {
\find(equiv(b,true))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_eq_4 (concrete_eq_4) =========================================
concrete_eq_4 {
\find(equiv(b,false))
\replacewith(not(b)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_impl_1 (concrete_impl_1) =========================================
concrete_impl_1 {
\find(imp(true,b))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_impl_2 (concrete_impl_2) =========================================
concrete_impl_2 {
\find(imp(false,b))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_impl_3 (concrete_impl_3) =========================================
concrete_impl_3 {
\find(imp(b,false))
\replacewith(not(b)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_impl_4 (concrete_impl_4) =========================================
concrete_impl_4 {
\find(imp(b,true))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_not_1 (concrete_not_1) =========================================
concrete_not_1 {
\find(not(true))
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_not_2 (concrete_not_2) =========================================
concrete_not_2 {
\find(not(false))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_or_1 (concrete_or_1) =========================================
concrete_or_1 {
\find(or(true,b))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_or_2 (concrete_or_2) =========================================
concrete_or_2 {
\find(or(false,b))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_or_3 (concrete_or_3) =========================================
concrete_or_3 {
\find(or(b,true))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_or_4 (concrete_or_4) =========================================
concrete_or_4 {
\find(or(b,false))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== concrete_or_5 (distr_elim) =========================================
concrete_or_5 {
\find(or(and(c,b),and(c,not(b))))
\replacewith(c) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== condition (condition) =========================================
condition {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #e0 ? #e1 : #e2;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (#e0) {
    #lhs = #e1;
  } else {
    #lhs = #e2;
  }
... }\] (post)) 
\heuristics(split_if, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== condition_not_simple (condition) =========================================
condition_not_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse ? #se1 : #se2;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0 = #nse;
  #lhs = #v0 ? #se1 : #se2;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== condition_simple (condition) =========================================
condition_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #se0 ? #se1 : #se2;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#se0,TRUE),#se1,#se2)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== contains (contains) =========================================
contains {
\find(clContains(seqConcat(seqSingleton(fstTextCharacter),textStringTail),searchString))
\sameUpdateLevel\add [equals(seqLen(searchString),newSym)]==>[] \replacewith(and(lt(newSym,seqLen(textStringTail)),or(equals(seqSub(seqConcat(seqSingleton(fstTextCharacter),textStringTail),Z(0(#)),newSym),searchString),clContains(textStringTail,searchString)))) 
\heuristics(stringsIntroduceNewSym, stringsContainsDefInline)
Choices: Strings:on}
-----------------------------------------------------
== containsAxiomAntec (containsAxiomAntec) =========================================
containsAxiomAntec {
\find(clContains(textString,searchString)==>)
\varcond(\notFreeIn(iv (variable), textString (Seq term)), \notFreeIn(iv (variable), searchString (Seq term)))
\replacewith([exists{iv (variable)}(and(and(geq(iv,Z(0(#))),leq(add(iv,seqLen(searchString)),seqLen(textString))),equals(seqSub(textString,iv,add(iv,seqLen(searchString))),searchString)))]==>[]) 
\heuristics(stringsExpandDefNormalOp)
Choices: Strings:on}
-----------------------------------------------------
== containsAxiomSucc (containsAxiomSucc) =========================================
containsAxiomSucc {
\find(==>clContains(textString,searchString))
\varcond(\notFreeIn(iv (variable), textString (Seq term)), \notFreeIn(iv (variable), searchString (Seq term)))
\replacewith([]==>[exists{iv (variable)}(and(and(geq(iv,Z(0(#))),leq(add(iv,seqLen(searchString)),seqLen(textString))),equals(seqSub(textString,iv,add(iv,seqLen(searchString))),searchString)))]) 
\heuristics(stringsExpandDefNormalOp)
Choices: Strings:on}
-----------------------------------------------------
== cosIsNaN (cosIsNaN) =========================================
cosIsNaN {
\find(cosDouble(arg))
\add [imp(or(doubleIsNaN(arg),doubleIsInfinite(arg)),doubleIsNaN(cosDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== cosIsNaNAlt (cosIsNaNAlt) =========================================
cosIsNaNAlt {
\find(doubleIsNaN(cosDouble(arg)))
\replacewith(or(doubleIsNaN(arg),doubleIsInfinite(arg))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== cosIsNotNaN (cosIsNotNaN) =========================================
cosIsNotNaN {
\find(cosDouble(arg))
\add [imp(and(not(doubleIsNaN(arg)),not(doubleIsInfinite(arg))),not(doubleIsNaN(cosDouble(arg))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== cosRange (cosRange) =========================================
cosRange {
\find(cosDouble(arg))
\add [or(and(geqDouble(cosDouble(arg),DFP(0(#))),leqDouble(cosDouble(arg),DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),doubleIsNaN(cosDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== cosRange2 (cosRange2) =========================================
cosRange2 {
\find(cosDouble(arg))
\add [imp(and(not(doubleIsNaN(arg)),not(doubleIsInfinite(arg))),and(geqDouble(cosDouble(arg),DFP(0(#))),leqDouble(cosDouble(arg),DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== cosRangeAlt (cosRangeAlt) =========================================
cosRangeAlt {
\find(==>doubleIsNaN(cosDouble(arg)))
\add [and(geqDouble(cosDouble(arg),DFP(0(#))),leqDouble(cosDouble(arg),DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== createdInHeapToElementOf (createdInHeapToElementOf) =========================================
createdInHeapToElementOf {
\find(createdInHeap(s,h))
\varcond(\notFreeIn(fv (variable), h (Heap term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), h (Heap term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(imp(elementOf(ov,fv,s),or(equals(ov,null),equals(boolean::select(h,ov,java.lang.Object::<created>),TRUE)))))) 
\heuristics(classAxiom)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithAllFields (createdInHeapWithAllFields) =========================================
createdInHeapWithAllFields {
\find(createdInHeap(allFields(o),h))
\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithAllFieldsEQ (createdInHeapWithAllFieldsEQ) =========================================
createdInHeapWithAllFieldsEQ {
\assumes ([equals(allFields(o),EQ)]==>[]) 
\find(createdInHeap(EQ,h))
\sameUpdateLevel\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithArrayRange (createdInHeapWithArrayRange) =========================================
createdInHeapWithArrayRange {
\find(createdInHeap(arrayRange(o,lower,upper),h))
\replacewith(or(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE)),lt(upper,lower))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithArrayRangeEQ (createdInHeapWithArrayRangeEQ) =========================================
createdInHeapWithArrayRangeEQ {
\assumes ([equals(arrayRange(o,lower,upper),EQ)]==>[]) 
\find(createdInHeap(EQ,h))
\sameUpdateLevel\replacewith(or(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE)),lt(upper,lower))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithEmpty (createdInHeapWithEmpty) =========================================
createdInHeapWithEmpty {
\find(createdInHeap(empty,h))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithObserver (createdInHeapWithObserver) =========================================
createdInHeapWithObserver {
\find(==>createdInHeap(obs,h))
\varcond(\isObserver (obs (LocSet term), h (Heap term)), )
\replacewith([]==>[wellFormed(h)]) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithObserverEQ (createdInHeapWithObserverEQ) =========================================
createdInHeapWithObserverEQ {
\assumes ([equals(obs,EQ)]==>[]) 
\find(==>createdInHeap(EQ,h))
\varcond(\isObserver (obs (LocSet term), h (Heap term)), )
\replacewith([]==>[wellFormed(h)]) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithSelect (createdInHeapWithSelect) =========================================
createdInHeapWithSelect {
\find(==>createdInHeap(LocSet::select(h,o,f),h))
\replacewith([]==>[wellFormed(h)]) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithSelectEQ (createdInHeapWithSelectEQ) =========================================
createdInHeapWithSelectEQ {
\assumes ([equals(LocSet::select(h,o,f),EQ)]==>[]) 
\find(==>createdInHeap(EQ,h))
\replacewith([]==>[wellFormed(h)]) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithSetMinusFreshLocs (createdInHeapWithSetMinusFreshLocs) =========================================
createdInHeapWithSetMinusFreshLocs {
\find(createdInHeap(setMinus(s,freshLocs(h)),h))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithSetMinusFreshLocsEQ (createdInHeapWithSetMinusFreshLocsEQ) =========================================
createdInHeapWithSetMinusFreshLocsEQ {
\assumes ([equals(setMinus(s,freshLocs(h)),EQ)]==>[]) 
\find(createdInHeap(EQ,h))
\sameUpdateLevel\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithSingleton (createdInHeapWithSingleton) =========================================
createdInHeapWithSingleton {
\find(createdInHeap(singleton(o,f),h))
\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithSingletonEQ (createdInHeapWithSingletonEQ) =========================================
createdInHeapWithSingletonEQ {
\assumes ([equals(singleton(o,f),EQ)]==>[]) 
\find(createdInHeap(EQ,h))
\sameUpdateLevel\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithUnion (createdInHeapWithUnion) =========================================
createdInHeapWithUnion {
\find(==>createdInHeap(union(s,s2),h))
\replacewith([]==>[createdInHeap(s2,h)]) ;
\replacewith([]==>[createdInHeap(s,h)]) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== createdInHeapWithUnionEQ (createdInHeapWithUnionEQ) =========================================
createdInHeapWithUnionEQ {
\assumes ([equals(union(s,s2),EQ)]==>[]) 
\find(==>createdInHeap(EQ,h))
\replacewith([]==>[createdInHeap(s2,h)]) ;
\replacewith([]==>[createdInHeap(s,h)]) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== crossInst (crossInst) =========================================
crossInst {
\assumes ([]==>[or(or(leq(k,Z(neglit(1(#)))),geq(k,i)),c)]) 
\find(all{v (variable)}(or(or(or(leq(v,Z(neglit(1(#)))),geq(v,j)),b),a))==>)
\add [and(equals(sk,k),subst{v (variable)}(sk,or(or(or(leq(v,Z(neglit(1(#)))),geq(v,j)),b),a)))]==>[] 
\heuristics(loopInvariant)
Choices: true}
-----------------------------------------------------
== cut (cut) =========================================
cut {
\add []==>[cutFormula] ;
\add [cutFormula]==>[] 
\heuristics(cut)
Choices: true}
-----------------------------------------------------
== cutUpperBound (cutUpperBound) =========================================
cutUpperBound {
\assumes ([all{v (variable)}(or(or(or(leq(v,Z(neglit(1(#)))),geq(v,j)),b),a))]==>[]) 
\find(==>or(or(leq(k,Z(neglit(1(#)))),geq(k,i)),c))
\add [not(equals(k,i))]==>[] ;
\add [equals(k,i)]==>[] 
\heuristics(loopInvariant)
Choices: true}
-----------------------------------------------------
== cut_direct (cut_direct) =========================================
cut_direct {
\find(cutFormula)
\sameUpdateLevel\add []==>[cutFormula] \replacewith(false) ;
\add [cutFormula]==>[] \replacewith(true) 
\heuristics(cut_direct)
Choices: true}
-----------------------------------------------------
== cut_direct_l (cut_direct_l) =========================================
cut_direct_l {
\find(b==>)
\add []==>[b] ;
\replacewith([b]==>[]) 

Choices: true}
-----------------------------------------------------
== cut_direct_r (cut_direct_r) =========================================
cut_direct_r {
\find(==>b)
\add [b]==>[] ;
\replacewith([]==>[b]) 

Choices: true}
-----------------------------------------------------
== defInDomainImpliesCreated (defInDomainImpliesCreated) =========================================
defInDomainImpliesCreated {
\find(inDomainImpliesCreated(m))
\varcond(\notFreeIn(o (variable), m (Map term)))
\replacewith(all{o (variable)}(imp(inDomain(m,o),equals(boolean::select(heap,o,java.lang.Object::<created>),TRUE)))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== defIsFinite (defIsFinite) =========================================
defIsFinite {
\find(isFinite(m))
\varcond(\notFreeIn(s (variable), m (Map term)), \notFreeIn(vx (variable), m (Map term)))
\replacewith(exists{s (variable)}(all{vx (variable)}(equiv(inDomain(m,vx),exists{ix (variable)}(and(and(leq(Z(0(#)),ix),lt(ix,seqLen(s))),equals(any::seqGet(s,ix),vx))))))) 

Choices: true}
-----------------------------------------------------
== defMapEmpty (defMapEmpty) =========================================
defMapEmpty {
\find(mapEmpty)
\replacewith(mapForeach{vy (variable)}(FALSE,mapUndef)) 

Choices: true}
-----------------------------------------------------
== defMapEquality (defMapEquality) =========================================
defMapEquality {
\find(equals(m0,m1))
\varcond(\notFreeIn(vy (variable), m1 (Map term)), \notFreeIn(vy (variable), m0 (Map term)))
\replacewith(all{vy (variable)}(and(equiv(inDomain(m0,vy),inDomain(m1,vy)),imp(inDomain(m0,vy),equals(mapGet(m0,vy),mapGet(m1,vy)))))) 

Choices: true}
-----------------------------------------------------
== defMapOverride (defMapOverride) =========================================
defMapOverride {
\find(mapOverride(m0,m1))
\varcond(\notFreeIn(vy (variable), m1 (Map term)), \notFreeIn(vy (variable), m0 (Map term)))
\replacewith(mapForeach{vy (variable)}(if-then-else(or(inDomain(m0,vy),inDomain(m1,vy)),TRUE,FALSE),if-then-else(inDomain(m1,vy),mapGet(m1,vy),mapGet(m0,vy)))) 

Choices: true}
-----------------------------------------------------
== defMapRemove (defMapRemove) =========================================
defMapRemove {
\find(mapRemove(m,key))
\varcond(\notFreeIn(vy (variable), key (any term)), \notFreeIn(vy (variable), m (Map term)))
\replacewith(mapForeach{vy (variable)}(if-then-else(and(inDomain(m,vy),not(equals(vy,key))),TRUE,FALSE),mapGet(m,vy))) 

Choices: true}
-----------------------------------------------------
== defMapSingleton (defMapSingleton) =========================================
defMapSingleton {
\find(mapSingleton(xa,y))
\varcond(\notFreeIn(vy (variable), y (any term)), \notFreeIn(vy (variable), xa (alpha term)))
\replacewith(mapForeach{vy (variable)}(if-then-else(equals(vy,any::cast(xa)),TRUE,FALSE),y)) 

Choices: true}
-----------------------------------------------------
== defMapUpdate (defMapUpdate) =========================================
defMapUpdate {
\find(mapUpdate(m,key,value))
\varcond(\notFreeIn(vy (variable), value (any term)), \notFreeIn(vy (variable), key (any term)), \notFreeIn(vy (variable), m (Map term)))
\replacewith(mapForeach{vy (variable)}(if-then-else(or(inDomain(m,vy),equals(vy,key)),TRUE,FALSE),if-then-else(equals(vy,key),value,mapGet(m,vy)))) 

Choices: true}
-----------------------------------------------------
== defOfEmpty (defOfEmpty) =========================================
defOfEmpty {
\find(seqEmpty)
\varcond(\notFreeIn(uSub (variable), te (any term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),Z(0(#)),te)) 

Choices: sequences:on}
-----------------------------------------------------
== defOfSeqConcat (defOfSeqConcat) =========================================
defOfSeqConcat {
\find(seqConcat(seq1,seq2))
\varcond(\notFreeIn(uSub (variable), seq2 (Seq term)), \notFreeIn(uSub (variable), seq1 (Seq term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),add(seqLen(seq1),seqLen(seq2)),if-then-else(lt(uSub,seqLen(seq1)),any::seqGet(seq1,uSub),any::seqGet(seq2,sub(uSub,seqLen(seq1)))))) 

Choices: sequences:on}
-----------------------------------------------------
== defOfSeqReverse (defOfSeqReverse) =========================================
defOfSeqReverse {
\find(seqReverse(seq))
\varcond(\notFreeIn(uSub (variable), seq (Seq term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),seqLen(seq),any::seqGet(seq,sub(sub(seqLen(seq),uSub),Z(1(#)))))) 

Choices: sequences:on}
-----------------------------------------------------
== defOfSeqSingleton (defOfSeqSingleton) =========================================
defOfSeqSingleton {
\find(seqSingleton(x))
\varcond(\notFreeIn(uSub (variable), x (any term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),Z(1(#)),x)) 

Choices: sequences:on}
-----------------------------------------------------
== defOfSeqSub (defOfSeqSub) =========================================
defOfSeqSub {
\find(seqSub(seq,from,to))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)), \notFreeIn(uSub (variable), seq (Seq term)))
\replacewith(seqDef{uSub (variable)}(from,to,any::seqGet(seq,uSub))) 

Choices: sequences:on}
-----------------------------------------------------
== defSeq2Map (defSeq2Map) =========================================
defSeq2Map {
\find(seq2map(s))
\varcond(\notFreeIn(ix (variable), s (Seq term)))
\replacewith(mapForeach{ix (variable)}(if-then-else(and(leq(Z(0(#)),ix),lt(ix,seqLen(s))),TRUE,FALSE),any::seqGet(s,ix))) 

Choices: true}
-----------------------------------------------------
== def_wellOrderLeqInt (def_wellOrderLeqInt) =========================================
def_wellOrderLeqInt {
\find(wellOrderLeqInt(intT1,intT2))
\replacewith(or(and(geq(intT1,intT2),lt(intT2,Z(0(#)))),and(leq(Z(0(#)),intT1),leq(intT1,intT2)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== definitionAllElementsOfArray (definitionAllElementsOfArray) =========================================
definitionAllElementsOfArray {
\find(allElementsOfArray(h,array,singleton(o,f)))
\varcond(\notFreeIn(j (variable), f (Field term)), \notFreeIn(j (variable), o (java.lang.Object term)), \notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(infiniteUnion{j (variable)}(if-then-else(and(leq(Z(0(#)),j),lt(j,length(array))),singleton(java.lang.Object::select(h,array,arr(j)),f),empty))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== definitionAllElementsOfArray2 (definitionAllElementsOfArray2) =========================================
definitionAllElementsOfArray2 {
\find(allElementsOfArray(h,array,allFields(o)))
\varcond(\notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(infiniteUnion{j (variable)}(if-then-else(and(leq(Z(0(#)),j),lt(j,length(array))),allFields(java.lang.Object::select(h,array,arr(j))),empty))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== definitionAllElementsOfArrayLocsets (definitionAllElementsOfArrayLocsets) =========================================
definitionAllElementsOfArrayLocsets {
\find(allElementsOfArrayLocsets(h,array,singleton(o,f)))
\varcond(\notFreeIn(j (variable), f (Field term)), \notFreeIn(j (variable), o (java.lang.Object term)), \notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(infiniteUnion{j (variable)}(if-then-else(and(leq(Z(0(#)),j),lt(j,length(array))),LocSet::select(h,java.lang.Object::select(h,array,arr(j)),f),empty))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== definitionOfNewObjectsIsomorphic (definitionOfNewObjectsIsomorphic) =========================================
definitionOfNewObjectsIsomorphic {
\find(==>newObjectsIsomorphic(s1,h1,s2,h2))
\replacewith([]==>[objectsIsomorphic(s1,s1,s2,s2)]) ;
\replacewith([]==>[sameTypes(s1,s2)]) ;
\replacewith([]==>[newOnHeap(h2,s2)]) ;
\replacewith([]==>[newOnHeap(h1,s1)]) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== definitionOfNewOnHeap (definitionOfNewOnHeap) =========================================
definitionOfNewOnHeap {
\find(==>newOnHeap(h,s))
\varcond(\notFreeIn(i (variable), h (Heap term)), \notFreeIn(i (variable), s (Seq term)))
\replacewith([]==>[all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,seqLen(s))),and(imp(equals(java.lang.Object::instance(any::seqGet(s,i)),TRUE),equals(boolean::select(h,java.lang.Object::seqGet(s,i),java.lang.Object::<created>),FALSE)),imp(equals(Seq::instance(any::seqGet(s,i)),TRUE),newOnHeap(h,Seq::seqGet(s,i))))))]) 
\heuristics(comprehensions)
Choices: true}
-----------------------------------------------------
== definitionOfObjectIsomorphic (definitionOfObjectIsomorphic) =========================================
definitionOfObjectIsomorphic {
\find(==>objectIsomorphic(s1,o1,s2,o2))
\varcond(\notFreeIn(i (variable), o2 (java.lang.Object term)), \notFreeIn(i (variable), o1 (java.lang.Object term)), \notFreeIn(i (variable), s2 (Seq term)), \notFreeIn(i (variable), s1 (Seq term)))
\replacewith([]==>[all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,seqLen(s1))),and(imp(equals(java.lang.Object::instance(any::seqGet(s1,i)),TRUE),equiv(equals(java.lang.Object::seqGet(s1,i),o1),equals(java.lang.Object::seqGet(s2,i),o2))),imp(equals(Seq::instance(any::seqGet(s1,i)),TRUE),objectIsomorphic(Seq::seqGet(s1,i),o1,Seq::seqGet(s2,i),o2)))))]) 
\heuristics(comprehensions)
Choices: true}
-----------------------------------------------------
== definitionOfObjectsIsomorphic (definitionOfObjectsIsomorphic) =========================================
definitionOfObjectsIsomorphic {
\find(==>objectsIsomorphic(s1,t1,s2,t2))
\varcond(\notFreeIn(i (variable), t2 (Seq term)), \notFreeIn(i (variable), t1 (Seq term)), \notFreeIn(i (variable), s2 (Seq term)), \notFreeIn(i (variable), s1 (Seq term)))
\replacewith([]==>[all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,seqLen(t1))),and(imp(equals(java.lang.Object::instance(any::seqGet(t1,i)),TRUE),objectIsomorphic(s1,java.lang.Object::seqGet(t1,i),s2,java.lang.Object::seqGet(t2,i))),imp(equals(Seq::instance(any::seqGet(t1,i)),TRUE),objectsIsomorphic(s1,Seq::seqGet(t1,i),s2,Seq::seqGet(t2,i))))))]) 
\heuristics(comprehensions)
Choices: true}
-----------------------------------------------------
== definitionOfSameTypes (definitionOfSameTypes) =========================================
definitionOfSameTypes {
\find(==>sameTypes(s1,s2))
\varcond(\notFreeIn(i (variable), s2 (Seq term)), \notFreeIn(i (variable), s1 (Seq term)))
\replacewith([]==>[and(equals(seqLen(s1),seqLen(s2)),all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,seqLen(s1))),and(sameType(any::seqGet(s1,i),any::seqGet(s2,i)),imp(equals(Seq::instance(any::seqGet(s1,i)),TRUE),sameTypes(Seq::seqGet(s1,i),Seq::seqGet(s2,i)))))))]) 
\heuristics(comprehensions)
Choices: true}
-----------------------------------------------------
== definitionSeqdefWorkaround (definitionSeqdefWorkaround) =========================================
definitionSeqdefWorkaround {
\find(seq_def_workaround(h,lower,upper,array))
\varcond(\notFreeIn(j (variable), upper (int term)), \notFreeIn(j (variable), lower (int term)), \notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(seqDef{j (variable)}(lower,upper,any::select(h,array,arr(j)))) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== definitionSeqdefWorkaround2 (definitionSeqdefWorkaround2) =========================================
definitionSeqdefWorkaround2 {
\find(seq_def_workaround2(h,lower,upper,array,singleton(o,f)))
\varcond(\notFreeIn(j (variable), upper (int term)), \notFreeIn(j (variable), lower (int term)), \notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), f (Field term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(seqDef{j (variable)}(lower,upper,any::select(h,java.lang.Object::select(h,array,arr(j)),f))) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== deleteMergePoint (deleteMergePoint) =========================================
deleteMergePoint {
\find(#allmodal ( (modal operator))\[{ ..
  //@ merge_point (#lhs);;
  ... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(merge_point, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== delete_unnecessary_cast (delete_unnecessary_cast) =========================================
delete_unnecessary_cast {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (#npit) #se;
... }\] (post))
\sameUpdateLevel\varcond(\hasSort(#npit (program NonPrimitiveType), G), \sub(\typeof(#se (program SimpleExpression)), G), )
\add [or(equals(#se,null),equals(G::instance(#se),TRUE))]==>[] \replacewith(update-application(elem-update(#lhs (program LeftHandSide))(#addCast(#se,#lhs)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== diamondToBox (diamondToBox) =========================================
diamondToBox {
\find(\<{ ..
  #s
... }\> (post))
\replacewith(not(\[{ ..
  #s
... }\] (not(post)))) 
\heuristics(boxDiamondConv)
Choices: programRules:Java}
-----------------------------------------------------
== diamondToBoxTransaction (diamondToBox) =========================================
diamondToBoxTransaction {
\find(diamond_transaction\[{ ..
  #s
... }\] (post))
\replacewith(not(box_transaction\[{ ..
  #s
... }\] (not(post)))) 
\heuristics(boxDiamondConv)
Choices: programRules:Java}
-----------------------------------------------------
== diamond_and_left (diamond_and_left) =========================================
diamond_and_left {
\find(#diamond ( (modal operator))\[{ ..
  #s
... }\] (and(post,post1))==>)
\replacewith([and(#diamond ( (modal operator))\[{ ..
  #s
... }\] (post),#diamond ( (modal operator))\[{ ..
  #s
... }\] (post1))]==>[]) 

Choices: programRules:Java}
-----------------------------------------------------
== diamond_and_right (diamond_and_right) =========================================
diamond_and_right {
\find(==>#diamond ( (modal operator))\[{ ..
  #s
... }\] (and(post,post1)))
\replacewith([]==>[#diamond ( (modal operator))\[{ ..
  #s
... }\] (post1)]) ;
\replacewith([]==>[#diamond ( (modal operator))\[{ ..
  #s
... }\] (post)]) 

Choices: programRules:Java}
-----------------------------------------------------
== diamond_false (diamond_false) =========================================
diamond_false {
\find(#diamond ( (modal operator))\[{ ..
  #s
... }\] (false))
\replacewith(false) 
\heuristics(modal_tautology)
Choices: programRules:Java}
-----------------------------------------------------
== diamond_or_left (diamond_or_left) =========================================
diamond_or_left {
\find(#diamond ( (modal operator))\[{ ..
  #s
... }\] (or(post,post1))==>)
\replacewith([or(#diamond ( (modal operator))\[{ ..
  #s
... }\] (post),#diamond ( (modal operator))\[{ ..
  #s
... }\] (post1))]==>[]) 

Choices: programRules:Java}
-----------------------------------------------------
== diamond_or_right (diamond_or_right) =========================================
diamond_or_right {
\find(==>#diamond ( (modal operator))\[{ ..
  #s
... }\] (or(post,post1)))
\replacewith([]==>[or(#diamond ( (modal operator))\[{ ..
  #s
... }\] (post),#diamond ( (modal operator))\[{ ..
  #s
... }\] (post1))]) 

Choices: programRules:Java}
-----------------------------------------------------
== diamond_split_termination (diamond_split_termination) =========================================
diamond_split_termination {
\find(\<{ ..
  #s
... }\> (post))
\replacewith(and(\[{ ..
  #s
... }\] (post),\<{ ..
  #s
... }\> (true))) 

Choices: programRules:Java}
-----------------------------------------------------
== disjointAllFields (disjointAllFields) =========================================
disjointAllFields {
\assumes ([equals(intersect(allFields(o),s),empty)]==>[]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\replacewith(false) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== disjointAllFields_2 (disjointAllFields_2) =========================================
disjointAllFields_2 {
\find(equals(intersect(allFields(o),allFields(o2)),empty))
\replacewith(not(equals(o,o2))) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== disjointAllObjects (disjointAllObjects) =========================================
disjointAllObjects {
\assumes ([equals(intersect(allObjects(f),s),empty)]==>[]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\replacewith(false) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== disjointAndSubset1 (disjointAndSubset1) =========================================
disjointAndSubset1 {
\assumes ([equals(intersect(s2,s3),empty)]==>[]) 
\find(subset(s,s2)==>)
\add [equals(intersect(s,s3),empty)]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== disjointAndSubset2 (disjointAndSubset2) =========================================
disjointAndSubset2 {
\assumes ([equals(intersect(s2,s3),empty)]==>[]) 
\find(subset(s,s3)==>)
\add [equals(intersect(s,s2),empty)]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== disjointAndSubset_3 (disjointAndSubset_3) =========================================
disjointAndSubset_3 {
\assumes ([equals(intersect(s1,s2),empty)]==>[]) 
\find(subset(s4,union(s2,s3))==>)
\add [imp(equals(intersect(s1,s3),empty),equals(intersect(s1,s4),empty))]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== disjointAndSubset_4 (disjointAndSubset_4) =========================================
disjointAndSubset_4 {
\assumes ([equals(intersect(s1,s2),empty)]==>[]) 
\find(subset(s4,union(s3,s2))==>)
\add [imp(equals(intersect(s1,s3),empty),equals(intersect(s1,s4),empty))]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== disjointAndSubset_5 (disjointAndSubset_5) =========================================
disjointAndSubset_5 {
\assumes ([equals(intersect(s2,s1),empty)]==>[]) 
\find(subset(s4,union(s2,s3))==>)
\add [imp(equals(intersect(s1,s3),empty),equals(intersect(s1,s4),empty))]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== disjointAndSubset_6 (disjointAndSubset_6) =========================================
disjointAndSubset_6 {
\assumes ([equals(intersect(s2,s1),empty)]==>[]) 
\find(subset(s4,union(s3,s2))==>)
\add [imp(equals(intersect(s1,s3),empty),equals(intersect(s1,s4),empty))]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== disjointArrayRangeAllFields1 (disjointArrayRangeAllFields) =========================================
disjointArrayRangeAllFields1 {
\find(equals(intersect(allFields(o1),arrayRange(o2,lower2,upper2)),empty))
\replacewith(not(and(equals(o1,o2),leq(lower2,upper2)))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== disjointArrayRangeAllFields2 (disjointArrayRangeAllFields) =========================================
disjointArrayRangeAllFields2 {
\find(equals(intersect(arrayRange(o1,lower1,upper1),allFields(o2)),empty))
\replacewith(not(and(equals(o1,o2),leq(lower1,upper1)))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== disjointArrayRanges (disjointArrayRanges) =========================================
disjointArrayRanges {
\find(equals(intersect(arrayRange(o1,lower1,upper1),arrayRange(o2,lower2,upper2)),empty))
\replacewith(not(and(and(and(equals(o1,o2),leq(lower1,upper1)),leq(lower2,upper2)),or(and(leq(lower1,lower2),leq(lower2,upper1)),and(leq(lower2,lower1),leq(lower1,upper2)))))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== disjointDefinition (disjointDefinition) =========================================
disjointDefinition {
\find(disjoint(s,s2))
\replacewith(equals(intersect(s,s2),empty)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== disjointInfiniteUnion (disjointInfiniteUnion) =========================================
disjointInfiniteUnion {
\find(equals(intersect(infiniteUnion{iv (variable)}(s2),s),empty))
\varcond(\notFreeIn(iv (variable), s (LocSet term)))
\replacewith(all{iv (variable)}(equals(intersect(s2,s),empty))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== disjointInfiniteUnion_2 (disjointInfiniteUnion_2) =========================================
disjointInfiniteUnion_2 {
\find(equals(intersect(s,infiniteUnion{iv (variable)}(s2)),empty))
\varcond(\notFreeIn(iv (variable), s (LocSet term)))
\replacewith(all{iv (variable)}(equals(intersect(s,s2),empty))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== disjointNotInOtherLocset1 (disjointNotInOtherLocset1) =========================================
disjointNotInOtherLocset1 {
\assumes ([equals(intersect(s,s2),empty)]==>[]) 
\find(elementOf(o,f,s)==>)
\add []==>[elementOf(o,f,s2)] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== disjointNotInOtherLocset2 (disjointNotInOtherLocset2) =========================================
disjointNotInOtherLocset2 {
\assumes ([equals(intersect(s,s2),empty)]==>[]) 
\find(elementOf(o,f,s2)==>)
\add []==>[elementOf(o,f,s)] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== disjointToElementOf (disjointToElementOf) =========================================
disjointToElementOf {
\find(disjoint(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(or(not(elementOf(ov,fv,s)),not(elementOf(ov,fv,s2)))))) 
\heuristics(semantics_blasting)
Choices: programRules:Java}
-----------------------------------------------------
== disjointWithEmpty (disjointWithEmpty) =========================================
disjointWithEmpty {
\find(disjoint(empty,s))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== disjointWithSingleton1 (disjointWithSingleton) =========================================
disjointWithSingleton1 {
\find(equals(intersect(s,singleton(o,f)),empty))
\replacewith(not(elementOf(o,f,s))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== disjointWithSingleton2 (disjointWithSingleton) =========================================
disjointWithSingleton2 {
\find(equals(intersect(singleton(o,f),s),empty))
\replacewith(not(elementOf(o,f,s))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== dismissNonSelectedField (dismissNonSelectedField) =========================================
dismissNonSelectedField {
\find(alpha::select(store(h,o,f1,x),u,f2))
\varcond(\differentFields (f1 (Field term), f2 (Field term)), )
\replacewith(alpha::select(h,u,f2)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== dismissNonSelectedFieldEQ (dismissNonSelectedFieldEQ) =========================================
dismissNonSelectedFieldEQ {
\assumes ([equals(store(h,o,f1,x),EQ)]==>[]) 
\find(alpha::select(EQ,u,f2))
\sameUpdateLevel\varcond(\differentFields (f1 (Field term), f2 (Field term)), )
\replacewith(alpha::select(h,u,f2)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== distr_existsAnd1 (distr_existsAnd1) =========================================
distr_existsAnd1 {
\find(exists{u (variable)}(and(phi,psi)))
\varcond(\notFreeIn(u (variable), psi (formula)))
\replacewith(and(exists{u (variable)}(phi),psi)) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: true}
-----------------------------------------------------
== distr_existsAnd2 (distr_existsAnd2) =========================================
distr_existsAnd2 {
\find(exists{u (variable)}(and(phi,psi)))
\varcond(\notFreeIn(u (variable), phi (formula)))
\replacewith(and(phi,exists{u (variable)}(psi))) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: true}
-----------------------------------------------------
== distr_existsOr (distr_existsOr) =========================================
distr_existsOr {
\find(exists{u (variable)}(or(phi,psi)))
\replacewith(or(exists{u (variable)}(phi),exists{u (variable)}(psi))) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: true}
-----------------------------------------------------
== distr_forallAnd (distr_forallAnd) =========================================
distr_forallAnd {
\find(all{u (variable)}(and(phi,psi)))
\replacewith(and(all{u (variable)}(phi),all{u (variable)}(psi))) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: true}
-----------------------------------------------------
== distr_forallOr1 (distr_forallOr1) =========================================
distr_forallOr1 {
\find(all{u (variable)}(or(phi,psi)))
\varcond(\notFreeIn(u (variable), psi (formula)))
\replacewith(or(all{u (variable)}(phi),psi)) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: true}
-----------------------------------------------------
== distr_forallOr2 (distr_forallOr2) =========================================
distr_forallOr2 {
\find(all{u (variable)}(or(phi,psi)))
\varcond(\notFreeIn(u (variable), phi (formula)))
\replacewith(or(phi,all{u (variable)}(psi))) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: true}
-----------------------------------------------------
== distributeIntersection (distributeIntersection) =========================================
distributeIntersection {
\find(intersect(s1,union(s2,s3)))
\replacewith(union(intersect(s1,s2),intersect(s1,s3))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== distributeIntersection_2 (distributeIntersection_2) =========================================
distributeIntersection_2 {
\find(intersect(union(s2,s3),s1))
\replacewith(union(intersect(s2,s1),intersect(s3,s1))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== divAddMultDenom (divAddMultDenom) =========================================
divAddMultDenom {
\find(div(add(divNum,mul(coef,divDenom)),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(add(div(divNum,divDenom),coef)) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== divGreatestDNeg (divGreatestDNeg) =========================================
divGreatestDNeg {
\find(lt(divNum,mul(divDenom,coef))==>)
\add [imp(lt(divDenom,Z(0(#))),lt(coef,div(divNum,divDenom)))]==>[] 

Choices: true}
-----------------------------------------------------
== divGreatestDPos (divGreatestDPos) =========================================
divGreatestDPos {
\find(leq(mul(divDenom,coef),divNum)==>)
\add [imp(gt(divDenom,Z(0(#))),leq(coef,div(divNum,divDenom)))]==>[] 

Choices: true}
-----------------------------------------------------
== divIncreasingNeg (divIncreasingNeg) =========================================
divIncreasingNeg {
\add [all{divDenom1 (variable)}(all{divNum1 (variable)}(all{divNum2 (variable)}(imp(and(lt(divDenom1,Z(0(#))),leq(divNum1,divNum2)),geq(div(divNum1,divDenom1),div(divNum2,divDenom1))))))]==>[] 

Choices: true}
-----------------------------------------------------
== divIncreasingPos (divIncreasingPos) =========================================
divIncreasingPos {
\add [all{divDenom1 (variable)}(all{divNum1 (variable)}(all{divNum2 (variable)}(imp(and(gt(divDenom1,Z(0(#))),leq(divNum1,divNum2)),leq(div(divNum1,divDenom1),div(divNum2,divDenom1))))))]==>[] 

Choices: true}
-----------------------------------------------------
== divLeastDNeg (divLeastDNeg) =========================================
divLeastDNeg {
\find(leq(mul(divDenom,coef),divNum)==>)
\add [imp(lt(divDenom,Z(0(#))),leq(div(divNum,divDenom),coef))]==>[] 

Choices: true}
-----------------------------------------------------
== divLeastDPos (divLeastDPos) =========================================
divLeastDPos {
\find(lt(divNum,mul(divDenom,coef))==>)
\add [imp(gt(divDenom,Z(0(#))),lt(div(divNum,divDenom),coef))]==>[] 

Choices: true}
-----------------------------------------------------
== divMinus (divMinus) =========================================
divMinus {
\find(div(neg(divNum),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(if-then-else(equals(mul(div(divNum,divDenom),divDenom),divNum),neg(div(divNum,divDenom)),if-then-else(gt(divDenom,Z(0(#))),sub(neg(div(divNum,divDenom)),Z(1(#))),add(neg(div(divNum,divDenom)),Z(1(#)))))) 

Choices: true}
-----------------------------------------------------
== divMinusDenom (divMinusDenom) =========================================
divMinusDenom {
\find(div(divNum,neg(divDenom)))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(neg(div(divNum,divDenom))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== divResOne1 (divResOne1) =========================================
divResOne1 {
\find(div(divNum,divDenom))
\add [imp(and(and(gt(divDenom,Z(0(#))),lt(divNum,Z(0(#)))),lt(neg(divDenom),divNum)),equals(div(divNum,divDenom),Z(neglit(1(#)))))]==>[] 

Choices: true}
-----------------------------------------------------
== divResOne2 (divResOne2) =========================================
divResOne2 {
\find(div(divNum,divDenom))
\add [imp(and(and(lt(divDenom,Z(0(#))),lt(divNum,Z(0(#)))),lt(divDenom,divNum)),equals(div(divNum,divDenom),Z(1(#))))]==>[] 

Choices: true}
-----------------------------------------------------
== divResZero1 (divResZero1) =========================================
divResZero1 {
\find(div(divNum,divDenom))
\add [imp(and(and(gt(divDenom,Z(0(#))),leq(Z(0(#)),divNum)),lt(divNum,divDenom)),equals(div(divNum,divDenom),Z(0(#))))]==>[] 

Choices: true}
-----------------------------------------------------
== divResZero2 (divResZero2) =========================================
divResZero2 {
\find(div(divNum,divDenom))
\add [imp(and(and(lt(divDenom,Z(0(#))),leq(Z(0(#)),divNum)),lt(divNum,neg(divDenom))),equals(div(divNum,divDenom),Z(0(#))))]==>[] 

Choices: true}
-----------------------------------------------------
== div_axiom (div_axiom) =========================================
div_axiom {
\find(div(divNum,divDenom))
\sameUpdateLevel\add [or(equals(divDenom,Z(0(#))),and(and(equals(div(divNum,divDenom),quotient),leq(mul(quotient,divDenom),divNum)),if-then-else(geq(divDenom,Z(0(#))),geq(mul(quotient,divDenom),add(add(Z(1(#)),divNum),mul(Z(neglit(1(#))),divDenom))),geq(mul(quotient,divDenom),add(add(Z(1(#)),divNum),divDenom)))))]==>[] 
\heuristics(notHumanReadable, polySimp_newSmallSym, defOps_div)
Choices: true}
-----------------------------------------------------
== div_cancel1 (div_cancel1) =========================================
div_cancel1 {
\find(div(mul(divNum,divDenom),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(divNum) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== div_cancel2 (div_cancel2) =========================================
div_cancel2 {
\find(div(mul(divDenom,divNum),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(divNum) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== div_exists (div_exists) =========================================
div_exists {
\find(div(divNum,divDenom))
\add [all{cnom (variable)}(imp(not(equals(cnom,Z(0(#)))),all{a (variable)}(exists{qu (variable)}(exists{rm (variable)}(and(and(equals(a,add(mul(qu,cnom),rm)),leq(Z(0(#)),rm)),if-then-else(geq(cnom,Z(0(#))),and(geq(mul(qu,cnom),add(add(Z(1(#)),a),mul(Z(neglit(1(#))),cnom))),lt(rm,cnom)),and(geq(mul(qu,cnom),add(add(Z(1(#)),a),cnom)),lt(rm,neg(cnom))))))))))]==>[] 

Choices: true}
-----------------------------------------------------
== div_literals (div_literals) =========================================
div_literals {
\find(div(Z(iz),Z(jz)))
\replacewith(#div(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== div_one (div_one) =========================================
div_one {
\find(div(divNum,Z(1(#))))
\replacewith(divNum) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== div_unique1 (div_unique1) =========================================
div_unique1 {
\find(div(divNum,divDenom))
\add [all{a (variable)}(all{cnom (variable)}(all{x (variable)}(all{y (variable)}(imp(and(and(and(and(gt(cnom,Z(0(#))),leq(mul(x,cnom),a)),leq(mul(y,cnom),a)),geq(mul(x,cnom),sub(add(Z(1(#)),a),cnom))),geq(mul(y,cnom),sub(add(Z(1(#)),a),cnom))),equals(x,y))))))]==>[] 

Choices: true}
-----------------------------------------------------
== div_unique2 (div_unique2) =========================================
div_unique2 {
\find(div(divNum,divDenom))
\add [all{a (variable)}(all{cnom (variable)}(all{x (variable)}(all{y (variable)}(imp(and(and(and(and(lt(cnom,Z(0(#))),leq(mul(x,cnom),a)),leq(mul(y,cnom),a)),geq(mul(x,cnom),add(add(Z(1(#)),a),cnom))),geq(mul(y,cnom),add(add(Z(1(#)),a),cnom))),equals(x,y))))))]==>[] 

Choices: true}
-----------------------------------------------------
== div_zero (div_zero) =========================================
div_zero {
\find(div(Z(0(#)),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(Z(0(#))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== divide_eq0 (divide_eq0) =========================================
divide_eq0 {
\assumes ([geq(divX,divXBoundPos)]==>[]) 
\find(equals(divProd,divProdBoundNonNeg)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundPos,Z(1(#))),imp(geq(divProdBoundNonNeg,Z(0(#))),leq(divY,div(divProdBoundNonNeg,divXBoundPos)))))]==>[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_eq1 (divide_eq1) =========================================
divide_eq1 {
\assumes ([geq(divX,divXBoundNonNeg)]==>[]) 
\find(equals(divProd,divProdBoundNeg)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundNonNeg,Z(0(#))),imp(leq(divProdBoundNeg,Z(neglit(1(#)))),leq(divY,Z(neglit(1(#)))))))]==>[] 
\heuristics(inEqSimp_nonLin_neg, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_eq2 (divide_eq2) =========================================
divide_eq2 {
\assumes ([geq(divX,divXBoundPos)]==>[]) 
\find(equals(divProd,divProdBoundNonPos)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundPos,Z(1(#))),imp(leq(divProdBoundNonPos,Z(0(#))),geq(divY,div(sub(add(divProdBoundNonPos,divXBoundPos),Z(1(#))),divXBoundPos)))))]==>[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_eq3 (divide_eq3) =========================================
divide_eq3 {
\assumes ([geq(divX,divXBoundNonNeg)]==>[]) 
\find(equals(divProd,divProdBoundPos)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundNonNeg,Z(0(#))),imp(geq(divProdBoundPos,Z(1(#))),geq(divY,Z(1(#))))))]==>[] 
\heuristics(inEqSimp_nonLin_pos, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_eq4 (divide_eq4) =========================================
divide_eq4 {
\assumes ([leq(divX,divXBoundNeg)]==>[]) 
\find(equals(divProd,divProdBoundNonPos)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNeg,Z(neglit(1(#)))),imp(leq(divProdBoundNonPos,Z(0(#))),leq(divY,div(divProdBoundNonPos,divXBoundNeg)))))]==>[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_eq5 (divide_eq5) =========================================
divide_eq5 {
\assumes ([leq(divX,divXBoundNonPos)]==>[]) 
\find(equals(divProd,divProdBoundPos)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNonPos,Z(0(#))),imp(geq(divProdBoundPos,Z(1(#))),leq(divY,Z(neglit(1(#)))))))]==>[] 
\heuristics(inEqSimp_nonLin_neg, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_eq6 (divide_eq6) =========================================
divide_eq6 {
\assumes ([leq(divX,divXBoundNeg)]==>[]) 
\find(equals(divProd,divProdBoundNonNeg)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNeg,Z(neglit(1(#)))),imp(geq(divProdBoundNonNeg,Z(0(#))),geq(divY,div(divProdBoundNonNeg,divXBoundNeg)))))]==>[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_eq7 (divide_eq7) =========================================
divide_eq7 {
\assumes ([leq(divX,divXBoundNonPos)]==>[]) 
\find(equals(divProd,divProdBoundNeg)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNonPos,Z(0(#))),imp(leq(divProdBoundNeg,Z(neglit(1(#)))),geq(divY,Z(1(#))))))]==>[] 
\heuristics(inEqSimp_nonLin_pos, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_equation (divide_equation) =========================================
divide_equation {
\find(equals(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(and(geq(elimGcd,Z(1(#))),equals(mod(elimGcdLeft,elimGcd),Z(0(#)))),leq(mod(elimGcdRight,elimGcd),add(Z(neglit(1(#))),elimGcd))),and(equals(mod(elimGcdRight,elimGcd),Z(0(#))),equals(div(elimGcdLeft,elimGcd),div(elimGcdRight,elimGcd))),equals(elimGcdLeft,elimGcdRight))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_geq (divide_geq) =========================================
divide_geq {
\find(geq(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(and(geq(elimGcd,Z(1(#))),equals(mod(elimGcdLeft,elimGcd),Z(0(#)))),leq(mod(elimGcdRight,elimGcd),add(Z(neglit(1(#))),elimGcd))),geq(div(elimGcdLeft,elimGcd),add(Z(1(#)),div(add(Z(neglit(1(#))),elimGcdRight),elimGcd))),geq(elimGcdLeft,elimGcdRight))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_inEq0 (divide_inEq0) =========================================
divide_inEq0 {
\assumes ([geq(divX,divXBoundPos)]==>[]) 
\find(leq(divProd,divProdBoundNonNeg)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundPos,Z(1(#))),imp(geq(divProdBoundNonNeg,Z(0(#))),leq(divY,div(divProdBoundNonNeg,divXBoundPos)))))]==>[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_inEq1 (divide_inEq1) =========================================
divide_inEq1 {
\assumes ([geq(divX,divXBoundNonNeg)]==>[]) 
\find(leq(divProd,divProdBoundNeg)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundNonNeg,Z(0(#))),imp(leq(divProdBoundNeg,Z(neglit(1(#)))),leq(divY,Z(neglit(1(#)))))))]==>[] 
\heuristics(inEqSimp_nonLin_neg, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_inEq2 (divide_inEq2) =========================================
divide_inEq2 {
\assumes ([geq(divX,divXBoundPos)]==>[]) 
\find(geq(divProd,divProdBoundNonPos)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundPos,Z(1(#))),imp(leq(divProdBoundNonPos,Z(0(#))),geq(divY,div(sub(add(divProdBoundNonPos,divXBoundPos),Z(1(#))),divXBoundPos)))))]==>[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_inEq3 (divide_inEq3) =========================================
divide_inEq3 {
\assumes ([geq(divX,divXBoundNonNeg)]==>[]) 
\find(geq(divProd,divProdBoundPos)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundNonNeg,Z(0(#))),imp(geq(divProdBoundPos,Z(1(#))),geq(divY,Z(1(#))))))]==>[] 
\heuristics(inEqSimp_nonLin_pos, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_inEq4 (divide_inEq4) =========================================
divide_inEq4 {
\assumes ([leq(divX,divXBoundNeg)]==>[]) 
\find(geq(divProd,divProdBoundNonPos)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNeg,Z(neglit(1(#)))),imp(leq(divProdBoundNonPos,Z(0(#))),leq(divY,div(divProdBoundNonPos,divXBoundNeg)))))]==>[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_inEq5 (divide_inEq5) =========================================
divide_inEq5 {
\assumes ([leq(divX,divXBoundNonPos)]==>[]) 
\find(geq(divProd,divProdBoundPos)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNonPos,Z(0(#))),imp(geq(divProdBoundPos,Z(1(#))),leq(divY,Z(neglit(1(#)))))))]==>[] 
\heuristics(inEqSimp_nonLin_neg, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_inEq6 (divide_inEq6) =========================================
divide_inEq6 {
\assumes ([leq(divX,divXBoundNeg)]==>[]) 
\find(leq(divProd,divProdBoundNonNeg)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNeg,Z(neglit(1(#)))),imp(geq(divProdBoundNonNeg,Z(0(#))),geq(divY,div(divProdBoundNonNeg,divXBoundNeg)))))]==>[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_inEq7 (divide_inEq7) =========================================
divide_inEq7 {
\assumes ([leq(divX,divXBoundNonPos)]==>[]) 
\find(leq(divProd,divProdBoundNeg)==>)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNonPos,Z(0(#))),imp(leq(divProdBoundNeg,Z(neglit(1(#)))),geq(divY,Z(1(#))))))]==>[] 
\heuristics(inEqSimp_nonLin_pos, inEqSimp_special_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== divide_leq (divide_leq) =========================================
divide_leq {
\find(leq(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(and(geq(elimGcd,Z(1(#))),equals(mod(elimGcdLeft,elimGcd),Z(0(#)))),leq(mod(elimGcdRight,elimGcd),add(Z(neglit(1(#))),elimGcd))),leq(div(elimGcdLeft,elimGcd),div(elimGcdRight,elimGcd)),leq(elimGcdLeft,elimGcdRight))) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== doWhileUnwind (doWhileUnwind) =========================================
doWhileUnwind {
\find(#allmodal ( (modal operator))\[{ ..
  do #s
  while (#e);
... }\] (post))
\varcond(\newLabel (#innerLabel (program Label)), \newLabel (#outerLabel (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #unwind-loop(do #s
  while (#e);)
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== doubleImpLeft (doubleImpLeft) =========================================
doubleImpLeft {
\find(imp(b,imp(c,d))==>)
\replacewith([d]==>[]) ;
\replacewith([]==>[c]) ;
\replacewith([]==>[b]) 
\heuristics(beta)
Choices: true}
-----------------------------------------------------
== double_not (double_not) =========================================
double_not {
\find(not(not(b)))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== double_unary_minus_literal (double_unary_minus) =========================================
double_unary_minus_literal {
\find(Z(neglit(neglit(iz))))
\replacewith(Z(iz)) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== dropEffectlessStores (dropEffectlessStores) =========================================
dropEffectlessStores {
\find(store(h,o,f,x))
\varcond(\dropEffectlessStores(h (Heap term), o (java.lang.Object term), f (Field term), x (any term), result (Heap term)), )
\replacewith(result) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfAllFields (elementOfAllFields) =========================================
elementOfAllFields {
\find(elementOf(o,f,allFields(o2)))
\replacewith(equals(o,o2)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfAllLocs (elementOfAllLocs) =========================================
elementOfAllLocs {
\find(elementOf(o,f,allLocs))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfAllObjects (elementOfAllObjects) =========================================
elementOfAllObjects {
\find(elementOf(o,f,allObjects(f2)))
\replacewith(equals(f,f2)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfArrayRange (elementOfArrayRange) =========================================
elementOfArrayRange {
\find(elementOf(o,f,arrayRange(o2,lower,upper)))
\varcond(\notFreeIn(iv (variable), upper (int term)), \notFreeIn(iv (variable), lower (int term)), \notFreeIn(iv (variable), f (Field term)))
\replacewith(and(equals(o,o2),exists{iv (variable)}(and(and(equals(f,arr(iv)),leq(lower,iv)),leq(iv,upper))))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfArrayRangeConcrete (elementOfArrayRangeConcrete) =========================================
elementOfArrayRangeConcrete {
\find(elementOf(o,arr(idx),arrayRange(o2,lower,upper)))
\replacewith(and(and(equals(o,o2),leq(lower,idx)),leq(idx,upper))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfArrayRangeEQ (elementOfArrayRangeEQ) =========================================
elementOfArrayRangeEQ {
\assumes ([equals(arrayRange(o2,lower,upper),EQ)]==>[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\varcond(\notFreeIn(iv (variable), upper (int term)), \notFreeIn(iv (variable), lower (int term)), \notFreeIn(iv (variable), f (Field term)))
\replacewith(and(equals(o,o2),exists{iv (variable)}(and(and(equals(f,arr(iv)),leq(lower,iv)),leq(iv,upper))))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfEmpty (elementOfEmpty) =========================================
elementOfEmpty {
\find(elementOf(o,f,empty))
\replacewith(false) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfFreshLocs (elementOfFreshLocs) =========================================
elementOfFreshLocs {
\find(elementOf(o,f,freshLocs(h)))
\replacewith(and(not(equals(o,null)),not(equals(boolean::select(h,o,java.lang.Object::<created>),TRUE)))) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfGuardedSet (elementOfGuardedSet) =========================================
elementOfGuardedSet {
\find(elementOf(o,f,if-then-else(phi,s,empty)))
\replacewith(and(phi,elementOf(o,f,s))) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfInfiniteUnion (elementOfInfiniteUnion) =========================================
elementOfInfiniteUnion {
\find(elementOf(o,f,infiniteUnion{av (variable)}(s)))
\varcond(\notFreeIn(av (variable), f (Field term)), \notFreeIn(av (variable), o (java.lang.Object term)))
\replacewith(exists{av (variable)}(elementOf(o,f,s))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfInfiniteUnion2Vars (elementOfInfiniteUnion2Vars) =========================================
elementOfInfiniteUnion2Vars {
\find(elementOf(o,f,infiniteUnion{av (variable), bv (variable)}(s)))
\varcond(\notFreeIn(bv (variable), f (Field term)), \notFreeIn(bv (variable), o (java.lang.Object term)), \notFreeIn(av (variable), f (Field term)), \notFreeIn(av (variable), o (java.lang.Object term)))
\replacewith(exists{av (variable)}(exists{bv (variable)}(elementOf(o,f,s)))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfInfiniteUnion2VarsEQ (elementOfInfiniteUnion2VarsEQ) =========================================
elementOfInfiniteUnion2VarsEQ {
\assumes ([equals(infiniteUnion{av (variable), bv (variable)}(s),EQ)]==>[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\varcond(\notFreeIn(bv (variable), f (Field term)), \notFreeIn(bv (variable), o (java.lang.Object term)), \notFreeIn(av (variable), f (Field term)), \notFreeIn(av (variable), o (java.lang.Object term)))
\replacewith(exists{av (variable)}(exists{bv (variable)}(elementOf(o,f,s)))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfInfiniteUnionEQ (elementOfInfiniteUnionEQ) =========================================
elementOfInfiniteUnionEQ {
\assumes ([equals(infiniteUnion{av (variable)}(s),EQ)]==>[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\varcond(\notFreeIn(av (variable), f (Field term)), \notFreeIn(av (variable), o (java.lang.Object term)))
\replacewith(exists{av (variable)}(elementOf(o,f,s))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfIntersect (elementOfIntersect) =========================================
elementOfIntersect {
\find(elementOf(o,f,intersect(s,s2)))
\replacewith(and(elementOf(o,f,s),elementOf(o,f,s2))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfIntersectEQ (elementOfIntersectEQ) =========================================
elementOfIntersectEQ {
\assumes ([equals(intersect(s,s2),EQ)]==>[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\replacewith(and(elementOf(o,f,s),elementOf(o,f,s2))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfSetMinus (elementOfSetMinus) =========================================
elementOfSetMinus {
\find(elementOf(o,f,setMinus(s,s2)))
\replacewith(and(elementOf(o,f,s),not(elementOf(o,f,s2)))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfSetMinusEQ (elementOfSetMinusEQ) =========================================
elementOfSetMinusEQ {
\assumes ([equals(setMinus(s,s2),EQ)]==>[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\replacewith(and(elementOf(o,f,s),not(elementOf(o,f,s2)))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfSingleton (elementOfSingleton) =========================================
elementOfSingleton {
\find(elementOf(o,f,singleton(o2,f2)))
\replacewith(and(equals(o,o2),equals(f,f2))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfSubsetImpliesElementOfSuperset (elementOfSubsetImpliesElementOfSuperset) =========================================
elementOfSubsetImpliesElementOfSuperset {
\assumes ([subset(s,s2)]==>[]) 
\find(elementOf(o,f,s)==>)
\add [elementOf(o,f,s2)]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfSubsetOfUnion1 (elementOfSubsetOfUnion1) =========================================
elementOfSubsetOfUnion1 {
\assumes ([subset(s,union(s2,s3))]==>[elementOf(o,f,s2)]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\add [equiv(elementOf(o,f,s),elementOf(o,f,intersect(s,s3)))]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfSubsetOfUnion2 (elementOfSubsetOfUnion2) =========================================
elementOfSubsetOfUnion2 {
\assumes ([subset(s,union(s2,s3))]==>[elementOf(o,f,s3)]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\add [equiv(elementOf(o,f,s),elementOf(o,f,intersect(s,s2)))]==>[] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfUnion (elementOfUnion) =========================================
elementOfUnion {
\find(elementOf(o,f,union(s,s2)))
\replacewith(or(elementOf(o,f,s),elementOf(o,f,s2))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elementOfUnionEQ (elementOfUnionEQ) =========================================
elementOfUnionEQ {
\assumes ([equals(union(s,s2),EQ)]==>[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\replacewith(or(elementOf(o,f,s),elementOf(o,f,s2))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== elimGcdEq (elimGcdEq) =========================================
elimGcdEq {
\find(equals(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(and(equals(mul(elimGcdLeftDiv,elimGcd),elimGcdLeft),leq(add(elimGcdRight,mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),add(Z(neglit(1(#))),elimGcd))),geq(add(elimGcdRight,mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),Z(0(#)))),and(equals(add(elimGcdRight,mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),Z(0(#))),equals(elimGcdLeftDiv,elimGcdRightDiv)),equals(elimGcdLeft,elimGcdRight))) 
\heuristics(notHumanReadable, polySimp_pullOutGcd)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== elimGcdGeq (elimGcdGeq) =========================================
elimGcdGeq {
\find(geq(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(geq(add(add(add(add(sub(elimGcd,Z(1(#))),mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#))),leq(add(add(add(mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#)))),geq(elimGcdLeftDiv,elimGcdRightDiv),geq(elimGcdLeft,elimGcdRight))) 
\heuristics(notHumanReadable, inEqSimp_pullOutGcd_geq, inEqSimp_pullOutGcd)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== elimGcdGeq_antec (elimGcdGeq_antec) =========================================
elimGcdGeq_antec {
\find(geq(elimGcdLeft,elimGcdRight)==>)
\replacewith([or(or(leq(elimGcd,Z(0(#))),leq(add(add(add(add(elimGcd,mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#)))),geq(elimGcdLeftDiv,elimGcdRightDiv))]==>[]) 
\heuristics(notHumanReadable, inEqSimp_pullOutGcd_antec, inEqSimp_pullOutGcd_geq, inEqSimp_pullOutGcd)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== elimGcdLeq (elimGcdLeq) =========================================
elimGcdLeq {
\find(leq(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(leq(add(add(add(add(sub(Z(1(#)),elimGcd),mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#))),geq(add(add(add(mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#)))),leq(elimGcdLeftDiv,elimGcdRightDiv),leq(elimGcdLeft,elimGcdRight))) 
\heuristics(notHumanReadable, inEqSimp_pullOutGcd_leq, inEqSimp_pullOutGcd)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== elimGcdLeq_antec (elimGcdLeq_antec) =========================================
elimGcdLeq_antec {
\find(leq(elimGcdLeft,elimGcdRight)==>)
\replacewith([or(or(leq(elimGcd,Z(0(#))),geq(add(add(add(add(neg(elimGcd),mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#)))),leq(elimGcdLeftDiv,elimGcdRightDiv))]==>[]) 
\heuristics(notHumanReadable, inEqSimp_pullOutGcd_antec, inEqSimp_pullOutGcd_leq, inEqSimp_pullOutGcd)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== elim_double_block (elim_double_block) =========================================
elim_double_block {
\find(#allmodal ( (modal operator))\[{
  {
    #slist
  }
}\] (post))
\replacewith(#allmodal ( (modal operator))\[{
  #slist
}\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_double_block_2 (elim_double_block) =========================================
elim_double_block_2 {
\find(#allmodal ( (modal operator))\[{ ..
  {
    {
      #slist
    }
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_double_block_3 (elim_double_block) =========================================
elim_double_block_3 {
\find(#allmodal ( (modal operator))\[{ ..
  {
    while (#e) #s
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  while (#e) #s
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_double_block_4 (elim_double_block) =========================================
elim_double_block_4 {
\find(#allmodal ( (modal operator))\[{ ..
  {
    for (#loopInit; #guard; #forupdates) #s
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  for (#loopInit; #guard; #forupdates) #s
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_double_block_5 (elim_double_block) =========================================
elim_double_block_5 {
\find(#allmodal ( (modal operator))\[{ ..
  {
    for (; #guard; #forupdates) #s
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  for (; #guard; #forupdates) #s
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_double_block_6 (elim_double_block) =========================================
elim_double_block_6 {
\find(#allmodal ( (modal operator))\[{ ..
  {
    for (#loopInit; #guard; ) #s
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  for (#loopInit; #guard; ) #s
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_double_block_7 (elim_double_block) =========================================
elim_double_block_7 {
\find(#allmodal ( (modal operator))\[{ ..
  {
    for (; #guard; ) #s
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  for (; #guard; ) #s
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_double_block_8 (elim_double_block) =========================================
elim_double_block_8 {
\find(#allmodal ( (modal operator))\[{ ..
  {
    do #s
    while (#e);
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  do #s
  while (#e);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_double_block_9 (elim_double_block) =========================================
elim_double_block_9 {
\find(#allmodal ( (modal operator))\[{ ..
  {
    {
      #slist
    }
    {
      #slist1
    }
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist
  }
  {
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== elim_exists0 (elim_exists0) =========================================
elim_exists0 {
\find(exists{Gvar (variable)}(equals(Gvar,subGterm)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists1 (elim_exists1) =========================================
elim_exists1 {
\find(exists{Gvar (variable)}(equals(subGterm,Gvar)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists2 (elim_exists2) =========================================
elim_exists2 {
\find(exists{Gvar (variable)}(equals(Gvar,Hterm)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(equals(G::instance(Hterm),TRUE)) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists3 (elim_exists3) =========================================
elim_exists3 {
\find(exists{Gvar (variable)}(equals(Hterm,Gvar)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(equals(G::instance(Hterm),TRUE)) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists4 (elim_exists4) =========================================
elim_exists4 {
\find(exists{Gvar (variable)}(and(phi,equals(Gvar,subGterm))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists5 (elim_exists5) =========================================
elim_exists5 {
\find(exists{Gvar (variable)}(and(phi,equals(subGterm,Gvar))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists6 (elim_exists6) =========================================
elim_exists6 {
\find(exists{Gvar (variable)}(and(phi,equals(Gvar,Hterm))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(and(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),TRUE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists7 (elim_exists7) =========================================
elim_exists7 {
\find(exists{Gvar (variable)}(and(phi,equals(Hterm,Gvar))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(and(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),TRUE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_leq (elim_exists_leq) =========================================
elim_exists_leq {
\find(exists{INTVar (variable)}(and(leq(INTVar,intTermLeft),geq(INTVar,intTermRight))))
\varcond(\notFreeIn(INTVar (variable), intTermRight (int term)), \notFreeIn(INTVar (variable), intTermLeft (int term)))
\replacewith(leq(intTermRight,intTermLeft)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_nonSingleton0 (elim_exists_nonSingleton0) =========================================
elim_exists_nonSingleton0 {
\find(exists{nonSingleVar (variable)}(not(equals(nonSingleVar,Hterm))))
\varcond(\notFreeIn(nonSingleVar (variable), Hterm (H term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_nonSingleton1 (elim_exists_nonSingleton1) =========================================
elim_exists_nonSingleton1 {
\find(exists{nonSingleVar (variable)}(not(equals(Hterm,nonSingleVar))))
\varcond(\notFreeIn(nonSingleVar (variable), Hterm (H term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_nonSingleton2 (elim_exists_nonSingleton2) =========================================
elim_exists_nonSingleton2 {
\find(exists{INTVar (variable)}(geq(INTVar,intTerm)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_nonSingleton3 (elim_exists_nonSingleton3) =========================================
elim_exists_nonSingleton3 {
\find(exists{INTVar (variable)}(leq(INTVar,intTerm)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_nonSingleton4 (elim_exists_nonSingleton4) =========================================
elim_exists_nonSingleton4 {
\find(exists{INTVar (variable)}(geq(intTerm,INTVar)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_nonSingleton5 (elim_exists_nonSingleton5) =========================================
elim_exists_nonSingleton5 {
\find(exists{INTVar (variable)}(leq(intTerm,INTVar)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_sub_1 (elim_exists_sub_1) =========================================
elim_exists_sub_1 {
\find(exists{locVar (variable)}(and(subset(locVar,locSetTermRight),subset(locSetTermLeft,locVar))))
\varcond(\notFreeIn(locVar (variable), locSetTermRight (LocSet term)), \notFreeIn(locVar (variable), locSetTermLeft (LocSet term)))
\replacewith(subset(locSetTermLeft,locSetTermRight)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_sub_1_and_phi (elim_exists_sub_1_and_phi) =========================================
elim_exists_sub_1_and_phi {
\find(exists{locVar (variable)}(and(and(subset(locVar,locSetTerm),subset(locSetTerm,locVar)),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(exists{locVar (variable)}(and(equals(locVar,locSetTerm),phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_exists_sub_1_or_phi (elim_exists_sub_1_or_phi) =========================================
elim_exists_sub_1_or_phi {
\find(exists{locVar (variable)}(or(and(subset(locVar,locSetTermRight),subset(locSetTermLeft,locVar)),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTermRight (LocSet term)), \notFreeIn(locVar (variable), locSetTermLeft (LocSet term)))
\replacewith(or(subset(locSetTermLeft,locSetTermRight),exists{locVar (variable)}(phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall0 (elim_forall0) =========================================
elim_forall0 {
\find(all{Gvar (variable)}(not(equals(Gvar,subGterm))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall1 (elim_forall1) =========================================
elim_forall1 {
\find(all{Gvar (variable)}(not(equals(subGterm,Gvar))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall10 (elim_forall10) =========================================
elim_forall10 {
\find(all{Gvar (variable)}(imp(equals(Gvar,Hterm),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall11 (elim_forall11) =========================================
elim_forall11 {
\find(all{Gvar (variable)}(imp(equals(Hterm,Gvar),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall12 (elim_forall12) =========================================
elim_forall12 {
\find(all{Gvar (variable)}(imp(and(psi,equals(Gvar,subGterm)),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,imp(psi,phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall13 (elim_forall13) =========================================
elim_forall13 {
\find(all{Gvar (variable)}(imp(and(psi,equals(subGterm,Gvar)),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,imp(psi,phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall14 (elim_forall14) =========================================
elim_forall14 {
\find(all{Gvar (variable)}(imp(and(psi,equals(Gvar,Hterm)),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),imp(psi,phi)),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall15 (elim_forall15) =========================================
elim_forall15 {
\find(all{Gvar (variable)}(imp(and(psi,equals(Hterm,Gvar)),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),imp(psi,phi)),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall16 (elim_forall16) =========================================
elim_forall16 {
\find(all{Gvar (variable)}(imp(and(equals(Gvar,subGterm),psi),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,imp(psi,phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall17 (elim_forall17) =========================================
elim_forall17 {
\find(all{Gvar (variable)}(imp(and(equals(subGterm,Gvar),psi),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,imp(psi,phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall18 (elim_forall18) =========================================
elim_forall18 {
\find(all{Gvar (variable)}(imp(and(equals(Gvar,Hterm),psi),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),imp(psi,phi)),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall19 (elim_forall19) =========================================
elim_forall19 {
\find(all{Gvar (variable)}(imp(and(equals(Hterm,Gvar),psi),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),imp(psi,phi)),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall2 (elim_forall2) =========================================
elim_forall2 {
\find(all{Gvar (variable)}(not(equals(Gvar,Hterm))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(equals(G::instance(Hterm),FALSE)) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall3 (elim_forall3) =========================================
elim_forall3 {
\find(all{Gvar (variable)}(not(equals(Hterm,Gvar))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(equals(G::instance(Hterm),FALSE)) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall4 (elim_forall4) =========================================
elim_forall4 {
\find(all{Gvar (variable)}(or(phi,not(equals(Gvar,subGterm)))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall5 (elim_forall5) =========================================
elim_forall5 {
\find(all{Gvar (variable)}(or(phi,not(equals(subGterm,Gvar)))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall6 (elim_forall6) =========================================
elim_forall6 {
\find(all{Gvar (variable)}(or(phi,not(equals(Gvar,Hterm)))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall7 (elim_forall7) =========================================
elim_forall7 {
\find(all{Gvar (variable)}(or(phi,not(equals(Hterm,Gvar)))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall8 (elim_forall8) =========================================
elim_forall8 {
\find(all{Gvar (variable)}(imp(equals(Gvar,subGterm),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall9 (elim_forall9) =========================================
elim_forall9 {
\find(all{Gvar (variable)}(imp(equals(subGterm,Gvar),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_eqSet_imp_phi (elim_forall_eqSet_imp_phi) =========================================
elim_forall_eqSet_imp_phi {
\find(all{locVar (variable)}(imp(and(subset(locVar,locSetTerm),subset(locSetTerm,locVar)),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(all{locVar (variable)}(imp(equals(locSetTerm,locVar),phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_leq (elim_forall_leq) =========================================
elim_forall_leq {
\find(all{INTVar (variable)}(or(leq(INTVar,intTermLeft),geq(INTVar,intTermRight))))
\varcond(\notFreeIn(INTVar (variable), intTermRight (int term)), \notFreeIn(INTVar (variable), intTermLeft (int term)))
\replacewith(leq(intTermRight,add(intTermLeft,Z(1(#))))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_nonSingleton0 (elim_forall_nonSingleton0) =========================================
elim_forall_nonSingleton0 {
\find(all{nonSingleVar (variable)}(equals(nonSingleVar,Hterm)))
\varcond(\notFreeIn(nonSingleVar (variable), Hterm (H term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_nonSingleton1 (elim_forall_nonSingleton1) =========================================
elim_forall_nonSingleton1 {
\find(all{nonSingleVar (variable)}(equals(Hterm,nonSingleVar)))
\varcond(\notFreeIn(nonSingleVar (variable), Hterm (H term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_nonSingleton2 (elim_forall_nonSingleton2) =========================================
elim_forall_nonSingleton2 {
\find(all{INTVar (variable)}(geq(INTVar,intTerm)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_nonSingleton3 (elim_forall_nonSingleton3) =========================================
elim_forall_nonSingleton3 {
\find(all{INTVar (variable)}(leq(INTVar,intTerm)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_nonSingleton4 (elim_forall_nonSingleton4) =========================================
elim_forall_nonSingleton4 {
\find(all{INTVar (variable)}(geq(intTerm,INTVar)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_nonSingleton5 (elim_forall_nonSingleton5) =========================================
elim_forall_nonSingleton5 {
\find(all{INTVar (variable)}(leq(intTerm,INTVar)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_subOfAll (elim_forall_subOfAll) =========================================
elim_forall_subOfAll {
\find(all{locVar (variable)}(subset(locSetTerm,locVar)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(equals(locSetTerm,empty)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_subOfAll_and_phi (elim_forall_subOfAll_and_phi) =========================================
elim_forall_subOfAll_and_phi {
\find(all{locVar (variable)}(and(subset(locSetTerm,locVar),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(and(equals(locSetTerm,empty),all{locVar (variable)}(phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_superOfAll (elim_forall_superOfAll) =========================================
elim_forall_superOfAll {
\find(all{locVar (variable)}(subset(locVar,locSetTerm)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(equals(locSetTerm,allLocs)) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== elim_forall_superOfAll_and_phi (elim_forall_superOfAll_and_phi) =========================================
elim_forall_superOfAll_and_phi {
\find(all{locVar (variable)}(and(subset(locVar,locSetTerm),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(and(equals(locSetTerm,allLocs),all{locVar (variable)}(phi))) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== emptyEqualsSingleton (emptyEqualsSingleton) =========================================
emptyEqualsSingleton {
\find(equals(empty,singleton(o,f)))
\replacewith(false) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== emptyModality (emptyModality) =========================================
emptyModality {
\find(#normal(post))
\replacewith(post) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== emptyModalityBoxTransaction (emptyModality) =========================================
emptyModalityBoxTransaction {
\find(box_transaction(post))
\replacewith(true) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== emptyModalityDiamondTransaction (emptyModality) =========================================
emptyModalityDiamondTransaction {
\find(diamond_transaction(post))
\replacewith(false) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== emptyStatement (emptyStatement) =========================================
emptyStatement {
\find(#allmodal ( (modal operator))\[{ ..
  ;
... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== endsWith (endsWith) =========================================
endsWith {
\find(clEndsWith(sourceStr,searchStr))
\replacewith(if-then-else(gt(seqLen(searchStr),seqLen(sourceStr)),false,equals(seqSub(sourceStr,sub(seqLen(sourceStr),seqLen(searchStr)),seqLen(sourceStr)),searchStr))) 
\heuristics(defOpsStartsEndsWith)
Choices: Strings:on}
-----------------------------------------------------
== enhancedfor_iterable (enhancedfor) =========================================
enhancedfor_iterable {
\find(#allmodal ( (modal operator))\[{ ..
  for (#ty #id : #e) #stm
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  enhancedfor-elim(for (#ty #id : #e) #stm)
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eqClose (eqClose) =========================================
eqClose {
\find(equals(s,s))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== eqSymm (eqSymm) =========================================
eqSymm {
\find(equals(commEqLeft,commEqRight))
\replacewith(equals(commEqRight,commEqLeft)) 
\heuristics(order_terms)
Choices: true}
-----------------------------------------------------
== eqTermCut (eqTermCut) =========================================
eqTermCut {
\find(t)
\sameUpdateLevel\add [not(equals(t,s))]==>[] ;
\add [equals(t,s)]==>[] 

Choices: true}
-----------------------------------------------------
== eq_add_iff1 (eq_add_iff1) =========================================
eq_add_iff1 {
\find(equals(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(equals(add(mul(sub(i0,i3),i1),i2),i4)) 

Choices: true}
-----------------------------------------------------
== eq_add_iff2 (eq_add_iff2) =========================================
eq_add_iff2 {
\find(equals(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(equals(i2,add(mul(sub(i3,i0),i1),i4))) 

Choices: true}
-----------------------------------------------------
== eq_and (eq_and) =========================================
eq_and {
\find(and(phi,phi))
\replacewith(phi) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== eq_and_2 (eq_and_2) =========================================
eq_and_2 {
\find(and(and(psi,phi),phi))
\replacewith(and(psi,phi)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== eq_eq (eq_eq) =========================================
eq_eq {
\find(equiv(phi,phi))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== eq_imp (eq_imp) =========================================
eq_imp {
\find(imp(phi,phi))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== eq_or (eq_or) =========================================
eq_or {
\find(or(phi,phi))
\replacewith(phi) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== eq_or_2 (eq_or_2) =========================================
eq_or_2 {
\find(or(or(psi,phi),phi))
\replacewith(or(psi,phi)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== eq_sides (eq_sides) =========================================
eq_sides {
\find(equals(i,j))
\replacewith(equals(sub(i,j),Z(0(#)))) 

Choices: true}
-----------------------------------------------------
== equalCharacters (equalCharacters) =========================================
equalCharacters {
\find(equals(C(iz1),C(iz2)))
\replacewith(equals(Z(iz1),Z(iz2))) 
\heuristics(stringsSimplify)
Choices: Strings:on}
-----------------------------------------------------
== equalRegEx (equalRegEx) =========================================
equalRegEx {
\find(equals(rexp1,rexp2))
\varcond(\notFreeIn(string (variable), rexp2 (RegEx term)), \notFreeIn(string (variable), rexp1 (RegEx term)))
\replacewith(all{string (variable)}(equiv(match(rexp1,string),match(rexp2,string)))) 

Choices: Strings:on}
-----------------------------------------------------
== equalUnique (equalUnique) =========================================
equalUnique {
\find(equals(f,f2))
\varcond(\equalUnique (f (any term), f2 (any term), result (formula)), )
\replacewith(result) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== equal_add (equal_add) =========================================
equal_add {
\find(==>equals(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==>[exists{j2 (variable)}(equals(add(i0,j2),add(i1,j2)))]) 

Choices: true}
-----------------------------------------------------
== equal_add_one (equal_add_one) =========================================
equal_add_one {
\find(equals(i0,i1))
\replacewith(equals(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: true}
-----------------------------------------------------
== equal_bprod1 (equal_bprod_same_index) =========================================
equal_bprod1 {
\find(==>equals(bprod{uSub1 (variable)}(i0,i1,t1),bprod{uSub2 (variable)}(i0,i1,t2)))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(uSub1,t2))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_bprod2 (equal_bprod_same_index) =========================================
equal_bprod2 {
\assumes ([equals(bprod{uSub1 (variable)}(i0,i1,t1),i)]==>[]) 
\find(==>equals(bprod{uSub2 (variable)}(i0,i1,t2),i))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(uSub1,t2))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_bprod3 (equal_bprod_same_index) =========================================
equal_bprod3 {
\assumes ([equals(bprod{uSub1 (variable)}(i0,i1,t1),i),equals(bprod{uSub2 (variable)}(i0,i1,t2),j)]==>[]) 
\find(==>equals(j,i))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(uSub1,t2))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_bprod5 (equal_bprod) =========================================
equal_bprod5 {
\find(==>equals(bprod{uSub1 (variable)}(i0,i1,t1),bprod{uSub2 (variable)}(i2,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(sub(add(uSub1,i2),i0),t2))))] ;
\add []==>[equals(sub(i1,i0),sub(i3,i2))] 
\heuristics(comprehensions_high_costs)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_bprod_perm1 (equal_bprod_perm) =========================================
equal_bprod_perm1 {
\find(==>equals(bprod{uSub1 (variable)}(i0,i1,t1),bprod{uSub2 (variable)}(i2,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[seqPerm(seqDef{uSub1 (variable)}(i0,i1,t1),seqDef{uSub2 (variable)}(i2,i3,t2))] 

Choices: (integerSimplificationRules:full & sequences:on)}
-----------------------------------------------------
== equal_bprod_perm2 (equal_bprod_perm) =========================================
equal_bprod_perm2 {
\assumes ([equals(bprod{uSub2 (variable)}(i2,i3,t2),t)]==>[]) 
\find(==>equals(bprod{uSub1 (variable)}(i0,i1,t1),t))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[seqPerm(seqDef{uSub1 (variable)}(i0,i1,t1),seqDef{uSub2 (variable)}(i2,i3,t2))] 

Choices: (integerSimplificationRules:full & sequences:on)}
-----------------------------------------------------
== equal_bsum1 (equal_bsum_same_index) =========================================
equal_bsum1 {
\find(==>equals(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i0,i1,t2)))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(uSub1,t2))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_bsum2 (equal_bsum_same_index) =========================================
equal_bsum2 {
\assumes ([equals(bsum{uSub1 (variable)}(i0,i1,t1),i)]==>[]) 
\find(==>equals(bsum{uSub2 (variable)}(i0,i1,t2),i))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(uSub1,t2))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_bsum3 (equal_bsum_same_index) =========================================
equal_bsum3 {
\assumes ([equals(bsum{uSub1 (variable)}(i0,i1,t1),i),equals(bsum{uSub2 (variable)}(i0,i1,t2),j)]==>[]) 
\find(==>equals(j,i))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(uSub1,t2))))] 
\heuristics(comprehensions)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_bsum5 (equal_bsum) =========================================
equal_bsum5 {
\find(==>equals(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i2,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(sub(add(uSub1,i2),i0),t2))))] ;
\add []==>[equals(sub(i1,i0),sub(i3,i2))] 
\heuristics(comprehensions_high_costs)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_bsum_perm1 (equal_bsum_perm) =========================================
equal_bsum_perm1 {
\find(==>equals(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i2,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[seqPerm(seqDef{uSub1 (variable)}(i0,i1,t1),seqDef{uSub2 (variable)}(i2,i3,t2))] 

Choices: (integerSimplificationRules:full & sequences:on)}
-----------------------------------------------------
== equal_bsum_perm2 (equal_bsum_perm) =========================================
equal_bsum_perm2 {
\assumes ([equals(bsum{uSub2 (variable)}(i2,i3,t2),t)]==>[]) 
\find(==>equals(bsum{uSub1 (variable)}(i0,i1,t1),t))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==>[seqPerm(seqDef{uSub1 (variable)}(i0,i1,t1),seqDef{uSub2 (variable)}(i2,i3,t2))] 

Choices: (integerSimplificationRules:full & sequences:on)}
-----------------------------------------------------
== equal_bsum_zero_cut (equal_bsum_zero_cut) =========================================
equal_bsum_zero_cut {
\find(==>equals(bsum{uSub1 (variable)}(i0,i1,t1),mul(bsum{uSub2 (variable)}(i2,i3,t2),t)))
\add [equals(bsum{uSub1 (variable)}(i0,i1,t1),Z(0(#)))]==>[] ;
\add []==>[equals(bsum{uSub1 (variable)}(i0,i1,t1),Z(0(#)))] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== equal_literals (equal_literals) =========================================
equal_literals {
\find(equals(Z(iz),Z(jz)))
\replacewith(#eq(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== equalityToElementOf (equalityToElementOf) =========================================
equalityToElementOf {
\find(equals(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(equiv(elementOf(ov,fv,s),elementOf(ov,fv,s2))))) 
\heuristics(semantics_blasting)
Choices: programRules:Java}
-----------------------------------------------------
== equalityToElementOfRight (equalityToElementOfRight) =========================================
equalityToElementOfRight {
\find(==>equals(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith([]==>[all{ov (variable)}(all{fv (variable)}(equiv(elementOf(ov,fv,s),elementOf(ov,fv,s2))))]) 
\heuristics(setEqualityBlastingRight)
Choices: programRules:Java}
-----------------------------------------------------
== equalityToSelect (equalityToSelect) =========================================
equalityToSelect {
\find(equals(h,h2))
\varcond(\notFreeIn(fv (variable), h2 (Heap term)), \notFreeIn(fv (variable), h (Heap term)), \notFreeIn(ov (variable), h2 (Heap term)), \notFreeIn(ov (variable), h (Heap term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(equals(any::select(h,ov,fv),any::select(h2,ov,fv))))) 
\heuristics(semantics_blasting)
Choices: programRules:Java}
-----------------------------------------------------
== equalityToSeqGetAndSeqLen (equalityToSeqGetAndSeqLen) =========================================
equalityToSeqGetAndSeqLen {
\find(equals(left,right))
\varcond(\notFreeIn(iv (variable), right (Seq term)), \notFreeIn(iv (variable), left (Seq term)))
\replacewith(and(equals(seqLen(left),seqLen(right)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(left))),equals(any::seqGet(left,iv),any::seqGet(right,iv)))))) 
\heuristics(defOpsSeqEquality)
Choices: sequences:on}
-----------------------------------------------------
== equalityToSeqGetAndSeqLenLeft (equalityToSeqGetAndSeqLenLeft) =========================================
equalityToSeqGetAndSeqLenLeft {
\find(equals(s,s2)==>)
\varcond(\notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\add [and(equals(seqLen(s),seqLen(s2)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(s2,iv)))))]==>[] 
\heuristics(inReachableStateImplication)
Choices: sequences:on}
-----------------------------------------------------
== equalityToSeqGetAndSeqLenRight (equalityToSeqGetAndSeqLenRight) =========================================
equalityToSeqGetAndSeqLenRight {
\find(==>equals(s,s2))
\varcond(\notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\replacewith([]==>[and(equals(seqLen(s),seqLen(s2)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(s2,iv)))))]) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== equality_comparison_double (equality comparison) =========================================
equality_comparison_double {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seDouble0 == #seDouble1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(eqDouble(#seDouble0,#seDouble1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== equality_comparison_new (equality comparison) =========================================
equality_comparison_new {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 == #senf1;
... }\] (post))
\replacewith(if-then-else(not(equals(#senf0,#senf1)),#allmodal ( (modal operator))\[{ ..
  #lhs = false;
... }\] (post),#allmodal ( (modal operator))\[{ ..
  #lhs = true;
... }\] (post))) 
\heuristics(split_if, simplify_prog, obsolete)
Choices: programRules:Java}
-----------------------------------------------------
== equality_comparison_simple (equality comparison) =========================================
equality_comparison_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 == #senf1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#senf0,#senf1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== equality_comparison_simple_float (equality comparison) =========================================
equality_comparison_simple_float {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seFloat0 == #seFloat1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(eqFloat(#seFloat0,#seFloat1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== equivAllRight (equivAllRight) =========================================
equivAllRight {
\find(==>equiv(all{u (variable)}(b),all{e2 (variable)}(c)))
\varcond(\notFreeIn(e2 (variable), b (formula)), \notFreeIn(u (variable), c (formula)))
\add []==>[all{u (variable)}(equiv(b,subst{e2 (variable)}(u,c)))] 

Choices: true}
-----------------------------------------------------
== equiv_left (equiv_left) =========================================
equiv_left {
\find(equiv(b,c)==>)
\replacewith([]==>[b,c]) ;
\replacewith([b,c]==>[]) 
\heuristics(beta)
Choices: true}
-----------------------------------------------------
== equiv_right (equiv_right) =========================================
equiv_right {
\find(==>equiv(b,c))
\replacewith([c]==>[b]) ;
\replacewith([b]==>[c]) 
\heuristics(beta)
Choices: true}
-----------------------------------------------------
== eval_array_this_access (eval_array_access) =========================================
eval_array_this_access {
\find(#allmodal ( (modal operator))\[{ ..
  this[#nse] = #se0;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0 = #nse;
  this[#v0] = #se0;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_access1 (assignmentUnfoldLeft) =========================================
eval_order_access1 {
\find(#allmodal ( (modal operator))\[{ ..
  #nv.#attribute = #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nv (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nv) #v0 = #nv;
  #v0.#attribute = #e;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_access2 (assignmentUnfoldRight) =========================================
eval_order_access2 {
\find(#allmodal ( (modal operator))\[{ ..
  #v = #nv.#attribute;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nv (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nv) #v0 = #nv;
  #v = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_access4 (assignmentSaveLocation) =========================================
eval_order_access4 {
\find(#allmodal ( (modal operator))\[{ ..
  #v.#a = #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#v (program Variable))),  \not \static(#a (program Variable)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#v) #v0 = #v;
  #typeof(#nse) #v1 = #nse;
  #v0.#a = #v1;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_access4_this (assignmentSaveLocationThis) =========================================
eval_order_access4_this {
\find(#allmodal ( (modal operator))\[{ ..
  #v.#a = #nse;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))),  \not \static(#a (program Variable)), \isThisReference (#v (program Variable)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v1 = #nse;
  #v.#a = #v1;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_array_access1 (assignmentUnfoldLeft) =========================================
eval_order_array_access1 {
\find(#allmodal ( (modal operator))\[{ ..
  #nv[#e] = #e0;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nv (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nv) #v0 = #nv;
  #v0[#e] = #e0;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_array_access2 (assignmentUnfoldLeft) =========================================
eval_order_array_access2 {
\find(#allmodal ( (modal operator))\[{ ..
  #v[#nse] = #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#ar1 (program Variable), \typeof(#v (program Variable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#v) #ar1 = #v;
  #typeof(#nse) #v0 = #nse;
  #ar1[#v0] = #e;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_array_access3 (assignmentSaveLocation) =========================================
eval_order_array_access3 {
\find(#allmodal ( (modal operator))\[{ ..
  #v[#se] = #nse;
... }\] (post))
\varcond(\new(#v2 (program Variable), \typeof(#se (program SimpleExpression))), \new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#v (program Variable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#v) #v0 = #v;
  #typeof(#se) #v2 = #se;
  #typeof(#nse) #v1 = #nse;
  #v0[#v2] = #v1;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_array_access4 (assignmentUnfoldRight) =========================================
eval_order_array_access4 {
\find(#allmodal ( (modal operator))\[{ ..
  #v = #nv[#e];
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nv (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nv) #v0 = #nv;
  #v = #v0[#e];
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_array_access5 (assignmentUnfoldRight) =========================================
eval_order_array_access5 {
\find(#allmodal ( (modal operator))\[{ ..
  #v = #v0[#nse];
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#ar1 (program Variable), \typeof(#v0 (program Variable))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#v0) #ar1 = #v0;
  #typeof(#nse) #v1 = #nse;
  #v = #ar1[#v1];
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_array_access6 (assignmentUnfoldRight) =========================================
eval_order_array_access6 {
\find(#allmodal ( (modal operator))\[{ ..
  #v = #nv.#length;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nv (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nv) #v0 = #nv;
  #v = #v0.#length;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_0_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_0_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] = #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = #e1;
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_0_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_0_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute = #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = #e;
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_10_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_10_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] |= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] | #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_10_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_10_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute |= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute |
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_11_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_11_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] ^= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] ^ #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_11_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_11_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute ^= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute ^
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_1_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_1_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] *= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] * #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_1_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_1_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute *= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute *
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_2_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_2_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] /= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] / #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_2_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_2_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute /= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute /
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_3_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_3_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] %= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] % #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_3_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_3_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute %= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute %
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_4_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_4_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] += #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] + #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_4_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_4_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute += #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute +
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_5_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_5_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] -= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] - #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_5_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_5_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute -= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute -
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_6_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_6_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] <<= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] << #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_6_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_6_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute <<= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute <<
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_7_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_7_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] >>= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] >> #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_7_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_7_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute >>= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute >>
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_8_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_8_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] >>>= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] >>> #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_8_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_8_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute >>>= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute >>>
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_9_0 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_9_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0[#e] &= #e1;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #typeof(#e) #v1 = #e;
  #v0[#v1] = (#typeof(#e0[#e])) (#v0[#v1] & #e1);
  #lhs0 = #v0[#v1];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== eval_order_iterated_assignments_9_1 (eval_order_iterated_assignments) =========================================
eval_order_iterated_assignments_9_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e0.#attribute &= #e;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e0) #v0 = #e0;
  #v0.#attribute = (#typeof(#attribute)) (#v0.#attribute &
                                            #e);
  #lhs0 = #v0.#attribute;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== exLeft (exLeft) =========================================
exLeft {
\find(exists{u (variable)}(b)==>)
\replacewith([subst{u (variable)}(sk,b)]==>[]) 
\heuristics(delta)
Choices: true}
-----------------------------------------------------
== exRight (exRight) =========================================
exRight {
\find(==>exists{u (variable)}(b))
\add []==>[subst{u (variable)}(t,b)] 
\heuristics(gamma)
Choices: true}
-----------------------------------------------------
== exRightHide (exRightHide) =========================================
exRightHide {
\find(==>exists{u (variable)}(b))
\addrules [insert_hidden {
\add []==>[exists{u (variable)}(b)] 

Choices: true}] \replacewith([]==>[subst{u (variable)}(t,b)]) 
\heuristics(gamma_destructive)
Choices: true}
-----------------------------------------------------
== ex_bool (ex_bool) =========================================
ex_bool {
\find(exists{x (variable)}(c))
\replacewith(or(subst{x (variable)}(FALSE,c),subst{x (variable)}(TRUE,c))) 
\heuristics(boolean_cases)
Choices: true}
-----------------------------------------------------
== ex_pull_out0 (ex_pull_out0) =========================================
ex_pull_out0 {
\find(and(exists{u (variable)}(b),c))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(and(b,c))) 
\heuristics(pullOutQuantifierEx)
Choices: true}
-----------------------------------------------------
== ex_pull_out1 (ex_pull_out1) =========================================
ex_pull_out1 {
\find(and(c,exists{u (variable)}(b)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(and(c,b))) 
\heuristics(pullOutQuantifierEx)
Choices: true}
-----------------------------------------------------
== ex_pull_out2 (ex_pull_out2) =========================================
ex_pull_out2 {
\find(or(exists{u (variable)}(b),c))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(or(b,c))) 
\heuristics(pullOutQuantifierEx)
Choices: true}
-----------------------------------------------------
== ex_pull_out3 (ex_pull_out3) =========================================
ex_pull_out3 {
\find(or(c,exists{u (variable)}(b)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(or(c,b))) 
\heuristics(pullOutQuantifierEx)
Choices: true}
-----------------------------------------------------
== ex_pull_out4 (ex_pull_out4) =========================================
ex_pull_out4 {
\find(or(exists{u (variable)}(b),exists{u2 (variable)}(c)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(or(b,subst{u2 (variable)}(u,c)))) 
\heuristics(pullOutQuantifierUnifying, pullOutQuantifierEx)
Choices: true}
-----------------------------------------------------
== ex_unused (ex_unused) =========================================
ex_unused {
\find(exists{u (variable)}(b))
\varcond(\notFreeIn(u (variable), b (formula)))
\replacewith(b) 
\heuristics(elimQuantifier)
Choices: true}
-----------------------------------------------------
== exact_instance_definition_boolean (exact_instance_definition_boolean) =========================================
exact_instance_definition_boolean {
\find(equals(boolean::exactInstance(bool),TRUE))
\varcond(\notFreeIn(bv (variable), bool (boolean term)))
\replacewith(exists{bv (variable)}(equals(bool,bv))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== exact_instance_definition_int (exact_instance_definition_int) =========================================
exact_instance_definition_int {
\find(equals(int::exactInstance(idx0),TRUE))
\varcond(\notFreeIn(iv (variable), idx0 (int term)))
\replacewith(exists{iv (variable)}(equals(idx0,iv))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== exact_instance_definition_null (exact_instance_definition_null) =========================================
exact_instance_definition_null {
\find(equals(Null::exactInstance(obj),TRUE))
\varcond(\notFreeIn(bv (variable), bool (boolean term)))
\replacewith(equals(obj,null)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== exact_instance_for_interfaces_or_abstract_classes (interfaces or abstract classes have no exact instances) =========================================
exact_instance_for_interfaces_or_abstract_classes {
\find(G::exactInstance(obj))
\varcond(\isAbstractOrInterface (G), )
\replacewith(FALSE) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== exact_instance_known_dynamic_type (exact_instance_known_dynamic_type) =========================================
exact_instance_known_dynamic_type {
\assumes ([equals(G::exactInstance(a),TRUE)]==>[]) 
\find(H::exactInstance(a))
\sameUpdateLevel\varcond(\not\same(G, H), )
\replacewith(FALSE) 
\heuristics(evaluate_instanceof, simplify)
Choices: true}
-----------------------------------------------------
== execBreak (execBreak) =========================================
execBreak {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Break) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakEliminateBreakLabel (execEliminateNonMatching) =========================================
execBreakEliminateBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Break #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakEliminateBreakLabelWildcard (execEliminateNonMatching) =========================================
execBreakEliminateBreakLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Break *) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakEliminateContinue (execEliminateNonMatching) =========================================
execBreakEliminateContinue {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakEliminateContinueLabel (execEliminateNonMatching) =========================================
execBreakEliminateContinueLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Continue #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakEliminateContinueLabelWildcard (execEliminateNonMatching) =========================================
execBreakEliminateContinueLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakEliminateExcCcatch (execEliminateNonMatching) =========================================
execBreakEliminateExcCcatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (#t #v0) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakEliminateReturn (execEliminateNonMatching) =========================================
execBreakEliminateReturn {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Return) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakEliminateReturnVal (execEliminateNonMatching) =========================================
execBreakEliminateReturnVal {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Return #t #v) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelEliminateBreak (execEliminateNonMatching) =========================================
execBreakLabelEliminateBreak {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Break) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelEliminateBreakLabelNoMatch (execEliminateNonMatching) =========================================
execBreakLabelEliminateBreakLabelNoMatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Break #lb1) {
    #slist1
  }#cs
... }\] (post))
\varcond(\different (#lb (program Label), #lb1 (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelEliminateContinue (execEliminateNonMatching) =========================================
execBreakLabelEliminateContinue {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelEliminateContinueLabel (execEliminateNonMatching) =========================================
execBreakLabelEliminateContinueLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Continue #lb1) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelEliminateContinueLabelWildcard (execEliminateNonMatching) =========================================
execBreakLabelEliminateContinueLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelEliminateExcCcatch (execEliminateNonMatching) =========================================
execBreakLabelEliminateExcCcatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (#t #v) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelEliminateReturn (execEliminateNonMatching) =========================================
execBreakLabelEliminateReturn {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Return) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelEliminateReturnVal (execEliminateNonMatching) =========================================
execBreakLabelEliminateReturnVal {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Return #t #v) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelMatch (execBreakLabel) =========================================
execBreakLabelMatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Break #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execBreakLabelWildcard (execBreakLabel) =========================================
execBreakLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    break;
    #slist
  } ccatch (\Break *) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execCatchThrow (execCatchThrow) =========================================
execCatchThrow {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (#t #v0) {
    #slist1
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (#se == null) {
    exec {
      throw new java.lang.NullPointerException();
    } ccatch (#t #v0) {
      #slist1
    }
  } else if (#se instanceof #t) {
    #t #v0;
    #v0 = (#t) #se;
    #slist1
  } else {
    throw #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinue (execContinue) =========================================
execContinue {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueEliminateBreak (execEliminateNonMatching) =========================================
execContinueEliminateBreak {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Break) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueEliminateBreakLabel (execEliminateNonMatching) =========================================
execContinueEliminateBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Break #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueEliminateBreakLabelWildcard (execEliminateNonMatching) =========================================
execContinueEliminateBreakLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Break *) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueEliminateExcCcatch (execEliminateNonMatching) =========================================
execContinueEliminateExcCcatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (#t #v0) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    continue;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueEliminateReturn (execEliminateNonMatching) =========================================
execContinueEliminateReturn {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Return) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueEliminateReturnVal (execEliminateNonMatching) =========================================
execContinueEliminateReturnVal {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Return #t #v) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelEliminateBreak (execEliminateNonMatching) =========================================
execContinueLabelEliminateBreak {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Break) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelEliminateBreakLabel (execEliminateNonMatching) =========================================
execContinueLabelEliminateBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Break #lb1) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelEliminateBreakLabelWildcard (execEliminateNonMatching) =========================================
execContinueLabelEliminateBreakLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Break *) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelEliminateContinue (execEliminateNonMatching) =========================================
execContinueLabelEliminateContinue {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelEliminateContinueLabelNoMatch (execEliminateNonMatching) =========================================
execContinueLabelEliminateContinueLabelNoMatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Continue #lb1) {
    #slist1
  }#cs
... }\] (post))
\varcond(\different (#lb (program Label), #lb1 (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelEliminateExcCcatch (execEliminateNonMatching) =========================================
execContinueLabelEliminateExcCcatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (#t #v) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    continue;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelEliminateReturn (execEliminateNonMatching) =========================================
execContinueLabelEliminateReturn {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Return) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelEliminateReturnVal (execEliminateNonMatching) =========================================
execContinueLabelEliminateReturnVal {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Return #t #v) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelMatch (execBreakLabel) =========================================
execContinueLabelMatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Continue #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execContinueLabelWildcard (execContinueLabel) =========================================
execContinueLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    continue;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execEmpty (execEmpty) =========================================
execEmpty {
\find(#allmodal ( (modal operator))\[{ ..
  exec {}#cs
... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execMultipleCatchThrow (execCatchThrow) =========================================
execMultipleCatchThrow {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (#t #v0) {
    #slist1
  } ccatch (#t2 #v1) {
    #slist3
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (#se == null) {
    exec {
      throw new java.lang.NullPointerException();
    } ccatch (#t #v0) {
      #slist1
    } ccatch (#t2 #v1) {
      #slist3
    }#cs
  } else if (#se instanceof #t) {
    #t #v0;
    #v0 = (#t) #se;
    #slist1
  } else {
    exec {
      throw #se;
    } ccatch (#t2 #v1) {
      #slist3
    }#cs
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execNoCcatch (execNoCcatch) =========================================
execNoCcatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturn (execReturn) =========================================
execReturn {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (\Return) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnEliminateBreak (execEliminateNonMatching) =========================================
execReturnEliminateBreak {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (\Break) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnEliminateBreakLabel (execEliminateNonMatching) =========================================
execReturnEliminateBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (\Break #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnEliminateBreakLabelWildcard (execEliminateNonMatching) =========================================
execReturnEliminateBreakLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (\Break *) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnEliminateContinue (execEliminateNonMatching) =========================================
execReturnEliminateContinue {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnEliminateContinueLabel (execEliminateNonMatching) =========================================
execReturnEliminateContinueLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (\Continue #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnEliminateContinueLabelWildcard (execEliminateNonMatching) =========================================
execReturnEliminateContinueLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnEliminateExcCcatch (execEliminateNonMatching) =========================================
execReturnEliminateExcCcatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (#t #v0) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnEliminateReturnVal (execEliminateNonMatching) =========================================
execReturnEliminateReturnVal {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return;
    #slist
  } ccatch (\Return #t #v) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnVal (execReturn) =========================================
execReturnVal {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Return #t #v) {
    #slist1
  }#cs
... }\] (post))
\varcond(\sub(\typeof(#se (program SimpleExpression)), \typeof(#v (program Variable))), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #t #v;
    #v = (#t) #se;
    #slist1
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValEliminateBreak (execEliminateNonMatching) =========================================
execReturnValEliminateBreak {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Break) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValEliminateBreakLabel (execEliminateNonMatching) =========================================
execReturnValEliminateBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Break #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValEliminateBreakLabelWildcard (execEliminateNonMatching) =========================================
execReturnValEliminateBreakLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Break *) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValEliminateContinue (execEliminateNonMatching) =========================================
execReturnValEliminateContinue {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValEliminateContinueLabel (execEliminateNonMatching) =========================================
execReturnValEliminateContinueLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Continue #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValEliminateContinueLabelWildcard (execEliminateNonMatching) =========================================
execReturnValEliminateContinueLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValEliminateExcCcatch (execEliminateNonMatching) =========================================
execReturnValEliminateExcCcatch {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (#t #v0) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    return #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValEliminateReturn (execEliminateNonMatching) =========================================
execReturnValEliminateReturn {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Return) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execReturnValNonMatchingType (execEliminateNonMatching) =========================================
execReturnValNonMatchingType {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  } ccatch (\Return #t #v) {
    #slist1
  }#cs
... }\] (post))
\varcond(\not\sub(\typeof(#se (program SimpleExpression)), \typeof(#v (program Variable))), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    return #se;
    #slist
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execThrowEliminateBreak (execEliminateNonMatching) =========================================
execThrowEliminateBreak {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (\Break) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execThrowEliminateBreakLabel (execEliminateNonMatching) =========================================
execThrowEliminateBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (\Break #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execThrowEliminateBreakLabelWildcard (execEliminateNonMatching) =========================================
execThrowEliminateBreakLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (\Break *) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execThrowEliminateContinue (execEliminateNonMatching) =========================================
execThrowEliminateContinue {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execThrowEliminateContinueLabel (execEliminateNonMatching) =========================================
execThrowEliminateContinueLabel {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (\Continue #lb) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execThrowEliminateContinueLabelWildcard (execEliminateNonMatching) =========================================
execThrowEliminateContinueLabelWildcard {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (\Continue) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execThrowEliminateReturn (execEliminateNonMatching) =========================================
execThrowEliminateReturn {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (\Return) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== execThrowEliminateReturnVal (execEliminateNonMatching) =========================================
execThrowEliminateReturnVal {
\find(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
    #slist
  } ccatch (\Return #t #v) {
    #slist1
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  exec {
    throw #se;
  }#cs
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== expIsInfinite (expIsInfinite) =========================================
expIsInfinite {
\find(expDouble(arg))
\add [imp(and(doubleIsInfinite(arg),gtDouble(arg,DFP(0(#)))),and(doubleIsInfinite(expDouble(arg)),gtDouble(expDouble(arg),DFP(0(#)))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== expIsNaN (expIsNaN) =========================================
expIsNaN {
\find(expDouble(arg))
\add [imp(doubleIsNaN(arg),doubleIsNaN(expDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== expIsZero (expIsZero) =========================================
expIsZero {
\find(expDouble(arg))
\add [imp(and(doubleIsInfinite(arg),ltDouble(arg,DFP(0(#)))),equals(expDouble(arg),DFP(0(#))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== expandInRangeByte (expandInRangeByte) =========================================
expandInRangeByte {
\find(inRangeByte(i))
\replacewith(and(leq(i,byte_MAX),leq(byte_MIN,i))) 
\heuristics(delayedExpansion, defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== expandInRangeChar (expandInRangeChar) =========================================
expandInRangeChar {
\find(inRangeChar(i))
\replacewith(and(leq(i,char_MAX),leq(char_MIN,i))) 
\heuristics(delayedExpansion, defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== expandInRangeInt (expandInRangeInt) =========================================
expandInRangeInt {
\find(inRangeInt(i))
\replacewith(and(leq(i,int_MAX),leq(int_MIN,i))) 
\heuristics(delayedExpansion, defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== expandInRangeLong (expandInRangeLong) =========================================
expandInRangeLong {
\find(inRangeLong(i))
\replacewith(and(leq(i,long_MAX),leq(long_MIN,i))) 
\heuristics(delayedExpansion, defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== expandInRangeShort (expandInRangeShort) =========================================
expandInRangeShort {
\find(inRangeShort(i))
\replacewith(and(leq(i,short_MAX),leq(short_MIN,i))) 
\heuristics(delayedExpansion, defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== expand_addJint (expand_addJint) =========================================
expand_addJint {
\find(addJint(i,i1))
\replacewith(moduloInt(add(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_addJlong (expand_addJlong) =========================================
expand_addJlong {
\find(addJlong(i,i1))
\replacewith(moduloLong(add(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_divJint (expand_divJint) =========================================
expand_divJint {
\find(divJint(i,i1))
\replacewith(moduloInt(jdiv(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_divJlong (expand_divJlong) =========================================
expand_divJlong {
\find(divJlong(i,i1))
\replacewith(moduloLong(jdiv(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expandInByte (expandInByte) =========================================
expandInByte {
\find(inByte(i))
\replacewith(true) 
\heuristics(concrete)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== expandInChar (expandInChar) =========================================
expandInChar {
\find(inChar(i))
\replacewith(true) 
\heuristics(concrete)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== expandInInt (expandInInt) =========================================
expandInInt {
\find(inInt(i))
\replacewith(true) 
\heuristics(concrete)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== expandInLong (expandInLong) =========================================
expandInLong {
\find(inLong(i))
\replacewith(true) 
\heuristics(concrete)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== expandInShort (expandInShort) =========================================
expandInShort {
\find(inShort(i))
\replacewith(true) 
\heuristics(concrete)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== expand_modJint (expand_modJint) =========================================
expand_modJint {
\find(modJint(i,i1))
\replacewith(moduloInt(jmod(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_modJlong (expand_modJlong) =========================================
expand_modJlong {
\find(modJlong(i,i1))
\replacewith(moduloLong(jmod(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_moduloByte (expand_moduloByte) =========================================
expand_moduloByte {
\find(moduloByte(i))
\replacewith(add(byte_MIN,mod(add(byte_HALFRANGE,i),byte_RANGE))) 
\heuristics(delayedExpansion, defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_moduloChar (expand_moduloChar) =========================================
expand_moduloChar {
\find(moduloChar(i))
\replacewith(mod(i,add(char_MAX,Z(1(#))))) 
\heuristics(delayedExpansion, defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_moduloInteger (expand_moduloInteger) =========================================
expand_moduloInteger {
\find(moduloInt(i))
\replacewith(add(int_MIN,mod(add(int_HALFRANGE,i),int_RANGE))) 
\heuristics(delayedExpansion, defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_moduloLong (expand_moduloLong) =========================================
expand_moduloLong {
\find(moduloLong(i))
\replacewith(add(long_MIN,mod(add(long_HALFRANGE,i),long_RANGE))) 
\heuristics(delayedExpansion, defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_moduloShort (expand_moduloShort) =========================================
expand_moduloShort {
\find(moduloShort(i))
\replacewith(add(short_MIN,mod(add(short_HALFRANGE,i),short_RANGE))) 
\heuristics(delayedExpansion, defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_mulJint (expand_mulJint) =========================================
expand_mulJint {
\find(mulJint(i,i1))
\replacewith(moduloInt(mul(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_mulJlong (expand_mulJlong) =========================================
expand_mulJlong {
\find(mulJlong(i,i1))
\replacewith(moduloLong(mul(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_subJint (expand_subJint) =========================================
expand_subJint {
\find(subJint(i,i1))
\replacewith(moduloInt(sub(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_subJlong (expand_subJlong) =========================================
expand_subJlong {
\find(subJlong(i,i1))
\replacewith(moduloLong(sub(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_unaryMinusJint (expand_unaryMinusJint) =========================================
expand_unaryMinusJint {
\find(unaryMinusJint(i))
\replacewith(moduloInt(neg(i))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== expand_unaryMinusJlong (expand_unaryMinusJlong) =========================================
expand_unaryMinusJlong {
\find(unaryMinusJlong(i))
\replacewith(moduloLong(neg(i))) 
\heuristics(defOps_expandJNumericOp)
Choices: true}
-----------------------------------------------------
== false_right (false_right) =========================================
false_right {
\find(==>false)
\replacewith([]==>[]) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== false_to_not_true (false_to_not_true) =========================================
false_to_not_true {
\find(equals(bo,FALSE))
\replacewith(not(equals(bo,TRUE))) 
\heuristics(concrete, simplify_boolean)
Choices: true}
-----------------------------------------------------
== finishJavaCardTransactionBox (finishJavaCardTransaction) =========================================
finishJavaCardTransactionBox {
\find(==>box_transaction\[{ ..
  #finishJavaCardTransaction;
... }\] (post))
\replacewith([]==>[box(post)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== finishJavaCardTransactionDiamond (finishJavaCardTransaction) =========================================
finishJavaCardTransactionDiamond {
\find(==>diamond_transaction\[{ ..
  #finishJavaCardTransaction;
... }\] (post))
\replacewith([]==>[diamond(post)]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== firstOfPair (firstOfPair) =========================================
firstOfPair {
\find(first(pair(t,t1)))
\replacewith(t) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== forInitUnfold (forInitUnfold) =========================================
forInitUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  for (#loopInit; #guard; #forupdates) #s
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    forInitUnfoldTransformer(#loopInit)
    for (; #guard; #forupdates) #s
  }
... }\] (post)) 
\heuristics(loop_expand)
Choices: programRules:Java}
-----------------------------------------------------
== for_to_while (for_to_while) =========================================
for_to_while {
\find(#allmodal ( (modal operator))\[{ ..
  #forloop
... }\] (post))
\varcond(\newLabel (#innerLabel (program Label)), \newLabel (#outerLabel (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #for-to-while(#forloop)
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== geq_add (geq_add) =========================================
geq_add {
\find(==>geq(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==>[exists{j2 (variable)}(geq(add(i0,j2),add(i1,j2)))]) 

Choices: true}
-----------------------------------------------------
== geq_add_one (geq_add_one) =========================================
geq_add_one {
\find(geq(i0,i1))
\replacewith(geq(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: true}
-----------------------------------------------------
== geq_diff_1 (geq_diff_1) =========================================
geq_diff_1 {
\find(geq(add(i0,Z(1(#))),i0))
\replacewith(true) 
\heuristics(int_arithmetic)
Choices: true}
-----------------------------------------------------
== geq_to_leq (geq_to_leq) =========================================
geq_to_leq {
\find(geq(i,i0))
\replacewith(leq(i0,i)) 

Choices: true}
-----------------------------------------------------
== geq_to_lt (geq_to_lt) =========================================
geq_to_lt {
\find(geq(i,j))
\replacewith(not(lt(i,j))) 

Choices: true}
-----------------------------------------------------
== geq_to_lt_alt (geq_to_lt_alt) =========================================
geq_to_lt_alt {
\find(geq(i,j))
\replacewith(or(gt(i,j),equals(i,j))) 

Choices: true}
-----------------------------------------------------
== getAnyOfArray2seq (getAnyOfArray2seq) =========================================
getAnyOfArray2seq {
\find(any::seqGet(array2seq(h,a),idx))
\add []==>[and(leq(Z(0(#)),idx),lt(idx,length(a)))] ;
\replacewith(any::select(h,a,arr(idx))) 

Choices: sequences:on}
-----------------------------------------------------
== getJavaCardTransient (getJavaCardTransient) =========================================
getJavaCardTransient {
\find(==>#allmodal ( (modal operator))\[{ ..
  #lhs
  =
  #jcsystemType.#getTransient(#se)@#jcsystemType;
... }\] (post))
\replacewith([]==>[not(equals(#se,null))]) ;
\replacewith([]==>[update-application(elem-update(#lhs (program LeftHandSide))(int::select(heap,#se,java.lang.Object::<transient>)),#allmodal(post))]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== getOfArray2seq (getOfArray2seq) =========================================
getOfArray2seq {
\find(alpha::seqGet(array2seq(h,a),idx))
\add []==>[and(leq(Z(0(#)),idx),lt(idx,length(a)))] ;
\replacewith(alpha::select(h,a,arr(idx))) 

Choices: sequences:on}
-----------------------------------------------------
== getOfMapEmpty (getOfMapEmpty) =========================================
getOfMapEmpty {
\find(mapGet(mapEmpty,x))
\sameUpdateLevel\replacewith(mapUndef) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== getOfMapForeach (getOfMapForeach) =========================================
getOfMapForeach {
\find(mapGet(mapForeach{v (variable)}(b,y),x))
\sameUpdateLevel\replacewith(if-then-else(inDomain(mapForeach{v (variable)}(b,y),x),subst{v (variable)}(alpha::cast(x),y),mapUndef)) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== getOfMapOverride (getOfMapOverride) =========================================
getOfMapOverride {
\find(mapGet(mapOverride(m0,m1),x))
\sameUpdateLevel\replacewith(if-then-else(inDomain(m1,x),mapGet(m1,x),mapGet(m0,x))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== getOfMapRemove (getOfMapRemove) =========================================
getOfMapRemove {
\find(mapGet(mapRemove(m,key),x))
\sameUpdateLevel\replacewith(if-then-else(equals(x,key),mapUndef,mapGet(m,x))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== getOfMapSingleton (getOfMapSingleton) =========================================
getOfMapSingleton {
\find(mapGet(mapSingleton(x,y),z))
\sameUpdateLevel\replacewith(if-then-else(equals(x,z),y,mapUndef)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== getOfMapUpdate (getOfMapUpdate) =========================================
getOfMapUpdate {
\find(mapGet(mapUpdate(m,key,value),x))
\sameUpdateLevel\replacewith(if-then-else(equals(x,key),value,mapGet(m,x))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== getOfSeq2Map (getOfSeq2Map) =========================================
getOfSeq2Map {
\find(mapGet(seq2map(s),x))
\sameUpdateLevel\replacewith(if-then-else(and(and(equals(int::instance(x),TRUE),leq(Z(0(#)),int::cast(x))),lt(int::cast(x),seqLen(s))),any::seqGet(s,int::cast(x)),mapUndef)) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== getOfSeqConcat (getOfSeqConcat) =========================================
getOfSeqConcat {
\find(alpha::seqGet(seqConcat(seq,seq2),idx))
\replacewith(if-then-else(lt(idx,seqLen(seq)),alpha::seqGet(seq,idx),alpha::seqGet(seq2,sub(idx,seqLen(seq))))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqConcatEQ (getOfSeqConcat) =========================================
getOfSeqConcatEQ {
\assumes ([equals(seqConcat(seq,seq2),EQ)]==>[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\replacewith(if-then-else(lt(idx,seqLen(seq)),alpha::seqGet(seq,idx),alpha::seqGet(seq2,sub(idx,seqLen(seq))))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqDef (getOfSeqDef) =========================================
getOfSeqDef {
\find(alpha::seqGet(seqDef{uSub (variable)}(from,to,t),idx))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(if-then-else(and(leq(Z(0(#)),idx),lt(idx,sub(to,from))),alpha::cast(subst{uSub (variable)}(add(idx,from),t)),alpha::cast(seqGetOutside))) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqDefEQ (getOfSeqDef) =========================================
getOfSeqDefEQ {
\assumes ([equals(seqDef{uSub (variable)}(from,to,t),EQ)]==>[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(if-then-else(and(leq(Z(0(#)),idx),lt(idx,sub(to,from))),alpha::cast(subst{uSub (variable)}(add(idx,from),t)),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqReverse (getOfSeqReverse) =========================================
getOfSeqReverse {
\find(alpha::seqGet(seqReverse(seq),idx))
\replacewith(alpha::seqGet(seq,sub(sub(seqLen(seq),Z(1(#))),idx))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqReverseEQ (getOfSeqReverse) =========================================
getOfSeqReverseEQ {
\assumes ([equals(seqReverse(seq),EQ)]==>[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\replacewith(alpha::seqGet(seq,sub(sub(seqLen(seq),Z(1(#))),idx))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqSingleton (getOfSeqSingleton) =========================================
getOfSeqSingleton {
\find(alpha::seqGet(seqSingleton(x),idx))
\replacewith(if-then-else(equals(idx,Z(0(#))),alpha::cast(x),alpha::cast(seqGetOutside))) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqSingletonConcrete (getOfSeqSingletonConcrete) =========================================
getOfSeqSingletonConcrete {
\find(alpha::seqGet(seqSingleton(x),Z(0(#))))
\replacewith(alpha::cast(x)) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqSingletonEQ (getOfSeqSingleton) =========================================
getOfSeqSingletonEQ {
\assumes ([equals(seqSingleton(x),EQ)]==>[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\replacewith(if-then-else(equals(idx,Z(0(#))),alpha::cast(x),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqSub (getOfSeqSub) =========================================
getOfSeqSub {
\find(alpha::seqGet(seqSub(seq,from,to),idx))
\replacewith(if-then-else(and(leq(Z(0(#)),idx),lt(idx,sub(to,from))),alpha::seqGet(seq,add(idx,from)),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== getOfSeqSubEQ (getOfSeqSub) =========================================
getOfSeqSubEQ {
\assumes ([equals(seqSub(seq,from,to),EQ)]==>[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\replacewith(if-then-else(and(leq(Z(0(#)),idx),lt(idx,sub(to,from))),alpha::seqGet(seq,add(idx,from)),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: sequences:on}
-----------------------------------------------------
== greater (greater) =========================================
greater {
\find(gt(i,i0))
\replacewith(lt(i0,i)) 

Choices: true}
-----------------------------------------------------
== greater_add (greater_add) =========================================
greater_add {
\find(==>gt(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==>[exists{j2 (variable)}(gt(add(i0,j2),add(i1,j2)))]) 

Choices: true}
-----------------------------------------------------
== greater_add_one (greater_add_one) =========================================
greater_add_one {
\find(gt(i0,i1))
\replacewith(gt(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: true}
-----------------------------------------------------
== greater_equal_than_comparison_new (greater-or-equal than distinction) =========================================
greater_equal_than_comparison_new {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 >= #senf1;
... }\] (post))
\replacewith(if-then-else(geq(#senf0,#senf1),#allmodal ( (modal operator))\[{ ..
  #lhs = true;
... }\] (post),#allmodal ( (modal operator))\[{ ..
  #lhs = false;
... }\] (post))) 
\heuristics(split_if, simplify_prog, obsolete)
Choices: programRules:Java}
-----------------------------------------------------
== greater_equal_than_comparison_simple (greater-or-equal than distinction) =========================================
greater_equal_than_comparison_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 >= #senf1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(geq(#senf0,#senf1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== greater_equal_than_comparison_simple_double (greater-or-equal than distinction) =========================================
greater_equal_than_comparison_simple_double {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seDouble0 >= #seDouble1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(geqDouble(#seDouble0,#seDouble1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== greater_equal_than_comparison_simple_float (greater-or-equal than distinction) =========================================
greater_equal_than_comparison_simple_float {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seFloat0 >= #seFloat1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(geqFloat(#seFloat0,#seFloat1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== greater_literals (greater_literals) =========================================
greater_literals {
\find(gt(Z(iz),Z(jz)))
\replacewith(#greater(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== greater_than_comparison_new (greater than distinction) =========================================
greater_than_comparison_new {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 > #senf1;
... }\] (post))
\replacewith(if-then-else(gt(#senf0,#senf1),#allmodal ( (modal operator))\[{ ..
  #lhs = true;
... }\] (post),#allmodal ( (modal operator))\[{ ..
  #lhs = false;
... }\] (post))) 
\heuristics(split_if, simplify_prog, obsolete)
Choices: programRules:Java}
-----------------------------------------------------
== greater_than_comparison_simple (greater than distinction) =========================================
greater_than_comparison_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 > #senf1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(gt(#senf0,#senf1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== greater_than_comparison_simple_double (greater than distinction) =========================================
greater_than_comparison_simple_double {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seDouble0 > #seDouble1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(gtDouble(#seDouble0,#seDouble1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== greater_than_comparison_simple_float (greater than distinction) =========================================
greater_than_comparison_simple_float {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seFloat0 > #seFloat1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(gtFloat(#seFloat0,#seFloat1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== gt_diff_1 (gt_diff_1) =========================================
gt_diff_1 {
\find(gt(add(i0,Z(1(#))),i0))
\replacewith(true) 
\heuristics(int_arithmetic)
Choices: true}
-----------------------------------------------------
== gt_to_lt (gt_to_lt) =========================================
gt_to_lt {
\find(gt(i,i0))
\replacewith(lt(i0,i)) 

Choices: true}
-----------------------------------------------------
== hashCodeBase (hashCodeBase) =========================================
hashCodeBase {
\find(clHashCode(seqEmpty))
\replacewith(Z(0(#))) 
\heuristics(simplify_literals)
Choices: Strings:on}
-----------------------------------------------------
== hideAuxiliaryEq (hideAuxiliaryEq) =========================================
hideAuxiliaryEq {
\find(equals(result,auxiliarySK)==>)
\addrules [replaceKnownAuxiliaryConstant {
\find(auxiliarySK)
\inSequentState\replacewith(result) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([]==>[]) 
\heuristics(hide_auxiliary_eq)
Choices: programRules:Java}
-----------------------------------------------------
== hideAuxiliaryEqConcrete (hideAuxiliaryEqConcrete) =========================================
hideAuxiliaryEqConcrete {
\find(equals(auxiliarySK,TRUE)==>)
\addrules [replaceKnownAuxiliaryConstant {
\find(auxiliarySK)
\inSequentState\replacewith(TRUE) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([]==>[]) 
\heuristics(hide_auxiliary_eq_const)
Choices: programRules:Java}
-----------------------------------------------------
== hideAuxiliaryEqConcrete2 (hideAuxiliaryEqConcrete2) =========================================
hideAuxiliaryEqConcrete2 {
\find(==>equals(auxiliarySK,TRUE))
\addrules [replaceKnownAuxiliaryConstant {
\find(auxiliarySK)
\inSequentState\replacewith(FALSE) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([]==>[]) 
\heuristics(hide_auxiliary_eq_const)
Choices: programRules:Java}
-----------------------------------------------------
== hide_left (hide_left) =========================================
hide_left {
\find(b==>)
\addrules [insert_hidden {
\add [b]==>[] 

Choices: true}] \replacewith([]==>[]) 

Choices: true}
-----------------------------------------------------
== hide_right (hide_right) =========================================
hide_right {
\find(==>b)
\addrules [insert_hidden {
\add []==>[b] 

Choices: true}] \replacewith([]==>[]) 

Choices: true}
-----------------------------------------------------
== i_minus_i_is_zero (i_minus_i_is_zero) =========================================
i_minus_i_is_zero {
\find(sub(i,i))
\replacewith(Z(0(#))) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== identityCastDouble (identity cast) =========================================
identityCastDouble {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (double) #seDouble;
... }\] (post))
\replacewith(#normalassign ( (modal operator))\[{ ..
  #loc = #seDouble;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== identityCastFloat (identity cast) =========================================
identityCastFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (float) #seFloat;
... }\] (post))
\replacewith(#normalassign ( (modal operator))\[{ ..
  #loc = #seFloat;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== if (ifElse) =========================================
if {
\find(#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
... }\] (post))
\replacewith(if-then-else(equals(#se,TRUE),#allmodal ( (modal operator))\[{ ..
  #s0
... }\] (post),#allmodal(post))) 

Choices: programRules:Java}
-----------------------------------------------------
== ifElse (ifElse) =========================================
ifElse {
\find(#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
  else #s1
... }\] (post))
\replacewith(if-then-else(equals(#se,TRUE),#allmodal ( (modal operator))\[{ ..
  #s0
... }\] (post),#allmodal ( (modal operator))\[{ ..
  #s1
... }\] (post))) 

Choices: programRules:Java}
-----------------------------------------------------
== ifElseFalse (ifElseFalse) =========================================
ifElseFalse {
\assumes ([equals(#se,FALSE)]==>[]) 
\find(==>#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
  else #s1
... }\] (post))
\replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #s1
... }\] (post)]) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== ifElseSkipElse (ifElseSkipElse) =========================================
ifElseSkipElse {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = true;
  if (#loc) #s0
  else #s1
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #loc = true;
  #s0
... }\] (post)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== ifElseSkipElseConditionInBlock (ifElseSkipElse) =========================================
ifElseSkipElseConditionInBlock {
\find(#allmodal ( (modal operator))\[{ ..
  {
    #loc = true;
  }
  if (#loc) #s0
  else #s1
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #loc = true;
  }
  #s0
... }\] (post)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== ifElseSkipThen (ifElseSkipThen) =========================================
ifElseSkipThen {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = false;
  if (#loc) #s0
  else #s1
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #loc = false;
  #s1
... }\] (post)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== ifElseSkipThenConditionInBlock (ifElseSkipThen) =========================================
ifElseSkipThenConditionInBlock {
\find(#allmodal ( (modal operator))\[{ ..
  {
    #loc = false;
  }
  if (#loc) #s0
  else #s1
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #loc = false;
  }
  #s1
... }\] (post)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== ifElseSplit (ifElseSplit) =========================================
ifElseSplit {
\find(==>#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
  else #s1
... }\] (post))
\add [equals(#se,FALSE)]==>[] \replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #s1
... }\] (post)]) ;
\add [equals(#se,TRUE)]==>[] \replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #s0
... }\] (post)]) 
\heuristics(split_if)
Choices: programRules:Java}
-----------------------------------------------------
== ifElseSplitLeft (ifElseSplitLeft) =========================================
ifElseSplitLeft {
\find(#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
  else #s1
... }\] (post)==>)
\add [equals(#se,FALSE)]==>[] \replacewith([#allmodal ( (modal operator))\[{ ..
  #s1
... }\] (post)]==>[]) ;
\add [equals(#se,TRUE)]==>[] \replacewith([#allmodal ( (modal operator))\[{ ..
  #s0
... }\] (post)]==>[]) 
\heuristics(split_if)
Choices: programRules:Java}
-----------------------------------------------------
== ifElseTrue (ifElseTrue) =========================================
ifElseTrue {
\assumes ([equals(#se,TRUE)]==>[]) 
\find(==>#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
  else #s1
... }\] (post))
\replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #s0
... }\] (post)]) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== ifElseUnfold (ifElseUnfold) =========================================
ifElseUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  if (#nse) #s0
  else #s1
... }\] (post))
\varcond(\new(#boolv (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #boolv;
  #boolv = #nse;
  if (#boolv) #s0
  else {
    #s1
  }
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== ifEnterThen (ifEnterThen) =========================================
ifEnterThen {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = true;
  if (#loc) #s0
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #loc = true;
  #s0
... }\] (post)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== ifEnterThenConditionInBlock (ifEnterThen) =========================================
ifEnterThenConditionInBlock {
\find(#allmodal ( (modal operator))\[{ ..
  {
    #loc = true;
  }
  if (#loc) #s0
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #loc = true;
  }
  #s0
... }\] (post)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== ifEqualsInteger (ifEqualsInteger) =========================================
ifEqualsInteger {
\find(equals(if-then-else(phi,x,y),Z(iz)))
\replacewith(or(and(phi,equals(x,Z(iz))),and(not(phi),equals(y,Z(iz))))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== ifEqualsNull (ifEqualsNull) =========================================
ifEqualsNull {
\find(equals(if-then-else(phi,x,y),null))
\replacewith(or(and(phi,equals(x,null)),and(not(phi),equals(y,null)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== ifEqualsTRUE (ifEqualsTRUE) =========================================
ifEqualsTRUE {
\find(equals(if-then-else(phi,x,y),TRUE))
\replacewith(or(and(phi,equals(x,TRUE)),and(not(phi),equals(y,TRUE)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_eq (ifExthenelse1_eq) =========================================
ifExthenelse1_eq {
\find(ifExThenElse{intVar (variable)}(equals(intVar,t),then,else))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(subst{intVar (variable)}(t,then)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_eq2 (ifExthenelse1_eq) =========================================
ifExthenelse1_eq2 {
\find(ifExThenElse{intVar (variable)}(equals(t,intVar),then,else))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(subst{intVar (variable)}(t,then)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_eq2_for (ifExthenelse1_eq) =========================================
ifExthenelse1_eq2_for {
\find(ifExThenElse{intVar (variable)}(equals(t,intVar),b,c))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(subst{intVar (variable)}(t,b)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_eq2_for_phi (ifExthenelse1_eq) =========================================
ifExthenelse1_eq2_for_phi {
\find(ifExThenElse{intVar (variable)}(and(phi,equals(t,intVar)),b,c))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(if-then-else(subst{intVar (variable)}(t,phi),subst{intVar (variable)}(t,b),c)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_eq2_phi (ifExthenelse1_eq) =========================================
ifExthenelse1_eq2_phi {
\find(ifExThenElse{intVar (variable)}(and(phi,equals(t,intVar)),then,else))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(if-then-else(subst{intVar (variable)}(t,phi),subst{intVar (variable)}(t,then),else)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_eq_for (ifExthenelse1_eq) =========================================
ifExthenelse1_eq_for {
\find(ifExThenElse{intVar (variable)}(equals(intVar,t),b,c))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(subst{intVar (variable)}(t,b)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_eq_for_phi (ifExthenelse1_eq) =========================================
ifExthenelse1_eq_for_phi {
\find(ifExThenElse{intVar (variable)}(and(phi,equals(intVar,t)),b,c))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(if-then-else(subst{intVar (variable)}(t,phi),subst{intVar (variable)}(t,b),c)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_eq_phi (ifExthenelse1_eq_phi) =========================================
ifExthenelse1_eq_phi {
\find(ifExThenElse{intVar (variable)}(and(phi,equals(intVar,t)),then,else))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(if-then-else(subst{intVar (variable)}(t,phi),subst{intVar (variable)}(t,then),else)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_false (ifExthenelse1_false) =========================================
ifExthenelse1_false {
\find(ifExThenElse{intVar (variable)}(false,then,else))
\replacewith(else) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_false_for (ifExthenelse1_false) =========================================
ifExthenelse1_false_for {
\find(ifExThenElse{intVar (variable)}(false,b,c))
\replacewith(c) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_min (ifExthenelse1_min) =========================================
ifExthenelse1_min {
\find(ifExThenElse{intVar (variable)}(phi,then,else))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), phi (formula)))
\replacewith(if-then-else(phi,subst{intVar (variable)}(Z(0(#)),then),else)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_min_for (ifExthenelse1_min) =========================================
ifExthenelse1_min_for {
\find(ifExThenElse{intVar (variable)}(phi,b,c))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), phi (formula)))
\replacewith(if-then-else(phi,subst{intVar (variable)}(Z(0(#)),b),c)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_solve (ifExthenelse1_solve) =========================================
ifExthenelse1_solve {
\find(ifExThenElse{intVar (variable)}(phi,then,else))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), intValue (int term)))
\add []==>[and(subst{intVar (variable)}(intValue,phi),all{intVar (variable)}(imp(phi,wellOrderLeqInt(intValue,intVar))))] \replacewith(ifExThenElse{intVar (variable)}(phi,then,else)) ;
\replacewith(subst{intVar (variable)}(intValue,then)) 

Choices: true}
-----------------------------------------------------
== ifExthenelse1_solve_for (ifExthenelse1_solve) =========================================
ifExthenelse1_solve_for {
\find(ifExThenElse{intVar (variable)}(phi,b,c))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), intValue (int term)))
\add []==>[and(subst{intVar (variable)}(intValue,phi),all{intVar (variable)}(imp(phi,wellOrderLeqInt(intValue,intVar))))] \replacewith(ifExThenElse{intVar (variable)}(phi,b,c)) ;
\replacewith(subst{intVar (variable)}(intValue,b)) 

Choices: true}
-----------------------------------------------------
== ifExthenelse1_split (ifExthenelse1_split) =========================================
ifExthenelse1_split {
\find(ifExThenElse{intVar (variable)}(phi,then,else))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), intSk (int skolem term)))
\add []==>[exists{intVar (variable)}(phi)] \replacewith(else) ;
\add [subst{intVar (variable)}(intSk,phi),all{intVar (variable)}(imp(phi,wellOrderLeqInt(intSk,intVar)))]==>[] \replacewith(subst{intVar (variable)}(intSk,then)) 
\heuristics(split_cond)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_split_for (ifExthenelse1_split) =========================================
ifExthenelse1_split_for {
\find(ifExThenElse{intVar (variable)}(phi,b,c))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), intSk (int skolem term)))
\add []==>[exists{intVar (variable)}(phi)] \replacewith(c) ;
\add [subst{intVar (variable)}(intSk,phi),all{intVar (variable)}(imp(phi,wellOrderLeqInt(intSk,intVar)))]==>[] \replacewith(subst{intVar (variable)}(intSk,b)) 
\heuristics(split_cond)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_unused_var (ifExthenelse1_unused_var) =========================================
ifExthenelse1_unused_var {
\find(ifExThenElse{intVar (variable)}(phi,then,else))
\varcond(\notFreeIn(intVar (variable), then (G2 term)))
\replacewith(if-then-else(exists{intVar (variable)}(phi),then,else)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== ifExthenelse1_unused_var_for (ifExthenelse1_unused_var) =========================================
ifExthenelse1_unused_var_for {
\find(ifExThenElse{intVar (variable)}(phi,b,c))
\varcond(\notFreeIn(intVar (variable), b (formula)))
\replacewith(if-then-else(exists{intVar (variable)}(phi),b,c)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== ifFalse (ifFalse) =========================================
ifFalse {
\assumes ([equals(#se,FALSE)]==>[]) 
\find(==>#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
... }\] (post))
\replacewith([]==>[#allmodal(post)]) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== ifSkipThen (ifSkipThen) =========================================
ifSkipThen {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = false;
  if (#loc) #s0
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #loc = false;
... }\] (post)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== ifSkipThenConditionInBlock (ifSkipThen) =========================================
ifSkipThenConditionInBlock {
\find(#allmodal ( (modal operator))\[{ ..
  {
    #loc = false;
  }
  if (#loc) #s0
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #loc = false;
  }
... }\] (post)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== ifSplit (ifElseSplit) =========================================
ifSplit {
\find(==>#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
... }\] (post))
\add [equals(#se,FALSE)]==>[] \replacewith([]==>[#allmodal(post)]) ;
\add [equals(#se,TRUE)]==>[] \replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #s0
... }\] (post)]) 
\heuristics(split_if)
Choices: programRules:Java}
-----------------------------------------------------
== ifSplitLeft (ifSplitLeft) =========================================
ifSplitLeft {
\find(#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
... }\] (post)==>)
\add [equals(#se,FALSE)]==>[] \replacewith([#allmodal(post)]==>[]) ;
\add [equals(#se,TRUE)]==>[] \replacewith([#allmodal ( (modal operator))\[{ ..
  #s0
... }\] (post)]==>[]) 
\heuristics(split_if)
Choices: programRules:Java}
-----------------------------------------------------
== ifTrue (ifTrue) =========================================
ifTrue {
\assumes ([equals(#se,TRUE)]==>[]) 
\find(==>#allmodal ( (modal operator))\[{ ..
  if (#se) #s0
... }\] (post))
\replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #s0
... }\] (post)]) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== ifUnfold (ifElseUnfold) =========================================
ifUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  if (#nse) #s0
... }\] (post))
\varcond(\new(#boolv (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #boolv;
  #boolv = #nse;
  if (#boolv) #s0
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== ifthenelse_concrete (ifthenelse_concrete) =========================================
ifthenelse_concrete {
\find(if-then-else(phi,true,false))
\replacewith(phi) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_concrete2 (ifthenelse_concrete) =========================================
ifthenelse_concrete2 {
\find(if-then-else(phi,false,true))
\replacewith(not(phi)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_concrete3 (ifthenelse_concrete) =========================================
ifthenelse_concrete3 {
\find(equals(if-then-else(phi,then,else),then))
\replacewith(or(phi,equals(else,then))) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_concrete4 (ifthenelse_concrete) =========================================
ifthenelse_concrete4 {
\find(equals(if-then-else(phi,then,else),else))
\replacewith(or(not(phi),equals(then,else))) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_equals (ifthenelse_equals) =========================================
ifthenelse_equals {
\find(equals(if-then-else(b,TRUE,FALSE),if-then-else(c,TRUE,FALSE)))
\replacewith(equiv(b,c)) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_equals_1 (ifthenelse_equals_1) =========================================
ifthenelse_equals_1 {
\find(equals(if-then-else(b,TRUE,FALSE),c))
\replacewith(equiv(b,equals(c,TRUE))) 

Choices: true}
-----------------------------------------------------
== ifthenelse_equals_2 (ifthenelse_equals_2) =========================================
ifthenelse_equals_2 {
\find(equals(b,if-then-else(c,TRUE,FALSE)))
\replacewith(equiv(equals(b,TRUE),c)) 

Choices: true}
-----------------------------------------------------
== ifthenelse_false (ifthenelse_false) =========================================
ifthenelse_false {
\find(if-then-else(false,then,else))
\replacewith(else) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_false_for (ifthenelse_false) =========================================
ifthenelse_false_for {
\find(if-then-else(false,b,c))
\replacewith(c) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_negated (ifthenelse_negated) =========================================
ifthenelse_negated {
\find(if-then-else(not(phi),then,else))
\replacewith(if-then-else(phi,else,then)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== ifthenelse_negated_for (ifthenelse_negated) =========================================
ifthenelse_negated_for {
\find(if-then-else(not(phi),b,c))
\replacewith(if-then-else(phi,c,b)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== ifthenelse_same_branches (ifthenelse_same_branches) =========================================
ifthenelse_same_branches {
\find(if-then-else(phi,then,then))
\replacewith(then) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_same_branches_for (ifthenelse_same_branches) =========================================
ifthenelse_same_branches_for {
\find(if-then-else(phi,b,b))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_split (ifthenelse_split) =========================================
ifthenelse_split {
\find(if-then-else(phi,then,else))
\sameUpdateLevel\add []==>[phi] \replacewith(else) ;
\add [phi]==>[] \replacewith(then) 
\heuristics(split_cond)
Choices: true}
-----------------------------------------------------
== ifthenelse_split_for (ifthenelse_split) =========================================
ifthenelse_split_for {
\find(if-then-else(phi,b,c))
\sameUpdateLevel\add []==>[phi] \replacewith(c) ;
\add [phi]==>[] \replacewith(b) 
\heuristics(split_cond)
Choices: true}
-----------------------------------------------------
== ifthenelse_to_or_for (ifthenelse_to_or_for) =========================================
ifthenelse_to_or_for {
\find(if-then-else(phi,b,c))
\replacewith(and(or(not(phi),b),or(phi,c))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: true}
-----------------------------------------------------
== ifthenelse_to_or_for2 (ifthenelse_to_or_for2) =========================================
ifthenelse_to_or_for2 {
\find(not(if-then-else(phi,b,c)))
\replacewith(and(or(not(phi),not(b)),or(phi,not(c)))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: true}
-----------------------------------------------------
== ifthenelse_to_or_left (ifthenelse_to_or_left) =========================================
ifthenelse_to_or_left {
\find(equals(if-then-else(phi,then,else),t))
\replacewith(and(or(not(phi),equals(then,t)),or(phi,equals(else,t)))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: true}
-----------------------------------------------------
== ifthenelse_to_or_left2 (ifthenelse_to_or_left2) =========================================
ifthenelse_to_or_left2 {
\find(not(equals(if-then-else(phi,then,else),t)))
\replacewith(and(or(not(phi),not(equals(then,t))),or(phi,not(equals(else,t))))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: true}
-----------------------------------------------------
== ifthenelse_to_or_right (ifthenelse_to_or_right) =========================================
ifthenelse_to_or_right {
\find(equals(t,if-then-else(phi,then,else)))
\replacewith(and(or(not(phi),equals(t,then)),or(phi,equals(t,else)))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: true}
-----------------------------------------------------
== ifthenelse_to_or_right2 (ifthenelse_to_or_right2) =========================================
ifthenelse_to_or_right2 {
\find(not(equals(t,if-then-else(phi,then,else))))
\replacewith(and(or(not(phi),not(equals(t,then))),or(phi,not(equals(t,else))))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: true}
-----------------------------------------------------
== ifthenelse_true (ifthenelse_true) =========================================
ifthenelse_true {
\find(if-then-else(true,then,else))
\replacewith(then) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== ifthenelse_true_for (ifthenelse_true) =========================================
ifthenelse_true_for {
\find(if-then-else(true,b,c))
\replacewith(b) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== impLeft (impLeft) =========================================
impLeft {
\find(imp(b,c)==>)
\replacewith([c]==>[]) ;
\replacewith([]==>[b]) 
\heuristics(beta)
Choices: true}
-----------------------------------------------------
== impRight (impRight) =========================================
impRight {
\find(==>imp(b,c))
\replacewith([b]==>[c]) 
\heuristics(alpha)
Choices: true}
-----------------------------------------------------
== inDomainConcrete (inDomainConcrete) =========================================
inDomainConcrete {
\assumes ([]==>[equals(mapUndef,y)]) 
\find(equals(mapGet(m,x),y)==>)
\add [inDomain(m,x)]==>[] 
\heuristics(inReachableStateImplication)
Choices: true}
-----------------------------------------------------
== inDomainOfMapEmpty (inDomainOfMapEmpty) =========================================
inDomainOfMapEmpty {
\find(inDomain(mapEmpty,x))
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== inDomainOfMapForeach (inDomainOfMapForeach) =========================================
inDomainOfMapForeach {
\find(inDomain(mapForeach{v (variable)}(b,y),x))
\replacewith(and(equals(subst{v (variable)}(alpha::cast(x),b),TRUE),equals(alpha::instance(x),TRUE))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== inDomainOfMapOverride (inDomainOfMapOverride) =========================================
inDomainOfMapOverride {
\find(inDomain(mapOverride(m0,m1),x))
\replacewith(or(inDomain(m0,x),inDomain(m1,x))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== inDomainOfMapRemove (inDomainOfMapRemove) =========================================
inDomainOfMapRemove {
\find(inDomain(mapRemove(m,key),x))
\replacewith(and(inDomain(m,x),not(equals(x,key)))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== inDomainOfMapSingleton (inDomainOfMapSingleton) =========================================
inDomainOfMapSingleton {
\find(inDomain(mapSingleton(x,y),z))
\replacewith(equals(x,z)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== inDomainOfMapUpdate (inDomainOfMapUpdate) =========================================
inDomainOfMapUpdate {
\find(inDomain(mapUpdate(m,key,value),x))
\replacewith(or(inDomain(m,x),equals(x,key))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== inDomainOfSeq2Map (inDomainOfSeq2Map) =========================================
inDomainOfSeq2Map {
\find(inDomain(seq2map(s),x))
\replacewith(and(and(equals(int::instance(x),TRUE),leq(Z(0(#)),int::cast(x))),lt(int::cast(x),seqLen(s)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_antiSymm0 (inEqSimp_and_antiSymm0) =========================================
inEqSimp_and_antiSymm0 {
\find(and(leq(i,i0),geq(i,i0)))
\replacewith(equals(i,i0)) 
\heuristics(inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_antiSymm1 (inEqSimp_and_antiSymm1) =========================================
inEqSimp_and_antiSymm1 {
\find(and(and(b,leq(i,i0)),geq(i,i0)))
\replacewith(and(b,equals(i,i0))) 
\heuristics(inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_contradInEq0 (inEqSimp_and_contradInEq0) =========================================
inEqSimp_and_contradInEq0 {
\find(and(leq(contradLeft,contradRightSmaller),geq(contradLeft,contradRightBigger)))
\replacewith(and(and(leq(contradLeft,contradRightSmaller),geq(contradLeft,contradRightBigger)),geq(contradRightSmaller,contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_and_contradInEqs, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_contradInEq1 (inEqSimp_and_contradInEq1) =========================================
inEqSimp_and_contradInEq1 {
\find(and(and(b,leq(contradLeft,contradRightSmaller)),geq(contradLeft,contradRightBigger)))
\replacewith(and(and(and(b,leq(contradLeft,contradRightSmaller)),geq(contradLeft,contradRightBigger)),geq(contradRightSmaller,contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_and_contradInEqs, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_strengthen0 (inEqSimp_and_strengthen0) =========================================
inEqSimp_and_strengthen0 {
\find(and(leq(strengthenLeft,strengthenRight),not(equals(strengthenLeft,strengthenRight))))
\replacewith(leq(strengthenLeft,add(Z(neglit(1(#))),strengthenRight))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_strengthen1 (inEqSimp_and_strengthen1) =========================================
inEqSimp_and_strengthen1 {
\find(and(geq(strengthenLeft,strengthenRight),not(equals(strengthenLeft,strengthenRight))))
\replacewith(geq(strengthenLeft,add(Z(1(#)),strengthenRight))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_strengthen2 (inEqSimp_and_strengthen2) =========================================
inEqSimp_and_strengthen2 {
\find(and(and(b,leq(strengthenLeft,strengthenRight)),not(equals(strengthenLeft,strengthenRight))))
\replacewith(and(b,leq(strengthenLeft,add(Z(neglit(1(#))),strengthenRight)))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_strengthen3 (inEqSimp_and_strengthen3) =========================================
inEqSimp_and_strengthen3 {
\find(and(and(b,geq(strengthenLeft,strengthenRight)),not(equals(strengthenLeft,strengthenRight))))
\replacewith(and(b,geq(strengthenLeft,add(Z(1(#)),strengthenRight)))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_subsumption0 (inEqSimp_and_subsumption0) =========================================
inEqSimp_and_subsumption0 {
\find(and(leq(subsumLeft,subsumRightSmaller),leq(subsumLeft,subsumRightBigger)))
\replacewith(and(leq(subsumLeft,subsumRightSmaller),or(leq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_subsumption1 (inEqSimp_and_subsumption1) =========================================
inEqSimp_and_subsumption1 {
\find(and(and(b,leq(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger)))
\replacewith(and(and(b,leq(subsumLeft,subsumRightSmaller)),or(leq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_subsumption2 (inEqSimp_and_subsumption2) =========================================
inEqSimp_and_subsumption2 {
\find(and(geq(subsumLeft,subsumRightSmaller),geq(subsumLeft,subsumRightBigger)))
\replacewith(and(or(leq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightSmaller)),geq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_subsumption3 (inEqSimp_and_subsumption3) =========================================
inEqSimp_and_subsumption3 {
\find(and(and(b,geq(subsumLeft,subsumRightSmaller)),geq(subsumLeft,subsumRightBigger)))
\replacewith(and(and(b,or(leq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightSmaller))),geq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_subsumption4 (inEqSimp_and_subsumption4) =========================================
inEqSimp_and_subsumption4 {
\find(and(leq(subsumLeft,subsumRightSmaller),not(equals(subsumLeft,subsumRightBigger))))
\replacewith(and(leq(subsumLeft,subsumRightSmaller),or(lt(subsumRightSmaller,subsumRightBigger),not(equals(subsumLeft,subsumRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_and_subsumptionEq, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_subsumption5 (inEqSimp_and_subsumption5) =========================================
inEqSimp_and_subsumption5 {
\find(and(and(b,leq(subsumLeft,subsumRightSmaller)),not(equals(subsumLeft,subsumRightBigger))))
\replacewith(and(and(b,leq(subsumLeft,subsumRightSmaller)),or(lt(subsumRightSmaller,subsumRightBigger),not(equals(subsumLeft,subsumRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_and_subsumptionEq, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_subsumption6 (inEqSimp_and_subsumption6) =========================================
inEqSimp_and_subsumption6 {
\find(and(geq(subsumLeft,subsumRightBigger),not(equals(subsumLeft,subsumRightSmaller))))
\replacewith(and(geq(subsumLeft,subsumRightBigger),or(lt(subsumRightSmaller,subsumRightBigger),not(equals(subsumLeft,subsumRightSmaller))))) 
\heuristics(notHumanReadable, inEqSimp_and_subsumptionEq, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_and_subsumption7 (inEqSimp_and_subsumption7) =========================================
inEqSimp_and_subsumption7 {
\find(and(and(b,geq(subsumLeft,subsumRightBigger)),not(equals(subsumLeft,subsumRightSmaller))))
\replacewith(and(and(b,geq(subsumLeft,subsumRightBigger)),or(lt(subsumRightSmaller,subsumRightBigger),not(equals(subsumLeft,subsumRightSmaller))))) 
\heuristics(notHumanReadable, inEqSimp_and_subsumptionEq, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_antiSymm (inEqSimp_antiSymm) =========================================
inEqSimp_antiSymm {
\assumes ([leq(i,i0)]==>[]) 
\find(geq(i,i0)==>)
\add [equals(i,i0)]==>[] 
\heuristics(inEqSimp_antiSymm, inEqSimp_saturate)
Choices: true}
-----------------------------------------------------
== inEqSimp_commuteGeq (inEqSimp_commuteGeq) =========================================
inEqSimp_commuteGeq {
\find(geq(commLeft,commRight))
\replacewith(leq(commRight,commLeft)) 
\heuristics(inEqSimp_commute, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_commuteLeq (inEqSimp_commuteLeq) =========================================
inEqSimp_commuteLeq {
\find(leq(commLeft,commRight))
\replacewith(geq(commRight,commLeft)) 
\heuristics(inEqSimp_commute, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_contradEq3 (inEqSimp_contradEq3) =========================================
inEqSimp_contradEq3 {
\assumes ([leq(contradLeft,contradRightSmaller)]==>[]) 
\find(equals(contradLeft,contradRightBigger))
\sameUpdateLevel\replacewith(and(geq(add(contradRightSmaller,mul(Z(neglit(1(#))),contradRightBigger)),Z(0(#))),equals(contradLeft,contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_contradEqs, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_contradEq7 (inEqSimp_contradEq7) =========================================
inEqSimp_contradEq7 {
\assumes ([geq(contradLeft,contradRightBigger)]==>[]) 
\find(equals(contradLeft,contradRightSmaller))
\sameUpdateLevel\replacewith(and(leq(add(contradRightBigger,mul(Z(neglit(1(#))),contradRightSmaller)),Z(0(#))),equals(contradLeft,contradRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_contradEqs, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_contradInEq0 (inEqSimp_contradInEq0) =========================================
inEqSimp_contradInEq0 {
\assumes ([leq(contradLeft,contradRightSmaller)]==>[]) 
\find(geq(contradLeft,contradRightBigger))
\sameUpdateLevel\replacewith(and(geq(contradRightSmaller,contradRightBigger),geq(contradLeft,contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_contradInEq1 (inEqSimp_contradInEq1) =========================================
inEqSimp_contradInEq1 {
\assumes ([geq(contradLeft,contradRightBigger)]==>[]) 
\find(leq(contradLeft,contradRightSmaller))
\sameUpdateLevel\replacewith(and(geq(contradRightSmaller,contradRightBigger),leq(contradLeft,contradRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_contradInEq2 (inEqSimp_contradInEq2) =========================================
inEqSimp_contradInEq2 {
\assumes ([leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller)]==>[]) 
\find(geq(mul(contradLeft,contradCoeffBigger),contradRightBigger))
\sameUpdateLevel\replacewith(and(imp(gt(contradCoeffSmaller,Z(0(#))),imp(gt(contradCoeffBigger,Z(0(#))),geq(mul(contradCoeffBigger,contradRightSmaller),mul(contradCoeffSmaller,contradRightBigger)))),geq(mul(contradLeft,contradCoeffBigger),contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_contradInEq3 (inEqSimp_contradInEq3) =========================================
inEqSimp_contradInEq3 {
\assumes ([leq(contradLeft,contradRightSmaller)]==>[]) 
\find(geq(mul(contradLeft,contradCoeffBigger),contradRightBigger))
\sameUpdateLevel\replacewith(and(imp(gt(contradCoeffBigger,Z(0(#))),geq(mul(contradCoeffBigger,contradRightSmaller),contradRightBigger)),geq(mul(contradLeft,contradCoeffBigger),contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_contradInEq4 (inEqSimp_contradInEq4) =========================================
inEqSimp_contradInEq4 {
\assumes ([geq(mul(contradLeft,contradCoeffBigger),contradRightBigger)]==>[]) 
\find(leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller))
\sameUpdateLevel\replacewith(and(imp(gt(contradCoeffSmaller,Z(0(#))),imp(gt(contradCoeffBigger,Z(0(#))),geq(mul(contradCoeffBigger,contradRightSmaller),mul(contradCoeffSmaller,contradRightBigger)))),leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_contradInEq5 (inEqSimp_contradInEq5) =========================================
inEqSimp_contradInEq5 {
\assumes ([geq(contradLeft,contradRightBigger)]==>[]) 
\find(leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller))
\sameUpdateLevel\replacewith(and(imp(gt(contradCoeffSmaller,Z(0(#))),geq(contradRightSmaller,mul(contradCoeffSmaller,contradRightBigger))),leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_exactShadow0 (inEqSimp_exactShadow0) =========================================
inEqSimp_exactShadow0 {
\assumes ([leq(mul(esLeft,esCoeff1),esRight1)]==>[]) 
\find(geq(mul(esLeft,esCoeff2),esRight2)==>)
\add [imp(and(gt(esCoeff1,Z(0(#))),gt(esCoeff2,Z(0(#)))),geq(add(mul(Z(neglit(1(#))),mul(esCoeff1,esRight2)),mul(esCoeff2,esRight1)),Z(0(#))))]==>[] 
\heuristics(notHumanReadable, inEqSimp_exactShadow, inEqSimp_saturate)
Choices: true}
-----------------------------------------------------
== inEqSimp_exactShadow1 (inEqSimp_exactShadow1) =========================================
inEqSimp_exactShadow1 {
\assumes ([leq(esLeft,esRight1)]==>[]) 
\find(geq(mul(esLeft,esCoeff2),esRight2)==>)
\add [imp(gt(esCoeff2,Z(0(#))),geq(add(mul(Z(neglit(1(#))),esRight2),mul(esCoeff2,esRight1)),Z(0(#))))]==>[] 
\heuristics(notHumanReadable, inEqSimp_exactShadow, inEqSimp_saturate)
Choices: true}
-----------------------------------------------------
== inEqSimp_exactShadow2 (inEqSimp_exactShadow2) =========================================
inEqSimp_exactShadow2 {
\assumes ([leq(mul(esLeft,esCoeff1),esRight1)]==>[]) 
\find(geq(esLeft,esRight2)==>)
\add [imp(gt(esCoeff1,Z(0(#))),geq(add(mul(Z(neglit(1(#))),mul(esCoeff1,esRight2)),esRight1),Z(0(#))))]==>[] 
\heuristics(notHumanReadable, inEqSimp_exactShadow, inEqSimp_saturate)
Choices: true}
-----------------------------------------------------
== inEqSimp_exactShadow3 (inEqSimp_exactShadow3) =========================================
inEqSimp_exactShadow3 {
\assumes ([leq(esLeft,esRight1)]==>[]) 
\find(geq(esLeft,esRight2)==>)
\add [geq(add(mul(Z(neglit(1(#))),esRight2),esRight1),Z(0(#)))]==>[] 
\heuristics(notHumanReadable, inEqSimp_exactShadow, inEqSimp_saturate)
Choices: true}
-----------------------------------------------------
== inEqSimp_geqRight (inEqSimp_geqRight) =========================================
inEqSimp_geqRight {
\find(==>geq(i,i0))
\replacewith([leq(add(add(Z(1(#)),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))]==>[]) 
\heuristics(notHumanReadable, inEqSimp_moveLeft, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_gtRight (inEqSimp_gtRight) =========================================
inEqSimp_gtRight {
\find(==>gt(i,i0))
\replacewith([leq(add(mul(Z(neglit(1(#))),i0),i),Z(0(#)))]==>[]) 
\heuristics(notHumanReadable, inEqSimp_moveLeft, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_gtToGeq (inEqSimp_gtToGeq) =========================================
inEqSimp_gtToGeq {
\find(gt(i,i0))
\replacewith(geq(add(add(Z(neglit(1(#))),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_makeNonStrict, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_homoInEq0 (inEqSimp_homoInEq0) =========================================
inEqSimp_homoInEq0 {
\find(leq(homoLeft,homoRight))
\replacewith(geq(add(homoRight,mul(homoLeft,Z(neglit(1(#))))),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_homo, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_homoInEq1 (inEqSimp_homoInEq1) =========================================
inEqSimp_homoInEq1 {
\find(geq(homoLeft,homoRight))
\replacewith(leq(add(homoRight,mul(homoLeft,Z(neglit(1(#))))),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_homo, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_invertInEq0 (inEqSimp_invertInEq0) =========================================
inEqSimp_invertInEq0 {
\find(leq(invertLeft,invertRight))
\replacewith(geq(mul(invertLeft,Z(neglit(1(#)))),mul(invertRight,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, inEqSimp_normalise, inEqSimp_directInEquations)
Choices: true}
-----------------------------------------------------
== inEqSimp_invertInEq1 (inEqSimp_invertInEq1) =========================================
inEqSimp_invertInEq1 {
\find(geq(invertLeft,invertRight))
\replacewith(leq(mul(invertLeft,Z(neglit(1(#)))),mul(invertRight,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, inEqSimp_normalise, inEqSimp_directInEquations)
Choices: true}
-----------------------------------------------------
== inEqSimp_leqRight (inEqSimp_leqRight) =========================================
inEqSimp_leqRight {
\find(==>leq(i,i0))
\replacewith([geq(add(add(Z(neglit(1(#))),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))]==>[]) 
\heuristics(notHumanReadable, inEqSimp_moveLeft, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_ltRight (inEqSimp_ltRight) =========================================
inEqSimp_ltRight {
\find(==>lt(i,i0))
\replacewith([geq(add(mul(Z(neglit(1(#))),i0),i),Z(0(#)))]==>[]) 
\heuristics(notHumanReadable, inEqSimp_moveLeft, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_ltToLeq (inEqSimp_ltToLeq) =========================================
inEqSimp_ltToLeq {
\find(lt(i,i0))
\replacewith(leq(add(add(Z(1(#)),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_makeNonStrict, inEqSimp_expand)
Choices: true}
-----------------------------------------------------
== inEqSimp_notGeq (inEqSimp_notGeq) =========================================
inEqSimp_notGeq {
\find(not(geq(i,i0)))
\replacewith(leq(add(add(Z(1(#)),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_notLeq (inEqSimp_notLeq) =========================================
inEqSimp_notLeq {
\find(not(leq(i,i0)))
\replacewith(geq(add(add(Z(neglit(1(#))),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_antiSymm0 (inEqSimp_or_antiSymm0) =========================================
inEqSimp_or_antiSymm0 {
\find(or(leq(antiSymmLeft,antiSymmRightSmaller),geq(antiSymmLeft,antiSymmRightBigger)))
\replacewith(if-then-else(equals(add(Z(2(#)),antiSymmRightSmaller),antiSymmRightBigger),not(equals(antiSymmLeft,add(Z(1(#)),antiSymmRightSmaller))),or(leq(antiSymmLeft,antiSymmRightSmaller),geq(antiSymmLeft,antiSymmRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_or_antiSymm, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_antiSymm1 (inEqSimp_or_antiSymm1) =========================================
inEqSimp_or_antiSymm1 {
\find(or(or(b,leq(antiSymmLeft,antiSymmRightSmaller)),geq(antiSymmLeft,antiSymmRightBigger)))
\replacewith(or(b,if-then-else(equals(add(Z(2(#)),antiSymmRightSmaller),antiSymmRightBigger),not(equals(antiSymmLeft,add(Z(1(#)),antiSymmRightSmaller))),or(leq(antiSymmLeft,antiSymmRightSmaller),geq(antiSymmLeft,antiSymmRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_or_antiSymm, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_subsumption0 (inEqSimp_or_subsumption0) =========================================
inEqSimp_or_subsumption0 {
\find(or(leq(subsumLeft,subsumRightSmaller),leq(subsumLeft,subsumRightBigger)))
\replacewith(or(and(geq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_subsumption1 (inEqSimp_or_subsumption1) =========================================
inEqSimp_or_subsumption1 {
\find(or(or(b,leq(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger)))
\replacewith(or(or(b,and(geq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightSmaller))),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_subsumption2 (inEqSimp_or_subsumption2) =========================================
inEqSimp_or_subsumption2 {
\find(or(geq(subsumLeft,subsumRightSmaller),geq(subsumLeft,subsumRightBigger)))
\replacewith(or(geq(subsumLeft,subsumRightSmaller),and(geq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_subsumption3 (inEqSimp_or_subsumption3) =========================================
inEqSimp_or_subsumption3 {
\find(or(or(b,geq(subsumLeft,subsumRightSmaller)),geq(subsumLeft,subsumRightBigger)))
\replacewith(or(or(b,geq(subsumLeft,subsumRightSmaller)),and(geq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_subsumption4 (inEqSimp_or_subsumption4) =========================================
inEqSimp_or_subsumption4 {
\find(or(equals(subsumLeft,subsumRightSmaller),leq(subsumLeft,subsumRightBigger)))
\replacewith(or(and(gt(subsumRightSmaller,subsumRightBigger),equals(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_subsumption5 (inEqSimp_or_subsumption5) =========================================
inEqSimp_or_subsumption5 {
\find(or(or(b,equals(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger)))
\replacewith(or(or(b,and(gt(subsumRightSmaller,subsumRightBigger),equals(subsumLeft,subsumRightSmaller))),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_subsumption6 (inEqSimp_or_subsumption6) =========================================
inEqSimp_or_subsumption6 {
\find(or(geq(subsumLeft,subsumRightSmaller),equals(subsumLeft,subsumRightBigger)))
\replacewith(or(geq(subsumLeft,subsumRightSmaller),and(gt(subsumRightSmaller,subsumRightBigger),equals(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_subsumption7 (inEqSimp_or_subsumption7) =========================================
inEqSimp_or_subsumption7 {
\find(or(or(b,geq(subsumLeft,subsumRightSmaller)),equals(subsumLeft,subsumRightBigger)))
\replacewith(or(or(b,geq(subsumLeft,subsumRightSmaller)),and(gt(subsumRightSmaller,subsumRightBigger),equals(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_tautInEq0 (inEqSimp_or_tautInEq0) =========================================
inEqSimp_or_tautInEq0 {
\find(or(leq(tautLeft,tautRightBigger),geq(tautLeft,tautRightSmaller)))
\replacewith(or(or(leq(tautLeft,tautRightBigger),geq(tautLeft,tautRightSmaller)),geq(tautRightBigger,add(Z(neglit(1(#))),tautRightSmaller)))) 
\heuristics(notHumanReadable, inEqSimp_or_tautInEqs, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_tautInEq1 (inEqSimp_or_tautInEq1) =========================================
inEqSimp_or_tautInEq1 {
\find(or(or(b,leq(tautLeft,tautRightBigger)),geq(tautLeft,tautRightSmaller)))
\replacewith(or(or(or(b,leq(tautLeft,tautRightBigger)),geq(tautLeft,tautRightSmaller)),geq(tautRightBigger,add(Z(neglit(1(#))),tautRightSmaller)))) 
\heuristics(notHumanReadable, inEqSimp_or_tautInEqs, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_tautInEq2 (inEqSimp_or_tautInEq2) =========================================
inEqSimp_or_tautInEq2 {
\find(or(geq(tautLeft,tautRightSmaller),leq(tautLeft,tautRightBigger)))
\replacewith(or(or(geq(tautLeft,tautRightSmaller),leq(tautLeft,tautRightBigger)),geq(tautRightBigger,add(Z(neglit(1(#))),tautRightSmaller)))) 
\heuristics(notHumanReadable, inEqSimp_or_tautInEqs, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_tautInEq3 (inEqSimp_or_tautInEq3) =========================================
inEqSimp_or_tautInEq3 {
\find(or(or(b,geq(tautLeft,tautRightSmaller)),leq(tautLeft,tautRightBigger)))
\replacewith(or(or(or(b,geq(tautLeft,tautRightSmaller)),leq(tautLeft,tautRightBigger)),geq(tautRightBigger,add(Z(neglit(1(#))),tautRightSmaller)))) 
\heuristics(notHumanReadable, inEqSimp_or_tautInEqs, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_weaken0 (inEqSimp_or_weaken0) =========================================
inEqSimp_or_weaken0 {
\find(or(leq(weakenLeft,weakenRightSmaller),equals(weakenLeft,weakenRightBigger)))
\replacewith(if-then-else(equals(weakenRightBigger,add(Z(1(#)),weakenRightSmaller)),leq(weakenLeft,weakenRightBigger),or(leq(weakenLeft,weakenRightSmaller),equals(weakenLeft,weakenRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_or_weaken, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_weaken1 (inEqSimp_or_weaken1) =========================================
inEqSimp_or_weaken1 {
\find(or(equals(weakenLeft,weakenRightSmaller),geq(weakenLeft,weakenRightBigger)))
\replacewith(if-then-else(equals(weakenRightBigger,add(Z(1(#)),weakenRightSmaller)),geq(weakenLeft,weakenRightSmaller),or(equals(weakenLeft,weakenRightSmaller),geq(weakenLeft,weakenRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_or_weaken, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_weaken2 (inEqSimp_or_weaken2) =========================================
inEqSimp_or_weaken2 {
\find(or(or(b,leq(weakenLeft,weakenRightSmaller)),equals(weakenLeft,weakenRightBigger)))
\replacewith(or(b,if-then-else(equals(weakenRightBigger,add(Z(1(#)),weakenRightSmaller)),leq(weakenLeft,weakenRightBigger),or(leq(weakenLeft,weakenRightSmaller),equals(weakenLeft,weakenRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_or_weaken, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_or_weaken3 (inEqSimp_or_weaken3) =========================================
inEqSimp_or_weaken3 {
\find(or(or(b,equals(weakenLeft,weakenRightSmaller)),geq(weakenLeft,weakenRightBigger)))
\replacewith(or(b,if-then-else(equals(weakenRightBigger,add(Z(1(#)),weakenRightSmaller)),geq(weakenLeft,weakenRightSmaller),or(equals(weakenLeft,weakenRightSmaller),geq(weakenLeft,weakenRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_or_weaken, inEqSimp_forNormalisation)
Choices: true}
-----------------------------------------------------
== inEqSimp_sepNegMonomial0 (inEqSimp_sepNegMonomial0) =========================================
inEqSimp_sepNegMonomial0 {
\find(leq(add(sepResidue,sepNegMono),Z(0(#))))
\replacewith(geq(mul(sepNegMono,Z(neglit(1(#)))),sepResidue)) 
\heuristics(notHumanReadable, inEqSimp_balance, inEqSimp_directInEquations)
Choices: true}
-----------------------------------------------------
== inEqSimp_sepNegMonomial1 (inEqSimp_sepNegMonomial1) =========================================
inEqSimp_sepNegMonomial1 {
\find(geq(add(sepResidue,sepNegMono),Z(0(#))))
\replacewith(leq(mul(sepNegMono,Z(neglit(1(#)))),sepResidue)) 
\heuristics(notHumanReadable, inEqSimp_balance, inEqSimp_directInEquations)
Choices: true}
-----------------------------------------------------
== inEqSimp_sepPosMonomial0 (inEqSimp_sepPosMonomial0) =========================================
inEqSimp_sepPosMonomial0 {
\find(leq(add(sepResidue,sepPosMono),Z(0(#))))
\replacewith(leq(sepPosMono,mul(sepResidue,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, inEqSimp_balance, inEqSimp_directInEquations)
Choices: true}
-----------------------------------------------------
== inEqSimp_sepPosMonomial1 (inEqSimp_sepPosMonomial1) =========================================
inEqSimp_sepPosMonomial1 {
\find(geq(add(sepResidue,sepPosMono),Z(0(#))))
\replacewith(geq(sepPosMono,mul(sepResidue,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, inEqSimp_balance, inEqSimp_directInEquations)
Choices: true}
-----------------------------------------------------
== inEqSimp_strengthen0 (inEqSimp_strengthen0) =========================================
inEqSimp_strengthen0 {
\assumes ([]==>[equals(strengthenLeft,strengthenRight)]) 
\find(leq(strengthenLeft,strengthenRight)==>)
\replacewith([leq(strengthenLeft,add(Z(neglit(1(#))),strengthenRight))]==>[]) 
\heuristics(notHumanReadable, inEqSimp_strengthen, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_strengthen1 (inEqSimp_strengthen1) =========================================
inEqSimp_strengthen1 {
\assumes ([]==>[equals(strengthenLeft,strengthenRight)]) 
\find(geq(strengthenLeft,strengthenRight)==>)
\replacewith([geq(strengthenLeft,add(Z(1(#)),strengthenRight))]==>[]) 
\heuristics(notHumanReadable, inEqSimp_strengthen, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_subsumption0 (inEqSimp_subsumption0) =========================================
inEqSimp_subsumption0 {
\assumes ([leq(subsumLeft,subsumRightSmaller)]==>[]) 
\find(leq(subsumLeft,subsumRightBigger))
\sameUpdateLevel\replacewith(or(leq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_subsumption1 (inEqSimp_subsumption1) =========================================
inEqSimp_subsumption1 {
\assumes ([geq(subsumLeft,subsumRightBigger)]==>[]) 
\find(geq(subsumLeft,subsumRightSmaller))
\sameUpdateLevel\replacewith(or(leq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_subsumption2 (inEqSimp_subsumption2) =========================================
inEqSimp_subsumption2 {
\assumes ([leq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller)]==>[]) 
\find(leq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger))
\sameUpdateLevel\replacewith(or(and(and(gt(subsumCoeffSmaller,Z(0(#))),gt(subsumCoeffBigger,Z(0(#)))),leq(mul(subsumCoeffBigger,subsumRightSmaller),mul(subsumCoeffSmaller,subsumRightBigger))),leq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_subsumption4 (inEqSimp_subsumption4) =========================================
inEqSimp_subsumption4 {
\assumes ([leq(subsumLeft,subsumRightSmaller)]==>[]) 
\find(leq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger))
\sameUpdateLevel\replacewith(or(and(gt(subsumCoeffBigger,Z(0(#))),leq(mul(subsumCoeffBigger,subsumRightSmaller),subsumRightBigger)),leq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_subsumption5 (inEqSimp_subsumption5) =========================================
inEqSimp_subsumption5 {
\assumes ([geq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger)]==>[]) 
\find(geq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller))
\sameUpdateLevel\replacewith(or(and(and(gt(subsumCoeffSmaller,Z(0(#))),gt(subsumCoeffBigger,Z(0(#)))),leq(mul(subsumCoeffBigger,subsumRightSmaller),mul(subsumCoeffSmaller,subsumRightBigger))),geq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== inEqSimp_subsumption6 (inEqSimp_subsumption6) =========================================
inEqSimp_subsumption6 {
\assumes ([geq(subsumLeft,subsumRightBigger)]==>[]) 
\find(geq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller))
\sameUpdateLevel\replacewith(or(and(gt(subsumCoeffSmaller,Z(0(#))),leq(subsumRightSmaller,mul(subsumCoeffSmaller,subsumRightBigger))),geq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: true}
-----------------------------------------------------
== indexOf (indexOf) =========================================
indexOf {
\find(clIndexOfChar(l,c,i))
\varcond(\notFreeIn(iv (variable), i (int term)), \notFreeIn(iv (variable), c (int term)), \notFreeIn(iv (variable), l (Seq term)))
\replacewith(ifExThenElse{iv (variable)}(and(and(and(geq(i,Z(0(#))),geq(iv,i)),lt(iv,seqLen(l))),equals(int::seqGet(l,iv),c)),iv,Z(neglit(1(#))))) 
\heuristics(stringsExpandDefNormalOp)
Choices: Strings:on}
-----------------------------------------------------
== indexOfSeqConcatFirst (indexOfSeqConcatFirst) =========================================
indexOfSeqConcatFirst {
\find(seqIndexOf(seqConcat(s1,s2),x))
\sameUpdateLevel\varcond(\notFreeIn(idx (variable), x (any term)), \notFreeIn(idx (variable), s2 (Seq term)), \notFreeIn(idx (variable), s1 (Seq term)))
\add []==>[exists{idx (variable)}(and(and(leq(Z(0(#)),idx),lt(idx,seqLen(s1))),equals(any::seqGet(s1,idx),x)))] ;
\replacewith(seqIndexOf(s1,x)) 

Choices: sequences:on}
-----------------------------------------------------
== indexOfSeqConcatSecond (indexOfSeqConcatSecond) =========================================
indexOfSeqConcatSecond {
\find(seqIndexOf(seqConcat(s1,s2),x))
\sameUpdateLevel\varcond(\notFreeIn(idx (variable), x (any term)), \notFreeIn(idx (variable), s2 (Seq term)), \notFreeIn(idx (variable), s1 (Seq term)))
\add []==>[and(not(exists{idx (variable)}(and(and(leq(Z(0(#)),idx),lt(idx,seqLen(s1))),equals(any::seqGet(s1,idx),x)))),exists{idx (variable)}(and(and(leq(Z(0(#)),idx),lt(idx,seqLen(s2))),equals(any::seqGet(s2,idx),x))))] ;
\replacewith(add(seqIndexOf(s2,x),seqLen(s1))) 

Choices: sequences:on}
-----------------------------------------------------
== indexOfSeqSingleton (indexOfSeqSingleton) =========================================
indexOfSeqSingleton {
\find(seqIndexOf(seqSingleton(x),x))
\sameUpdateLevel\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== indexOfSeqSub (indexOfSeqSub) =========================================
indexOfSeqSub {
\find(seqIndexOf(seqSub(s,from,to),x))
\sameUpdateLevel\varcond(\notFreeIn(nx (variable), to (int term)), \notFreeIn(nx (variable), from (int term)), \notFreeIn(nx (variable), x (any term)), \notFreeIn(nx (variable), s (Seq term)))
\add []==>[and(and(and(leq(from,seqIndexOf(s,x)),lt(seqIndexOf(s,x),to)),leq(Z(0(#)),from)),exists{nx (variable)}(and(and(leq(Z(0(#)),nx),lt(nx,seqLen(s))),equals(any::seqGet(s,nx),x))))] ;
\replacewith(sub(seqIndexOf(s,x),from)) 

Choices: sequences:on}
-----------------------------------------------------
== indexOfStr (indexOfStr) =========================================
indexOfStr {
\find(clIndexOfCl(sourceStr,i,searchStr))
\varcond(\notFreeIn(iv (variable), i (int term)), \notFreeIn(iv (variable), sourceStr (Seq term)), \notFreeIn(iv (variable), searchStr (Seq term)))
\replacewith(ifExThenElse{iv (variable)}(and(and(and(geq(iv,i),geq(iv,Z(0(#)))),leq(add(iv,seqLen(searchStr)),seqLen(sourceStr))),equals(seqSub(sourceStr,iv,add(iv,seqLen(searchStr))),searchStr)),iv,Z(neglit(1(#))))) 
\heuristics(stringsExpandDefNormalOp)
Choices: Strings:on}
-----------------------------------------------------
== ineffectiveCast (ineffectiveCast) =========================================
ineffectiveCast {
\assumes ([equals(H::instance(t),TRUE)]==>[]) 
\find(H::cast(t))
\sameUpdateLevel\add [equals(H::cast(t),t)]==>[] 
\heuristics(inReachableStateImplication)
Choices: true}
-----------------------------------------------------
== ineffectiveCast2 (ineffectiveCast2) =========================================
ineffectiveCast2 {
\assumes ([equals(cs,gt)]==>[]) 
\find(C::cast(gt))
\sameUpdateLevel\add [equals(C::cast(gt),gt)]==>[] 
\heuristics(inReachableStateImplication)
Choices: true}
-----------------------------------------------------
== ineffectiveCast3 (ineffectiveCast3) =========================================
ineffectiveCast3 {
\assumes ([equals(H::exactInstance(t),TRUE)]==>[]) 
\find(H::cast(t))
\sameUpdateLevel\add [equals(H::cast(t),t)]==>[] 
\heuristics(inReachableStateImplication)
Choices: true}
-----------------------------------------------------
== inequality_comparison_new (inequality comparison) =========================================
inequality_comparison_new {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 != #senf1;
... }\] (post))
\replacewith(if-then-else(not(equals(#senf0,#senf1)),#allmodal ( (modal operator))\[{ ..
  #lhs = true;
... }\] (post),#allmodal ( (modal operator))\[{ ..
  #lhs = false;
... }\] (post))) 
\heuristics(split_if, simplify_prog, obsolete)
Choices: programRules:Java}
-----------------------------------------------------
== inequality_comparison_simple (inequality comparison) =========================================
inequality_comparison_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 != #senf1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#senf0,#senf1),FALSE,TRUE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== inequality_comparison_simple_double (inequality comparison) =========================================
inequality_comparison_simple_double {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seDouble0 != #seDouble1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(eqDouble(#seDouble0,#seDouble1),FALSE,TRUE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== inequality_comparison_simple_float (inequality comparison) =========================================
inequality_comparison_simple_float {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seFloat0 != #seFloat1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(eqFloat(#seFloat0,#seFloat1),FALSE,TRUE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== infiniteUnionUnused (infiniteUnionUnused) =========================================
infiniteUnionUnused {
\find(infiniteUnion{av (variable)}(s))
\varcond(\notFreeIn(av (variable), s (LocSet term)))
\replacewith(s) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== insert_constant_string_value (insert_constant_string_value) =========================================
insert_constant_string_value {
\assumes ([wellFormed(heap)]==>[]) 
\find(#csv)
\sameUpdateLevel\replacewith(if-then-else(equals(#constantvalue(#csv),null),null,strPool(Seq::cast(#constantvalue(#csv))))) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== insert_constant_value (insert_constant_value) =========================================
insert_constant_value {
\find(#cv)
\replacewith(#constantvalue(#cv)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== insert_eq_all (insert_eq_all) =========================================
insert_eq_all {
\find(equals(sr,tr)==>)
\addrules [auto_insert_eq {
\find(sr)
\replacewith(tr) 
\heuristics(simplify)
Choices: true}] \replacewith([]==>[]) 

Choices: true}
-----------------------------------------------------
== insert_eqv_lr (insert_eqv_lr) =========================================
insert_eqv_lr {
\find(equiv(br,cr)==>)
\addrules [insert_eqv {
\find(br)
\replacewith(cr) 
\heuristics(simplify)
Choices: true}] 

Choices: true}
-----------------------------------------------------
== insert_eqv_once_lr (insert_eqv_once_lr) =========================================
insert_eqv_once_lr {
\find(equiv(br,cr)==>)
\addrules [insert_eqv {
\find(br)
\replacewith(cr) 

Choices: true}] 

Choices: true}
-----------------------------------------------------
== insert_eqv_once_rl (insert_eqv_once_rl) =========================================
insert_eqv_once_rl {
\find(equiv(br,cr)==>)
\addrules [insert_eqv {
\find(cr)
\replacewith(br) 

Choices: true}] 

Choices: true}
-----------------------------------------------------
== insert_eqv_rl (insert_eqv_rl) =========================================
insert_eqv_rl {
\find(equiv(br,cr)==>)
\addrules [insert_eqv {
\find(cr)
\replacewith(br) 
\heuristics(simplify)
Choices: true}] 

Choices: true}
-----------------------------------------------------
== instAll (instAll) =========================================
instAll {
\assumes ([all{u (variable)}(b)]==>[]) 
\find(t)
\add [subst{u (variable)}(t,b)]==>[] 

Choices: true}
-----------------------------------------------------
== instEx (instEx) =========================================
instEx {
\assumes ([]==>[exists{u (variable)}(b)]) 
\find(t)
\add []==>[subst{u (variable)}(t,b)] 

Choices: true}
-----------------------------------------------------
== instanceCreation (instanceCreation) =========================================
instanceCreation {
\find(#allmodal ( (modal operator))\[{ ..
  #n
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#n (program SimpleInstanceCreation))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#v0) #v0 = create-object(#n);
  constructor-call(#n)
  post-work(#v0)
... }\] (post)) 
\heuristics(method_expand)
Choices: programRules:Java}
-----------------------------------------------------
== instanceCreationAssignment (instanceCreationAssignment) =========================================
instanceCreationAssignment {
\find(#normal ( (modal operator))\[{ ..
  #lhs = #n;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))))
\replacewith(#normal ( (modal operator))\[{ ..
  #typeof(#v0) #v0 = create-object(#n);
  constructor-call(#n)
  post-work(#v0)
  #lhs = #v0;
... }\] (post)) 
\heuristics(method_expand)
Choices: programRules:Java}
-----------------------------------------------------
== instanceCreationAssignmentUnfoldArguments (instanceCreationAssignmentUnfoldArguments) =========================================
instanceCreationAssignmentUnfoldArguments {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nsn;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #evaluate-arguments(#lhs = #nsn)
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== instanceCreationUnfoldArguments (instanceCreationUnfoldArguments) =========================================
instanceCreationUnfoldArguments {
\find(#allmodal ( (modal operator))\[{ ..
  #nsn
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #evaluate-arguments(#nsn)
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== instanceof_eval (instanceof_eval) =========================================
instanceof_eval {
\find(#allmodal ( (modal operator))\[{ ..
  #v = #nse instanceof #t;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0 = #nse;
  #v = #v0 instanceof #t;
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== instanceof_known_dynamic_type (instanceof_known_dynamic_type) =========================================
instanceof_known_dynamic_type {
\assumes ([equals(G::exactInstance(a),TRUE)]==>[]) 
\find(H::instance(a))
\sameUpdateLevel\varcond(\sub(G, H), )
\replacewith(TRUE) 
\heuristics(evaluate_instanceof, simplify)
Choices: true}
-----------------------------------------------------
== instanceof_known_dynamic_type_2 (instanceof_known_dynamic_type_2) =========================================
instanceof_known_dynamic_type_2 {
\assumes ([equals(G::exactInstance(a),TRUE)]==>[]) 
\find(H::instance(a))
\sameUpdateLevel\varcond(\not\sub(G, H), )
\replacewith(FALSE) 
\heuristics(evaluate_instanceof, simplify)
Choices: true}
-----------------------------------------------------
== instanceof_not_compatible (instanceof disjoint type) =========================================
instanceof_not_compatible {
\find(equals(G::instance(a),TRUE))
\varcond(\sub(Null, G), \disjointModuloNull(G, \typeof(a (any term))), )
\replacewith(equals(a,null)) 
\heuristics(evaluate_instanceof, concrete)
Choices: true}
-----------------------------------------------------
== instanceof_not_compatible_2 (instanceof disjoint type) =========================================
instanceof_not_compatible_2 {
\find(equals(G::instance(a),FALSE))
\varcond(\sub(Null, G), \disjointModuloNull(G, \typeof(a (any term))), )
\replacewith(not(equals(a,null))) 
\heuristics(evaluate_instanceof, concrete)
Choices: true}
-----------------------------------------------------
== instanceof_not_compatible_3 (instanceof disjoint type) =========================================
instanceof_not_compatible_3 {
\find(equals(G::instance(a),TRUE))
\varcond(\not\sub(Null, G), \disjointModuloNull(G, \typeof(a (any term))), )
\replacewith(false) 
\heuristics(evaluate_instanceof, concrete)
Choices: true}
-----------------------------------------------------
== instanceof_not_compatible_4 (instanceof disjoint type) =========================================
instanceof_not_compatible_4 {
\find(equals(G::instance(a),FALSE))
\varcond(\not\sub(Null, G), \disjointModuloNull(G, \typeof(a (any term))), )
\replacewith(true) 
\heuristics(evaluate_instanceof, concrete)
Choices: true}
-----------------------------------------------------
== instanceof_not_compatible_5 (instanceof disjoint type) =========================================
instanceof_not_compatible_5 {
\assumes ([equals(H::instance(a),TRUE)]==>[]) 
\find(equals(G::instance(a),TRUE))
\varcond(\sub(Null, G), \disjointModuloNull(G, H), )
\replacewith(equals(a,null)) 
\heuristics(evaluate_instanceof, concrete)
Choices: true}
-----------------------------------------------------
== instanceof_static_type (instanceof static supertype) =========================================
instanceof_static_type {
\find(G::instance(a))
\varcond(\sub(\typeof(a (any term)), G), )
\replacewith(TRUE) 
\heuristics(evaluate_instanceof, concrete)
Choices: true}
-----------------------------------------------------
== instanceof_static_type_2 (instanceof static supertype) =========================================
instanceof_static_type_2 {
\assumes ([equals(a2,a)]==>[]) 
\find(G::instance(a))
\sameUpdateLevel\varcond(\sub(\typeof(a2 (any term)), G), )
\replacewith(TRUE) 
\heuristics(evaluate_instanceof, concrete)
Choices: true}
-----------------------------------------------------
== intDivRem (intDivRem) =========================================
intDivRem {
\find(jmod(divNum,divDenom))
\add [imp(not(equals(divDenom,Z(0(#)))),equals(divNum,add(mul(jdiv(divNum,divDenom),divDenom),jmod(divNum,divDenom))))]==>[] 

Choices: true}
-----------------------------------------------------
== intLongToFloatAddition1 (float addition) =========================================
intLongToFloatAddition1 {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seLong + #seFloat;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddFloat(float::cast(#seLong),#seFloat)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== intToFloatAddition (float addition) =========================================
intToFloatAddition {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = #seCharByteShortInt + #seFloat;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaAddFloat(float::cast(#seCharByteShortInt),#seFloat)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== int_diff_minus_eq (int_diff_minus_eq) =========================================
int_diff_minus_eq {
\find(sub(i0,neg(i1)))
\replacewith(add(i0,i1)) 

Choices: true}
-----------------------------------------------------
== int_induction (int_induction) =========================================
int_induction {
\add [all{nv (variable)}(imp(geq(nv,Z(0(#))),b))]==>[] ;
\add []==>[all{nv (variable)}(imp(and(geq(nv,Z(0(#))),b),subst{nv (variable)}(add(nv,Z(1(#))),b)))] ;
\add []==>[subst{nv (variable)}(Z(0(#)),b)] 

Choices: true}
-----------------------------------------------------
== intersectAllFieldsFreshLocs (intersectAllFieldsFreshLocs) =========================================
intersectAllFieldsFreshLocs {
\find(equals(intersect(allFields(o),freshLocs(h)),empty))
\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== intersectWithAllLocs (intersectWithAllLocs) =========================================
intersectWithAllLocs {
\find(intersect(allLocs,s))
\replacewith(s) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== intersectWithAllLocsRight (intersectWithAllLocs) =========================================
intersectWithAllLocsRight {
\find(intersect(s,allLocs))
\replacewith(s) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== intersectWithEmpty (intersectWithEmpty) =========================================
intersectWithEmpty {
\find(intersect(empty,s))
\replacewith(empty) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== intersectWithEmptyRight (intersectWithEmpty) =========================================
intersectWithEmptyRight {
\find(intersect(s,empty))
\replacewith(empty) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== intersectWithItself (intersectWithItself) =========================================
intersectWithItself {
\find(intersect(s,s))
\replacewith(s) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== intersectWithSingleton (intersectWithSingleton) =========================================
intersectWithSingleton {
\find(intersect(singleton(o,f),s))
\replacewith(if-then-else(elementOf(o,f,s),singleton(o,f),empty)) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== intersectionSetMinusItself (intersectionSetMinusItself) =========================================
intersectionSetMinusItself {
\find(intersect(setMinus(s1,s2),s2))
\replacewith(empty) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== intersectionSetMinusItself_2 (intersectionSetMinusItself_2) =========================================
intersectionSetMinusItself_2 {
\find(intersect(s2,setMinus(s1,s2)))
\replacewith(empty) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== introduceAxiom (introduceAxiom) =========================================
introduceAxiom {
\add [cutFormula]==>[] 

Choices: true}
-----------------------------------------------------
== irrflConcrete1 (irrflConcrete1) =========================================
irrflConcrete1 {
\find(lt(i,i)==>)
\replacewith([false]==>[]) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== irrflConcrete2 (irrflConcrete2) =========================================
irrflConcrete2 {
\find(gt(i,i)==>)
\replacewith([false]==>[]) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== isFiniteOfMapEmpty (isFiniteOfMapEmpty) =========================================
isFiniteOfMapEmpty {
\find(isFinite(mapEmpty))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== isFiniteOfMapRemove (isFiniteOfMapRemove) =========================================
isFiniteOfMapRemove {
\find(isFinite(mapRemove(m,key)))
\sameUpdateLevel\replacewith(isFinite(m)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== isFiniteOfMapSingleton (isFiniteOfMapSingleton) =========================================
isFiniteOfMapSingleton {
\find(isFinite(mapSingleton(key,value)))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== isFiniteOfMapUpdate (isFiniteOfMapUpdate) =========================================
isFiniteOfMapUpdate {
\find(isFinite(mapUpdate(m,key,value)))
\sameUpdateLevel\replacewith(isFinite(m)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== isFiniteOfSeq2Map (isFiniteOfSeq2Map) =========================================
isFiniteOfSeq2Map {
\find(isFinite(seq2map(s)))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== iterated_assignments_0 (eval_order_iterated_assignments) =========================================
iterated_assignments_0 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 = #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = #e;
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_1 (eval_order_iterated_assignments) =========================================
iterated_assignments_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 *= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 * #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_10 (eval_order_iterated_assignments) =========================================
iterated_assignments_10 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 |= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 | #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_11 (eval_order_iterated_assignments) =========================================
iterated_assignments_11 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 ^= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 ^ #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_2 (eval_order_iterated_assignments) =========================================
iterated_assignments_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 /= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 / #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_3 (eval_order_iterated_assignments) =========================================
iterated_assignments_3 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 %= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 % #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_4 (eval_order_iterated_assignments) =========================================
iterated_assignments_4 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 += #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 + #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_5 (eval_order_iterated_assignments) =========================================
iterated_assignments_5 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 -= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 - #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_6 (eval_order_iterated_assignments) =========================================
iterated_assignments_6 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 <<= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 << #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_7 (eval_order_iterated_assignments) =========================================
iterated_assignments_7 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 >>= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 >> #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_8 (eval_order_iterated_assignments) =========================================
iterated_assignments_8 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 >>>= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 >>> #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== iterated_assignments_9 (eval_order_iterated_assignments) =========================================
iterated_assignments_9 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1 &= #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 & #e);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== javaShiftLeftIntDef (javaShiftLeftIntDef) =========================================
javaShiftLeftIntDef {
\find(shiftleftJint(left,right))
\replacewith(moduloInt(shiftleft(left,mod(right,Z(2(3(#))))))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== javaShiftLeftLongDef (javaShiftLeftLongDef) =========================================
javaShiftLeftLongDef {
\find(shiftleftJlong(left,right))
\replacewith(moduloLong(shiftleft(left,mod(right,Z(4(6(#))))))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== javaShiftRightIntDef (javaShiftRightIntDef) =========================================
javaShiftRightIntDef {
\find(shiftrightJint(left,right))
\replacewith(moduloInt(shiftright(left,mod(right,Z(2(3(#))))))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== javaShiftRightLongDef (javaShiftRightLongDef) =========================================
javaShiftRightLongDef {
\find(shiftrightJlong(left,right))
\replacewith(moduloLong(shiftright(left,mod(right,Z(4(6(#))))))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== jdivAddMultDenom (jdivAddMultDenom) =========================================
jdivAddMultDenom {
\add [all{N (variable)}(all{D (variable)}(all{A (variable)}(imp(not(equals(D,Z(0(#)))),equals(jdiv(add(N,mul(A,D)),D),if-then-else(equals(N,mul(jdiv(N,D),D)),add(jdiv(N,D),A),if-then-else(and(not(equals(N,mul(jdiv(N,D),D))),equiv(geq(N,Z(0(#))),geq(add(N,mul(D,A)),Z(0(#))))),add(jdiv(N,D),A),if-then-else(and(and(not(equals(N,mul(jdiv(N,D),D))),equiv(geq(N,Z(0(#))),lt(add(N,mul(D,A)),Z(0(#))))),equiv(gt(D,Z(0(#))),lt(add(N,mul(D,A)),Z(0(#))))),add(add(jdiv(N,D),A),Z(1(#))),sub(add(jdiv(N,D),A),Z(1(#)))))))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jdivMultDenom1 (jdivMultDenom1) =========================================
jdivMultDenom1 {
\find(jdiv(mul(divDenom,cfac),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(cfac) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== jdivMultDenom2 (jdivMultDenom2) =========================================
jdivMultDenom2 {
\find(jdiv(mul(cfac,divDenom),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(cfac) 

Choices: true}
-----------------------------------------------------
== jdivPulloutMinusDenom (jdivPulloutMinusDenom) =========================================
jdivPulloutMinusDenom {
\find(jdiv(divNum,neg(divDenom)))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(neg(jdiv(divNum,divDenom))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== jdivPulloutMinusNum (jdivPulloutMinusNum) =========================================
jdivPulloutMinusNum {
\find(jdiv(neg(divNum),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(neg(jdiv(divNum,divDenom))) 

Choices: true}
-----------------------------------------------------
== jdiv_axiom (jdiv_axiom) =========================================
jdiv_axiom {
\find(jdiv(divNum,divDenom))
\sameUpdateLevel\add [equals(jdiv(divNum,divDenom),if-then-else(geq(divNum,Z(0(#))),div(divNum,divDenom),mul(div(mul(divNum,Z(neglit(1(#)))),divDenom),Z(neglit(1(#))))))]==>[] 
\heuristics(notHumanReadable, defOps_jdiv)
Choices: true}
-----------------------------------------------------
== jdiv_axiom_inline (jdiv_axiom_inline) =========================================
jdiv_axiom_inline {
\find(jdiv(divNum,divDenom))
\replacewith(if-then-else(geq(divNum,Z(0(#))),div(divNum,divDenom),mul(div(mul(divNum,Z(neglit(1(#)))),divDenom),Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, defOps_jdiv_inline)
Choices: true}
-----------------------------------------------------
== jdiv_one (jdiv_one) =========================================
jdiv_one {
\find(jdiv(divNum,Z(1(#))))
\replacewith(divNum) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== jdiv_uniqueNegNeg (jdiv_uniqueNegNeg) =========================================
jdiv_uniqueNegNeg {
\find(jdiv(divNum,divDenom))
\add [all{a (variable)}(all{cnom (variable)}(all{x (variable)}(all{y (variable)}(imp(and(and(and(and(and(lt(a,Z(0(#))),lt(cnom,Z(0(#)))),geq(mul(x,cnom),a)),geq(mul(y,cnom),a)),lt(mul(add(x,Z(1(#))),cnom),a)),lt(mul(add(y,Z(1(#))),cnom),a)),equals(x,y))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jdiv_uniqueNegPos (jdiv_uniqueNegPos) =========================================
jdiv_uniqueNegPos {
\find(jdiv(divNum,divDenom))
\add [all{a (variable)}(all{cnom (variable)}(all{x (variable)}(all{y (variable)}(imp(and(and(and(and(and(lt(a,Z(0(#))),gt(cnom,Z(0(#)))),geq(mul(x,cnom),a)),geq(mul(y,cnom),a)),lt(mul(sub(x,Z(1(#))),cnom),a)),lt(mul(sub(y,Z(1(#))),cnom),a)),equals(x,y))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jdiv_uniquePosNeg (jdiv_uniquePosNeg) =========================================
jdiv_uniquePosNeg {
\find(jdiv(divNum,divDenom))
\add [all{a (variable)}(all{cnom (variable)}(all{x (variable)}(all{y (variable)}(imp(and(and(and(and(and(geq(a,Z(0(#))),lt(cnom,Z(0(#)))),leq(mul(x,cnom),a)),leq(mul(y,cnom),a)),gt(mul(sub(x,Z(1(#))),cnom),a)),gt(mul(sub(y,Z(1(#))),cnom),a)),equals(x,y))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jdiv_uniquePosPos (jdiv_uniquePosPos) =========================================
jdiv_uniquePosPos {
\find(jdiv(divNum,divDenom))
\add [all{a (variable)}(all{cnom (variable)}(all{x (variable)}(all{y (variable)}(imp(and(and(and(and(and(geq(a,Z(0(#))),gt(cnom,Z(0(#)))),leq(mul(x,cnom),a)),leq(mul(y,cnom),a)),gt(mul(add(x,Z(1(#))),cnom),a)),gt(mul(add(y,Z(1(#))),cnom),a)),equals(x,y))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jdiv_zero (jdiv_zero) =========================================
jdiv_zero {
\find(jdiv(Z(0(#)),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(Z(0(#))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== jmodAddMultDenomZero (jmodAddMultDenomZero) =========================================
jmodAddMultDenomZero {
\find(equals(jmod(add(N,mul(A,D)),D),Z(0(#))))
\sameUpdateLevel\add []==>[not(equals(D,Z(0(#))))] ;
\replacewith(equals(jmod(N,D),Z(0(#)))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== jmodAltZero (jmodAltZero) =========================================
jmodAltZero {
\add [all{N (variable)}(all{D (variable)}(imp(not(equals(D,Z(0(#)))),equiv(equals(jmod(N,D),Z(0(#))),exists{A (variable)}(equals(N,mul(A,D)))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jmodDivisible (jmodDivisible) =========================================
jmodDivisible {
\add [all{D (variable)}(all{A (variable)}(imp(not(equals(D,Z(0(#)))),equals(jmod(mul(D,A),D),Z(0(#))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jmodDivisibleRep (jmodDivisibleRep) =========================================
jmodDivisibleRep {
\find(jmod(mul(D,A),D))
\add []==>[not(equals(D,Z(0(#))))] ;
\replacewith(Z(0(#))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== jmodNumZero (jmodNumZero) =========================================
jmodNumZero {
\find(jmod(Z(0(#)),divDenom))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== jmodUnique1 (jmodUnique1) =========================================
jmodUnique1 {
\add [all{a (variable)}(all{deb (variable)}(all{cmod (variable)}(imp(and(and(and(and(geq(a,Z(0(#))),not(equals(deb,Z(0(#))))),leq(Z(0(#)),cmod)),lt(cmod,if-then-else(gt(deb,Z(0(#))),deb,neg(deb)))),exists{x (variable)}(equals(a,add(mul(deb,x),cmod)))),equals(cmod,jmod(a,deb))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jmodUnique2 (jmodUnique2) =========================================
jmodUnique2 {
\add [all{a (variable)}(all{deb (variable)}(all{cmod (variable)}(imp(and(and(and(and(leq(a,Z(0(#))),not(equals(deb,Z(0(#))))),lt(neg(cmod),if-then-else(gt(deb,Z(0(#))),deb,neg(deb)))),leq(cmod,Z(0(#)))),exists{x (variable)}(equals(a,add(mul(deb,x),cmod)))),equals(cmod,jmod(a,deb))))))]==>[] 

Choices: true}
-----------------------------------------------------
== jmod_NumNeg (jmod_NumNeg) =========================================
jmod_NumNeg {
\find(jmod(divNum,divDenom))
\add [imp(and(not(equals(divDenom,Z(0(#)))),leq(divNum,Z(0(#)))),gt(jmod(divNum,divDenom),if-then-else(geq(divDenom,Z(0(#))),neg(divDenom),divDenom)))]==>[] 

Choices: true}
-----------------------------------------------------
== jmod_NumPos (jmod_NumPos) =========================================
jmod_NumPos {
\find(jmod(divNum,divDenom))
\add [imp(and(not(equals(divDenom,Z(0(#)))),geq(divNum,Z(0(#)))),lt(jmod(divNum,divDenom),if-then-else(geq(divDenom,Z(0(#))),divDenom,neg(divDenom))))]==>[] 

Choices: true}
-----------------------------------------------------
== jmod_axiom (jmod_axiom) =========================================
jmod_axiom {
\find(jmod(divNum,divDenom))
\replacewith(add(divNum,mul(mul(jdiv(divNum,divDenom),Z(neglit(1(#)))),divDenom))) 
\heuristics(notHumanReadable, defOps_mod)
Choices: true}
-----------------------------------------------------
== jmod_geZero (jmod_geZero) =========================================
jmod_geZero {
\find(jmod(divNum,divDenom))
\add [imp(not(equals(divDenom,Z(0(#)))),leq(Z(0(#)),if-then-else(geq(divNum,Z(0(#))),jmod(divNum,divDenom),neg(jmod(divNum,divDenom)))))]==>[] 

Choices: true}
-----------------------------------------------------
== jmod_pulloutminusDenom (jmod_pulloutminusDenom) =========================================
jmod_pulloutminusDenom {
\find(jmod(divNum,neg(divDenom)))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(jmod(divNum,divDenom)) 

Choices: true}
-----------------------------------------------------
== jmod_pulloutminusNum (jmod_pulloutminusNum) =========================================
jmod_pulloutminusNum {
\find(jmod(neg(divNum),divDenom))
\add []==>[not(equals(divDenom,Z(0(#))))] ;
\replacewith(neg(jmod(divNum,divDenom))) 

Choices: true}
-----------------------------------------------------
== jmodjmod (jmodjmod) =========================================
jmodjmod {
\add [all{N (variable)}(all{D1 (variable)}(all{D2 (variable)}(imp(and(and(and(not(equals(D1,Z(0(#)))),not(equals(D2,Z(0(#))))),equals(jmod(D1,D2),Z(0(#)))),equiv(geq(D1,Z(0(#))),geq(D2,Z(0(#))))),equals(jmod(N,D2),jmod(jmod(N,D1),D2))))))]==>[] 

Choices: true}
-----------------------------------------------------
== lastIndexOf (lastIndexOf) =========================================
lastIndexOf {
\find(clLastIndexOfChar(sourceStr,c,i))
\varcond(\notFreeIn(iv (variable), sourceStr (Seq term)), \notFreeIn(iv (variable), i (int term)), \notFreeIn(iv (variable), c (int term)))
\replacewith(ifExThenElse{iv (variable)}(and(and(and(gt(iv,Z(0(#))),geq(i,iv)),lt(sub(i,iv),seqLen(sourceStr))),equals(int::seqGet(sourceStr,sub(i,iv)),c)),sub(i,iv),Z(neglit(1(#))))) 
\heuristics(stringsExpandDefNormalOp)
Choices: Strings:on}
-----------------------------------------------------
== lastIndexOfStr (lastIndexOfStr) =========================================
lastIndexOfStr {
\find(clLastIndexOfCl(sourceStr,i,searchStr))
\varcond(\notFreeIn(iv (variable), sourceStr (Seq term)), \notFreeIn(iv (variable), i (int term)), \notFreeIn(iv (variable), searchStr (Seq term)))
\replacewith(ifExThenElse{iv (variable)}(and(and(and(gt(iv,Z(0(#))),geq(sub(i,iv),Z(0(#)))),leq(sub(add(seqLen(searchStr),i),iv),seqLen(sourceStr))),equals(seqSub(sourceStr,sub(i,iv),sub(add(seqLen(searchStr),i),iv)),searchStr)),sub(i,iv),Z(neglit(1(#))))) 
\heuristics(stringsExpandDefNormalOp)
Choices: Strings:on}
-----------------------------------------------------
== le1_add1_eq_le (le1_add1_eq_le) =========================================
le1_add1_eq_le {
\find(lt(i0,add(i1,Z(1(#)))))
\replacewith(leq(i0,i1)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== left_add_mult_distrib (left_add_mult_distrib) =========================================
left_add_mult_distrib {
\find(add(mul(i0,i1),add(mul(i2,i1),i3)))
\replacewith(add(mul(add(i0,i2),i1),i3)) 

Choices: true}
-----------------------------------------------------
== lenNonNegative (lenNonNegative) =========================================
lenNonNegative {
\find(seqLen(seq))
\sameUpdateLevel\add [leq(Z(0(#)),seqLen(seq))]==>[] 
\heuristics(inReachableStateImplication)
Choices: sequences:on}
-----------------------------------------------------
== lenOfArray2seq (lenOfArray2seq) =========================================
lenOfArray2seq {
\find(seqLen(array2seq(h,a)))
\replacewith(length(a)) 

Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqConcat (lenOfSeqConcat) =========================================
lenOfSeqConcat {
\find(seqLen(seqConcat(seq,seq2)))
\replacewith(add(seqLen(seq),seqLen(seq2))) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqConcatEQ (lenOfSeqConcat) =========================================
lenOfSeqConcatEQ {
\assumes ([equals(seqConcat(seq,seq2),EQ)]==>[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(add(seqLen(seq),seqLen(seq2))) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqDef (lenOfSeqDef) =========================================
lenOfSeqDef {
\find(seqLen(seqDef{uSub (variable)}(from,to,t)))
\replacewith(if-then-else(lt(from,to),sub(to,from),Z(0(#)))) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqDefEQ (lenOfSeqDef) =========================================
lenOfSeqDefEQ {
\assumes ([equals(seqDef{uSub (variable)}(from,to,t),EQ)]==>[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(if-then-else(leq(from,to),sub(to,from),Z(0(#)))) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqEmpty (lenOfSeqEmpty) =========================================
lenOfSeqEmpty {
\find(seqLen(seqEmpty))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqEmptyEQ (lenOfSeqEmpty) =========================================
lenOfSeqEmptyEQ {
\assumes ([equals(seqEmpty,EQ)]==>[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqReverse (lenOfSeqReverse) =========================================
lenOfSeqReverse {
\find(seqLen(seqReverse(seq)))
\replacewith(seqLen(seq)) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqReverseEQ (lenOfSeqReverse) =========================================
lenOfSeqReverseEQ {
\assumes ([equals(seqReverse(seq),EQ)]==>[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(seqLen(seq)) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqSingleton (lenOfSeqSingleton) =========================================
lenOfSeqSingleton {
\find(seqLen(seqSingleton(x)))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqSingletonEQ (lenOfSeqSingleton) =========================================
lenOfSeqSingletonEQ {
\assumes ([equals(seqSingleton(x),EQ)]==>[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqSub (lenOfSeqSub) =========================================
lenOfSeqSub {
\find(seqLen(seqSub(seq,from,to)))
\replacewith(if-then-else(lt(from,to),sub(to,from),Z(0(#)))) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== lenOfSeqSubEQ (lenOfSeqSub) =========================================
lenOfSeqSubEQ {
\assumes ([equals(seqSub(seq,from,to),EQ)]==>[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(if-then-else(lt(from,to),sub(to,from),Z(0(#)))) 
\heuristics(find_term_not_in_assumes, simplify)
Choices: sequences:on}
-----------------------------------------------------
== lengthReplace (lengthReplace) =========================================
lengthReplace {
\find(seqLen(clReplace(str,searchChar,replaceChar)))
\replacewith(seqLen(str)) 
\heuristics(stringsSimplify)
Choices: Strings:on}
-----------------------------------------------------
== lengthReplaceEQ (lengthReplaceEQ) =========================================
lengthReplaceEQ {
\assumes ([equals(clReplace(str,searchChar,replaceChar),newStr)]==>[]) 
\find(seqLen(newStr))
\sameUpdateLevel\replacewith(seqLen(str)) 
\heuristics(stringsSimplify)
Choices: Strings:on}
-----------------------------------------------------
== leq_add (leq_add) =========================================
leq_add {
\find(==>leq(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==>[exists{j2 (variable)}(leq(add(i0,j2),add(i1,j2)))]) 

Choices: true}
-----------------------------------------------------
== leq_add_iff1 (leq_add_iff1) =========================================
leq_add_iff1 {
\find(leq(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(leq(add(mul(sub(i0,i3),i1),i2),i4)) 

Choices: true}
-----------------------------------------------------
== leq_add_iff2 (leq_add_iff2) =========================================
leq_add_iff2 {
\find(leq(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(leq(i2,add(mul(sub(i3,i0),i1),i4))) 

Choices: true}
-----------------------------------------------------
== leq_add_one (leq_add_one) =========================================
leq_add_one {
\find(leq(i0,i1))
\replacewith(leq(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: true}
-----------------------------------------------------
== leq_diff1_eq (leq_diff1_eq) =========================================
leq_diff1_eq {
\find(leq(i0,sub(i1,Z(1(#)))))
\replacewith(lt(i0,i1)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== leq_diff_1 (leq_diff_1) =========================================
leq_diff_1 {
\find(leq(i0,add(i0,Z(1(#)))))
\replacewith(true) 
\heuristics(int_arithmetic)
Choices: true}
-----------------------------------------------------
== leq_iff_diff_leq_0 (leq_iff_diff_leq_0) =========================================
leq_iff_diff_leq_0 {
\find(leq(i0,i1))
\replacewith(leq(sub(i0,i1),Z(0(#)))) 

Choices: true}
-----------------------------------------------------
== leq_literals (leq_literals) =========================================
leq_literals {
\find(leq(Z(iz),Z(jz)))
\replacewith(#leq(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== leq_to_geq (leq_to_geq) =========================================
leq_to_geq {
\find(leq(i,i0))
\replacewith(geq(i0,i)) 

Choices: true}
-----------------------------------------------------
== leq_to_gt (leq_to_gt) =========================================
leq_to_gt {
\find(leq(i,j))
\replacewith(not(gt(i,j))) 

Choices: true}
-----------------------------------------------------
== leq_to_gt_alt (leq_to_gt_alt) =========================================
leq_to_gt_alt {
\find(leq(i,j))
\replacewith(or(lt(i,j),equals(i,j))) 

Choices: true}
-----------------------------------------------------
== leq_trans (leq_trans) =========================================
leq_trans {
\assumes ([leq(i,i0)]==>[]) 
\find(leq(i0,i1)==>)
\add [leq(i,i1)]==>[] 

Choices: true}
-----------------------------------------------------
== less_1_mult (less_1_mult) =========================================
less_1_mult {
\find(and(lt(Z(1(#)),i0),lt(Z(1(#)),i1)))
\replacewith(lt(Z(1(#)),mul(i0,i1))) 

Choices: true}
-----------------------------------------------------
== less_add (less_add) =========================================
less_add {
\find(==>lt(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==>[exists{j2 (variable)}(lt(add(i0,j2),add(i1,j2)))]) 

Choices: true}
-----------------------------------------------------
== less_add_iff1 (less_add_iff1) =========================================
less_add_iff1 {
\find(lt(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(lt(add(mul(sub(i0,i3),i1),i2),i4)) 

Choices: true}
-----------------------------------------------------
== less_add_iff2 (less_add_iff2) =========================================
less_add_iff2 {
\find(lt(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(lt(i2,add(mul(sub(i3,i0),i1),i4))) 

Choices: true}
-----------------------------------------------------
== less_add_one (less_add_one) =========================================
less_add_one {
\find(lt(i0,i1))
\replacewith(lt(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: true}
-----------------------------------------------------
== less_base (less_base) =========================================
less_base {
\find(lt(i,i))
\replacewith(false) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== less_equal_than_comparison_new (less-or-equal than distinction) =========================================
less_equal_than_comparison_new {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 <= #senf1;
... }\] (post))
\replacewith(if-then-else(leq(#senf0,#senf1),#allmodal ( (modal operator))\[{ ..
  #lhs = true;
... }\] (post),#allmodal ( (modal operator))\[{ ..
  #lhs = false;
... }\] (post))) 
\heuristics(split_if, simplify_prog, obsolete)
Choices: programRules:Java}
-----------------------------------------------------
== less_equal_than_comparison_simple (less-or-equal than distinction) =========================================
less_equal_than_comparison_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 <= #senf1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(leq(#senf0,#senf1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== less_equal_than_comparison_simple_double (less-or-equal than distinction) =========================================
less_equal_than_comparison_simple_double {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seDouble0 <= #seDouble1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(leqDouble(#seDouble0,#seDouble1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== less_equal_than_comparison_simple_float (less-or-equal than distinction) =========================================
less_equal_than_comparison_simple_float {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seFloat0 <= #seFloat1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(leqFloat(#seFloat0,#seFloat1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== less_iff_diff_less_0 (less_iff_diff_less_0) =========================================
less_iff_diff_less_0 {
\find(lt(i0,i1))
\replacewith(lt(sub(i0,i1),Z(0(#)))) 

Choices: true}
-----------------------------------------------------
== less_is_alternative_1 (less_is_alternative_1) =========================================
less_is_alternative_1 {
\assumes ([lt(i,i0),lt(i0,i)]==>[]) 
\closegoal
Choices: true}
-----------------------------------------------------
== less_is_alternative_2 (less_is_alternative_2) =========================================
less_is_alternative_2 {
\assumes ([]==>[lt(i,i0)]) 
\find(==>lt(i0,i))
\add [equals(i,i0)]==>[] 

Choices: true}
-----------------------------------------------------
== less_is_total (less_is_total) =========================================
less_is_total {
\find(i)
\sameUpdateLevel\add [lt(i0,i)]==>[] ;
\add [equals(i,i0)]==>[] ;
\add [lt(i,i0)]==>[] 

Choices: true}
-----------------------------------------------------
== less_is_total_heu (less_is_total_heu) =========================================
less_is_total_heu {
\assumes ([]==>[lt(i,i0),equals(i,i0),lt(i0,i)]) 
\closegoal
Choices: true}
-----------------------------------------------------
== less_literals (less_literals) =========================================
less_literals {
\find(lt(Z(iz),Z(jz)))
\replacewith(#less(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== less_neg (less_neg) =========================================
less_neg {
\find(lt(i,i0))
\replacewith(not(lt(i0,add(i,Z(1(#)))))) 

Choices: true}
-----------------------------------------------------
== less_plus (less_plus) =========================================
less_plus {
\find(lt(Z(0(#)),add(i0,i1)))
\replacewith(lt(neg(i0),i1)) 

Choices: true}
-----------------------------------------------------
== less_sub (less_sub) =========================================
less_sub {
\find(lt(i,i0))
\replacewith(lt(neg(i0),neg(i))) 

Choices: true}
-----------------------------------------------------
== less_than_comparison_new (lesser than distinction) =========================================
less_than_comparison_new {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 < #senf1;
... }\] (post))
\replacewith(if-then-else(lt(#senf0,#senf1),#allmodal ( (modal operator))\[{ ..
  #lhs = true;
... }\] (post),#allmodal ( (modal operator))\[{ ..
  #lhs = false;
... }\] (post))) 
\heuristics(split_if, simplify_prog, obsolete)
Choices: programRules:Java}
-----------------------------------------------------
== less_than_comparison_simple (lesser than distinction) =========================================
less_than_comparison_simple {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #senf0 < #senf1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(lt(#senf0,#senf1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== less_than_comparison_simple_double (lesser than distinction) =========================================
less_than_comparison_simple_double {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seDouble0 < #seDouble1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(ltDouble(#seDouble0,#seDouble1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== less_than_comparison_simple_float (lesser than distinction) =========================================
less_than_comparison_simple_float {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #seFloat0 < #seFloat1;
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(ltFloat(#seFloat0,#seFloat1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== less_trans (less_trans) =========================================
less_trans {
\assumes ([lt(i,i0)]==>[]) 
\find(lt(i0,i1)==>)
\add [lt(i,i1)]==>[] 

Choices: true}
-----------------------------------------------------
== less_zero_is_total (less_zero_is_total) =========================================
less_zero_is_total {
\find(i)
\sameUpdateLevel\add [lt(Z(0(#)),i)]==>[] ;
\add [equals(i,Z(0(#)))]==>[] ;
\add [lt(i,Z(0(#)))]==>[] 

Choices: true}
-----------------------------------------------------
== local_cut (local_cut) =========================================
local_cut {
\find(phi)
\replacewith(and(or(not(psi),phi),or(psi,phi))) 

Choices: true}
-----------------------------------------------------
== log1Concrete (log1Concrete) =========================================
log1Concrete {
\find(log(base,Z(1(#))))
\replacewith(if-then-else(gt(base,Z(1(#))),Z(0(#)),undefinedLog(base,Z(1(#))))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== logDefinition (logDefinition) =========================================
logDefinition {
\find(log(base,x))
\replacewith(if-then-else(and(geq(x,Z(1(#))),gt(base,Z(1(#)))),if-then-else(lt(x,base),Z(0(#)),add(Z(1(#)),log(base,div(x,base)))),undefinedLog(base,x))) 

Choices: true}
-----------------------------------------------------
== logLessThanPow (logLessThanPow) =========================================
logLessThanPow {
\find(lt(log(base,x),exp))
\add [imp(and(and(and(gt(base,Z(1(#))),geq(x,Z(1(#)))),lt(x,pow(base,exp))),geq(exp,Z(1(#)))),lt(log(base,x),exp))]==>[] 

Choices: true}
-----------------------------------------------------
== logLessThanPowConcrete (logLessThanPowConcrete) =========================================
logLessThanPowConcrete {
\find(==>lt(log(base,x),exp))
\add []==>[and(and(and(gt(base,Z(1(#))),geq(x,Z(1(#)))),lt(x,pow(base,exp))),geq(exp,Z(1(#))))] 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== logMono (logMono) =========================================
logMono {
\find(leq(log(base,x),log(base,x_2)))
\add [imp(and(and(geq(x,Z(1(#))),geq(x_2,x)),gt(base,Z(1(#)))),leq(log(base,x),log(base,x_2)))]==>[] 

Choices: true}
-----------------------------------------------------
== logMonoConcrete (logMonoConcrete) =========================================
logMonoConcrete {
\find(leq(log(base,x_2),add(Z(neglit(1(#))),log(base,x)))==>)
\add []==>[and(and(geq(x,Z(1(#))),geq(x_2,x)),gt(base,Z(1(#))))] 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== logPositive (logPositive) =========================================
logPositive {
\find(log(base,x))
\add [imp(and(gt(base,Z(1(#))),geq(x,Z(1(#)))),geq(log(base,x),Z(0(#))))]==>[] 

Choices: true}
-----------------------------------------------------
== logPositiveConcrete (logPositiveConcrete) =========================================
logPositiveConcrete {
\find(leq(log(base,x),Z(neglit(1(#))))==>)
\add []==>[and(gt(base,Z(1(#))),geq(x,Z(1(#))))] 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== logPowIdentity (logPowIdentity) =========================================
logPowIdentity {
\find(log(base,x))
\varcond(\notFreeIn(i (variable), base (int term)), \notFreeIn(i (variable), x (int term)))
\add [imp(gt(base,Z(1(#))),all{i (variable)}(imp(geq(i,Z(0(#))),equals(log(base,pow(base,i)),i))))]==>[] 

Choices: true}
-----------------------------------------------------
== logPowIdentityConcrete (logPowIdentityConcrete) =========================================
logPowIdentityConcrete {
\find(log(base,pow(base,exp)))
\replacewith(if-then-else(gt(base,Z(1(#))),if-then-else(geq(exp,Z(0(#))),exp,log(base,undefinedPow(base,exp))),undefinedLog(base,pow(base,exp)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== logProdIdentity (logProdIdentity) =========================================
logProdIdentity {
\find(log(base,bprod{i (variable)}(Z(0(#)),exp,base)))
\varcond(\notFreeIn(i (variable), base (int term)), \notFreeIn(i (variable), exp (int term)))
\add [imp(and(geq(exp,Z(0(#))),gt(base,Z(1(#)))),equals(log(base,bprod{i (variable)}(Z(0(#)),exp,base)),exp))]==>[] 

Choices: true}
-----------------------------------------------------
== logProdIdentityConcrete (logProdIdentityConcrete) =========================================
logProdIdentityConcrete {
\find(log(base,bprod{i (variable)}(Z(0(#)),exp,base)))
\varcond(\notFreeIn(i (variable), base (int term)), \notFreeIn(i (variable), exp (int term)))
\replacewith(if-then-else(gt(base,Z(1(#))),if-then-else(lt(exp,Z(0(#))),Z(0(#)),exp),undefinedLog(base,bprod{i (variable)}(Z(0(#)),exp,base)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== logProduct (logProduct) =========================================
logProduct {
\find(log(base,mul(x,base)))
\add [imp(and(geq(x,Z(1(#))),gt(base,Z(1(#)))),equals(log(base,mul(x,base)),add(log(base,x),Z(1(#)))))]==>[] 

Choices: true}
-----------------------------------------------------
== logSelfConcrete (logSelfConcrete) =========================================
logSelfConcrete {
\find(log(base,base))
\replacewith(if-then-else(gt(base,Z(1(#))),Z(1(#)),undefinedLog(base,base))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== logSqueeze (logSqueeze) =========================================
logSqueeze {
\find(equals(log(base,x),exp))
\add [imp(and(and(and(and(gt(base,Z(1(#))),geq(x,Z(1(#)))),geq(x,pow(base,exp))),lt(x,pow(base,add(exp,Z(1(#)))))),geq(exp,Z(0(#)))),equals(log(base,x),exp))]==>[] 

Choices: true}
-----------------------------------------------------
== logTimesBaseConcrete (logTimesBaseConcrete) =========================================
logTimesBaseConcrete {
\find(log(base,mul(x,base)))
\replacewith(if-then-else(and(geq(x,Z(1(#))),gt(base,Z(1(#)))),add(log(base,x),Z(1(#))),undefinedLog(base,mul(x,base)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== loopScopeInvBox (loopScopeInvBox) =========================================
loopScopeInvBox {
\find(#box ( (modal operator))\[{ ..
  while (#nse) #body
... }\] (post))
\varcond(\new(#permissionsBefore_LOOP (program Variable), KeYJavaType:null,Heap), \new(#savedHeapBefore_LOOP (program Variable), KeYJavaType:null,Heap), \new(#heapBefore_LOOP (program Variable), KeYJavaType:null,Heap), \new(#x (program Variable), (type, sort): (boolean,boolean)), \varcond (\storeTermIn(loopFormula (formula), #box ( (modal operator))\[{
  while (#nse) #body
}\] (post))), \varcond (\storeStmtIn(#loopStmt (program Statement), #box ( (modal operator))\[{
  while (#nse) #body
}\] (post))), \hasInvariant(#loopStmt (program Statement)), \getInvariant(#loopStmt (program Statement), #box ( (modal operator)), inv (formula)), \getFreeInvariant(#loopStmt (program Statement), #box ( (modal operator)), freeInv (formula)), )
\add [#wellFormedCond(loopFormula,anon_heap_LOOP,anon_savedHeap_LOOP,anon_permissions_LOOP)]==>[] \replacewith(update-application(parallel-upd(parallel-upd(#createBeforeLoopUpdate(loopFormula,#heapBefore_LOOP,#savedHeapBefore_LOOP,#permissionsBefore_LOOP),#createLocalAnonUpdate(loopFormula)),#createHeapAnonUpdate(loopFormula,anon_heap_LOOP,anon_savedHeap_LOOP,anon_permissions_LOOP)),imp(and(inv,freeInv),#box ( (modal operator))\[{ ..
  boolean #x;
  loop-scope (#x) {
    if (#nse) {
      #body
      continue;
    } else {
      break;
    }
  }
... }\] (and(imp(equals(#x<<loopScopeIndex>>,TRUE),post),imp(equals(#x<<loopScopeIndex>>,FALSE),and(inv,#createFrameCond(loopFormula,#heapBefore_LOOP,#savedHeapBefore_LOOP,#permissionsBefore_LOOP)))))))) ;
\replacewith(inv) 
\heuristics(loop_scope_inv_taclet)
Choices: (programRules:Java & javaLoopTreatment:efficient)}
-----------------------------------------------------
== loopScopeInvDia (loopScopeInvDia) =========================================
loopScopeInvDia {
\find(#dia ( (modal operator))\[{ ..
  while (#nse) #body
... }\] (post))
\varcond(\new(#permissionsBefore_LOOP (program Variable), KeYJavaType:null,Heap), \new(#savedHeapBefore_LOOP (program Variable), KeYJavaType:null,Heap), \new(#heapBefore_LOOP (program Variable), KeYJavaType:null,Heap), \new(#variant (program Variable), KeYJavaType:null,any), \new(#x (program Variable), (type, sort): (boolean,boolean)), \varcond (\storeTermIn(loopFormula (formula), #dia ( (modal operator))\[{
  while (#nse) #body
}\] (post))), \varcond (\storeStmtIn(#loopStmt (program Statement), #dia ( (modal operator))\[{
  while (#nse) #body
}\] (post))), \hasInvariant(#loopStmt (program Statement)), \getInvariant(#loopStmt (program Statement), #dia ( (modal operator)), inv (formula)), \getFreeInvariant(#loopStmt (program Statement), #dia ( (modal operator)), freeInv (formula)), \getVariant(#loopStmt (program Statement), variantTerm (any term)), )
\add [#wellFormedCond(loopFormula,anon_heap_LOOP,anon_savedHeap_LOOP,anon_permissions_LOOP)]==>[] \replacewith(update-application(parallel-upd(parallel-upd(#createBeforeLoopUpdate(loopFormula,#heapBefore_LOOP,#savedHeapBefore_LOOP,#permissionsBefore_LOOP),#createLocalAnonUpdate(loopFormula)),#createHeapAnonUpdate(loopFormula,anon_heap_LOOP,anon_savedHeap_LOOP,anon_permissions_LOOP)),update-application(elem-update(#variant (program Variable))(variantTerm),imp(and(inv,freeInv),#dia ( (modal operator))\[{ ..
  boolean #x;
  loop-scope (#x) {
    if (#nse) {
      #body
      continue;
    } else {
      break;
    }
  }
... }\] (and(imp(equals(#x<<loopScopeIndex>>,TRUE),post),imp(equals(#x<<loopScopeIndex>>,FALSE),and(and(inv,#createFrameCond(loopFormula,#heapBefore_LOOP,#savedHeapBefore_LOOP,#permissionsBefore_LOOP)),prec(variantTerm,#variant))))))))) ;
\replacewith(inv) 
\heuristics(loop_scope_inv_taclet)
Choices: (programRules:Java & javaLoopTreatment:efficient)}
-----------------------------------------------------
== loopUnwind (loopUnwind) =========================================
loopUnwind {
\find(#allmodal ( (modal operator))\[{ ..
  while (#e) #s
... }\] (post))
\varcond(\newLabel (#innerLabel (program Label)), \newLabel (#outerLabel (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #unwind-loop(while (#e) #s)
... }\] (post)) 
\heuristics(loop_expand)
Choices: programRules:Java}
-----------------------------------------------------
== lsBreak (lsBreak) =========================================
lsBreak {
\find(#allmodal ( (modal operator))\[{ ..
  loop-scope (#lhs) {
    break;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = true;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lsContinue (lsContinue) =========================================
lsContinue {
\find(#allmodal ( (modal operator))\[{ ..
  loop-scope (#lhs) {
    continue;
    #slist
  }
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(FALSE),post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lsLblBreak (lsLblBreak) =========================================
lsLblBreak {
\find(#allmodal ( (modal operator))\[{ ..
  loop-scope (#lhs) {
    break;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #lhs = true;
    break;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lsLblContinueMatch (lsLblContinueMatch) =========================================
lsLblContinueMatch {
\find(#allmodal ( (modal operator))\[{ ..
  #lb:
  loop-scope (#lhs) {
    continue;
    #slist
  }
... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(FALSE),post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lsLblContinueNoMatch1 (lsLblContinueNoMatch1) =========================================
lsLblContinueNoMatch1 {
\find(#allmodal ( (modal operator))\[{ ..
  loop-scope (#lhs) {
    continue;
    #slist
  }
... }\] (post))
\varcond(\varcond (\storeStmtIn(#lsStmt (program Statement), #allmodal ( (modal operator))\[{
  loop-scope (#lhs) {
    continue;
    #slist
  }
}\] (post))), \varcond (\not\isLabeled(#lsStmt (program Statement)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = true;
  continue;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lsLblContinueNoMatch2 (lsLblContinueNoMatch2) =========================================
lsLblContinueNoMatch2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lb1:
  loop-scope (#lhs) {
    continue;
    #slist
  }
... }\] (post))
\varcond(\different (#lb1 (program Label), #lb (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = true;
  continue;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lsReturnNonVoid (lsReturnNonVoid) =========================================
lsReturnNonVoid {
\find(#allmodal ( (modal operator))\[{ ..
  loop-scope (#lhs) {
    return #se;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = true;
  return #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lsReturnVoid (lsReturnVoid) =========================================
lsReturnVoid {
\find(#allmodal ( (modal operator))\[{ ..
  loop-scope (#lhs) {
    return;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = true;
  return;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lsThrow (lsThrow) =========================================
lsThrow {
\find(#allmodal ( (modal operator))\[{ ..
  loop-scope (#lhs) {
    throw #se;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = true;
  throw #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== lt_diff_1 (lt_diff_1) =========================================
lt_diff_1 {
\find(lt(i0,add(i0,Z(1(#)))))
\replacewith(true) 
\heuristics(int_arithmetic)
Choices: true}
-----------------------------------------------------
== lt_to_gt (lt_to_gt) =========================================
lt_to_gt {
\find(lt(i,i0))
\replacewith(gt(i0,i)) 

Choices: true}
-----------------------------------------------------
== lt_to_leq_1 (lt_to_leq_1) =========================================
lt_to_leq_1 {
\find(or(lt(i,j),equals(i,j)))
\replacewith(leq(i,j)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== lt_to_leq_2 (lt_to_leq_2) =========================================
lt_to_leq_2 {
\assumes ([]==>[lt(i,j)]) 
\find(==>equals(i,j))
\replacewith([]==>[leq(i,j)]) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== make_insert_eq (make_insert_eq) =========================================
make_insert_eq {
\find(equals(sr,tr)==>)
\addrules [insert_eq {
\find(sr)
\replacewith(tr) 

Choices: true}] 

Choices: true}
-----------------------------------------------------
== make_insert_eq_nonrigid (make_insert_eq_nonrigid) =========================================
make_insert_eq_nonrigid {
\find(equals(s,t)==>)
\addrules [insert_eq_nonrigid {
\find(s)
\sameUpdateLevel\replacewith(t) 

Choices: true}] 

Choices: true}
-----------------------------------------------------
== mapEqualityRight (mapEqualityRight) =========================================
mapEqualityRight {
\find(==>equals(m0,m1))
\varcond(\notFreeIn(vy (variable), m1 (Map term)), \notFreeIn(vy (variable), m0 (Map term)))
\replacewith([]==>[all{vy (variable)}(and(equiv(inDomain(m0,vy),inDomain(m1,vy)),imp(inDomain(m0,vy),equals(mapGet(m0,vy),mapGet(m1,vy)))))]) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== mapRemoveUnchanged (mapRemoveUnchanged) =========================================
mapRemoveUnchanged {
\find(equals(m,mapRemove(m,key)))
\replacewith(not(inDomain(m,key))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== mapRemoveUnchanged2 (mapRemoveUnchanged2) =========================================
mapRemoveUnchanged2 {
\find(equals(mapRemove(m,key),m))
\replacewith(not(inDomain(m,key))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== mapSizeNotNegativeForFiniteMaps (mapSizeNotNegativeForFiniteMaps) =========================================
mapSizeNotNegativeForFiniteMaps {
\find(mapSize(m))
\add [imp(isFinite(m),geq(mapSize(m),Z(0(#))))]==>[] 
\heuristics(inReachableStateImplication)
Choices: true}
-----------------------------------------------------
== mapUpdateUnchanged (mapUpdateUnchanged) =========================================
mapUpdateUnchanged {
\find(equals(m,mapUpdate(m,key,value)))
\replacewith(and(inDomain(m,key),equals(mapGet(m,key),value))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== mapUpdateUnchanged2 (mapUpdateUnchanged2) =========================================
mapUpdateUnchanged2 {
\find(equals(mapUpdate(m,key,value),m))
\replacewith(and(inDomain(m,key),equals(mapGet(m,key),value))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== maxAxiom (maxAxiom) =========================================
maxAxiom {
\find(equals(max{x (variable)}(b,t),t2)==>)
\varcond(\notFreeIn(y (variable), t2 (int term)), \notFreeIn(y (variable), t (int term)), \notFreeIn(y (variable), b (boolean term)), \notFreeIn(x (variable), t2 (int term)))
\add []==>[exists{x (variable)}(and(equals(b,TRUE),all{y (variable)}(imp(equals(subst{x (variable)}(y,b),TRUE),leq(subst{x (variable)}(y,t),t)))))] ;
\add [and(all{y (variable)}(subst{x (variable)}(y,imp(equals(b,TRUE),leq(t,t2)))),exists{y (variable)}(subst{x (variable)}(y,and(equals(b,TRUE),equals(t,t2)))))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== measuredByCheck (measuredByCheck) =========================================
measuredByCheck {
\assumes ([measuredBy(m)]==>[]) 
\find(measuredByCheck(c))
\sameUpdateLevel\replacewith(prec(c,m)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== measuredByCheckEmpty (measuredByCheckEmpty) =========================================
measuredByCheckEmpty {
\assumes ([measuredByEmpty]==>[]) 
\find(measuredByCheck(c))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== memsetEmpty (memsetEmpty) =========================================
memsetEmpty {
\find(memset(h,empty,x))
\replacewith(h) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== methodBodyExpand (methodBodyExpand) =========================================
methodBodyExpand {
\find(#allmodal ( (modal operator))\[{ ..
  #mb
... }\] (post))
\replacewith(#introAtPreDefs(#allmodal ( (modal operator))\[{ ..
  expand-method-body(#mb)
... }\] (post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== methodCall (methodCall) =========================================
methodCall {
\find(==>#allmodal ( (modal operator))\[{ ..
  #se.#mn(#selist);
... }\] (post))
\varcond(\not \staticMethodReference(#se (program SimpleExpression), #mn (program MethodName), #selist (program SimpleExpression)), \mayExpandMethod(#se (program SimpleExpression), #mn (program MethodName), #selist (program SimpleExpression)), )
\add [equals(#se,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  method-call(#se.#mn(#selist))
... }\] (post)]) 
\heuristics(method_expand)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== methodCallEmpty (methodCallEmpty) =========================================
methodCallEmpty {
\find(#allmodal ( (modal operator))\[{ ..
  method-frame (#ex) {}
... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallEmptyNoreturnBox (methodCallEmpty) =========================================
methodCallEmptyNoreturnBox {
\find(\[{ ..
  method-frame (result->#v0, #ex) {}
... }\] (post))
\replacewith(box(post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallEmptyReturn (methodCallReturn) =========================================
methodCallEmptyReturn {
\find(#allmodal ( (modal operator))\[{ ..
  method-frame (#ex) {
    return;
    #slist
  }
... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallParamThrow (methodCallThrow) =========================================
methodCallParamThrow {
\find(#allmodal ( (modal operator))\[{ ..
  method-frame (result->#v0, #ex) {
    throw #se;
    #slist
  }
... }\] (post))
\varcond(\isLocalVariable (#se (program SimpleExpression)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  throw #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallReturn (methodCallReturn) =========================================
methodCallReturn {
\find(#allmodal ( (modal operator))\[{ ..
  method-frame (result->#v0, #ex) {
    return #se;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  method-frame (#ex) {
    #v0 = #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallReturnIgnoreResult (methodCallReturn) =========================================
methodCallReturnIgnoreResult {
\find(#allmodal ( (modal operator))\[{ ..
  method-frame (#ex) {
    return #se;
    #slist
  }
... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallSuper (methodCallSuper) =========================================
methodCallSuper {
\find(#allmodal ( (modal operator))\[{ ..
  super.#mn(#elist);
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  method-call(super.#mn(#elist))
... }\] (post)) 
\heuristics(method_expand, simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallThrow (methodCallThrow) =========================================
methodCallThrow {
\find(#allmodal ( (modal operator))\[{ ..
  method-frame (#ex) {
    throw #se;
    #slist
  }
... }\] (post))
\varcond(\isLocalVariable (#se (program SimpleExpression)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  throw #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallUnfoldArguments (methodCallUnfoldArguments) =========================================
methodCallUnfoldArguments {
\find(#allmodal ( (modal operator))\[{ ..
  #nsmr
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #evaluate-arguments(#nsmr)
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallUnfoldTarget (methodCallUnfoldTarget) =========================================
methodCallUnfoldTarget {
\find(#allmodal ( (modal operator))\[{ ..
  #nse.#mn(#elist);
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0;
  #v0 = #nse;
  #v0.#mn(#elist);
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallWithAssignment (methodCallWithAssignment) =========================================
methodCallWithAssignment {
\find(==>#allmodal ( (modal operator))\[{ ..
  #lhs = #se.#mn(#selist);
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))), \not \staticMethodReference(#se (program SimpleExpression), #mn (program MethodName), #selist (program SimpleExpression)), \mayExpandMethod(#se (program SimpleExpression), #mn (program MethodName), #selist (program SimpleExpression)), )
\add [equals(#se,null)]==>[] \replacewith([]==>[false]) ;
\replacewith([]==>[#allmodal ( (modal operator))\[{ ..
  #typeof(#lhs) #v0;
  method-call(#se.#mn(#selist))
  #lhs = #v0;
... }\] (post)]) 
\heuristics(method_expand)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== methodCallWithAssignmentSuper (methodCallSuper) =========================================
methodCallWithAssignmentSuper {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = super.#mn(#elist);
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#lhs) #v0;
  method-call(super.#mn(#elist))
  #lhs = #v0;
... }\] (post)) 
\heuristics(method_expand, simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallWithAssignmentUnfoldArguments (methodCallUnfoldArguments) =========================================
methodCallWithAssignmentUnfoldArguments {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nsmr;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #evaluate-arguments(#lhs = #nsmr)
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallWithAssignmentUnfoldTarget (methodCallUnfoldTarget) =========================================
methodCallWithAssignmentUnfoldTarget {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #nse.#mn(#elist);
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0;
  #v0 = #nse;
  #lhs = #v0.#mn(#elist);
... }\] (post)) 
\heuristics(simplify_autoname)
Choices: programRules:Java}
-----------------------------------------------------
== methodCallWithAssignmentWithinClass (methodCall) =========================================
methodCallWithAssignmentWithinClass {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #mn(#elist);
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))), \mayExpandMethod(null, #mn (program MethodName), #elist (program Expression)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#lhs) #v0;
  method-call(#mn(#elist))
  #lhs = #v0;
... }\] (post)) 
\heuristics(method_expand)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== methodCallWithinClass (methodCall) =========================================
methodCallWithinClass {
\find(#allmodal ( (modal operator))\[{ ..
  #mn(#elist);
... }\] (post))
\varcond(\mayExpandMethod(null, #mn (program MethodName), #elist (program Expression)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  method-call(#mn(#elist))
... }\] (post)) 
\heuristics(method_expand)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== minAxiom (minAxiom) =========================================
minAxiom {
\find(equals(min{x (variable)}(b,t),t2)==>)
\varcond(\notFreeIn(y (variable), t2 (int term)), \notFreeIn(y (variable), t (int term)), \notFreeIn(y (variable), b (boolean term)), \notFreeIn(x (variable), t2 (int term)))
\add []==>[exists{x (variable)}(and(equals(b,TRUE),all{y (variable)}(imp(equals(subst{x (variable)}(y,b),TRUE),geq(subst{x (variable)}(y,t),t)))))] ;
\add [and(all{y (variable)}(subst{x (variable)}(y,imp(equals(b,TRUE),geq(t,t2)))),exists{y (variable)}(subst{x (variable)}(y,and(equals(b,TRUE),equals(t,t2)))))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== minus_distribute_1 (minus_distribute) =========================================
minus_distribute_1 {
\find(neg(add(i,i1)))
\replacewith(add(neg(i),neg(i1))) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== minus_distribute_2 (minus_distribute) =========================================
minus_distribute_2 {
\find(neg(sub(i,i1)))
\replacewith(add(neg(i),i1)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== mod_axiom (mod_axiom) =========================================
mod_axiom {
\find(mod(divNum,divDenom))
\replacewith(add(divNum,mul(mul(div(divNum,divDenom),Z(neglit(1(#)))),divDenom))) 
\heuristics(notHumanReadable, defOps_mod)
Choices: true}
-----------------------------------------------------
== mod_geZero (mod_geZero) =========================================
mod_geZero {
\find(mod(divNum,divDenom))
\add [imp(not(equals(divDenom,Z(0(#)))),leq(Z(0(#)),mod(divNum,divDenom)))]==>[] 

Choices: true}
-----------------------------------------------------
== mod_homoEq (mod_homoEq) =========================================
mod_homoEq {
\find(equals(mod(modNumLeft,modDenom),mod(modNumRight,modDenom)))
\replacewith(equals(mod(sub(modNumLeft,modNumRight),modDenom),Z(0(#)))) 
\heuristics(notHumanReadable, defOps_modHomoEq)
Choices: true}
-----------------------------------------------------
== mod_lessDenom (mod_lessDenom) =========================================
mod_lessDenom {
\find(mod(divNum,divDenom))
\add [imp(not(equals(divDenom,Z(0(#)))),lt(mod(divNum,divDenom),if-then-else(geq(divDenom,Z(0(#))),divDenom,neg(divDenom))))]==>[] 

Choices: true}
-----------------------------------------------------
== moduloByteFixpoint (moduloByteFixpoint) =========================================
moduloByteFixpoint {
\assumes ([inRangeByte(i)]==>[]) 
\find(moduloByte(i))
\sameUpdateLevel\replacewith(i) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== moduloByteFixpointInline (moduloByteFixpointInline) =========================================
moduloByteFixpointInline {
\find(moduloByte(i))
\sameUpdateLevel\add [equals(if-then-else(inRangeByte(i),i,moduloT),moduloT),equals(moduloByte(i),moduloT)]==>[] \replacewith(moduloT) 

Choices: true}
-----------------------------------------------------
== moduloByteIsInByte (moduloByteIsInByte) =========================================
moduloByteIsInByte {
\find(inByte(moduloByte(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloByteIsInRangeByte (moduloByteIsInRangeByte) =========================================
moduloByteIsInRangeByte {
\find(inRangeByte(moduloByte(i)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloCharFixpoint (moduloCharFixpoint) =========================================
moduloCharFixpoint {
\assumes ([inRangeChar(i)]==>[]) 
\find(moduloChar(i))
\sameUpdateLevel\replacewith(i) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== moduloCharFixpointInline (moduloCharFixpointInline) =========================================
moduloCharFixpointInline {
\find(moduloChar(i))
\sameUpdateLevel\add [equals(if-then-else(inRangeChar(i),i,moduloT),moduloT),equals(moduloChar(i),moduloT)]==>[] \replacewith(moduloT) 

Choices: true}
-----------------------------------------------------
== moduloCharIsInChar (moduloCharIsInChar) =========================================
moduloCharIsInChar {
\find(inChar(moduloChar(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloCharIsInRangeChar (moduloCharIsInRangeChar) =========================================
moduloCharIsInRangeChar {
\find(inRangeChar(moduloChar(i)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloIntFixpoint (moduloIntFixpoint) =========================================
moduloIntFixpoint {
\assumes ([inRangeInt(i)]==>[]) 
\find(moduloInt(i))
\sameUpdateLevel\replacewith(i) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== moduloIntFixpointInline (moduloIntFixpointInline) =========================================
moduloIntFixpointInline {
\find(moduloInt(i))
\sameUpdateLevel\add [equals(if-then-else(inRangeInt(i),i,moduloT),moduloT),equals(moduloInt(i),moduloT)]==>[] \replacewith(moduloT) 

Choices: true}
-----------------------------------------------------
== moduloIntIsInInt (moduloIntIsInInt) =========================================
moduloIntIsInInt {
\find(inInt(moduloInt(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloIntIsInRangeInt (moduloIntIsInRangeInt) =========================================
moduloIntIsInRangeInt {
\find(inRangeInt(moduloInt(i)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloLongFixpoint (moduloLongFixpoint) =========================================
moduloLongFixpoint {
\assumes ([inRangeLong(i)]==>[]) 
\find(moduloLong(i))
\sameUpdateLevel\replacewith(i) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== moduloLongFixpointInline (moduloLongFixpointInline) =========================================
moduloLongFixpointInline {
\find(moduloLong(i))
\sameUpdateLevel\add [equals(if-then-else(inRangeLong(i),i,moduloT),moduloT),equals(moduloLong(i),moduloT)]==>[] \replacewith(moduloT) 

Choices: true}
-----------------------------------------------------
== moduloLongIsInLong (moduloLongIsInLong) =========================================
moduloLongIsInLong {
\find(inLong(moduloLong(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloLongIsInRangeLong (moduloLongIsInRangeLong) =========================================
moduloLongIsInRangeLong {
\find(inRangeLong(moduloLong(i)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloShortFixpoint (moduloShortFixpoint) =========================================
moduloShortFixpoint {
\assumes ([inRangeShort(i)]==>[]) 
\find(moduloShort(i))
\sameUpdateLevel\replacewith(i) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== moduloShortFixpointInline (moduloShortFixpointInline) =========================================
moduloShortFixpointInline {
\find(moduloShort(i))
\sameUpdateLevel\add [equals(if-then-else(inRangeShort(i),i,moduloT),moduloT),equals(moduloShort(i),moduloT)]==>[] \replacewith(moduloT) 

Choices: true}
-----------------------------------------------------
== moduloShortIsInRangeShort (moduloShortIsInRangeShort) =========================================
moduloShortIsInRangeShort {
\find(inRangeShort(moduloShort(i)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== moduloShortIsInShort (moduloShortIsInShort) =========================================
moduloShortIsInShort {
\find(inShort(moduloShort(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== mul_assoc (mul_assoc) =========================================
mul_assoc {
\find(mul(mul(i,i0),i1))
\replacewith(mul(i,mul(i0,i1))) 

Choices: true}
-----------------------------------------------------
== mul_comm (mul_comm) =========================================
mul_comm {
\find(mul(i0,i1))
\replacewith(mul(i1,i0)) 

Choices: true}
-----------------------------------------------------
== mul_distribute_4 (multiply_distribute) =========================================
mul_distribute_4 {
\find(mul(i0,add(i1,i2)))
\replacewith(add(mul(i0,i1),mul(i0,i2))) 

Choices: true}
-----------------------------------------------------
== mul_distribute_5 (multiply_distribute) =========================================
mul_distribute_5 {
\find(mul(add(i1,i2),i0))
\replacewith(add(mul(i0,i1),mul(i0,i2))) 

Choices: true}
-----------------------------------------------------
== mul_literals (mul_literals) =========================================
mul_literals {
\find(mul(Z(iz),Z(jz)))
\replacewith(#mul(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== mult_eq_1_iff (mult_eq_1_iff) =========================================
mult_eq_1_iff {
\find(equals(mul(i0,i1),Z(1(#))))
\replacewith(or(and(equals(i0,Z(1(#))),equals(i1,Z(1(#)))),and(equals(i0,Z(neglit(1(#)))),equals(i1,Z(neglit(1(#))))))) 

Choices: true}
-----------------------------------------------------
== mult_eq_self_iff (mult_eq_self_iff) =========================================
mult_eq_self_iff {
\find(equals(i0,mul(i0,i1)))
\replacewith(or(equals(i0,Z(0(#))),equals(i1,Z(1(#))))) 

Choices: true}
-----------------------------------------------------
== mult_leq_0_iff (mult_leq_0_iff) =========================================
mult_leq_0_iff {
\find(leq(mul(i0,i1),Z(0(#))))
\replacewith(or(and(leq(i0,Z(0(#))),leq(Z(0(#)),i1)),and(leq(Z(0(#)),i0),leq(i1,Z(0(#)))))) 

Choices: true}
-----------------------------------------------------
== mult_less_0_iff (mult_less_0_iff) =========================================
mult_less_0_iff {
\find(lt(mul(i0,i1),Z(0(#))))
\replacewith(or(and(lt(i0,Z(0(#))),lt(Z(0(#)),i1)),and(lt(Z(0(#)),i0),lt(i1,Z(0(#)))))) 

Choices: true}
-----------------------------------------------------
== mult_neg (mult_neg) =========================================
mult_neg {
\find(and(lt(i0,Z(0(#))),lt(i1,Z(0(#)))))
\replacewith(lt(Z(0(#)),mul(i0,i1))) 

Choices: true}
-----------------------------------------------------
== mult_pos (mult_pos) =========================================
mult_pos {
\find(and(lt(Z(0(#)),i0),lt(Z(0(#)),i1)))
\replacewith(lt(Z(0(#)),mul(i0,i1))) 

Choices: true}
-----------------------------------------------------
== mult_pos_neg (mult_pos_neg) =========================================
mult_pos_neg {
\find(and(lt(i0,Z(0(#))),lt(Z(0(#)),i1)))
\replacewith(lt(mul(i0,i1),Z(0(#)))) 

Choices: true}
-----------------------------------------------------
== multiply_2_inEq0 (multiply_2_inEq0) =========================================
multiply_2_inEq0 {
\assumes ([leq(multFacLeft,multFacRight)]==>[]) 
\find(leq(multLeft,multRight)==>)
\add [geq(mul(multLeft,multFacLeft),add(add(mul(neg(multRight),multFacRight),mul(multRight,multFacLeft)),mul(multLeft,multFacRight)))]==>[] 
\heuristics(inEqSimp_nonLin_multiply, inEqSimp_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== multiply_2_inEq1 (multiply_2_inEq1) =========================================
multiply_2_inEq1 {
\assumes ([geq(multFacLeft,multFacRight)]==>[]) 
\find(leq(multLeft,multRight)==>)
\add [leq(mul(multLeft,multFacLeft),add(add(mul(neg(multRight),multFacRight),mul(multRight,multFacLeft)),mul(multLeft,multFacRight)))]==>[] 
\heuristics(inEqSimp_nonLin_multiply, inEqSimp_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== multiply_2_inEq2 (multiply_2_inEq2) =========================================
multiply_2_inEq2 {
\assumes ([leq(multFacLeft,multFacRight)]==>[]) 
\find(geq(multLeft,multRight)==>)
\add [leq(mul(multLeft,multFacLeft),add(add(mul(neg(multRight),multFacRight),mul(multRight,multFacLeft)),mul(multLeft,multFacRight)))]==>[] 
\heuristics(inEqSimp_nonLin_multiply, inEqSimp_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== multiply_2_inEq3 (multiply_2_inEq3) =========================================
multiply_2_inEq3 {
\assumes ([geq(multFacLeft,multFacRight)]==>[]) 
\find(geq(multLeft,multRight)==>)
\add [geq(mul(multLeft,multFacLeft),add(add(mul(neg(multRight),multFacRight),mul(multRight,multFacLeft)),mul(multLeft,multFacRight)))]==>[] 
\heuristics(inEqSimp_nonLin_multiply, inEqSimp_nonLin)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== multiply_distribute_1 (multiply_distribute) =========================================
multiply_distribute_1 {
\find(mul(add(i0,i1),add(j0,j1)))
\replacewith(add(add(mul(i0,j0),mul(i0,j1)),add(mul(i1,j0),mul(i1,j1)))) 

Choices: true}
-----------------------------------------------------
== multiply_distribute_2 (multiply_distribute) =========================================
multiply_distribute_2 {
\find(mul(add(i0,i1),sub(j0,j1)))
\replacewith(add(sub(mul(i0,j0),mul(i0,j1)),sub(mul(i1,j0),mul(i1,j1)))) 

Choices: true}
-----------------------------------------------------
== multiply_distribute_3 (multiply_distribute) =========================================
multiply_distribute_3 {
\find(mul(sub(i0,i1),sub(j0,j1)))
\replacewith(add(sub(mul(i0,j0),mul(i0,j1)),sub(mul(i1,j1),mul(i1,j0)))) 

Choices: true}
-----------------------------------------------------
== multiply_eq (multiply_eq) =========================================
multiply_eq {
\find(equals(multLeft,multRight)==>)
\add [equals(mul(multLeft,multFac),mul(multRight,multFac))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== multiply_inEq0 (multiply_inEq0) =========================================
multiply_inEq0 {
\find(leq(multLeft,multRight)==>)
\add [if-then-else(geq(multFac,Z(0(#))),leq(mul(multLeft,multFac),mul(multRight,multFac)),geq(mul(multLeft,multFac),mul(multRight,multFac)))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== multiply_inEq1 (multiply_inEq1) =========================================
multiply_inEq1 {
\find(geq(multLeft,multRight)==>)
\add [if-then-else(geq(multFac,Z(0(#))),geq(mul(multLeft,multFac),mul(multRight,multFac)),leq(mul(multLeft,multFac),mul(multRight,multFac)))]==>[] 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== narrowSelectArrayType (narrowSelectArrayType) =========================================
narrowSelectArrayType {
\assumes ([wellFormed(h)]==>[equals(o,null)]) 
\find(beta::select(h,o,arr(idx)))
\sameUpdateLevel\varcond(\hasSort(\elemSort(o (java.lang.Object term)), alpha), \strict\sub(alpha, beta), )
\replacewith(alpha::select(h,o,arr(idx))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== narrowSelectType (narrowSelectType) =========================================
narrowSelectType {
\assumes ([wellFormed(h)]==>[]) 
\find(beta::select(h,o,f))
\varcond(\fieldType(f (Field term), alpha), \strict\sub(alpha, beta), )
\replacewith(alpha::select(h,o,f)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingByteCastBigint (cast) =========================================
narrowingByteCastBigint {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = (byte) #seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastByte(#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== narrowingByteCastInt (cast) =========================================
narrowingByteCastInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (byte) #seInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastByte(#seInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingByteCastLong (cast) =========================================
narrowingByteCastLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (byte) #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastByte(#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingByteCastShort (cast) =========================================
narrowingByteCastShort {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (byte) #seShort;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastByte(#seShort)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingCastFloatToInt (cast) =========================================
narrowingCastFloatToInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (int) #seFloat;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(int::cast(#seFloat)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingCastFloatToLong (cast) =========================================
narrowingCastFloatToLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (long) #seFloat;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(int::cast(#seFloat)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingCharCastBigint (cast) =========================================
narrowingCharCastBigint {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = (char) #seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastChar(#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== narrowingCharCastByte (cast) =========================================
narrowingCharCastByte {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (char) #seByte;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastChar(#seByte)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingCharCastInt (cast) =========================================
narrowingCharCastInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (char) #seInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastChar(#seInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingCharCastLong (cast) =========================================
narrowingCharCastLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (char) #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastChar(#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingCharCastShort (cast) =========================================
narrowingCharCastShort {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (char) #seShort;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastChar(#seShort)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingIntCastBigint (cast) =========================================
narrowingIntCastBigint {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = (int) #seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastInt(#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== narrowingIntCastLong (cast) =========================================
narrowingIntCastLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (int) #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastInt(#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingLongCastBigint (cast) =========================================
narrowingLongCastBigint {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = (long) #seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastLong(#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== narrowingShortCastBigint (cast) =========================================
narrowingShortCastBigint {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = (short) #seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastShort(#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== narrowingShortCastInt (cast) =========================================
narrowingShortCastInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (short) #seInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastShort(#seInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== narrowingShortCastLong (cast) =========================================
narrowingShortCastLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (short) #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastShort(#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== neg_literal (neg_literal) =========================================
neg_literal {
\find(neg(Z(iz)))
\replacewith(Z(neglit(iz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== neq_and (neq_and) =========================================
neq_and {
\find(and(phi,not(phi)))
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== neq_and_2 (neq_and_2) =========================================
neq_and_2 {
\find(and(not(phi),phi))
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== neq_and_3 (neq_and_3) =========================================
neq_and_3 {
\find(and(and(psi,phi),not(phi)))
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== neq_and_4 (neq_and_4) =========================================
neq_and_4 {
\find(and(and(psi,not(phi)),phi))
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== neq_or (neq_or) =========================================
neq_or {
\find(or(phi,not(phi)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== neq_or_2 (neq_or_2) =========================================
neq_or_2 {
\find(or(not(phi),phi))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== neq_or_3 (neq_or_3) =========================================
neq_or_3 {
\find(or(or(psi,phi),not(phi)))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== neq_or_4 (neq_or_4) =========================================
neq_or_4 {
\find(or(or(psi,not(phi)),phi))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== newSym_eq (newSym_eq) =========================================
newSym_eq {
\find(equals(mul(newSymLeft,newSymLeftCoeff),newSymRight)==>)
\add [equals(newSymLeft,add(l,newSymDef))]==>[] 
\heuristics(polySimp_newSmallSym, polySimp_newSym, polySimp_leftNonUnit)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== niceDouble (niceDouble) =========================================
niceDouble {
\find(doubleIsNice(arg))
\replacewith(and(not(doubleIsNaN(arg)),not(doubleIsInfinite(arg)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== niceFloat (niceFloat) =========================================
niceFloat {
\find(floatIsNice(arg))
\replacewith(and(not(floatIsNaN(arg)),not(floatIsInfinite(arg)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== nnf_ex2all (nnf_ex2all) =========================================
nnf_ex2all {
\find(==>exists{u (variable)}(phi))
\replacewith([all{u (variable)}(not(phi))]==>[]) 
\heuristics(notHumanReadable, moveQuantToLeft)
Choices: true}
-----------------------------------------------------
== nnf_imp2or (nnf_imp2or) =========================================
nnf_imp2or {
\find(imp(phi,psi))
\replacewith(or(not(phi),psi)) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: true}
-----------------------------------------------------
== nnf_notAll (nnf_notAll) =========================================
nnf_notAll {
\find(not(all{u (variable)}(phi)))
\replacewith(exists{u (variable)}(not(phi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: true}
-----------------------------------------------------
== nnf_notAnd (nnf_notAnd) =========================================
nnf_notAnd {
\find(not(and(phi,psi)))
\replacewith(or(not(phi),not(psi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: true}
-----------------------------------------------------
== nnf_notEqv (nnf_notEqv) =========================================
nnf_notEqv {
\find(not(equiv(phi,psi)))
\replacewith(equiv(phi,not(psi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: true}
-----------------------------------------------------
== nnf_notEx (nnf_notEx) =========================================
nnf_notEx {
\find(not(exists{u (variable)}(phi)))
\replacewith(all{u (variable)}(not(phi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: true}
-----------------------------------------------------
== nnf_notOr (nnf_notOr) =========================================
nnf_notOr {
\find(not(or(phi,psi)))
\replacewith(and(not(phi),not(psi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: true}
-----------------------------------------------------
== noElementOfSupersetImpliesNoElementOfSubset (noElementOfSupersetImpliesNoElementOfSubset) =========================================
noElementOfSupersetImpliesNoElementOfSubset {
\assumes ([subset(s,s2)]==>[]) 
\find(==>elementOf(o,f,s2))
\add []==>[elementOf(o,f,s)] 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== nonNull (nonNull) =========================================
nonNull {
\find(nonNull(heapSV,o,depth))
\varcond(\notFreeIn(i (variable), depth (int term)), \notFreeIn(i (variable), heapSV (Heap term)), \notFreeIn(i (variable), o (java.lang.Object term)), \isReferenceArray(o (java.lang.Object term)), )
\replacewith(and(not(equals(o,null)),imp(gt(depth,Z(0(#))),all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,length(o))),nonNull(heapSV,java.lang.Object::select(heapSV,o,arr(i)),sub(depth,Z(1(#))))))))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== nonNullZero (nonNullZero) =========================================
nonNullZero {
\find(nonNull(heapSV,o,Z(0(#))))
\replacewith(not(equals(o,null))) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== notInDomain (notInDomain) =========================================
notInDomain {
\find(==>inDomain(m,x))
\add [equals(mapGet(m,x),mapUndef)]==>[] 
\heuristics(inReachableStateImplication)
Choices: true}
-----------------------------------------------------
== notLeft (notLeft) =========================================
notLeft {
\find(not(b)==>)
\replacewith([]==>[b]) 
\heuristics(alpha)
Choices: true}
-----------------------------------------------------
== notRight (notRight) =========================================
notRight {
\find(==>not(b))
\replacewith([b]==>[]) 
\heuristics(alpha)
Choices: true}
-----------------------------------------------------
== nullCreated (nullCreated) =========================================
nullCreated {
\add [or(all{h (variable)}(equals(boolean::select(h,null,java.lang.Object::<created>),TRUE)),all{h (variable)}(equals(boolean::select(h,null,java.lang.Object::<created>),FALSE)))]==>[] 

Choices: programRules:Java}
-----------------------------------------------------
== nullIsNotNonNull (nullIsNotNonNull) =========================================
nullIsNotNonNull {
\find(nonNull(heapSV,null,depth))
\replacewith(false) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== nullString (nullString) =========================================
nullString {
\find(strContent(null))
\replacewith(seqConcat(seqSingleton(C(0(1(1(#))))),seqConcat(seqSingleton(C(7(1(1(#))))),seqConcat(seqSingleton(C(8(0(1(#))))),seqSingleton(C(8(0(1(#))))))))) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== null_can_always_be_stored_in_a_reference_type_array (null_can_always_be_stored_in_a_reference_type_array) =========================================
null_can_always_be_stored_in_a_reference_type_array {
\assumes ([]==>[equals(array,null)]) 
\find(arrayStoreValid(array,null))
\sameUpdateLevel\varcond(\isReferenceArray(array (GOS term)), )
\replacewith(true) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== observerDependency (observerDependency) =========================================
observerDependency {
\find(termWithLargeHeap)
\inSequentState\varcond(\sameObserver (termWithLargeHeap (any term), termWithSmallHeap (any term)), )
\add []==>[#ObserverEquality(termWithLargeHeap,termWithSmallHeap)] ;
\replacewith(termWithSmallHeap) 

Choices: programRules:Java}
-----------------------------------------------------
== observerDependencyEQ (observerDependencyEQ) =========================================
observerDependencyEQ {
\find(equals(t1,t2))
\inSequentState\varcond(\sameObserver (t1 (any term), t2 (any term)), )
\add []==>[#ObserverEquality(t1,t2)] ;
\replacewith(true) 

Choices: programRules:Java}
-----------------------------------------------------
== observerDependencyEquiv (observerDependencyEQ) =========================================
observerDependencyEquiv {
\find(equiv(t1,t2))
\inSequentState\varcond(\sameObserver (t1 (formula), t2 (formula)), )
\add []==>[#ObserverEquality(t1,t2)] ;
\replacewith(true) 

Choices: programRules:Java}
-----------------------------------------------------
== observerDependencyFormula (observerDependency) =========================================
observerDependencyFormula {
\find(termWithLargeHeap)
\inSequentState\varcond(\sameObserver (termWithLargeHeap (formula), termWithSmallHeap (formula)), )
\add []==>[#ObserverEquality(termWithLargeHeap,termWithSmallHeap)] ;
\replacewith(termWithSmallHeap) 

Choices: programRules:Java}
-----------------------------------------------------
== onlyCreatedObjectsAreInLocSets (onlyCreatedObjectsAreInLocSets) =========================================
onlyCreatedObjectsAreInLocSets {
\assumes ([wellFormed(h)]==>[]) 
\find(elementOf(o2,f2,LocSet::select(h,o,f))==>)
\add [or(equals(o2,null),equals(boolean::select(h,o2,java.lang.Object::<created>),TRUE))]==>[] 
\heuristics(inReachableStateImplication)
Choices: programRules:Java}
-----------------------------------------------------
== onlyCreatedObjectsAreInLocSetsEQ (onlyCreatedObjectsAreInLocSetsEQ) =========================================
onlyCreatedObjectsAreInLocSetsEQ {
\assumes ([wellFormed(h),equals(LocSet::select(h,o,f),EQ)]==>[]) 
\find(elementOf(o2,f2,EQ)==>)
\add [or(equals(o2,null),equals(boolean::select(h,o2,java.lang.Object::<created>),TRUE))]==>[] 
\heuristics(inReachableStateImplication)
Choices: programRules:Java}
-----------------------------------------------------
== onlyCreatedObjectsAreObserved (onlyCreatedObjectsAreObserved) =========================================
onlyCreatedObjectsAreObserved {
\find(obs)
\sameUpdateLevel\varcond(\isObserver (obs (deltaObject term), h (Heap term)), )
\add [or(equals(obs,null),equals(boolean::select(h,obs,java.lang.Object::<created>),TRUE))]==>[] 
\heuristics(inReachableStateImplication)
Choices: programRules:Java}
-----------------------------------------------------
== onlyCreatedObjectsAreObservedInLocSets (onlyCreatedObjectsAreObservedInLocSets) =========================================
onlyCreatedObjectsAreObservedInLocSets {
\find(elementOf(o,f,obs)==>)
\varcond(\isObserver (obs (LocSet term), h (Heap term)), )
\add [or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))]==>[] 
\heuristics(inReachableStateImplication)
Choices: programRules:Java}
-----------------------------------------------------
== onlyCreatedObjectsAreObservedInLocSetsEQ (onlyCreatedObjectsAreObservedInLocSetsEQ) =========================================
onlyCreatedObjectsAreObservedInLocSetsEQ {
\assumes ([equals(obs,EQ)]==>[]) 
\find(elementOf(o,f,EQ)==>)
\varcond(\isObserver (obs (LocSet term), h (Heap term)), )
\add [or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))]==>[] 
\heuristics(inReachableStateImplication)
Choices: programRules:Java}
-----------------------------------------------------
== onlyCreatedObjectsAreReferenced (onlyCreatedObjectsAreReferenced) =========================================
onlyCreatedObjectsAreReferenced {
\assumes ([wellFormed(h)]==>[]) 
\find(deltaObject::select(h,o,f))
\sameUpdateLevel\add [or(equals(deltaObject::select(h,o,f),null),equals(boolean::select(h,deltaObject::select(h,o,f),java.lang.Object::<created>),TRUE))]==>[] 
\heuristics(inReachableStateImplication)
Choices: programRules:Java}
-----------------------------------------------------
== only_created_objects_are_reachable (only_created_objects_are_reachable) =========================================
only_created_objects_are_reachable {
\assumes ([wellFormed(h)]==>[equals(o,null)]) 
\find(reach(h,s,o,o2,n)==>)
\add [or(not(equals(boolean::select(h,o,java.lang.Object::<created>),TRUE)),equals(boolean::select(h,o2,java.lang.Object::<created>),TRUE))]==>[] 
\heuristics(inReachableStateImplication)
Choices: reach:on}
-----------------------------------------------------
== optAxiom (optAxiom) =========================================
optAxiom {
\find(match(opt(rexp),string))
\replacewith(or(match(repeat(rexp,Z(0(#))),string),match(rexp,string))) 
\heuristics(simplify)
Choices: Strings:on}
-----------------------------------------------------
== optEmpty (optEmpty) =========================================
optEmpty {
\find(match(opt(rexp),seqEmpty))
\replacewith(true) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== orJIntDef (orJIntDef) =========================================
orJIntDef {
\find(orJint(left,right))
\replacewith(moduloInt(binaryOr(left,right))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== orJintInInt (orJintInInt) =========================================
orJintInInt {
\find(orJint(left,right))
\sameUpdateLevel\add [inRangeInt(orJint(left,right))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== orLeft (orLeft) =========================================
orLeft {
\find(or(b,c)==>)
\replacewith([c]==>[]) ;
\replacewith([b]==>[]) 
\heuristics(beta)
Choices: true}
-----------------------------------------------------
== orRight (orRight) =========================================
orRight {
\find(==>or(b,c))
\replacewith([]==>[b,c]) 
\heuristics(alpha)
Choices: true}
-----------------------------------------------------
== parallelWithSkip1 (parallelWithSkip1) =========================================
parallelWithSkip1 {
\find(parallel-upd(skip,u))
\replacewith(u) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== parallelWithSkip2 (parallelWithSkip2) =========================================
parallelWithSkip2 {
\find(parallel-upd(u,skip))
\replacewith(u) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== partition_inequation (partition_inequation) =========================================
partition_inequation {
\assumes ([]==>[lt(i,i0)]) 
\find(lt(i,i1)==>)
\add []==>[lt(i1,i0)] 

Choices: true}
-----------------------------------------------------
== permissionDefaultValue (permissionDefaultValue) =========================================
permissionDefaultValue {
\find(Permission::defaultValue)
\replacewith(initFullPermission) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== polyDiv_pullOut (polyDiv_pullOut) =========================================
polyDiv_pullOut {
\find(div(divNum,divDenom))
\replacewith(if-then-else(equals(divDenom,Z(0(#))),div(divNum,Z(0(#))),add(div(add(divNum,mul(mul(polyDivCoeff,Z(neglit(1(#)))),divDenom)),divDenom),polyDivCoeff))) 
\heuristics(notHumanReadable, defOps_divModPullOut, polyDivision)
Choices: true}
-----------------------------------------------------
== polyDiv_zero (polyDiv_zero) =========================================
polyDiv_zero {
\find(div(Z(0(#)),divDenom))
\replacewith(if-then-else(equals(divDenom,Z(0(#))),div(Z(0(#)),Z(0(#))),Z(0(#)))) 
\heuristics(polyDivision)
Choices: true}
-----------------------------------------------------
== polyMod_ltdivDenom (polyMod_ltdivDenom) =========================================
polyMod_ltdivDenom {
\find(mod(divNum,divDenom))
\add [and(imp(gt(divDenom,Z(0(#))),lt(mod(divNum,divDenom),divDenom)),imp(lt(divDenom,Z(0(#))),lt(mod(divNum,divDenom),neg(divDenom))))]==>[] 

Choices: true}
-----------------------------------------------------
== polyMod_pullOut (polyMod_pullOut) =========================================
polyMod_pullOut {
\find(mod(divNum,divDenom))
\replacewith(mod(add(divNum,mul(mul(polyDivCoeff,Z(neglit(1(#)))),divDenom)),divDenom)) 
\heuristics(notHumanReadable, defOps_divModPullOut, polyDivision)
Choices: true}
-----------------------------------------------------
== polyMod_zero (polyMod_zero) =========================================
polyMod_zero {
\find(mod(Z(0(#)),divDenom))
\replacewith(Z(0(#))) 
\heuristics(concrete, polyDivision)
Choices: true}
-----------------------------------------------------
== polySimp_addAssoc (polySimp_addAssoc) =========================================
polySimp_addAssoc {
\find(add(addAssocPoly0,add(addAssocPoly1,addAssocMono)))
\replacewith(add(add(addAssocPoly0,addAssocPoly1),addAssocMono)) 
\heuristics(polySimp_addAssoc, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_addComm0 (polySimp_addComm0) =========================================
polySimp_addComm0 {
\find(add(commLeft,commRight))
\replacewith(add(commRight,commLeft)) 
\heuristics(polySimp_addOrder, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_addComm1 (polySimp_addComm1) =========================================
polySimp_addComm1 {
\find(add(add(i0,commLeft),commRight))
\replacewith(add(add(i0,commRight),commLeft)) 
\heuristics(polySimp_addOrder, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_addLiterals (polySimp_addLiterals) =========================================
polySimp_addLiterals {
\find(add(add(i,Z(iz)),Z(jz)))
\replacewith(add(i,#add(Z(iz),Z(jz)))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== polySimp_critPair (polySimp_critPair) =========================================
polySimp_critPair {
\assumes ([equals(cpLeft1,cpRight1)]==>[]) 
\find(equals(cpLeft2,cpRight2)==>)
\add [equals(add(mul(#divideLCRMonomials(cpLeft2,cpLeft1),add(mul(Z(neglit(1(#))),cpRight1),cpLeft1)),mul(#divideLCRMonomials(cpLeft1,cpLeft2),add(cpRight2,mul(Z(neglit(1(#))),cpLeft2)))),Z(0(#)))]==>[] 
\heuristics(notHumanReadable, polySimp_critPair, polySimp_saturate)
Choices: true}
-----------------------------------------------------
== polySimp_elimNeg (polySimp_elimNeg) =========================================
polySimp_elimNeg {
\find(neg(i))
\replacewith(mul(i,Z(neglit(1(#))))) 
\heuristics(polySimp_elimSubNeg, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_elimOne (polySimp_elimOne) =========================================
polySimp_elimOne {
\find(mul(i,Z(1(#))))
\replacewith(i) 
\heuristics(polySimp_elimOneRight, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_elimOneLeft0 (polySimp_elimOneLeft0) =========================================
polySimp_elimOneLeft0 {
\find(mul(Z(1(#)),i))
\replacewith(i) 
\heuristics(polySimp_elimOneLeft, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_elimOneLeft1 (polySimp_elimOneLeft1) =========================================
polySimp_elimOneLeft1 {
\find(mul(mul(i0,Z(1(#))),i))
\replacewith(mul(i0,i)) 
\heuristics(polySimp_elimOneLeft, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_elimSub (polySimp_elimSub) =========================================
polySimp_elimSub {
\find(sub(i,i0))
\replacewith(add(i,mul(i0,Z(neglit(1(#)))))) 
\heuristics(polySimp_elimSubNeg, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_homoEq (polySimp_homoEq) =========================================
polySimp_homoEq {
\find(equals(homoLeft,homoRight))
\replacewith(equals(add(homoRight,mul(homoLeft,Z(neglit(1(#))))),Z(0(#)))) 
\heuristics(notHumanReadable, polySimp_homo, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_invertEq (polySimp_invertEq) =========================================
polySimp_invertEq {
\find(equals(invertLeft,invertRight))
\replacewith(equals(mul(invertLeft,Z(neglit(1(#)))),mul(invertRight,Z(neglit(1(#)))))) 
\heuristics(polySimp_normalise, polySimp_directEquations)
Choices: true}
-----------------------------------------------------
== polySimp_mulAssoc (polySimp_mulAssoc) =========================================
polySimp_mulAssoc {
\find(mul(mulAssocMono0,mul(mulAssocMono1,mulAssocAtom)))
\replacewith(mul(mul(mulAssocMono0,mulAssocMono1),mulAssocAtom)) 
\heuristics(polySimp_mulAssoc, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_mulComm0 (polySimp_mulComm0) =========================================
polySimp_mulComm0 {
\find(mul(commLeft,commRight))
\replacewith(mul(commRight,commLeft)) 
\heuristics(polySimp_mulOrder, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_mulComm1 (polySimp_mulComm1) =========================================
polySimp_mulComm1 {
\find(mul(mul(i0,commLeft),commRight))
\replacewith(mul(mul(i0,commRight),commLeft)) 
\heuristics(polySimp_mulOrder, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_mulLiterals (polySimp_mulLiterals) =========================================
polySimp_mulLiterals {
\find(mul(mul(i,Z(iz)),Z(jz)))
\replacewith(mul(i,#mul(Z(iz),Z(jz)))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== polySimp_pullOutFactor0 (polySimp_pullOutFactor0) =========================================
polySimp_pullOutFactor0 {
\find(add(mul(pullOutCommon,pullOutLeft),mul(pullOutCommon,pullOutRight)))
\replacewith(mul(pullOutCommon,add(pullOutLeft,pullOutRight))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_pullOutFactor0b (polySimp_pullOutFactor0b) =========================================
polySimp_pullOutFactor0b {
\find(add(add(i0,mul(pullOutCommon,pullOutLeft)),mul(pullOutCommon,pullOutRight)))
\replacewith(add(i0,mul(pullOutCommon,add(pullOutLeft,pullOutRight)))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_pullOutFactor1 (polySimp_pullOutFactor1) =========================================
polySimp_pullOutFactor1 {
\find(add(pullOutCommon,mul(pullOutCommon,pullOutRight)))
\replacewith(mul(pullOutCommon,add(Z(1(#)),pullOutRight))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_pullOutFactor1b (polySimp_pullOutFactor1b) =========================================
polySimp_pullOutFactor1b {
\find(add(add(i0,pullOutCommon),mul(pullOutCommon,pullOutRight)))
\replacewith(add(i0,mul(pullOutCommon,add(Z(1(#)),pullOutRight)))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_pullOutFactor2 (polySimp_pullOutFactor2) =========================================
polySimp_pullOutFactor2 {
\find(add(mul(pullOutCommon,pullOutLeft),pullOutCommon))
\replacewith(mul(pullOutCommon,add(pullOutLeft,Z(1(#))))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_pullOutFactor2b (polySimp_pullOutFactor2b) =========================================
polySimp_pullOutFactor2b {
\find(add(add(i0,mul(pullOutCommon,pullOutLeft)),pullOutCommon))
\replacewith(add(i0,mul(pullOutCommon,add(pullOutLeft,Z(1(#)))))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_pullOutFactor3 (polySimp_pullOutFactor3) =========================================
polySimp_pullOutFactor3 {
\find(add(pullOutCommon,pullOutCommon))
\replacewith(mul(pullOutCommon,Z(2(#)))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_pullOutFactor3b (polySimp_pullOutFactor3b) =========================================
polySimp_pullOutFactor3b {
\find(add(add(i0,pullOutCommon),pullOutCommon))
\replacewith(add(i0,mul(pullOutCommon,Z(2(#))))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_rightDist (polySimp_rightDist) =========================================
polySimp_rightDist {
\find(mul(distCoeff,add(distSummand0,distSummand1)))
\replacewith(add(mul(distCoeff,distSummand0),mul(distSummand1,distCoeff))) 
\heuristics(polySimp_dist, polySimp_expand)
Choices: true}
-----------------------------------------------------
== polySimp_sepNegMonomial (polySimp_sepNegMonomial) =========================================
polySimp_sepNegMonomial {
\find(equals(add(sepResidue,sepNegMono),Z(0(#))))
\replacewith(equals(mul(sepNegMono,Z(neglit(1(#)))),sepResidue)) 
\heuristics(polySimp_balance, polySimp_directEquations)
Choices: true}
-----------------------------------------------------
== polySimp_sepPosMonomial (polySimp_sepPosMonomial) =========================================
polySimp_sepPosMonomial {
\find(equals(add(sepResidue,sepPosMono),Z(0(#))))
\replacewith(equals(sepPosMono,mul(sepResidue,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, polySimp_balance, polySimp_directEquations)
Choices: true}
-----------------------------------------------------
== poolIsInjective (poolIsInjective) =========================================
poolIsInjective {
\find(equals(strPool(slit1),strPool(slit2)))
\replacewith(equals(slit1,slit2)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== poolKeyIsContentOfValue (poolKeyIsContentOfValue) =========================================
poolKeyIsContentOfValue {
\find(strContent(strPool(slit)))
\replacewith(slit) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== pos_mult_eq_1_iff (pos_mult_eq_1_iff) =========================================
pos_mult_eq_1_iff {
\find(imp(lt(Z(0(#)),i0),equals(mul(i0,i1),Z(1(#)))))
\replacewith(and(equals(i0,Z(1(#))),equals(i1,Z(1(#))))) 

Choices: true}
-----------------------------------------------------
== postdecrement (postdecrement) =========================================
postdecrement {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs1--;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) #lhs1 - 1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postdecrement_array (postdecrement_array) =========================================
postdecrement_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e[#e0]--;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#e0) #v0 = #e0;
  #v[#v0] = (#typeof(#e[#e0])) (#v[#v0] - 1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postdecrement_assignment (postdecrement_assignment) =========================================
postdecrement_assignment {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1--;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#lhs0 (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#lhs0) #v = #lhs1;
  #lhs1 = (#typeof(#lhs1)) (#lhs1 - 1);
  #lhs0 = #v;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postdecrement_assignment_array (postdecrement_assignment_array) =========================================
postdecrement_assignment_array {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e[#e0]--;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#lhs0 (program LeftHandSide))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#e0) #v0 = #e0;
  #typeof(#lhs0) #v1 = #v[#v0];
  #v[#v0] = (#typeof(#e[#e0])) (#v[#v0] - 1);
  #lhs0 = #v1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postdecrement_assignment_attribute (postdecrement_assignment_attribute) =========================================
postdecrement_assignment_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e.#attribute--;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#lhs0 (program LeftHandSide))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#lhs0) #v1 = #v.#attribute;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute -
                                           1);
  #lhs0 = #v1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postdecrement_attribute (postdecrement_attribute) =========================================
postdecrement_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  #e.#attribute--;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute -
                                           1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postincrement (postincrement) =========================================
postincrement {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs1++;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 + 1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postincrement_array (postincrement_array) =========================================
postincrement_array {
\find(#allmodal ( (modal operator))\[{ ..
  #e[#e0]++;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#e0) #v0 = #e0;
  #v[#v0] = (#typeof(#e[#e0])) (#v[#v0] + 1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postincrement_assignment (postincrement_assignment) =========================================
postincrement_assignment {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #lhs1++;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#lhs0 (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#lhs0) #v = #lhs1;
  #lhs1 = (#typeof(#lhs1)) (#lhs1 + 1);
  #lhs0 = #v;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postincrement_assignment_array (postincrement_assignment_array) =========================================
postincrement_assignment_array {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e[#e0]++;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#lhs0 (program LeftHandSide))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#e0) #v0 = #e0;
  #typeof(#lhs0) #v1 = #v[#v0];
  #v[#v0] = (#typeof(#e[#e0])) (#v[#v0] + 1);
  #lhs0 = #v1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postincrement_assignment_attribute (postincrement_assignment_attribute) =========================================
postincrement_assignment_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = #e.#attribute++;
... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#lhs0 (program LeftHandSide))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#lhs0) #v1 = #v.#attribute;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute +
                                           1);
  #lhs0 = #v1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== postincrement_attribute (postincrement_attribute) =========================================
postincrement_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  #e.#attribute++;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute +
                                           1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== pow2InIntLower (pow2InIntLower) =========================================
pow2InIntLower {
\find(leq(pow(Z(2(#)),exp),Z(neglit(9(4(6(3(8(4(7(4(1(2(#)))))))))))))==>)
\add []==>[geq(exp,Z(0(#)))] 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== pow2InIntUpper (pow2InIntUpper) =========================================
pow2InIntUpper {
\find(geq(pow(Z(2(#)),exp),Z(8(4(6(3(8(4(7(4(1(2(#))))))))))))==>)
\add []==>[and(geq(exp,Z(0(#))),leq(exp,Z(0(3(#)))))] 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== powAdd (powAdd) =========================================
powAdd {
\find(pow(base,add(exp,exp_2)))
\replacewith(if-then-else(and(geq(exp,Z(0(#))),geq(exp_2,Z(0(#)))),mul(pow(base,exp),pow(base,exp_2)),pow(base,add(exp,exp_2)))) 

Choices: true}
-----------------------------------------------------
== powConcrete0 (powConcrete0) =========================================
powConcrete0 {
\find(pow(base,Z(0(#))))
\replacewith(Z(1(#))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== powConcrete1 (powConcrete1) =========================================
powConcrete1 {
\find(pow(base,Z(1(#))))
\replacewith(base) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== powDef (powDef) =========================================
powDef {
\find(pow(base,exp))
\varcond(\notFreeIn(i (variable), base (int term)), \notFreeIn(i (variable), exp (int term)))
\replacewith(if-then-else(geq(exp,Z(0(#))),bprod{i (variable)}(Z(0(#)),exp,base),undefinedPow(base,exp))) 

Choices: true}
-----------------------------------------------------
== powGeq1Concrete (powGeq1Concrete) =========================================
powGeq1Concrete {
\find(leq(pow(base,exp),Z(0(#)))==>)
\add []==>[and(geq(exp,Z(0(#))),geq(base,Z(1(#))))] 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== powIsInfinite1 (powIsInfinite1) =========================================
powIsInfinite1 {
\find(powDouble(arg1,arg2))
\add [imp(or(and(and(or(geqDouble(arg1,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))),leqDouble(arg1,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))),doubleIsInfinite(arg2)),gtDouble(arg2,DFP(0(#)))),and(and(and(ltDouble(arg1,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))),gtDouble(arg1,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))),doubleIsInfinite(arg2)),ltDouble(arg2,DFP(0(#))))),and(doubleIsInfinite(powDouble(arg1,arg2)),gtDouble(powDouble(arg1,arg2),DFP(0(#)))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powIsInfinite2 (powIsInfinite2) =========================================
powIsInfinite2 {
\find(powDouble(arg1,arg2))
\add [imp(or(and(eqDouble(arg1,DFP(0(#))),ltDouble(arg2,DFP(0(#)))),and(and(doubleIsInfinite(arg1),gtDouble(arg1,DFP(0(#)))),gtDouble(arg2,DFP(0(#))))),and(doubleIsInfinite(powDouble(arg1,arg2)),gtDouble(powDouble(arg1,arg2),DFP(0(#)))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powIsNaN1 (powIsNaN1) =========================================
powIsNaN1 {
\find(powDouble(arg1,arg2))
\add [imp(doubleIsNaN(arg2),doubleIsNaN(powDouble(arg1,arg2)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powIsNaN2 (powIsNaN2) =========================================
powIsNaN2 {
\find(powDouble(arg1,arg2))
\add [imp(and(doubleIsNaN(arg1),not(equals(arg2,DFP(0(#))))),doubleIsNaN(powDouble(arg1,arg2)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powIsNaN3 (powIsNaN3) =========================================
powIsNaN3 {
\find(powDouble(arg1,arg2))
\add [imp(and(or(geqDouble(arg1,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))),leqDouble(arg1,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))),doubleIsInfinite(arg2)),doubleIsNaN(powDouble(arg1,arg2)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powIsNotNaN (powIsNotNaN) =========================================
powIsNotNaN {
\find(powDouble(arg1,arg2))
\add [imp(and(not(doubleIsNaN(arg1)),equals(arg2,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),equals(powDouble(arg1,arg2),arg1))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powIsOne (powIsOne) =========================================
powIsOne {
\find(powDouble(arg1,arg2))
\add [imp(equals(arg2,DFP(0(#))),equals(powDouble(arg1,arg2),DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powIsZero1 (powIsZero1) =========================================
powIsZero1 {
\find(powDouble(arg1,arg2))
\add [imp(or(and(and(or(geqDouble(arg1,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))),leqDouble(arg1,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))),doubleIsInfinite(arg2)),ltDouble(arg2,DFP(0(#)))),and(and(and(ltDouble(arg1,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))),gtDouble(arg1,negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))),doubleIsInfinite(arg2)),gtDouble(arg2,DFP(0(#))))),equals(powDouble(arg1,arg2),DFP(0(#))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powIsZero2 (powIsZero2) =========================================
powIsZero2 {
\find(powDouble(arg1,arg2))
\add [imp(or(and(eqDouble(arg1,DFP(0(#))),gtDouble(arg2,DFP(0(#)))),and(and(doubleIsInfinite(arg1),gtDouble(arg1,DFP(0(#)))),ltDouble(arg2,DFP(0(#))))),equals(powDouble(arg1,arg2),DFP(0(#))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== powLogLess (powLogLess) =========================================
powLogLess {
\find(pow(base,log(base,exp)))
\add [imp(and(geq(exp,Z(1(#))),gt(base,Z(1(#)))),leq(pow(base,log(base,exp)),exp))]==>[] 

Choices: true}
-----------------------------------------------------
== powLogMore2 (powLogMore2) =========================================
powLogMore2 {
\find(pow(base,log(base,x)))
\add [imp(and(equals(base,Z(2(#))),geq(x,Z(1(#)))),lt(sub(x,pow(base,log(base,x))),pow(base,log(base,x))))]==>[] 

Choices: true}
-----------------------------------------------------
== powMono (powMono) =========================================
powMono {
\find(leq(pow(base,exp),pow(base,exp_2)))
\add [imp(and(and(geq(exp,Z(0(#))),geq(exp_2,exp)),geq(base,Z(1(#)))),leq(pow(base,exp),pow(base,exp_2)))]==>[] 

Choices: true}
-----------------------------------------------------
== powMonoConcrete (powMonoConcrete) =========================================
powMonoConcrete {
\find(leq(pow(base,exp_2),add(Z(neglit(1(#))),pow(base,exp)))==>)
\add []==>[and(and(geq(exp,Z(0(#))),geq(exp_2,exp)),geq(base,Z(1(#))))] 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== powMonoConcreteRight (powMonoConcreteRight) =========================================
powMonoConcreteRight {
\find(==>leq(pow(base,exp),pow(base,exp_2)))
\add []==>[and(and(geq(exp,Z(0(#))),geq(exp_2,exp)),geq(base,Z(1(#))))] 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== powPositive (powPositive) =========================================
powPositive {
\find(pow(base,exp))
\add [imp(and(geq(exp,Z(0(#))),geq(base,Z(1(#)))),geq(pow(base,exp),Z(1(#))))]==>[] 

Choices: true}
-----------------------------------------------------
== powPositiveConcrete (powPositiveConcrete) =========================================
powPositiveConcrete {
\find(leq(pow(base,exp),Z(neglit(1(#))))==>)
\add []==>[and(geq(exp,Z(0(#))),geq(base,Z(1(#))))] 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== powSplitFactor (powSplitFactor) =========================================
powSplitFactor {
\find(pow(base,exp))
\replacewith(if-then-else(geq(exp,Z(0(#))),if-then-else(geq(exp,Z(1(#))),mul(base,pow(base,sub(exp,Z(1(#))))),Z(1(#))),undefinedPow(base,exp))) 

Choices: true}
-----------------------------------------------------
== pow_literals (pow_literals) =========================================
pow_literals {
\find(pow(Z(iz),Z(jz)))
\replacewith(#pow(Z(iz),Z(jz))) 
\heuristics(nonDuplicateAppCheckEq, simplify_literals)
Choices: true}
-----------------------------------------------------
== precOfDouble (precOfDouble) =========================================
precOfDouble {
\find(prec(d1,d2))
\replacewith(ltDouble(d1,d2)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== precOfFloat (precOfFloat) =========================================
precOfFloat {
\find(prec(f1,f2))
\replacewith(ltFloat(f1,f2)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== precOfInt (precOfInt) =========================================
precOfInt {
\find(prec(a,b))
\replacewith(and(leq(Z(0(#)),a),lt(a,b))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== precOfIntPair (precOfIntPair) =========================================
precOfIntPair {
\find(prec(a,pair(b,x)))
\replacewith(and(leq(Z(0(#)),a),leq(a,b))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== precOfPair (precOfPair) =========================================
precOfPair {
\find(prec(pair(a1,b1),pair(a2,b2)))
\replacewith(or(prec(a1,a2),and(equals(a1,a2),prec(b1,b2)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== precOfPairInt (precOfPairInt) =========================================
precOfPairInt {
\find(prec(pair(a,x),b))
\replacewith(and(leq(Z(0(#)),a),lt(a,b))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== precOfSeq (precOfSeq) =========================================
precOfSeq {
\find(prec(s1,s2))
\varcond(\notFreeIn(jv (variable), s2 (Seq term)), \notFreeIn(jv (variable), s1 (Seq term)), \notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s1 (Seq term)))
\replacewith(or(and(equals(seqLen(s1),seqLen(s2)),exists{iv (variable)}(and(and(and(leq(Z(0(#)),iv),lt(iv,seqLen(s1))),prec(any::seqGet(s1,iv),any::seqGet(s2,iv))),all{jv (variable)}(imp(and(leq(Z(0(#)),jv),lt(jv,iv)),equals(any::seqGet(s1,jv),any::seqGet(s2,jv))))))),lt(seqLen(s1),seqLen(s2)))) 

Choices: true}
-----------------------------------------------------
== predecrement (predecrement) =========================================
predecrement {
\find(#allmodal ( (modal operator))\[{ ..
  --#lhs1;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 - 1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== predecrement_array (predecrement_array) =========================================
predecrement_array {
\find(#allmodal ( (modal operator))\[{ ..
  --#e[#e0];
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#e0) #v0 = #e0;
  #v[#v0] = (#typeof(#e[#e0])) (#v[#v0] - 1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== predecrement_assignment (predecrement_assignment) =========================================
predecrement_assignment {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = --#lhs1;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 - 1);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== predecrement_assignment_array (predecrement_assignment_array) =========================================
predecrement_assignment_array {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = --#e[#e0];
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#e0) #v0 = #e0;
  #v[#v0] = (#typeof(#e[#e0])) (#v[#v0] - 1);
  #lhs0 = #v[#v0];
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== predecrement_assignment_attribute (predecrement_assignment_attribute) =========================================
predecrement_assignment_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = --#e.#attribute;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute -
                                           1);
  #lhs = #v.#attribute;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== predecrement_attribute (predecrement_attribute) =========================================
predecrement_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  --#e.#attribute;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute -
                                           1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== preincrement (preincrement) =========================================
preincrement {
\find(#allmodal ( (modal operator))\[{ ..
  ++#lhs1;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 + 1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== preincrement_array (preincrement_array) =========================================
preincrement_array {
\find(#allmodal ( (modal operator))\[{ ..
  ++#e[#e0];
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#e0) #v0 = #e0;
  #v[#v0] = (#typeof(#e[#e0])) (#v[#v0] + 1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== preincrement_assignment (preincrement_assignment) =========================================
preincrement_assignment {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = ++#lhs1;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs1 = (#typeof(#lhs1)) (#lhs1 + 1);
  #lhs0 = #lhs1;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== preincrement_assignment_array (preincrement_assignment_array) =========================================
preincrement_assignment_array {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = ++#e[#e0];
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #typeof(#e0) #v0 = #e0;
  #v[#v0] = (#typeof(#e[#e0])) (#v[#v0] + 1);
  #lhs0 = #v[#v0];
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== preincrement_assignment_attribute (preincrement_assignment_attribute) =========================================
preincrement_assignment_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs0 = ++#e.#attribute;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute +
                                           1);
  #lhs0 = #v.#attribute;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== preincrement_attribute (preincrement_attribute) =========================================
preincrement_attribute {
\find(#allmodal ( (modal operator))\[{ ..
  ++#e.#attribute;
... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#e) #v = #e;
  #v.#attribute = (#typeof(#attribute)) (#v.#attribute +
                                           1);
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== prod_empty (prod_empty) =========================================
prod_empty {
\find(prod{x (variable)}(FALSE,t))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== prod_one (prod_one) =========================================
prod_one {
\find(prod{x (variable)}(range,Z(1(#))))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== pullOut (pullOut) =========================================
pullOut {
\find(t)
\sameUpdateLevel\add [equals(t,sk)]==>[] \replacewith(sk) 
\heuristics(semantics_blasting)
Choices: true}
-----------------------------------------------------
== pullOutSelect (pullOutSelect) =========================================
pullOutSelect {
\find(beta::select(h,o,f))
\sameUpdateLevel\add [equals(beta::select(h,o,f),selectSK<<selectSK>>)]==>[] \replacewith(selectSK<<selectSK>>) 
\heuristics(pull_out_select)
Choices: programRules:Java}
-----------------------------------------------------
== pullOutbsum1 (pullOutbsum1) =========================================
pullOutbsum1 {
\find(geq(bsum{uSub1 (variable)}(i0,i1,t1),t)==>)
\add [equals(bsum{uSub1 (variable)}(i0,i1,t1),sk)]==>[] \replacewith([geq(sk,t)]==>[]) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== pullOutbsum2 (pullOutbsum2) =========================================
pullOutbsum2 {
\find(leq(bsum{uSub1 (variable)}(i0,i1,t1),t)==>)
\add [equals(bsum{uSub1 (variable)}(i0,i1,t1),sk)]==>[] \replacewith([leq(sk,t)]==>[]) 

Choices: integerSimplificationRules:full}
-----------------------------------------------------
== pull_out_neg_1 (pull_out_minus) =========================================
pull_out_neg_1 {
\find(mul(neg(i0),i1))
\replacewith(neg(mul(i0,i1))) 

Choices: true}
-----------------------------------------------------
== pull_out_neg_2 (pull_out_minus) =========================================
pull_out_neg_2 {
\find(mul(i0,neg(i1)))
\replacewith(neg(mul(i0,i1))) 

Choices: true}
-----------------------------------------------------
== qeq_literals (qeq_literals) =========================================
qeq_literals {
\find(geq(Z(iz),Z(jz)))
\replacewith(#geq(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== reachAddOne (reachAddOne) =========================================
reachAddOne {
\find(reach(h,s,o,o2,add(Z(1(#)),n)))
\varcond(\notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\replacewith(and(and(and(geq(n,Z(neglit(1(#)))),not(equals(o,null))),not(equals(o2,null))),or(and(equals(n,Z(neglit(1(#)))),equals(o,o2)),exists{ov (variable)}(and(reach(h,s,o,ov,n),acc(h,s,ov,o2)))))) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reachAddOne2 (reachAddOne2) =========================================
reachAddOne2 {
\find(reach(h,s,o,o2,add(n,Z(1(#)))))
\varcond(\notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\replacewith(and(and(and(geq(n,Z(neglit(1(#)))),not(equals(o,null))),not(equals(o2,null))),or(and(equals(n,Z(neglit(1(#)))),equals(o,o2)),exists{ov (variable)}(and(reach(h,s,o,ov,n),acc(h,s,ov,o2)))))) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reachDefinition (reachDefinition) =========================================
reachDefinition {
\find(reach(h,s,o,o2,n))
\varcond(\notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\replacewith(and(and(and(geq(n,Z(0(#))),not(equals(o,null))),not(equals(o2,null))),or(and(equals(n,Z(0(#))),equals(o,o2)),exists{ov (variable)}(and(reach(h,s,o,ov,sub(n,Z(1(#)))),acc(h,s,ov,o2)))))) 

Choices: reach:on}
-----------------------------------------------------
== reachDependenciesAnon (reachDependenciesAnon) =========================================
reachDependenciesAnon {
\find(reach(anon(h,s2,h2),s,o,o2,n))
\sameUpdateLevel\varcond(\notFreeIn(nv (variable), n (int term)), \notFreeIn(nv (variable), o2 (java.lang.Object term)), \notFreeIn(nv (variable), o (java.lang.Object term)), \notFreeIn(nv (variable), s (LocSet term)), \notFreeIn(nv (variable), h2 (Heap term)), \notFreeIn(nv (variable), s2 (LocSet term)), \notFreeIn(nv (variable), h (Heap term)), \notFreeIn(fv (variable), n (int term)), \notFreeIn(fv (variable), o2 (java.lang.Object term)), \notFreeIn(fv (variable), o (java.lang.Object term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(fv (variable), h2 (Heap term)), \notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), h (Heap term)), \notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h2 (Heap term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\add [all{ov (variable)}(all{fv (variable)}(not(and(and(elementOf(ov,fv,s2),exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,ov,nv)))),elementOf(ov,fv,s)))))]==>[] \replacewith(reach(h,s,o,o2,n)) ;
\add []==>[all{ov (variable)}(all{fv (variable)}(not(and(and(elementOf(ov,fv,s2),exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,ov,nv)))),elementOf(ov,fv,s)))))] 

Choices: reach:on}
-----------------------------------------------------
== reachDependenciesAnonCoarse (reachDependenciesAnonCoarse) =========================================
reachDependenciesAnonCoarse {
\find(reach(anon(h,s2,h2),s,o,o2,n))
\sameUpdateLevel\varcond(\notFreeIn(nv (variable), n (int term)), \notFreeIn(nv (variable), o2 (java.lang.Object term)), \notFreeIn(nv (variable), o (java.lang.Object term)), \notFreeIn(nv (variable), s (LocSet term)), \notFreeIn(nv (variable), h2 (Heap term)), \notFreeIn(nv (variable), s2 (LocSet term)), \notFreeIn(nv (variable), h (Heap term)), \notFreeIn(fv (variable), n (int term)), \notFreeIn(fv (variable), o2 (java.lang.Object term)), \notFreeIn(fv (variable), o (java.lang.Object term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(fv (variable), h2 (Heap term)), \notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), h (Heap term)), \notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h2 (Heap term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\add [all{ov (variable)}(all{fv (variable)}(not(and(and(elementOf(ov,fv,s2),exists{nv (variable)}(reach(h,s,o,ov,nv))),elementOf(ov,fv,s)))))]==>[] \replacewith(reach(h,s,o,o2,n)) ;
\add []==>[all{ov (variable)}(all{fv (variable)}(not(and(and(elementOf(ov,fv,s2),exists{nv (variable)}(reach(h,s,o,ov,nv))),elementOf(ov,fv,s)))))] 

Choices: reach:on}
-----------------------------------------------------
== reachDependenciesStore (reachDependenciesStore) =========================================
reachDependenciesStore {
\find(reach(store(h,o3,f,x),s,o,o2,n))
\sameUpdateLevel\varcond(\notFreeIn(nv (variable), n (int term)), \notFreeIn(nv (variable), o2 (java.lang.Object term)), \notFreeIn(nv (variable), o (java.lang.Object term)), \notFreeIn(nv (variable), s (LocSet term)), \notFreeIn(nv (variable), x (any term)), \notFreeIn(nv (variable), f (Field term)), \notFreeIn(nv (variable), o3 (java.lang.Object term)), \notFreeIn(nv (variable), h (Heap term)))
\add [not(and(exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,o3,nv))),elementOf(o3,f,s)))]==>[] \replacewith(reach(h,s,o,o2,n)) ;
\add []==>[not(and(exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,o3,nv))),elementOf(o3,f,s)))] 

Choices: reach:on}
-----------------------------------------------------
== reachDependenciesStoreEQ (reachDependenciesStoreEQ) =========================================
reachDependenciesStoreEQ {
\assumes ([equals(store(h,o3,f,x),h2)]==>[]) 
\find(reach(h2,s,o,o2,n))
\sameUpdateLevel\varcond(\notFreeIn(nv (variable), n (int term)), \notFreeIn(nv (variable), o2 (java.lang.Object term)), \notFreeIn(nv (variable), o (java.lang.Object term)), \notFreeIn(nv (variable), s (LocSet term)), \notFreeIn(nv (variable), x (any term)), \notFreeIn(nv (variable), f (Field term)), \notFreeIn(nv (variable), o3 (java.lang.Object term)), \notFreeIn(nv (variable), h (Heap term)))
\add [not(and(exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,o3,nv))),elementOf(o3,f,s)))]==>[] \replacewith(reach(h,s,o,o2,n)) ;
\add []==>[not(and(exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,o3,nv))),elementOf(o3,f,s)))] 

Choices: reach:on}
-----------------------------------------------------
== reachDependenciesStoreSimple (reachDependenciesStoreSimple) =========================================
reachDependenciesStoreSimple {
\find(reach(store(h,o3,f2,x),allObjects(f),o,o2,n))
\varcond(\metaDisjoint f (Field term), f2 (Field term), )
\replacewith(reach(h,allObjects(f),o,o2,n)) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reachDependenciesStoreSimpleEQ (reachDependenciesStoreSimpleEQ) =========================================
reachDependenciesStoreSimpleEQ {
\assumes ([equals(store(h,o3,f2,x),h2)]==>[]) 
\find(reach(h2,allObjects(f),o,o2,n))
\varcond(\metaDisjoint f (Field term), f2 (Field term), )
\replacewith(reach(h,allObjects(f),o,o2,n)) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reachDoesNotDependOnCreatedness (reachDoesNotDependOnCreatedness) =========================================
reachDoesNotDependOnCreatedness {
\find(reach(create(h,o3),s,o,o2,n))
\replacewith(reach(h,s,o,o2,n)) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reachEndOfUniquePath (reachEndOfUniquePath) =========================================
reachEndOfUniquePath {
\assumes ([reach(h,allObjects(f),o,o2,n),equals(alpha::select(h,o2,f),null),equals(alpha::select(h,o3,f),null)]==>[]) 
\find(reach(h,allObjects(f),o,o3,n2)==>)
\varcond(\different (n (int term), n2 (int term)), )
\add [and(equals(o2,o3),equals(n,n2))]==>[] 
\heuristics(inReachableStateImplication)
Choices: reach:on}
-----------------------------------------------------
== reachEndOfUniquePath2 (reachEndOfUniquePath2) =========================================
reachEndOfUniquePath2 {
\assumes ([reach(h,allObjects(f),o,o2,n),equals(alpha::select(h,o2,f),null)]==>[]) 
\find(reach(h,allObjects(f),o,o3,n2)==>)
\varcond(\different (o (java.lang.Object term), o2 (java.lang.Object term)), \different (n (int term), n2 (int term)), )
\add [or(lt(n2,n),and(equals(o2,o3),equals(n,n2)))]==>[] 
\heuristics(inReachableStateImplication)
Choices: reach:on}
-----------------------------------------------------
== reachNull (reachNull) =========================================
reachNull {
\find(reach(h,s,o,null,n))
\replacewith(false) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reachNull2 (reachNull2) =========================================
reachNull2 {
\find(reach(h,s,null,o2,n))
\replacewith(false) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reachOne (reachOne) =========================================
reachOne {
\find(reach(h,s,o,o2,Z(1(#))))
\replacewith(acc(h,s,o,o2)) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reachUniquePathSameSteps (reachUniquePathSameSteps) =========================================
reachUniquePathSameSteps {
\assumes ([reach(h,allObjects(f),o,o2,n)]==>[]) 
\find(reach(h,allObjects(f),o,o3,n)==>)
\varcond(\different (o2 (java.lang.Object term), o3 (java.lang.Object term)), )
\add [equals(o2,o3)]==>[] 
\heuristics(inReachableStateImplication)
Choices: reach:on}
-----------------------------------------------------
== reachZero (reachZero) =========================================
reachZero {
\find(reach(h,s,o,o2,Z(0(#))))
\replacewith(and(not(equals(o,null)),equals(o,o2))) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reach_does_not_depend_on_fresh_locs (reach_does_not_depend_on_fresh_locs) =========================================
reach_does_not_depend_on_fresh_locs {
\assumes ([]==>[equals(o,null)]) 
\find(reach(anon(h,empty,h2),s,o,o2,n))
\add []==>[and(wellFormed(h),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))] ;
\replacewith(reach(h,s,o,o2,n)) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== reach_does_not_depend_on_fresh_locs_EQ (reach_does_not_depend_on_fresh_locs_EQ) =========================================
reach_does_not_depend_on_fresh_locs_EQ {
\assumes ([equals(anon(h,empty,h2),EQ)]==>[equals(o,null)]) 
\find(reach(EQ,s,o,o2,n))
\add []==>[and(wellFormed(h),equals(boolean::select(h,o,java.lang.Object::<created>),TRUE))] ;
\replacewith(reach(h,s,o,o2,n)) 
\heuristics(simplify)
Choices: reach:on}
-----------------------------------------------------
== readPermission (readPermission) =========================================
readPermission {
\find(readPermission(p))
\replacewith(readPermissionObject(currentThread,p)) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== readPermissionObject (readPermissionObject) =========================================
readPermissionObject {
\find(readPermissionObject(o,p))
\replacewith(true) 
\heuristics(concrete)
Choices: permissions:off}
-----------------------------------------------------
== reference_type_cast (reference_type_cast) =========================================
reference_type_cast {
\find(==>#allmodal ( (modal operator))\[{ ..
  #lhs = (#npit) #se;
... }\] (post))
\varcond(\hasSort(#npit (program NonPrimitiveType), G), \not\sub(\typeof(#se (program SimpleExpression)), G), )
\add []==>[or(equals(#se,null),equals(G::instance(#se),TRUE))] \replacewith([]==>[false]) ;
\replacewith([]==>[update-application(elem-update(#lhs (program LeftHandSide))(#addCast(#se,#lhs)),#allmodal(post))]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== referencedObjectIsCreatedRight (referencedObjectIsCreatedRight) =========================================
referencedObjectIsCreatedRight {
\assumes ([]==>[equals(deltaObject::select(h,o,f),null)]) 
\find(==>equals(boolean::select(h,deltaObject::select(h,o,f),java.lang.Object::<created>),TRUE))
\replacewith([]==>[wellFormed(h)]) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== referencedObjectIsCreatedRightEQ (referencedObjectIsCreatedRightEQ) =========================================
referencedObjectIsCreatedRightEQ {
\assumes ([equals(deltaObject::select(h,o,f),EQ)]==>[equals(EQ,null)]) 
\find(==>equals(boolean::select(h,EQ,java.lang.Object::<created>),TRUE))
\replacewith([]==>[wellFormed(h)]) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== regExAxiom (regExAxiom) =========================================
regExAxiom {
\find(match(regEx(stringAsPattern),string))
\replacewith(equals(string,stringAsPattern)) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatAltLeft (regExConcatAltLeft) =========================================
regExConcatAltLeft {
\find(match(regExConcat(alt(rexp1,rexp2),rexp3),string))
\replacewith(or(match(regExConcat(rexp1,rexp3),string),match(regExConcat(rexp2,rexp3),string))) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatAltRight (regExConcatAltRight) =========================================
regExConcatAltRight {
\find(match(regExConcat(rexp1,alt(rexp2,rexp3)),string))
\replacewith(or(match(regExConcat(rexp1,rexp2),string),match(regExConcat(rexp1,rexp3),string))) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatAxiom (regExConcatAxiom) =========================================
regExConcatAxiom {
\find(match(regExConcat(rexp1,rexp2),string))
\varcond(\notFreeIn(endIdx (variable), string (Seq term)), \notFreeIn(endIdx (variable), rexp2 (RegEx term)), \notFreeIn(endIdx (variable), rexp1 (RegEx term)))
\replacewith(exists{endIdx (variable)}(and(and(and(geq(endIdx,Z(0(#))),leq(endIdx,seqLen(string))),match(rexp1,seqSub(string,Z(0(#)),endIdx))),match(rexp2,seqSub(string,endIdx,seqLen(string)))))) 
\heuristics(simplify)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatConcreteStringLeft (regExConcatConcreteStringLeft) =========================================
regExConcatConcreteStringLeft {
\find(match(regExConcat(regEx(pattern),rexp),string))
\replacewith(and(and(leq(seqLen(pattern),seqLen(string)),match(regEx(pattern),seqSub(string,Z(0(#)),seqLen(pattern)))),match(rexp,seqSub(string,seqLen(pattern),seqLen(string))))) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatConcreteStringRight (regExConcatConcreteStringRight) =========================================
regExConcatConcreteStringRight {
\find(match(regExConcat(rexp,regEx(pattern)),string))
\replacewith(and(and(leq(seqLen(pattern),seqLen(string)),match(rexp,seqSub(string,Z(0(#)),sub(seqLen(string),seqLen(pattern))))),match(regEx(pattern),seqSub(string,sub(seqLen(string),seqLen(pattern)),seqLen(string))))) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatOptLeft (regExConcatOptLeft) =========================================
regExConcatOptLeft {
\find(match(regExConcat(opt(rexp1),rexp2),string))
\replacewith(or(match(rexp2,string),match(regExConcat(rexp1,rexp2),string))) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatOptRight (regExConcatOptRight) =========================================
regExConcatOptRight {
\find(match(regExConcat(rexp1,opt(rexp2)),string))
\replacewith(or(match(rexp1,string),match(regExConcat(rexp1,rexp2),string))) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatRepeatLeft (regExConcatRepeatLeft) =========================================
regExConcatRepeatLeft {
\find(match(regExConcat(repeat(rexp1,nTimes),rexp2),string))
\varcond(\notFreeIn(string2 (variable), nTimes (int term)), \notFreeIn(string2 (variable), rexp2 (RegEx term)), \notFreeIn(string2 (variable), rexp1 (RegEx term)), \notFreeIn(string2 (variable), string (Seq term)), \notFreeIn(string1 (variable), nTimes (int term)), \notFreeIn(string1 (variable), rexp2 (RegEx term)), \notFreeIn(string1 (variable), rexp1 (RegEx term)), \notFreeIn(string1 (variable), string (Seq term)))
\replacewith(if-then-else(equals(nTimes,Z(0(#))),match(rexp2,string),if-then-else(lt(nTimes,Z(0(#))),false,exists{string1 (variable)}(exists{string2 (variable)}(and(and(match(repeat(rexp1,nTimes),string1),match(rexp2,string2)),equals(string,seqConcat(string1,string2)))))))) 
\heuristics(simplify)
Choices: Strings:on}
-----------------------------------------------------
== regExConcatRepeatRight (regExConcatRepeatRight) =========================================
regExConcatRepeatRight {
\find(match(regExConcat(rexp1,repeat(rexp2,nTimes)),string))
\varcond(\notFreeIn(string2 (variable), nTimes (int term)), \notFreeIn(string2 (variable), rexp2 (RegEx term)), \notFreeIn(string2 (variable), rexp1 (RegEx term)), \notFreeIn(string2 (variable), string (Seq term)), \notFreeIn(string1 (variable), nTimes (int term)), \notFreeIn(string1 (variable), rexp2 (RegEx term)), \notFreeIn(string1 (variable), rexp1 (RegEx term)), \notFreeIn(string1 (variable), string (Seq term)))
\replacewith(if-then-else(equals(nTimes,Z(0(#))),match(rexp1,string),if-then-else(lt(nTimes,Z(0(#))),false,exists{string1 (variable)}(exists{string2 (variable)}(and(and(match(rexp1,string1),match(repeat(rexp2,nTimes),string2)),equals(string,seqConcat(string1,string2)))))))) 
\heuristics(simplify)
Choices: Strings:on}
-----------------------------------------------------
== removeZeros (removeZeros) =========================================
removeZeros {
\find(clRemoveZeros(l))
\replacewith(if-then-else(or(equals(l,seqEmpty),equals(int::seqGet(l,Z(0(#))),C(8(4(#))))),l,clRemoveZeros(seqSub(l,Z(1(#)),seqLen(l))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== remove_parentheses_attribute_left (remove_parentheses) =========================================
remove_parentheses_attribute_left {
\find(#allmodal ( (modal operator))\[{ ..
  (#e.#attribute) = #e0;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #e.#attribute = #e0;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== remove_parentheses_lhs_left (remove_parentheses) =========================================
remove_parentheses_lhs_left {
\find(#allmodal ( (modal operator))\[{ ..
  (#lhs) = #e;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #e;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== remove_parentheses_right (remove_parentheses_right) =========================================
remove_parentheses_right {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (#e);
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #e;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== repeatAxiom (repeatAxiom) =========================================
repeatAxiom {
\find(match(repeat(rexp,nTimes),string))
\varcond(\notFreeIn(endIdx (variable), string (Seq term)), \notFreeIn(endIdx (variable), nTimes (int term)), \notFreeIn(endIdx (variable), rexp (RegEx term)))
\replacewith(if-then-else(lt(nTimes,Z(0(#))),false,if-then-else(equals(nTimes,Z(0(#))),equals(string,empty),exists{endIdx (variable)}(and(and(and(geq(endIdx,Z(0(#))),leq(endIdx,seqLen(string))),match(rexp,seqSub(string,Z(0(#)),endIdx))),match(repeat(rexp,sub(nTimes,Z(1(#)))),seqSub(string,endIdx,seqLen(string)))))))) 

Choices: Strings:on}
-----------------------------------------------------
== repeatMatchEmpty (repeatMatchEmpty) =========================================
repeatMatchEmpty {
\find(match(repeat(rexp,nTimes1),seqEmpty))
\replacewith(or(equals(nTimes1,Z(0(#))),and(gt(nTimes1,Z(0(#))),match(rexp,seqEmpty)))) 
\heuristics(simplify)
Choices: Strings:on}
-----------------------------------------------------
== repeatOnce (repeatOnce) =========================================
repeatOnce {
\find(repeat(rexp,Z(1(#))))
\replacewith(rexp) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== repeatPlusAxiom (repeatPlusAxiom) =========================================
repeatPlusAxiom {
\find(match(repeatPlus(rexp),string))
\varcond(\notFreeIn(nTimes (variable), string (Seq term)), \notFreeIn(nTimes (variable), rexp (RegEx term)))
\replacewith(exists{nTimes (variable)}(and(geq(nTimes,Z(1(#))),match(repeat(rexp,nTimes),string)))) 
\heuristics(simplify)
Choices: Strings:on}
-----------------------------------------------------
== repeatStarAxiom (repeatStarAxiom) =========================================
repeatStarAxiom {
\find(match(repeatStar(rexp),string))
\varcond(\notFreeIn(nTimes (variable), string (Seq term)), \notFreeIn(nTimes (variable), rexp (RegEx term)))
\replacewith(exists{nTimes (variable)}(and(geq(nTimes,Z(0(#))),match(repeat(rexp,nTimes),string)))) 
\heuristics(simplify)
Choices: Strings:on}
-----------------------------------------------------
== repeatZero (repeatZero) =========================================
repeatZero {
\find(repeat(rexp,Z(0(#))))
\replacewith(regEx(seqEmpty)) 
\heuristics(concrete)
Choices: Strings:on}
-----------------------------------------------------
== replaceConcat (replaceConcat) =========================================
replaceConcat {
\find(clReplace(seqConcat(leftStr,rightStr),searchChar,replaceChar))
\replacewith(seqConcat(clReplace(leftStr,searchChar,replaceChar),clReplace(rightStr,searchChar,replaceChar))) 
\heuristics(stringsMoveReplaceInside)
Choices: Strings:on}
-----------------------------------------------------
== replaceCons (replaceCons) =========================================
replaceCons {
\find(clReplace(seqConcat(seqSingleton(fstChar),str),searchChar,replChar))
\replacewith(if-then-else(equals(searchChar,fstChar),seqConcat(seqSingleton(replChar),clReplace(str,searchChar,replChar)),seqConcat(seqSingleton(fstChar),clReplace(str,searchChar,replChar)))) 
\heuristics(defOpsReplaceInline)
Choices: Strings:on}
-----------------------------------------------------
== replaceDef (replaceDef) =========================================
replaceDef {
\find(clReplace(str,searchChar,replChar))
\sameUpdateLevel\varcond(\notFreeIn(pos (variable), replChar (int term)), \notFreeIn(pos (variable), searchChar (int term)), \notFreeIn(pos (variable), str (Seq term)))
\add [and(equals(clReplace(str,searchChar,replChar),newSym),equals(seqDef{pos (variable)}(Z(0(#)),seqLen(str),if-then-else(equals(int::seqGet(str,pos),searchChar),replChar,int::seqGet(str,pos))),newSym))]==>[] 
\heuristics(stringsIntroduceNewSym, defOpsReplace)
Choices: Strings:on}
-----------------------------------------------------
== replaceEmpty (replaceEmpty) =========================================
replaceEmpty {
\find(clReplace(seqEmpty,searchChar,replChar))
\replacewith(seqEmpty) 
\heuristics(stringsSimplify)
Choices: Strings:on}
-----------------------------------------------------
== replaceSingleton (replaceSingleton) =========================================
replaceSingleton {
\find(clReplace(seqSingleton(fstChar),searchChar,replChar))
\replacewith(if-then-else(equals(searchChar,fstChar),seqSingleton(replChar),seqSingleton(fstChar))) 
\heuristics(stringsSimplify)
Choices: Strings:on}
-----------------------------------------------------
== replaceSubstring (replaceSubstring) =========================================
replaceSubstring {
\assumes ([equals(seqSub(str,startIdx,endIdx),subStr)]==>[]) 
\find(clReplace(subStr,searchChar,replaceChar))
\sameUpdateLevel\replacewith(if-then-else(and(and(geq(startIdx,Z(0(#))),geq(endIdx,startIdx)),leq(endIdx,seqLen(str))),seqSub(clReplace(str,searchChar,replaceChar),startIdx,endIdx),clReplace(subStr,searchChar,replaceChar))) 
\heuristics(stringsMoveReplaceInside)
Choices: Strings:on}
-----------------------------------------------------
== replace_byte_HALFRANGE (replace_byte_HALFRANGE) =========================================
replace_byte_HALFRANGE {
\find(byte_HALFRANGE)
\replacewith(Z(8(2(1(#))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_byte_MAX (replace_byte_MAX) =========================================
replace_byte_MAX {
\find(byte_MAX)
\replacewith(Z(7(2(1(#))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_byte_MIN (replace_byte_MIN) =========================================
replace_byte_MIN {
\find(byte_MIN)
\replacewith(Z(neglit(8(2(1(#)))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_byte_RANGE (replace_byte_RANGE) =========================================
replace_byte_RANGE {
\find(byte_RANGE)
\replacewith(Z(6(5(2(#))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_char_MAX (replace_char_MAX) =========================================
replace_char_MAX {
\find(char_MAX)
\replacewith(Z(5(3(5(5(6(#))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_char_MIN (replace_char_MIN) =========================================
replace_char_MIN {
\find(char_MIN)
\replacewith(Z(0(#))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_char_RANGE (replace_char_RANGE) =========================================
replace_char_RANGE {
\find(char_RANGE)
\replacewith(Z(6(3(5(5(6(#))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_int_HALFRANGE (replace_int_HALFRANGE) =========================================
replace_int_HALFRANGE {
\find(int_HALFRANGE)
\replacewith(Z(8(4(6(3(8(4(7(4(1(2(#)))))))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_int_MAX (replace_int_MAX) =========================================
replace_int_MAX {
\find(int_MAX)
\replacewith(Z(7(4(6(3(8(4(7(4(1(2(#)))))))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_int_MIN (replace_int_MIN) =========================================
replace_int_MIN {
\find(int_MIN)
\replacewith(Z(neglit(8(4(6(3(8(4(7(4(1(2(#))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_int_RANGE (replace_int_RANGE) =========================================
replace_int_RANGE {
\find(int_RANGE)
\replacewith(Z(6(9(2(7(6(9(4(9(2(4(#)))))))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_known_left (replace_known_left) =========================================
replace_known_left {
\assumes ([b]==>[]) 
\find(b)
\sameUpdateLevel\replacewith(true) 
\heuristics(replace_known_left)
Choices: true}
-----------------------------------------------------
== replace_known_right (replace_known_right) =========================================
replace_known_right {
\assumes ([]==>[b]) 
\find(b)
\sameUpdateLevel\replacewith(false) 
\heuristics(replace_known_right)
Choices: true}
-----------------------------------------------------
== replace_long_HALFRANGE (replace_long_HALFRANGE) =========================================
replace_long_HALFRANGE {
\find(long_HALFRANGE)
\replacewith(Z(8(0(8(5(7(7(4(5(8(6(3(0(2(7(3(3(2(2(9(#))))))))))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_long_MAX (replace_long_MAX) =========================================
replace_long_MAX {
\find(long_MAX)
\replacewith(Z(7(0(8(5(7(7(4(5(8(6(3(0(2(7(3(3(2(2(9(#))))))))))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_long_MIN (replace_long_MIN) =========================================
replace_long_MIN {
\find(long_MIN)
\replacewith(Z(neglit(8(0(8(5(7(7(4(5(8(6(3(0(2(7(3(3(2(2(9(#)))))))))))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_long_RANGE (replace_long_RANGE) =========================================
replace_long_RANGE {
\find(long_RANGE)
\replacewith(Z(6(1(6(1(5(5(9(0(7(3(7(0(4(4(7(6(4(4(8(1(#)))))))))))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_short_HALFRANGE (replace_short_HALFRANGE) =========================================
replace_short_HALFRANGE {
\find(short_HALFRANGE)
\replacewith(Z(8(6(7(2(3(#))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_short_MAX (replace_short_MAX) =========================================
replace_short_MAX {
\find(short_MAX)
\replacewith(Z(7(6(7(2(3(#))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_short_MIN (replace_short_MIN) =========================================
replace_short_MIN {
\find(short_MIN)
\replacewith(Z(neglit(8(6(7(2(3(#)))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== replace_short_RANGE (replace_short_RANGE) =========================================
replace_short_RANGE {
\find(short_RANGE)
\replacewith(Z(6(3(5(5(6(#))))))) 
\heuristics(defOps_expandRanges)
Choices: true}
-----------------------------------------------------
== returnUnfold (returnUnfold) =========================================
returnUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  return #nse;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0 = #nse;
  return #v0;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== rotate_and (rotate_and) =========================================
rotate_and {
\find(and(b,and(c,d)))
\replacewith(and(c,and(b,d))) 

Choices: true}
-----------------------------------------------------
== rotate_or (rotate_or) =========================================
rotate_or {
\find(or(b,or(c,d)))
\replacewith(or(c,or(b,d))) 

Choices: true}
-----------------------------------------------------
== rotate_params (rotate_params) =========================================
rotate_params {
\find(add(i,add(i0,i1)))
\replacewith(add(i0,add(i,i1))) 

Choices: true}
-----------------------------------------------------
== sameTypeFalse (sameTypeFalse) =========================================
sameTypeFalse {
\assumes ([equals(G::exactInstance(x1),TRUE),equals(H::exactInstance(x2),TRUE)]==>[]) 
\find(sameType(x1,x2))
\varcond(\not\same(G, H), )
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== sameTypeTrue (sameTypeTrue) =========================================
sameTypeTrue {
\assumes ([equals(G::exactInstance(x1),TRUE),equals(G::exactInstance(x2),TRUE)]==>[]) 
\find(sameType(x1,x2))
\replacewith(true) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== same_boxes_left (same_boxes_left) =========================================
same_boxes_left {
\assumes ([\[{ ..
  #s
... }\] (post)]==>[]) 
\find(\[{ ..
  #s
... }\] (post1)==>)
\add [\[{ ..
  #s
... }\] (and(post,post1))]==>[] 

Choices: programRules:Java}
-----------------------------------------------------
== same_boxes_right (same_boxes_right) =========================================
same_boxes_right {
\assumes ([]==>[\[{ ..
  #s
... }\] (post)]) 
\find(==>\[{ ..
  #s
... }\] (post1))
\add []==>[\[{ ..
  #s
... }\] (or(post,post1))] 

Choices: programRules:Java}
-----------------------------------------------------
== same_diamonds_left (same_diamonds_left) =========================================
same_diamonds_left {
\assumes ([\<{ ..
  #s
... }\> (post)]==>[]) 
\find(\<{ ..
  #s
... }\> (post1)==>)
\add [\<{ ..
  #s
... }\> (and(post,post1))]==>[] 

Choices: programRules:Java}
-----------------------------------------------------
== same_diamonds_right (same_diamonds_right) =========================================
same_diamonds_right {
\assumes ([]==>[\<{
  #s
}\> (post)]) 
\find(==>\<{
  #s
}\> (post1))
\add []==>[\<{
  #s
}\> (or(post,post1))] 

Choices: programRules:Java}
-----------------------------------------------------
== schiffl_lemma_2 (schiffl_lemma_2) =========================================
schiffl_lemma_2 {
\find(seqPerm(s,t)==>)
\varcond(\notFreeIn(y (variable), t (Seq term)), \notFreeIn(y (variable), s (Seq term)), \notFreeIn(x (variable), t (Seq term)), \notFreeIn(x (variable), s (Seq term)), \notFreeIn(r (variable), t (Seq term)), \notFreeIn(r (variable), s (Seq term)), \notFreeIn(iv (variable), t (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\add [all{x (variable)}(all{y (variable)}(imp(and(and(and(and(and(equals(any::seqGet(s,x),any::seqGet(t,x)),equals(any::seqGet(s,y),any::seqGet(t,y))),leq(Z(0(#)),x)),lt(x,seqLen(s))),leq(Z(0(#)),y)),lt(y,seqLen(s))),exists{r (variable)}(and(and(and(and(equals(seqLen(r),seqLen(s)),seqNPerm(r)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(t,int::seqGet(r,iv)))))),equals(int::seqGet(r,x),x)),equals(int::seqGet(r,y),y))))))]==>[] 

Choices: true}
-----------------------------------------------------
== schiffl_thm_1 (schiffl_thm_1) =========================================
schiffl_thm_1 {
\find(seqPerm(s,t)==>)
\varcond(\notFreeIn(idx (variable), t (Seq term)), \notFreeIn(idx (variable), s (Seq term)), \notFreeIn(idx (variable), b (any term)), \notFreeIn(idx (variable), a (any term)), \notFreeIn(idx (variable), y (int term)), \notFreeIn(idx (variable), x (int term)))
\add [imp(and(and(and(and(and(and(seqPerm(s,t),equals(any::seqGet(s,x),any::seqGet(t,x))),equals(any::seqGet(s,y),any::seqGet(t,y))),leq(Z(0(#)),x)),lt(x,seqLen(s))),leq(Z(0(#)),y)),lt(y,seqLen(s))),seqPerm(seqDef{idx (variable)}(Z(0(#)),seqLen(s),if-then-else(equals(idx,y),b,if-then-else(equals(idx,x),a,any::seqGet(s,idx)))),seqDef{idx (variable)}(Z(0(#)),seqLen(s),if-then-else(equals(idx,y),b,if-then-else(equals(idx,x),a,any::seqGet(t,idx))))))]==>[] 

Choices: true}
-----------------------------------------------------
== secondOfPair (secondOfPair) =========================================
secondOfPair {
\find(second(pair(t,t1)))
\replacewith(t1) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== selectCreatedOfAnon (selectCreatedOfAnon) =========================================
selectCreatedOfAnon {
\find(boolean::select(anon(h,s,h2),o,java.lang.Object::<created>))
\replacewith(if-then-else(equals(boolean::select(h,o,java.lang.Object::<created>),TRUE),TRUE,boolean::select(h2,o,java.lang.Object::<created>))) 
\heuristics(simplify_heap_high_costs)
Choices: programRules:Java}
-----------------------------------------------------
== selectCreatedOfAnonAsFormula (selectCreatedOfAnonAsFormula) =========================================
selectCreatedOfAnonAsFormula {
\find(equals(boolean::select(anon(h,s,h2),o,java.lang.Object::<created>),TRUE))
\replacewith(or(equals(boolean::select(h,o,java.lang.Object::<created>),TRUE),equals(boolean::select(h2,o,java.lang.Object::<created>),TRUE))) 
\heuristics(simplify_ENLARGING)
Choices: programRules:Java}
-----------------------------------------------------
== selectCreatedOfAnonAsFormulaEQ (selectCreatedOfAnonAsFormulaEQ) =========================================
selectCreatedOfAnonAsFormulaEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==>[]) 
\find(equals(boolean::select(EQ,o,java.lang.Object::<created>),TRUE))
\sameUpdateLevel\replacewith(or(equals(boolean::select(h,o,java.lang.Object::<created>),TRUE),equals(boolean::select(h2,o,java.lang.Object::<created>),TRUE))) 
\heuristics(simplify_ENLARGING)
Choices: programRules:Java}
-----------------------------------------------------
== selectCreatedOfAnonEQ (selectCreatedOfAnonEQ) =========================================
selectCreatedOfAnonEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==>[]) 
\find(boolean::select(EQ,o,java.lang.Object::<created>))
\sameUpdateLevel\replacewith(if-then-else(equals(boolean::select(h,o,java.lang.Object::<created>),TRUE),TRUE,boolean::select(h2,o,java.lang.Object::<created>))) 
\heuristics(simplify_heap_high_costs)
Choices: programRules:Java}
-----------------------------------------------------
== selectOfAnon (selectOfAnon) =========================================
selectOfAnon {
\find(beta::select(anon(h,s,h2),o,f))
\replacewith(if-then-else(or(and(elementOf(o,f,s),not(equals(f,java.lang.Object::<created>))),elementOf(o,f,freshLocs(h))),beta::select(h2,o,f),beta::select(h,o,f))) 
\heuristics(semantics_blasting)
Choices: programRules:Java}
-----------------------------------------------------
== selectOfAnonEQ (selectOfAnonEQ) =========================================
selectOfAnonEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==>[]) 
\find(beta::select(EQ,o,f))
\sameUpdateLevel\replacewith(if-then-else(or(and(elementOf(o,f,s),not(equals(f,java.lang.Object::<created>))),elementOf(o,f,freshLocs(h))),beta::select(h2,o,f),beta::select(h,o,f))) 
\heuristics(simplify_heap_high_costs)
Choices: programRules:Java}
-----------------------------------------------------
== selectOfCreate (selectOfCreate) =========================================
selectOfCreate {
\find(beta::select(create(h,o),o2,f))
\replacewith(if-then-else(and(and(equals(o,o2),not(equals(o,null))),equals(f,java.lang.Object::<created>)),beta::cast(TRUE),beta::select(h,o2,f))) 
\heuristics(semantics_blasting)
Choices: programRules:Java}
-----------------------------------------------------
== selectOfCreateEQ (selectOfCreateEQ) =========================================
selectOfCreateEQ {
\assumes ([equals(create(h,o),EQ)]==>[]) 
\find(beta::select(EQ,o2,f))
\sameUpdateLevel\replacewith(if-then-else(and(and(equals(o,o2),not(equals(o,null))),equals(f,java.lang.Object::<created>)),beta::cast(TRUE),beta::select(h,o2,f))) 
\heuristics(simplify_heap_high_costs)
Choices: programRules:Java}
-----------------------------------------------------
== selectOfMemset (selectOfMemset) =========================================
selectOfMemset {
\find(beta::select(memset(h,s,x),o,f))
\replacewith(if-then-else(and(elementOf(o,f,s),not(equals(f,java.lang.Object::<created>))),beta::cast(x),beta::select(h,o,f))) 
\heuristics(semantics_blasting)
Choices: programRules:Java}
-----------------------------------------------------
== selectOfMemsetEQ (selectOfMemsetEQ) =========================================
selectOfMemsetEQ {
\assumes ([equals(memset(h,s,x),EQ)]==>[]) 
\find(beta::select(EQ,o,f))
\sameUpdateLevel\replacewith(if-then-else(and(elementOf(o,f,s),not(equals(f,java.lang.Object::<created>))),beta::cast(x),beta::select(h,o,f))) 
\heuristics(simplify_heap_high_costs)
Choices: programRules:Java}
-----------------------------------------------------
== selectOfStore (selectOfStore) =========================================
selectOfStore {
\find(beta::select(store(h,o,f,x),o2,f2))
\replacewith(if-then-else(and(and(equals(o,o2),equals(f,f2)),not(equals(f,java.lang.Object::<created>))),beta::cast(x),beta::select(h,o2,f2))) 
\heuristics(semantics_blasting)
Choices: programRules:Java}
-----------------------------------------------------
== selectOfStoreEQ (selectOfStoreEQ) =========================================
selectOfStoreEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==>[]) 
\find(beta::select(EQ,o2,f2))
\sameUpdateLevel\replacewith(if-then-else(and(and(equals(o,o2),equals(f,f2)),not(equals(f,java.lang.Object::<created>))),beta::cast(x),beta::select(h,o2,f2))) 
\heuristics(simplify_heap_high_costs)
Choices: programRules:Java}
-----------------------------------------------------
== seqConcatUnfoldLeft (seqConcatUnfold) =========================================
seqConcatUnfoldLeft {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \singleton(#nseLeft, #eRight);
... }\] (post))
\varcond(\new(#vLeftNew (program Variable), \typeof(#nseLeft (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseLeft) #vLeftNew = #nseLeft;
  #v = \singleton(#vLeftNew, #eRight);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqConcatUnfoldRight (seqConcatUnfold) =========================================
seqConcatUnfoldRight {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \singleton(#seLeft, #nseRight);
... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseRight) #vRightNew = #nseRight;
  #v = \singleton(#seLeft, #vRightNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqConcatWithSeqEmpty1 (seqConcatWithEmpty) =========================================
seqConcatWithSeqEmpty1 {
\find(seqConcat(seq,seqEmpty))
\replacewith(seq) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== seqConcatWithSeqEmpty2 (seqConcatWithEmpty) =========================================
seqConcatWithSeqEmpty2 {
\find(seqConcat(seqEmpty,seq))
\replacewith(seq) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== seqDefOfSeq (seqDefOfSeq) =========================================
seqDefOfSeq {
\find(seqDef{u (variable)}(Z(0(#)),x,any::seqGet(s,u)))
\varcond(\notFreeIn(v (variable), s (Seq term)), \notFreeIn(v (variable), x (int term)), \notFreeIn(u (variable), s (Seq term)), \notFreeIn(u (variable), x (int term)))
\replacewith(if-then-else(equals(seqLen(s),x),s,if-then-else(gt(seqLen(s),x),seqSub(s,Z(0(#)),x),seqConcat(s,seqDef{v (variable)}(seqLen(s),x,seqGetOutside))))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== seqDef_empty (seqDef_empty) =========================================
seqDef_empty {
\find(seqDef{uSub (variable)}(from,idx,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), idx (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqEmpty) ;
\add []==>[leq(idx,from)] 

Choices: sequences:on}
-----------------------------------------------------
== seqDef_induction_lower (seqDef_induction_lower) =========================================
seqDef_induction_lower {
\find(seqDef{uSub (variable)}(from,to,t))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqConcat(if-then-else(lt(from,to),seqSingleton(subst{uSub (variable)}(from,t)),seqEmpty),seqDef{uSub (variable)}(add(from,Z(1(#))),to,t))) 

Choices: sequences:on}
-----------------------------------------------------
== seqDef_induction_lower_concrete (seqDef_induction_lower_concrete) =========================================
seqDef_induction_lower_concrete {
\find(seqDef{uSub (variable)}(add(Z(neglit(1(#))),from),to,t))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqConcat(if-then-else(lt(add(Z(neglit(1(#))),from),to),seqSingleton(subst{uSub (variable)}(add(Z(neglit(1(#))),from),t)),seqEmpty),seqDef{uSub (variable)}(from,to,t))) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== seqDef_induction_upper (seqDef_induction_upper) =========================================
seqDef_induction_upper {
\find(seqDef{uSub (variable)}(from,to,t))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqConcat(seqDef{uSub (variable)}(from,sub(to,Z(1(#))),t),if-then-else(lt(from,to),seqSingleton(subst{uSub (variable)}(sub(to,Z(1(#))),t)),seqEmpty))) 

Choices: sequences:on}
-----------------------------------------------------
== seqDef_induction_upper_concrete (seqDef_induction_upper_concrete) =========================================
seqDef_induction_upper_concrete {
\find(seqDef{uSub (variable)}(from,add(Z(1(#)),to),t))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqConcat(seqDef{uSub (variable)}(from,to,t),if-then-else(leq(from,to),seqSingleton(subst{uSub (variable)}(to,t)),seqEmpty))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== seqDef_lower_equals_upper (seqDef_lower_equals_upper) =========================================
seqDef_lower_equals_upper {
\find(seqDef{uSub (variable)}(idx,idx,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), idx (int term)))
\replacewith(seqEmpty) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== seqDef_one_summand (seqDef_one_summand) =========================================
seqDef_one_summand {
\find(seqDef{uSub (variable)}(from,idx,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), idx (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(if-then-else(equals(add(from,Z(1(#))),idx),seqSingleton(subst{uSub (variable)}(from,t)),seqDef{uSub (variable)}(from,idx,t))) 

Choices: sequences:on}
-----------------------------------------------------
== seqDef_split (seqDef_split) =========================================
seqDef_split {
\find(seqDef{uSub (variable)}(from,to,t))
\varcond(\notFreeIn(uSub1 (variable), t (any term)), \notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), idx (int term)), \notFreeIn(uSub (variable), from (int term)), \notFreeIn(uSub1 (variable), to (int term)), \notFreeIn(uSub1 (variable), idx (int term)), \notFreeIn(uSub1 (variable), from (int term)))
\replacewith(if-then-else(and(leq(from,idx),lt(idx,to)),seqConcat(seqDef{uSub (variable)}(from,idx,t),seqDef{uSub1 (variable)}(idx,to,subst{uSub (variable)}(uSub1,t))),seqDef{uSub (variable)}(from,to,t))) 

Choices: sequences:on}
-----------------------------------------------------
== seqDef_split_in_three (seqDef_split_in_three) =========================================
seqDef_split_in_three {
\find(seqDef{uSub (variable)}(from,to,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub1 (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)), \notFreeIn(uSub1 (variable), idx (int term)), \notFreeIn(uSub1 (variable), t (any term)), \notFreeIn(uSub (variable), idx (int term)))
\replacewith(seqConcat(seqDef{uSub (variable)}(from,idx,t),seqConcat(seqSingleton(subst{uSub (variable)}(idx,t)),seqDef{uSub1 (variable)}(add(idx,Z(1(#))),to,subst{uSub (variable)}(uSub1,t))))) ;
\add []==>[and(leq(from,idx),lt(idx,to))] 

Choices: sequences:on}
-----------------------------------------------------
== seqGetAlphaCast (seqGetAlphaCast) =========================================
seqGetAlphaCast {
\find(alpha::seqGet(seq,at))
\add [equals(alpha::cast(any::seqGet(seq,at)),alpha::seqGet(seq,at))]==>[] 
\heuristics(inReachableStateImplication)
Choices: sequences:on}
-----------------------------------------------------
== seqGetUnfoldLeft (seqGetUnfold) =========================================
seqGetUnfoldLeft {
\find(#allmodal ( (modal operator))\[{ ..
  #v = #nseLeft[#eRight];
... }\] (post))
\varcond(\new(#vLeftNew (program Variable), \typeof(#nseLeft (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseLeft) #vLeftNew = #nseLeft;
  #v = #vLeftNew[#eRight];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqGetUnfoldRight (seqGetUnfold) =========================================
seqGetUnfoldRight {
\find(#allmodal ( (modal operator))\[{ ..
  #v = #seLeft[#nseRight];
... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseRight) #vRightNew = #nseRight;
  #v = #seLeft[#vRightNew];
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqIndexOf (seqIndexOf) =========================================
seqIndexOf {
\find(seqIndexOf(s,t))
\varcond(\notFreeIn(m (variable), t (any term)), \notFreeIn(m (variable), s (Seq term)), \notFreeIn(n (variable), t (any term)), \notFreeIn(n (variable), s (Seq term)))
\add [imp(exists{n (variable)}(and(and(leq(Z(0(#)),n),lt(n,seqLen(s))),equals(any::seqGet(s,n),t))),and(and(and(leq(Z(0(#)),seqIndexOf(s,t)),lt(seqIndexOf(s,t),seqLen(s))),equals(any::seqGet(s,seqIndexOf(s,t)),t)),all{m (variable)}(imp(and(leq(Z(0(#)),m),lt(m,seqIndexOf(s,t))),not(equals(any::seqGet(s,m),t))))))]==>[] 

Choices: sequences:on}
-----------------------------------------------------
== seqIndexOfUnfoldLeft (seqIndexOfUnfold) =========================================
seqIndexOfUnfoldLeft {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \indexOf(#nseLeft, #eRight);
... }\] (post))
\varcond(\new(#vLeftNew (program Variable), \typeof(#nseLeft (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseLeft) #vLeftNew = #nseLeft;
  #v = \indexOf(#vLeftNew, #eRight);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqIndexOfUnfoldRight (seqIndexOfUnfold) =========================================
seqIndexOfUnfoldRight {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \indexOf(#seLeft, #nseRight);
... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseRight) #vRightNew = #nseRight;
  #v = \indexOf(#seLeft, #vRightNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqLengthUnfold (seqLengthUnfold) =========================================
seqLengthUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  #v = #nse.length;
... }\] (post))
\varcond(\new(#vNew (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #vNew = #nse;
  #v = #vNew.length;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqOutsideValue (seqOutsideValue) =========================================
seqOutsideValue {
\find(seqGetOutside)
\add [all{s (variable)}(all{iv (variable)}(imp(or(lt(iv,Z(0(#))),leq(seqLen(s),iv)),equals(any::seqGet(s,iv),seqGetOutside))))]==>[] 

Choices: sequences:on}
-----------------------------------------------------
== seqReverseOfSeqEmpty (seqReverseOfSeqEmpty) =========================================
seqReverseOfSeqEmpty {
\find(seqReverse(seqEmpty))
\replacewith(seqEmpty) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== seqReverseUnfold (seqReverseUnfold) =========================================
seqReverseUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \seq_reverse(#nse);
... }\] (post))
\varcond(\new(#vNew (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #vNew = #nse;
  #v = \seq_reverse(#vNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqSelfDefinition (seqSelfDefinition) =========================================
seqSelfDefinition {
\find(seq)
\add [all{s (variable)}(equals(s,seqDef{u (variable)}(Z(0(#)),seqLen(s),any::seqGet(s,u))))]==>[] 

Choices: sequences:on}
-----------------------------------------------------
== seqSelfDefinitionEQ2 (seqSelfDefinition) =========================================
seqSelfDefinitionEQ2 {
\assumes ([equals(seqLen(s),x)]==>[]) 
\find(seqDef{u (variable)}(Z(0(#)),x,any::seqGet(s,u)))
\sameUpdateLevel\varcond(\notFreeIn(u (variable), s (Seq term)), \notFreeIn(u (variable), x (int term)))
\replacewith(s) 
\heuristics(simplify)
Choices: sequences:on}
-----------------------------------------------------
== seqSingletonUnfold (seqSingletonUnfold) =========================================
seqSingletonUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \seq_singleton(#nse);
... }\] (post))
\varcond(\new(#vNew (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #vNew = #nse;
  #v = \seq_singleton(#vNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqSubUnfoldLeft (seqSubUnfold) =========================================
seqSubUnfoldLeft {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \seq_sub(#nseLeft, #eMiddle, #eRight);
... }\] (post))
\varcond(\new(#vLeftNew (program Variable), \typeof(#nseLeft (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseLeft) #vLeftNew = #nseLeft;
  #v = \seq_sub(#vLeftNew, #eMiddle, #eRight);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqSubUnfoldMiddle (seqSubUnfold) =========================================
seqSubUnfoldMiddle {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \seq_sub(#seLeft, #nseMiddle, #eRight);
... }\] (post))
\varcond(\new(#vMiddleNew (program Variable), \typeof(#nseMiddle (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseMiddle) #vMiddleNew = #nseMiddle;
  #v = \seq_sub(#seLeft, #vMiddleNew, #eRight);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== seqSubUnfoldRight (seqSubUnfold) =========================================
seqSubUnfoldRight {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \seq_sub(#seLeft, #seMiddle, #nseRight);
... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseRight) #vRightNew = #nseRight;
  #v = \seq_sub(#seLeft, #seMiddle, #vRightNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== sequentialToParallel1 (sequentialToParallel1) =========================================
sequentialToParallel1 {
\find(update-application(u,update-application(u2,t)))
\replacewith(update-application(parallel-upd(u,update-application(u,u2)),t)) 
\heuristics(update_join)
Choices: true}
-----------------------------------------------------
== sequentialToParallel2 (sequentialToParallel2) =========================================
sequentialToParallel2 {
\find(update-application(u,update-application(u2,phi)))
\replacewith(update-application(parallel-upd(u,update-application(u,u2)),phi)) 
\heuristics(update_join)
Choices: true}
-----------------------------------------------------
== sequentialToParallel3 (sequentialToParallel3) =========================================
sequentialToParallel3 {
\find(update-application(u,update-application(u2,u3)))
\replacewith(update-application(parallel-upd(u,update-application(u,u2)),u3)) 
\heuristics(update_join)
Choices: true}
-----------------------------------------------------
== setIntersectUnfoldLeft (setIntersectUnfold) =========================================
setIntersectUnfoldLeft {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \intersect(#nseLeft, #eRight);
... }\] (post))
\varcond(\new(#vLeftNew (program Variable), \typeof(#nseLeft (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseLeft) #vLeftNew = #nseLeft;
  #v = \intersect(#vLeftNew, #eRight);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== setIntersectUnfoldRight (setIntersectUnfold) =========================================
setIntersectUnfoldRight {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \intersect(#seLeft, #nseRight);
... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseRight) #vRightNew = #nseRight;
  #v = \intersect(#seLeft, #vRightNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== setJavaCardTransient (setJavaCardTransient) =========================================
setJavaCardTransient {
\find(==>#allmodal ( (modal operator))\[{ ..
  #jcsystemType.#setTransient(#se, #se1)@#jcsystemType;
... }\] (post))
\replacewith([]==>[not(equals(#se,null))]) ;
\replacewith([]==>[update-application(elem-update(heap)(store(heap,#se,java.lang.Object::<transient>,#se1)),#allmodal(post))]) 
\heuristics(simplify_prog)
Choices: (programRules:Java & JavaCard:on)}
-----------------------------------------------------
== setMinusItself (setMinusItself) =========================================
setMinusItself {
\find(setMinus(s,s))
\replacewith(empty) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== setMinusOfUnion (setMinusOfUnion) =========================================
setMinusOfUnion {
\find(setMinus(union(s,s2),s3))
\replacewith(union(setMinus(s,s3),setMinus(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== setMinusOfUnionEQ (setMinusOfUnionEQ) =========================================
setMinusOfUnionEQ {
\assumes ([equals(union(s,s2),EQ)]==>[]) 
\find(setMinus(EQ,s3))
\sameUpdateLevel\replacewith(union(setMinus(s,s3),setMinus(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== setMinusSingleton (setMinusSingleton) =========================================
setMinusSingleton {
\assumes ([]==>[elementOf(o,f,s)]) 
\find(setMinus(s,singleton(o,f)))
\replacewith(s) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== setMinusUnfoldLeft (setMinusUnfold) =========================================
setMinusUnfoldLeft {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \set_minus(#nseLeft, #eRight);
... }\] (post))
\varcond(\new(#vLeftNew (program Variable), \typeof(#nseLeft (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseLeft) #vLeftNew = #nseLeft;
  #v = \set_minus(#vLeftNew, #eRight);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== setMinusUnfoldRight (setMinusUnfold) =========================================
setMinusUnfoldRight {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \set_minus(#seLeft, #nseRight);
... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseRight) #vRightNew = #nseRight;
  #v = \set_minus(#seLeft, #vRightNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== setMinusWithAllLocs (setMinusWithAllLocs) =========================================
setMinusWithAllLocs {
\find(setMinus(s,allLocs))
\replacewith(empty) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== setMinusWithEmpty1 (setMinusWithEmpty) =========================================
setMinusWithEmpty1 {
\find(setMinus(s,empty))
\replacewith(s) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== setMinusWithEmpty2 (setMinusWithEmpty) =========================================
setMinusWithEmpty2 {
\find(setMinus(empty,s))
\replacewith(empty) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== setUnionUnfoldLeft (setUnionUnfold) =========================================
setUnionUnfoldLeft {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \set_union(#nseLeft, #eRight);
... }\] (post))
\varcond(\new(#vLeftNew (program Variable), \typeof(#nseLeft (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseLeft) #vLeftNew = #nseLeft;
  #v = \set_union(#vLeftNew, #eRight);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== setUnionUnfoldRight (setUnionUnfold) =========================================
setUnionUnfoldRight {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \set_union(#seLeft, #nseRight);
... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseRight) #vRightNew = #nseRight;
  #v = \set_union(#seLeft, #vRightNew);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== shiftLeftDef (shiftLeftDef) =========================================
shiftLeftDef {
\find(shiftleft(left,right))
\replacewith(if-then-else(lt(right,Z(0(#))),shiftrightPositiveShift(left,neg(right)),shiftleftPositiveShift(left,right))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== shiftLeftPositiveShiftDef (shiftLeftPositiveShiftDef) =========================================
shiftLeftPositiveShiftDef {
\find(shiftleftPositiveShift(left,right))
\replacewith(mul(left,pow(Z(2(#)),right))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== shiftRightDef (shiftRightDef) =========================================
shiftRightDef {
\find(shiftright(left,right))
\replacewith(if-then-else(lt(right,Z(0(#))),shiftleftPositiveShift(left,neg(right)),shiftrightPositiveShift(left,right))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== shiftRightPositiveShiftDef (shiftRightPositiveShiftDef) =========================================
shiftRightPositiveShiftDef {
\find(shiftrightPositiveShift(left,right))
\replacewith(div(left,pow(Z(2(#)),right))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== shift_paren_and (shift_paren_and) =========================================
shift_paren_and {
\find(and(assoc0,and(assoc1,assoc2)))
\replacewith(and(and(assoc0,assoc1),assoc2)) 
\heuristics(cnf_andAssoc, conjNormalForm)
Choices: true}
-----------------------------------------------------
== shift_paren_or (shift_paren_or) =========================================
shift_paren_or {
\find(or(assoc0,or(assoc1,assoc2)))
\replacewith(or(or(assoc0,assoc1),assoc2)) 
\heuristics(cnf_orAssoc, conjNormalForm)
Choices: true}
-----------------------------------------------------
== shiftleft_literals (shift) =========================================
shiftleft_literals {
\find(shiftleft(Z(iz),Z(jz)))
\replacewith(#ShiftLeft(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== shiftright_literals (shift) =========================================
shiftright_literals {
\find(shiftright(Z(iz),Z(jz)))
\replacewith(#ShiftRight(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== sign_case_distinction (sign_case_distinction) =========================================
sign_case_distinction {
\add [geq(signCasesLeft,Z(1(#)))]==>[] ;
\add [equals(signCasesLeft,Z(0(#)))]==>[] ;
\add [leq(signCasesLeft,Z(neglit(1(#))))]==>[] 
\heuristics(inEqSimp_signCases)
Choices: true}
-----------------------------------------------------
== simplifyIfThenElseUpdate1 (simplifyIfThenElse) =========================================
simplifyIfThenElseUpdate1 {
\find(if-then-else(phi,update-application(u1,t),update-application(u2,t)))
\varcond(\simplifyIfThenElseUpdate(phi, u1, u2, t, result), )
\replacewith(result) 

Choices: true}
-----------------------------------------------------
== simplifyIfThenElseUpdate2 (simplifyIfThenElse) =========================================
simplifyIfThenElseUpdate2 {
\find(if-then-else(phi,t,update-application(u2,t)))
\varcond(\simplifyIfThenElseUpdate(phi, u1, u2, t, result), )
\replacewith(result) 

Choices: true}
-----------------------------------------------------
== simplifyIfThenElseUpdate3 (simplifyIfThenElse) =========================================
simplifyIfThenElseUpdate3 {
\find(if-then-else(phi,update-application(u1,t),t))
\varcond(\simplifyIfThenElseUpdate(phi, u1, u2, t, result), )
\replacewith(result) 

Choices: true}
-----------------------------------------------------
== simplifyIfThenElseUpdate4 (simplifyIfThenElse) =========================================
simplifyIfThenElseUpdate4 {
\find(if-then-else(phi,t,t))
\varcond(\simplifyIfThenElseUpdate(phi, u1, u2, t, result), )
\replacewith(result) 

Choices: true}
-----------------------------------------------------
== simplifySelectOfAnon (simplifySelectOfAnon) =========================================
simplifySelectOfAnon {
\find(equals(beta::select(anon(h,s,h2),o,f),sk)==>)
\addrules [replaceKnownSelect {
\find(beta::select(anon(h,s,h2),o,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([equals(if-then-else(or(and(elementOf(o,f,s),not(equals(f,java.lang.Object::<created>))),elementOf(o,f,freshLocs(h))),beta::select(h2,o,f),beta::select(h,o,f)),sk)]==>[]) 
\heuristics(simplify_select)
Choices: programRules:Java}
-----------------------------------------------------
== simplifySelectOfAnonEQ (simplifySelectOfAnonEQ) =========================================
simplifySelectOfAnonEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==>[]) 
\find(equals(beta::select(EQ,o,f),sk)==>)
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([equals(if-then-else(or(and(elementOf(o,f,s),not(equals(f,java.lang.Object::<created>))),elementOf(o,f,freshLocs(h))),beta::select(h2,o,f),beta::select(h,o,f)),sk)]==>[]) 
\heuristics(simplify_select)
Choices: programRules:Java}
-----------------------------------------------------
== simplifySelectOfCreate (simplifySelectOfCreate) =========================================
simplifySelectOfCreate {
\find(equals(beta::select(create(h,o),o2,f),sk)==>)
\addrules [replaceKnownSelect {
\find(beta::select(create(h,o),o2,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([equals(if-then-else(and(and(equals(o,o2),not(equals(o,null))),equals(f,java.lang.Object::<created>)),beta::cast(TRUE),beta::select(h,o2,f)),sk)]==>[]) 
\heuristics(simplify_select)
Choices: programRules:Java}
-----------------------------------------------------
== simplifySelectOfCreateEQ (simplifySelectOfCreateEQ) =========================================
simplifySelectOfCreateEQ {
\assumes ([equals(create(h,o),EQ)]==>[]) 
\find(equals(beta::select(EQ,o2,f),sk)==>)
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o2,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([equals(if-then-else(and(and(equals(o,o2),not(equals(o,null))),equals(f,java.lang.Object::<created>)),beta::cast(TRUE),beta::select(h,o2,f)),sk)]==>[]) 
\heuristics(simplify_select)
Choices: programRules:Java}
-----------------------------------------------------
== simplifySelectOfMemset (simplifySelectOfMemset) =========================================
simplifySelectOfMemset {
\find(equals(beta::select(memset(h,s,x),o,f),sk)==>)
\addrules [replaceKnownSelect {
\find(beta::select(memset(h,s,x),o,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([equals(if-then-else(and(elementOf(o,f,s),not(equals(f,java.lang.Object::<created>))),x,beta::select(h,o,f)),sk)]==>[]) 
\heuristics(simplify_select)
Choices: programRules:Java}
-----------------------------------------------------
== simplifySelectOfMemsetEQ (simplifySelectOfMemsetEQ) =========================================
simplifySelectOfMemsetEQ {
\assumes ([equals(memset(h,s,x),EQ)]==>[]) 
\find(equals(beta::select(EQ,o,f),sk)==>)
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([equals(if-then-else(and(elementOf(o,f,s),not(equals(f,java.lang.Object::<created>))),x,beta::select(h,o,f)),sk)]==>[]) 
\heuristics(simplify_select)
Choices: programRules:Java}
-----------------------------------------------------
== simplifySelectOfStore (simplifySelectOfStore) =========================================
simplifySelectOfStore {
\find(equals(beta::select(store(h,o,f,x),o2,f2),sk)==>)
\addrules [replaceKnownSelect {
\find(beta::select(store(h,o,f,x),o2,f2))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([equals(if-then-else(and(and(equals(o,o2),equals(f,f2)),not(equals(f,java.lang.Object::<created>))),beta::cast(x),beta::select(h,o2,f2)),sk)]==>[]) 
\heuristics(simplify_select)
Choices: programRules:Java}
-----------------------------------------------------
== simplifySelectOfStoreEQ (simplifySelectOfStoreEQ) =========================================
simplifySelectOfStoreEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==>[]) 
\find(equals(beta::select(EQ,o2,f2),sk)==>)
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o2,f2))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: programRules:Java}] \replacewith([equals(if-then-else(and(and(equals(o,o2),equals(f,f2)),not(equals(f,java.lang.Object::<created>))),beta::cast(x),beta::select(h,o2,f2)),sk)]==>[]) 
\heuristics(simplify_select)
Choices: programRules:Java}
-----------------------------------------------------
== simplifyUpdate1 (simplifyUpdate1) =========================================
simplifyUpdate1 {
\find(update-application(u,t))
\varcond(\dropEffectlessElementaries(u (update), t (any term), result (any term)), )
\replacewith(result) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== simplifyUpdate2 (simplifyUpdate2) =========================================
simplifyUpdate2 {
\find(update-application(u,phi))
\varcond(\dropEffectlessElementaries(u (update), phi (formula), result (formula)), )
\replacewith(result) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== simplifyUpdate3 (simplifyUpdate3) =========================================
simplifyUpdate3 {
\find(update-application(u,u2))
\varcond(\dropEffectlessElementaries(u (update), u2 (update), result (update)), )
\replacewith(result) 
\heuristics(update_elim)
Choices: true}
-----------------------------------------------------
== sinIsNaN (sinIsNaN) =========================================
sinIsNaN {
\find(sinDouble(arg))
\add [imp(or(doubleIsNaN(arg),doubleIsInfinite(arg)),doubleIsNaN(sinDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sinIsNotNaN (sinIsNotNaN) =========================================
sinIsNotNaN {
\find(sinDouble(arg))
\add [imp(and(not(doubleIsNaN(arg)),not(doubleIsInfinite(arg))),not(doubleIsNaN(sinDouble(arg))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sinRange2 (sinRange2) =========================================
sinRange2 {
\find(sinDouble(arg))
\add [imp(and(not(doubleIsNaN(arg)),not(doubleIsInfinite(arg))),and(geqDouble(sinDouble(arg),negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),leqDouble(sinDouble(arg),DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sinRange3 (sinRange3) =========================================
sinRange3 {
\find(sinDouble(arg))
\add [imp(and(not(doubleIsNaN(arg)),not(doubleIsInfinite(arg))),and(geqDouble(mulDouble(sinDouble(arg),sinDouble(arg)),DFP(0(#))),leqDouble(mulDouble(sinDouble(arg),sinDouble(arg)),DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sineIsNaNAlt (sineIsNaNAlt) =========================================
sineIsNaNAlt {
\find(doubleIsNaN(sinDouble(arg)))
\replacewith(or(doubleIsNaN(arg),doubleIsInfinite(arg))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== sineIsZero (sineIsZero) =========================================
sineIsZero {
\find(sinDouble(arg))
\add [imp(equals(arg,DFP(0(#))),equals(sinDouble(arg),DFP(0(#))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sineRange (sineRange) =========================================
sineRange {
\find(sinDouble(arg))
\add [or(and(geqDouble(sinDouble(arg),negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),leqDouble(sinDouble(arg),DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),doubleIsNaN(sinDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sineRangeAlt (sineRangeAlt) =========================================
sineRangeAlt {
\find(==>doubleIsNaN(sinDouble(arg)))
\add [and(geqDouble(sinDouble(arg),negDouble(DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),leqDouble(sinDouble(arg),DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#))))))))))))))))))))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== singletonAssignment (singletonAssignment) =========================================
singletonAssignment {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \singleton(#seObj.#a);
... }\] (post))
\replacewith(update-application(elem-update(#v (program Variable))(singleton(#seObj,#memberPVToField(#a))),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== singletonEqualsEmpty (singletonEqualsEmpty) =========================================
singletonEqualsEmpty {
\find(equals(singleton(o,f),empty))
\replacewith(false) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== singletonUnfold (singletonUnfold) =========================================
singletonUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  #v = \singleton(#nseObj.#a);
... }\] (post))
\varcond(\new(#vObjNew (program Variable), \typeof(#nseObj (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nseObj) #vObjNew = #nseObj;
  #v = \singleton(#vObjNew.#a);
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== sizeOfMapEmpty (sizeOfMapEmpty) =========================================
sizeOfMapEmpty {
\find(mapSize(mapEmpty))
\sameUpdateLevel\replacewith(Z(0(#))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== sizeOfMapRemove (sizeOfMapRemove) =========================================
sizeOfMapRemove {
\find(mapSize(mapRemove(m,key)))
\add [imp(isFinite(m),equals(mapSize(mapRemove(m,key)),if-then-else(inDomain(m,key),sub(mapSize(m),Z(1(#))),mapSize(m))))]==>[] 
\heuristics(inReachableStateImplication)
Choices: true}
-----------------------------------------------------
== sizeOfMapSingleton (sizeOfMapSingleton) =========================================
sizeOfMapSingleton {
\find(mapSize(mapSingleton(key,value)))
\sameUpdateLevel\replacewith(Z(1(#))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== sizeOfMapUpdate (sizeOfMapUpdate) =========================================
sizeOfMapUpdate {
\find(mapSize(mapUpdate(m,key,value)))
\add [imp(isFinite(m),equals(mapSize(mapUpdate(m,key,value)),if-then-else(inDomain(m,key),mapSize(m),add(mapSize(m),Z(1(#))))))]==>[] 
\heuristics(inReachableStateImplication)
Choices: true}
-----------------------------------------------------
== sizeOfSeq2Map (sizeOfSeq2Map) =========================================
sizeOfSeq2Map {
\find(mapSize(seq2map(s)))
\sameUpdateLevel\replacewith(seqLen(s)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== sortsDisjoint1 (sortsDisjoint1) =========================================
sortsDisjoint1 {
\find(equals(x,y))
\varcond(\not\sub(Null, G), \disjointModuloNull(G, H), )
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== sortsDisjoint2 (sortsDisjoint2) =========================================
sortsDisjoint2 {
\find(equals(x,y))
\varcond(\not\sub(Null, H), \disjointModuloNull(G, H), )
\replacewith(false) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== sortsDisjointModuloNull (sortsDisjointModuloNull) =========================================
sortsDisjointModuloNull {
\find(equals(x,y))
\varcond(\strict\sub(Null, G), \strict\sub(Null, H), \disjointModuloNull(G, H), )
\replacewith(and(equals(x,null),equals(y,null))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== special_constructor_call (special_constructor_call) =========================================
special_constructor_call {
\find(#allmodal ( (modal operator))\[{ ..
  #scr
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  special-constructor-call(#scr)
... }\] (post)) 
\heuristics(method_expand)
Choices: programRules:Java}
-----------------------------------------------------
== splitEquation (splitEquation) =========================================
splitEquation {
\find(equals(splitEqLeft,splitEqRight))
\replacewith(and(geq(splitEqLeft,splitEqRight),leq(splitEqLeft,splitEqRight))) 

Choices: true}
-----------------------------------------------------
== splitEquationSucc (splitEquationSucc) =========================================
splitEquationSucc {
\find(==>equals(splitEqLeft,splitEqRight))
\replacewith([]==>[leq(splitEqLeft,splitEqRight)]) ;
\replacewith([]==>[geq(splitEqLeft,splitEqRight)]) 
\heuristics(notHumanReadable, inEqSimp_split_eq, inEqSimp_nonLin)
Choices: true}
-----------------------------------------------------
== split_or_strong (split_or_strong) =========================================
split_or_strong {
\find(or(b,c)==>)
\replacewith([c]==>[b]) ;
\replacewith([b]==>[]) 

Choices: true}
-----------------------------------------------------
== sqrtIsInfinite (sqrtIsInfinite) =========================================
sqrtIsInfinite {
\find(sqrtDouble(arg))
\add [imp(and(doubleIsInfinite(arg),gtDouble(arg,DFP(0(#)))),and(doubleIsInfinite(sqrtDouble(arg)),gtDouble(sqrtDouble(arg),DFP(0(#)))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sqrtIsNaN (sqrtIsNaN) =========================================
sqrtIsNaN {
\find(sqrtDouble(arg))
\add [imp(or(doubleIsNaN(arg),ltDouble(arg,DFP(0(#)))),doubleIsNaN(sqrtDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sqrtIsNotNaN (sqrtIsNotNaN) =========================================
sqrtIsNotNaN {
\find(sqrtDouble(arg))
\add [imp(and(not(doubleIsNaN(arg)),geqDouble(arg,DFP(0(#)))),not(doubleIsNaN(sqrtDouble(arg))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sqrtIsSmaller (sqrtIsSmaller) =========================================
sqrtIsSmaller {
\find(sqrtDouble(arg))
\add [imp(and(not(doubleIsInfinite(arg)),gtDouble(arg,DFP(8(0(4(7(1(0(0(0(8(8(1(4(2(8(1(7(0(6(4(#)))))))))))))))))))))),ltDouble(sqrtDouble(arg),arg))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== sqrtIsZero (sqrtIsZero) =========================================
sqrtIsZero {
\find(sqrtDouble(arg))
\add [imp(equals(arg,DFP(0(#))),equals(sqrtDouble(arg),DFP(0(#))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== square_nonneg (square_nonneg) =========================================
square_nonneg {
\find(leq(Z(0(#)),mul(i0,i0)))
\replacewith(true) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== startsWith (startsWith) =========================================
startsWith {
\find(clStartsWith(sourceStr,searchStr))
\replacewith(if-then-else(gt(seqLen(searchStr),seqLen(sourceStr)),false,equals(seqSub(sourceStr,Z(0(#)),seqLen(searchStr)),searchStr))) 
\heuristics(defOpsStartsEndsWith)
Choices: Strings:on}
-----------------------------------------------------
== staticMethodCall (methodCall) =========================================
staticMethodCall {
\find(#allmodal ( (modal operator))\[{ ..
  #se.#mn(#elist);
... }\] (post))
\varcond(\staticMethodReference(#se (program SimpleExpression), #mn (program MethodName), #elist (program Expression)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  method-call(#se.#mn(#elist))
... }\] (post)) 
\heuristics(method_expand)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== staticMethodCallStaticViaTypereference (methodCall) =========================================
staticMethodCallStaticViaTypereference {
\find(#allmodal ( (modal operator))\[{ ..
  #t.#mn(#elist);
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  method-call(#t.#mn(#elist))
... }\] (post)) 
\heuristics(method_expand)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== staticMethodCallStaticWithAssignmentViaTypereference (methodCall) =========================================
staticMethodCallStaticWithAssignmentViaTypereference {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #t.#mn(#elist);
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#lhs) #v0;
  method-call(#t.#mn(#elist))
  #lhs = #v0;
... }\] (post)) 
\heuristics(method_expand)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== staticMethodCallWithAssignment (methodCall) =========================================
staticMethodCallWithAssignment {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = #se.#mn(#elist);
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))), \staticMethodReference(#se (program SimpleExpression), #mn (program MethodName), #elist (program Expression)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#lhs) #v0;
  method-call(#se.#mn(#elist))
  #lhs = #v0;
... }\] (post)) 
\heuristics(method_expand)
Choices: (programRules:Java & initialisation:disableStaticInitialisation)}
-----------------------------------------------------
== stringAssignment (stringAssignment) =========================================
stringAssignment {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #slit;
... }\] (post))
\sameUpdateLevel\add [not(equals(strPool(#slit),null)),equals(boolean::select(heap,strPool(#slit),java.lang.Object::<created>),TRUE)]==>[] \replacewith(update-application(elem-update(#v (program Variable))(strPool(#slit)),#normalassign(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcat (stringConcat) =========================================
stringConcat {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #sstr1 + #sstr2;
... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(strContent(#sstr1),strContent(#sstr2)))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcatBooleanLeft (stringConcatBooleanLeft) =========================================
stringConcatBooleanLeft {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #seLeft + #sstrRight;
... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(if-then-else(equals(#seLeft,TRUE),seqConcat(seqSingleton(C(6(1(1(#))))),seqConcat(seqSingleton(C(4(1(1(#))))),seqConcat(seqSingleton(C(7(1(1(#))))),seqSingleton(C(1(0(1(#)))))))),seqConcat(seqSingleton(C(2(0(1(#))))),seqConcat(seqSingleton(C(7(9(#)))),seqConcat(seqSingleton(C(8(0(1(#))))),seqConcat(seqSingleton(C(5(1(1(#))))),seqSingleton(C(1(0(1(#)))))))))),strContent(#sstrRight)))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcatBooleanRight (stringConcatBooleanRight) =========================================
stringConcatBooleanRight {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #sstrLeft + #seRight;
... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(strContent(#sstrLeft),if-then-else(equals(#seRight,TRUE),seqConcat(seqSingleton(C(6(1(1(#))))),seqConcat(seqSingleton(C(4(1(1(#))))),seqConcat(seqSingleton(C(7(1(1(#))))),seqSingleton(C(1(0(1(#)))))))),seqConcat(seqSingleton(C(2(0(1(#))))),seqConcat(seqSingleton(C(7(9(#)))),seqConcat(seqSingleton(C(8(0(1(#))))),seqConcat(seqSingleton(C(5(1(1(#))))),seqSingleton(C(1(0(1(#))))))))))))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcatCharExpLeft (stringConcatCharExpLeft) =========================================
stringConcatCharExpLeft {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #seLeft + #sstrRight;
... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(seqSingleton(#seLeft),strContent(#sstrRight)))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcatCharExpRight (stringConcatCharExpRight) =========================================
stringConcatCharExpRight {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #sstrLeft + #seRight;
... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(strContent(#sstrLeft),seqSingleton(#seRight)))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcatIntExpLeft (stringConcatIntExpLeft) =========================================
stringConcatIntExpLeft {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #seLeft + #sstrRight;
... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(clTranslateInt(#seLeft),strContent(#sstrRight)))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcatIntExpRight (stringConcatIntExpRight) =========================================
stringConcatIntExpRight {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #sstrLeft + #seRight;
... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(strContent(#sstrLeft),clTranslateInt(#seRight)))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcatObjectLeft (stringConcatObjectLeft) =========================================
stringConcatObjectLeft {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #seLeft + #sstrRight;
... }\] (post))
\sameUpdateLevel\add [equals(#seLeft,null),equals(strContent(sk),seqConcat(strContent(null),strContent(#sstrRight)))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) ;
\add []==>[equals(#seLeft,null)] \replacewith(#normalassign ( (modal operator))\[{ ..
  #v = #seLeft.toString() + #sstrRight;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== stringConcatObjectRight (stringConcatObjectRight) =========================================
stringConcatObjectRight {
\find(#normalassign ( (modal operator))\[{ ..
  #v = #sstrLeft + #seRight;
... }\] (post))
\sameUpdateLevel\add [equals(#seRight,null),equals(strContent(sk),seqConcat(strContent(#sstrLeft),strContent(null)))]==>[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) ;
\add []==>[equals(#seRight,null)] \replacewith(#normalassign ( (modal operator))\[{ ..
  #v = #sstrLeft + #seRight.toString();
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: true}
-----------------------------------------------------
== sub (sub) =========================================
sub {
\find(sub(i,i0))
\replacewith(add(i,neg(i0))) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== subSeqComplete (subSeqComplete) =========================================
subSeqComplete {
\find(seqSub(seq,Z(0(#)),seqLen(seq)))
\replacewith(seq) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqCompleteSeqDef (subSeqCompleteSeqDef) =========================================
subSeqCompleteSeqDef {
\find(seqSub(seqDef{i (variable)}(Z(0(#)),u,a),Z(0(#)),u))
\replacewith(seqDef{i (variable)}(Z(0(#)),u,a)) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqCompleteSeqDefEQ (subSeqCompleteSeqDefEQ) =========================================
subSeqCompleteSeqDefEQ {
\assumes ([equals(seqDef{i (variable)}(Z(0(#)),u,a),EQ)]==>[]) 
\find(seqSub(EQ,Z(0(#)),u))
\replacewith(seqDef{i (variable)}(Z(0(#)),u,a)) 
\heuristics(concrete, no_self_application)
Choices: sequences:on}
-----------------------------------------------------
== subSeqConcat (subSeqConcat) =========================================
subSeqConcat {
\find(seqSub(seqConcat(s1,s2),l,u))
\replacewith(seqConcat(seqSub(s1,l,if-then-else(lt(seqLen(s1),u),seqLen(s1),u)),seqSub(s2,if-then-else(lt(l,seqLen(s1)),Z(0(#)),sub(l,seqLen(s1))),sub(u,seqLen(s1))))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== subSeqConcatEQ (subSeqConcatEQ) =========================================
subSeqConcatEQ {
\assumes ([equals(seqConcat(s1,s2),EQ)]==>[]) 
\find(seqSub(EQ,l,u))
\replacewith(seqConcat(seqSub(s1,l,if-then-else(lt(seqLen(s1),u),seqLen(s1),u)),seqSub(s2,if-then-else(lt(l,seqLen(s1)),Z(0(#)),sub(l,seqLen(s1))),sub(u,seqLen(s1))))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: sequences:on}
-----------------------------------------------------
== subSeqEmpty (subSeqEmpty) =========================================
subSeqEmpty {
\find(seqSub(seq,i,i))
\replacewith(seqEmpty) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqHeadSeqDef (subSeqHeadSeqDef) =========================================
subSeqHeadSeqDef {
\find(seqSub(seqConcat(seqDef{i (variable)}(Z(0(#)),u,a),seq),Z(0(#)),u))
\replacewith(seqDef{i (variable)}(Z(0(#)),u,a)) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqHeadSeqDefEQ (subSeqHeadSeqDefEQ) =========================================
subSeqHeadSeqDefEQ {
\assumes ([equals(seqDef{i (variable)}(Z(0(#)),u,a),EQ)]==>[]) 
\find(seqSub(seqConcat(EQ,seq),Z(0(#)),u))
\replacewith(seqDef{i (variable)}(Z(0(#)),u,a)) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqSingleton (subSeqSingleton) =========================================
subSeqSingleton {
\find(seqSub(seqSingleton(x),Z(0(#)),Z(1(#))))
\replacewith(seqSingleton(x)) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqSingleton2 (subSeqSingleton2) =========================================
subSeqSingleton2 {
\find(seqSub(seqSingleton(x),l,u))
\replacewith(seqConcat(seqSub(seqEmpty,if-then-else(lt(l,Z(0(#))),l,Z(0(#))),if-then-else(lt(u,Z(0(#))),u,Z(0(#)))),seqConcat(if-then-else(and(leq(l,Z(0(#))),geq(u,Z(1(#)))),seqSingleton(x),seqEmpty),seqSub(seqEmpty,if-then-else(gt(l,Z(0(#))),l,Z(1(#))),if-then-else(gt(u,Z(0(#))),u,Z(1(#))))))) 
\heuristics(simplify_enlarging)
Choices: sequences:on}
-----------------------------------------------------
== subSeqSingleton2EQ (subSeqSingleton2EQ) =========================================
subSeqSingleton2EQ {
\assumes ([equals(seqSingleton(x),EQ)]==>[]) 
\find(seqSub(EQ,l,u))
\replacewith(seqConcat(seqSub(seqEmpty,if-then-else(lt(l,Z(0(#))),l,Z(0(#))),if-then-else(lt(u,Z(0(#))),u,Z(0(#)))),seqConcat(if-then-else(and(leq(l,Z(0(#))),geq(u,Z(1(#)))),seqSingleton(x),seqEmpty),seqSub(seqEmpty,if-then-else(gt(l,Z(0(#))),l,Z(1(#))),if-then-else(gt(u,Z(0(#))),u,Z(1(#))))))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: sequences:on}
-----------------------------------------------------
== subSeqSingletonEQ (subSeqSingletonEQ) =========================================
subSeqSingletonEQ {
\assumes ([equals(seqSingleton(x),EQ)]==>[]) 
\find(seqSub(EQ,Z(0(#)),Z(1(#))))
\replacewith(seqSingleton(x)) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqTailEQL (subSeqTail) =========================================
subSeqTailEQL {
\assumes ([equals(seqLen(seq),EQ)]==>[]) 
\find(seqSub(seqConcat(seqSingleton(x),seq),Z(1(#)),add(Z(1(#)),EQ)))
\sameUpdateLevel\replacewith(seq) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqTailEQR (subSeqTail) =========================================
subSeqTailEQR {
\assumes ([equals(seqLen(seq),EQ)]==>[]) 
\find(seqSub(seqConcat(seqSingleton(x),seq),Z(1(#)),add(EQ,Z(1(#)))))
\sameUpdateLevel\replacewith(seq) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqTailL (subSeqTail) =========================================
subSeqTailL {
\find(seqSub(seqConcat(seqSingleton(x),seq),Z(1(#)),add(Z(1(#)),seqLen(seq))))
\replacewith(seq) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== subSeqTailR (subSeqTail) =========================================
subSeqTailR {
\find(seqSub(seqConcat(seqSingleton(x),seq),Z(1(#)),add(seqLen(seq),Z(1(#)))))
\replacewith(seq) 
\heuristics(concrete)
Choices: sequences:on}
-----------------------------------------------------
== sub_equations_left (sub_equations_left) =========================================
sub_equations_left {
\assumes ([equals(i,i0)]==>[]) 
\find(equals(j,j0)==>)
\add [equals(sub(j,i),sub(j0,i0))]==>[] 

Choices: true}
-----------------------------------------------------
== sub_equations_right (sub_equations_right) =========================================
sub_equations_right {
\assumes ([equals(i,i0)]==>[]) 
\find(==>equals(j,j0))
\add []==>[equals(sub(j,i),sub(j0,i0))] 

Choices: true}
-----------------------------------------------------
== sub_literals (sub_literals) =========================================
sub_literals {
\find(sub(Z(iz),Z(jz)))
\replacewith(#sub(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== sub_sub_elim (sub_sub_elim) =========================================
sub_sub_elim {
\find(neg(neg(i)))
\replacewith(i) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== sub_zero_1 (sub_zero_1) =========================================
sub_zero_1 {
\find(Z(neglit(0(#))))
\replacewith(Z(0(#))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== sub_zero_2 (sub_zero_2) =========================================
sub_zero_2 {
\find(sub(i,Z(0(#))))
\replacewith(i) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== subsetOfEmpty (subsetOfEmpty) =========================================
subsetOfEmpty {
\find(subset(s,empty))
\replacewith(equals(s,empty)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfIntersectWithItSelf1 (subsetOfIntersectWithItSelf1) =========================================
subsetOfIntersectWithItSelf1 {
\find(subset(s,intersect(s,s2)))
\replacewith(subset(s,s2)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfIntersectWithItSelf2 (subsetOfIntersectWithItSelf2) =========================================
subsetOfIntersectWithItSelf2 {
\find(subset(s,intersect(s2,s)))
\replacewith(subset(s,s2)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfIntersectWithItSelfEQ1 (subsetOfIntersectWithItSelfEQ1) =========================================
subsetOfIntersectWithItSelfEQ1 {
\assumes ([equals(intersect(s,s2),EQ)]==>[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(subset(s,s2)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfIntersectWithItSelfEQ2 (subsetOfIntersectWithItSelfEQ2) =========================================
subsetOfIntersectWithItSelfEQ2 {
\assumes ([equals(intersect(s2,s),EQ)]==>[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(subset(s,s2)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfItself (subsetOfItself) =========================================
subsetOfItself {
\find(subset(s,s))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfUnionWithItSelf1 (subsetOfUnionWithItSelf1) =========================================
subsetOfUnionWithItSelf1 {
\find(subset(s,union(s,s2)))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfUnionWithItSelf2 (subsetOfUnionWithItSelf2) =========================================
subsetOfUnionWithItSelf2 {
\find(subset(s,union(s2,s)))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfUnionWithItSelfEQ1 (subsetOfUnionWithItSelfEQ1) =========================================
subsetOfUnionWithItSelfEQ1 {
\assumes ([equals(union(s,s2),EQ)]==>[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetOfUnionWithItSelfEQ2 (subsetOfUnionWithItSelfEQ2) =========================================
subsetOfUnionWithItSelfEQ2 {
\assumes ([equals(union(s2,s),EQ)]==>[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetSingletonLeft (subsetSingletonLeft) =========================================
subsetSingletonLeft {
\find(subset(singleton(o,f),s))
\replacewith(elementOf(o,f,s)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== subsetSingletonLeftEQ (subsetSingletonLeftEQ) =========================================
subsetSingletonLeftEQ {
\assumes ([equals(singleton(o,f),EQ)]==>[]) 
\find(subset(EQ,s))
\sameUpdateLevel\replacewith(elementOf(o,f,s)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== subsetSingletonRight (subsetSingletonRight) =========================================
subsetSingletonRight {
\find(subset(s,singleton(o,f)))
\replacewith(or(equals(s,empty),equals(s,singleton(o,f)))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== subsetSingletonRightEQ (subsetSingletonRightEQ) =========================================
subsetSingletonRightEQ {
\assumes ([equals(singleton(o,f),EQ)]==>[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(or(equals(s,empty),equals(s,singleton(o,f)))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== subsetToElementOf (subsetToElementOf) =========================================
subsetToElementOf {
\find(subset(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(imp(elementOf(ov,fv,s),elementOf(ov,fv,s2))))) 
\heuristics(semantics_blasting)
Choices: programRules:Java}
-----------------------------------------------------
== subsetToElementOfRight (subsetToElementOfRight) =========================================
subsetToElementOfRight {
\find(==>subset(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith([]==>[all{ov (variable)}(all{fv (variable)}(imp(elementOf(ov,fv,s),elementOf(ov,fv,s2))))]) 
\heuristics(setEqualityBlastingRight)
Choices: programRules:Java}
-----------------------------------------------------
== subsetUnionLeft (subsetUnionLeft) =========================================
subsetUnionLeft {
\find(subset(union(s,s2),s3))
\replacewith(and(subset(s,s3),subset(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== subsetUnionLeftEQ (subsetUnionLeftEQ) =========================================
subsetUnionLeftEQ {
\assumes ([equals(union(s,s2),EQ)]==>[]) 
\find(subset(EQ,s3))
\sameUpdateLevel\replacewith(and(subset(s,s3),subset(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== subsetWithAllLocs (subsetOfAllLocs) =========================================
subsetWithAllLocs {
\find(subset(s,allLocs))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetWithAllLocs2 (subsetWithAllLocs) =========================================
subsetWithAllLocs2 {
\find(subset(allLocs,s))
\replacewith(equals(s,allLocs)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetWithEmpty (subsetWithEmpty) =========================================
subsetWithEmpty {
\find(subset(empty,s))
\replacewith(true) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== subsetWithSetMinusLeft (subsetWithSetMinusLeft) =========================================
subsetWithSetMinusLeft {
\find(subset(setMinus(s,s2),s3))
\replacewith(subset(s,union(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== subsetWithSetMinusLeftEQ (subsetWithSetMinusLeftEQ) =========================================
subsetWithSetMinusLeftEQ {
\assumes ([equals(setMinus(s,s2),EQ)]==>[]) 
\find(subset(EQ,s3))
\sameUpdateLevel\replacewith(subset(s,union(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== subst_to_eq (subst_to_eq) =========================================
subst_to_eq {
\find(subst{u (variable)}(t,target))
\sameUpdateLevel\add [equals(sk,t)]==>[] \replacewith(subst{u (variable)}(sk,target)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== subst_to_eq_for (subst_to_eq) =========================================
subst_to_eq_for {
\find(subst{u (variable)}(t,phi))
\sameUpdateLevel\add [equals(sk,t)]==>[] \replacewith(subst{u (variable)}(sk,phi)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== substringSubstring (substringSubstring) =========================================
substringSubstring {
\find(seqSub(seqSub(str,innerStartIdx,innerEndIdx),outerStartIdx,outerEndIdx))
\sameUpdateLevel\add [imp(and(and(and(and(and(geq(innerStartIdx,Z(0(#))),geq(innerEndIdx,innerStartIdx)),leq(innerEndIdx,seqLen(str))),geq(outerStartIdx,Z(0(#)))),geq(outerEndIdx,outerStartIdx)),leq(outerEndIdx,sub(innerEndIdx,innerStartIdx))),and(equals(seqSub(seqSub(str,innerStartIdx,innerEndIdx),outerStartIdx,outerEndIdx),newSym),equals(seqSub(str,add(outerStartIdx,innerStartIdx),add(innerStartIdx,outerEndIdx)),newSym)))]==>[] 
\heuristics(stringsIntroduceNewSym, stringsReduceSubstring)
Choices: Strings:on}
-----------------------------------------------------
== substringSubstring2 (substringSubstring2) =========================================
substringSubstring2 {
\assumes ([equals(seqSub(str,innerStartIdx,innerEndIdx),innerSub)]==>[]) 
\find(seqSub(innerSub,outerStartIdx,outerEndIdx))
\sameUpdateLevel\add [imp(and(and(and(and(and(geq(innerStartIdx,Z(0(#))),geq(innerEndIdx,innerStartIdx)),leq(innerEndIdx,seqLen(str))),geq(outerStartIdx,Z(0(#)))),geq(outerEndIdx,outerStartIdx)),leq(outerEndIdx,sub(innerEndIdx,innerStartIdx))),and(equals(seqSub(innerSub,outerStartIdx,outerEndIdx),newSym),equals(seqSub(str,add(outerStartIdx,innerStartIdx),add(innerStartIdx,outerEndIdx)),newSym)))]==>[] 
\heuristics(stringsIntroduceNewSym, stringsReduceSubstring)
Choices: Strings:on}
-----------------------------------------------------
== sum_empty (sum_empty) =========================================
sum_empty {
\find(sum{x (variable)}(FALSE,t))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== sum_zero (sum_zero) =========================================
sum_zero {
\find(sum{x (variable)}(range,Z(0(#))))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: integerSimplificationRules:full}
-----------------------------------------------------
== swapQuantifiersAll (swapQuantifiersAll) =========================================
swapQuantifiersAll {
\find(all{u (variable)}(all{v (variable)}(phi)))
\replacewith(all{v (variable)}(all{u (variable)}(phi))) 
\heuristics(swapQuantifiers)
Choices: true}
-----------------------------------------------------
== swapQuantifiersEx (swapQuantifiersEx) =========================================
swapQuantifiersEx {
\find(exists{u (variable)}(exists{v (variable)}(phi)))
\replacewith(exists{v (variable)}(exists{u (variable)}(phi))) 
\heuristics(swapQuantifiers)
Choices: true}
-----------------------------------------------------
== switch (switch) =========================================
switch {
\find(#allmodal ( (modal operator))\[{ ..
  #sw
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  switch-to-if(#sw)
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== switch_brackets (switch_brackets) =========================================
switch_brackets {
\find(add(add(i,i0),i1))
\replacewith(add(i,add(i0,i1))) 

Choices: true}
-----------------------------------------------------
== switch_params (switch_params) =========================================
switch_params {
\find(add(i0,i1))
\replacewith(add(i1,i0)) 

Choices: true}
-----------------------------------------------------
== synchronizedBlockEmpty (synchronizedBlockEmpty) =========================================
synchronizedBlockEmpty {
\find(==>#allmodal ( (modal operator))\[{ ..
  synchronized(#se) {}
... }\] (post))
\varcond(\isLocalVariable (#se (program SimpleExpression)), )
\replacewith([]==>[not(equals(#se,null))]) ;
\replacewith([]==>[#allmodal(post)]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: (programRules:Java & runtimeExceptions:ban)}
-----------------------------------------------------
== synchronizedBlockEmpty2 (synchronizedBlockEmpty) =========================================
synchronizedBlockEmpty2 {
\find(#allmodal ( (modal operator))\[{ ..
  synchronized(#cr) {}
... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== synchronizedBlockEvalSync (synchronizedBlockEvalSync) =========================================
synchronizedBlockEvalSync {
\find(#allmodal ( (modal operator))\[{ ..
  synchronized(#nsencr) {
    #slist
  }
... }\] (post))
\varcond(\new(#loc (program Variable), \typeof(#nsencr (program NonSimpleExpressionNoClassReference))), \isLocalVariable (#nsencr (program NonSimpleExpressionNoClassReference)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nsencr) #loc = #nsencr;
  synchronized(#loc) {
    #slist
  }
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tanIsNaN (tanIsNaN) =========================================
tanIsNaN {
\find(tanDouble(arg))
\add [imp(or(doubleIsNaN(arg),doubleIsInfinite(arg)),doubleIsNaN(tanDouble(arg)))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== tanIsZero (tanIsZero) =========================================
tanIsZero {
\find(tanDouble(arg))
\add [imp(equals(arg,DFP(0(#))),equals(tanDouble(arg),DFP(0(#))))]==>[] 
\heuristics(userTaclets1)
Choices: true}
-----------------------------------------------------
== theorem_of_archimedes (theorem_of_archimedes) =========================================
theorem_of_archimedes {
\assumes ([gt(i0,sub(i1,Z(1(#))))]==>[]) 
\find(lt(i0,i1)==>)
\replacewith([false]==>[]) 

Choices: true}
-----------------------------------------------------
== throwBox (throwBox) =========================================
throwBox {
\find(#box ( (modal operator))\[{
  throw #se;
  #slist
}\] (post))
\replacewith(true) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== throwDiamond (throwDiamond) =========================================
throwDiamond {
\find(#diamond ( (modal operator))\[{
  throw #se;
  #slist
}\] (post))
\replacewith(false) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== throwLabel (throwLabel) =========================================
throwLabel {
\find(#allmodal ( (modal operator))\[{ ..
  #lb:
  throw #se;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  throw #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== throwLabelBlock (throwLabelBlock) =========================================
throwLabelBlock {
\find(#allmodal ( (modal operator))\[{ ..
  #lb:
  {
    throw #se;
    #slist
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  throw #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== throwNull (throwNull) =========================================
throwNull {
\find(#allmodal ( (modal operator))\[{ ..
  throw null;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  throw new java.lang.NullPointerException();
... }\] (post)) 

Choices: programRules:Java}
-----------------------------------------------------
== throwUnfold (throwUnfold) =========================================
throwUnfold {
\find(#allmodal ( (modal operator))\[{ ..
  throw #nse;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#nse) #v0 = #nse;
  throw #v0;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== throwUnfoldMore (throwUnfold) =========================================
throwUnfoldMore {
\find(#allmodal ( (modal operator))\[{ ..
  throw #se;
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#se (program SimpleExpression))), \isLocalVariable (#se (program SimpleExpression)), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#se) #v0 = #se;
  throw #v0;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== times_minus_one_1 (times_minus_one) =========================================
times_minus_one_1 {
\find(mul(i,Z(neglit(1(#)))))
\replacewith(neg(i)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== times_minus_one_2 (times_minus_one) =========================================
times_minus_one_2 {
\find(mul(Z(neglit(1(#))),i))
\replacewith(neg(i)) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== times_one_1 (times_one) =========================================
times_one_1 {
\find(mul(i,Z(1(#))))
\replacewith(i) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== times_one_2 (times_one) =========================================
times_one_2 {
\find(mul(Z(1(#)),i))
\replacewith(i) 
\heuristics(simplify_int)
Choices: true}
-----------------------------------------------------
== times_zero_1 (times_zero) =========================================
times_zero_1 {
\find(mul(i,Z(0(#))))
\replacewith(Z(0(#))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== times_zero_2 (times_zero) =========================================
times_zero_2 {
\find(mul(Z(0(#)),i))
\replacewith(Z(0(#))) 
\heuristics(simplify_literals)
Choices: true}
-----------------------------------------------------
== translate# (translate#) =========================================
translate# {
\find(clTranslateInt(Z(#)))
\replacewith(seqEmpty) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate0 (translate0) =========================================
translate0 {
\find(clTranslateInt(Z(0(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(8(4(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate1 (translate1) =========================================
translate1 {
\find(clTranslateInt(Z(1(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(9(4(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate2 (translate2) =========================================
translate2 {
\find(clTranslateInt(Z(2(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(0(5(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate3 (translate3) =========================================
translate3 {
\find(clTranslateInt(Z(3(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(1(5(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate4 (translate4) =========================================
translate4 {
\find(clTranslateInt(Z(4(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(2(5(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate5 (translate5) =========================================
translate5 {
\find(clTranslateInt(Z(5(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(3(5(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate6 (translate6) =========================================
translate6 {
\find(clTranslateInt(Z(6(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(4(5(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate7 (translate7) =========================================
translate7 {
\find(clTranslateInt(Z(7(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(5(5(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate8 (translate8) =========================================
translate8 {
\find(clTranslateInt(Z(8(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(6(5(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translate9 (translate9) =========================================
translate9 {
\find(clTranslateInt(Z(9(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(7(5(#)))))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translateCheckedAddInt (translateCheckedAddInt) =========================================
translateCheckedAddInt {
\find(checkedAddInt(left,right))
\replacewith(add(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedAddLong (translateCheckedAddLong) =========================================
translateCheckedAddLong {
\find(checkedAddLong(left,right))
\replacewith(add(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedBitwiseAndInt (translateCheckedBitwiseAndInt) =========================================
translateCheckedBitwiseAndInt {
\find(checkedBitwiseAndInt(left,right))
\replacewith(binaryAnd(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedBitwiseAndLong (translateCheckedBitwiseAndLong) =========================================
translateCheckedBitwiseAndLong {
\find(checkedBitwiseAndLong(left,right))
\replacewith(binaryAnd(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedBitwiseNegateInt (translateCheckedBitwiseNegateInt) =========================================
translateCheckedBitwiseNegateInt {
\find(checkedBitwiseNegateInt(left))
\replacewith(sub(neg(left),Z(1(#)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedBitwiseNegateLong (translateCheckedBitwiseNegateLong) =========================================
translateCheckedBitwiseNegateLong {
\find(checkedBitwiseNegateLong(left))
\replacewith(sub(neg(left),Z(1(#)))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedBitwiseOrInt (translateCheckedBitwiseOrInt) =========================================
translateCheckedBitwiseOrInt {
\find(checkedBitwiseOrInt(left,right))
\replacewith(binaryOr(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedBitwiseOrLong (translateCheckedBitwiseOrLong) =========================================
translateCheckedBitwiseOrLong {
\find(checkedBitwiseOrLong(left,right))
\replacewith(binaryOr(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedBitwiseXOrInt (translateCheckedBitwiseXOrInt) =========================================
translateCheckedBitwiseXOrInt {
\find(checkedBitwiseXOrInt(left,right))
\replacewith(binaryXOr(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedBitwiseXOrLong (translateCheckedBitwiseXOrLong) =========================================
translateCheckedBitwiseXOrLong {
\find(checkedBitwiseXOrLong(left,right))
\replacewith(binaryXOr(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedDivInt (translateCheckedDivInt) =========================================
translateCheckedDivInt {
\find(checkedDivInt(left,right))
\replacewith(jdiv(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedDivLong (translateCheckedDivLong) =========================================
translateCheckedDivLong {
\find(checkedDivLong(left,right))
\replacewith(jdiv(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedMulInt (translateCheckedMulInt) =========================================
translateCheckedMulInt {
\find(checkedMulInt(left,right))
\replacewith(mul(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedMulLong (translateCheckedMulLong) =========================================
translateCheckedMulLong {
\find(checkedMulLong(left,right))
\replacewith(mul(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedShiftLeftInt (translateCheckedShiftLeftInt) =========================================
translateCheckedShiftLeftInt {
\find(checkedShiftLeftInt(left,right))
\replacewith(shiftleft(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedShiftLeftLong (translateCheckedShiftLeftLong) =========================================
translateCheckedShiftLeftLong {
\find(checkedShiftLeftLong(left,right))
\replacewith(shiftleft(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedShiftRightInt (translateCheckedShiftRightInt) =========================================
translateCheckedShiftRightInt {
\find(checkedShiftRightInt(left,right))
\replacewith(shiftright(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedShiftRightLong (translateCheckedShiftRightLong) =========================================
translateCheckedShiftRightLong {
\find(checkedShiftRightLong(left,right))
\replacewith(shiftright(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedSubInt (translateCheckedSubInt) =========================================
translateCheckedSubInt {
\find(checkedSubInt(left,right))
\replacewith(sub(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedSubLong (translateCheckedSubLong) =========================================
translateCheckedSubLong {
\find(checkedSubLong(left,right))
\replacewith(sub(left,right)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedUnaryMinusInt (translateCheckedUnaryMinusInt) =========================================
translateCheckedUnaryMinusInt {
\find(checkedUnaryMinusInt(left))
\replacewith(neg(left)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateCheckedUnaryMinusLong (translateCheckedUnaryMinusLong) =========================================
translateCheckedUnaryMinusLong {
\find(checkedUnaryMinusLong(left))
\replacewith(neg(left)) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== translateJavaAddInt (translateJavaAdd) =========================================
translateJavaAddInt {
\find(javaAddInt(left,right))
\replacewith(add(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaAddLong (translateJavaAdd) =========================================
translateJavaAddLong {
\find(javaAddLong(left,right))
\replacewith(add(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaBitwiseAndInt (translateJavaBitwiseAnd) =========================================
translateJavaBitwiseAndInt {
\find(javaBitwiseAndInt(left,right))
\replacewith(binaryAnd(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaBitwiseAndLong (translateJavaBitwiseAnd) =========================================
translateJavaBitwiseAndLong {
\find(javaBitwiseAndLong(left,right))
\replacewith(binaryAnd(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaBitwiseOrInt (translateJavaBitwiseOr) =========================================
translateJavaBitwiseOrInt {
\find(javaBitwiseOrInt(left,right))
\replacewith(binaryOr(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaBitwiseOrLong (translateJavaBitwiseOr) =========================================
translateJavaBitwiseOrLong {
\find(javaBitwiseOrLong(left,right))
\replacewith(binaryOr(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaBitwiseXOrInt (translateJavaBitwiseXOr) =========================================
translateJavaBitwiseXOrInt {
\find(javaBitwiseXOrInt(left,right))
\replacewith(binaryXOr(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaBitwiseXOrLong (translateJavaBitwiseXOr) =========================================
translateJavaBitwiseXOrLong {
\find(javaBitwiseXOrLong(left,right))
\replacewith(binaryXOr(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaCastByte (translateJavaCast) =========================================
translateJavaCastByte {
\find(javaCastByte(left))
\replacewith(left) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaCastChar (translateJavaCast) =========================================
translateJavaCastChar {
\find(javaCastChar(left))
\replacewith(left) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaCastInt (translateJavaCast) =========================================
translateJavaCastInt {
\find(javaCastInt(left))
\replacewith(left) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaCastLong (translateJavaCast) =========================================
translateJavaCastLong {
\find(javaCastLong(left))
\replacewith(left) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaCastShort (translateJavaCast) =========================================
translateJavaCastShort {
\find(javaCastShort(left))
\replacewith(left) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaDivInt (translateJavaDiv) =========================================
translateJavaDivInt {
\find(javaDivInt(left,right))
\replacewith(jdiv(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaDivLong (translateJavaDiv) =========================================
translateJavaDivLong {
\find(javaDivLong(left,right))
\replacewith(jdiv(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaMod (translateJavaMod) =========================================
translateJavaMod {
\find(javaMod(left,right))
\replacewith(jmod(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaMulInt (translateJavaMul) =========================================
translateJavaMulInt {
\find(javaMulInt(left,right))
\replacewith(mul(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaMulLong (translateJavaMul) =========================================
translateJavaMulLong {
\find(javaMulLong(left,right))
\replacewith(mul(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaShiftLeftInt (translateJavaShiftLeft) =========================================
translateJavaShiftLeftInt {
\find(javaShiftLeftInt(left,right))
\replacewith(shiftleft(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaShiftLeftLong (translateJavaShiftLeft) =========================================
translateJavaShiftLeftLong {
\find(javaShiftLeftLong(left,right))
\replacewith(shiftleft(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaShiftRightInt (translateJavaShiftRight) =========================================
translateJavaShiftRightInt {
\find(javaShiftRightInt(left,right))
\replacewith(shiftright(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaShiftRightLong (translateJavaShiftRight) =========================================
translateJavaShiftRightLong {
\find(javaShiftRightLong(left,right))
\replacewith(shiftright(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaSubInt (translateJavaSub) =========================================
translateJavaSubInt {
\find(javaSubInt(left,right))
\replacewith(sub(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaSubLong (translateJavaSub) =========================================
translateJavaSubLong {
\find(javaSubLong(left,right))
\replacewith(sub(left,right)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaUnaryMinusInt (translateJavaUnaryMinus) =========================================
translateJavaUnaryMinusInt {
\find(javaUnaryMinusInt(left))
\replacewith(neg(left)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateJavaUnaryMinusLong (translateJavaUnaryMinus) =========================================
translateJavaUnaryMinusLong {
\find(javaUnaryMinusLong(left))
\replacewith(neg(left)) 
\heuristics(simplify, javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translateNegLit (translateNegLit) =========================================
translateNegLit {
\find(clTranslateInt(Z(neglit(iz))))
\replacewith(seqConcat(seqSingleton(C(5(4(#)))),clTranslateInt(Z(iz)))) 
\heuristics(integerToString)
Choices: Strings:on}
-----------------------------------------------------
== translatejavaBitwiseNegateInt (translateJavaBitwiseNegation) =========================================
translatejavaBitwiseNegateInt {
\find(javaBitwiseNegateInt(left))
\replacewith(bitwiseNegateJint(left)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== translatejavaBitwiseNegateLong (translateJavaBitwiseNegation) =========================================
translatejavaBitwiseNegateLong {
\find(javaBitwiseNegateLong(left))
\replacewith(bitwiseNegateJlong(left)) 
\heuristics(javaIntegerSemantics)
Choices: (programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF))}
-----------------------------------------------------
== true_left (true_left) =========================================
true_left {
\find(true==>)
\replacewith([]==>[]) 
\heuristics(concrete)
Choices: true}
-----------------------------------------------------
== true_to_not_false (true_to_not_false) =========================================
true_to_not_false {
\find(equals(bo,TRUE))
\replacewith(not(equals(bo,FALSE))) 

Choices: true}
-----------------------------------------------------
== tryBreak (tryBreak) =========================================
tryBreak {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    break;
    #slist
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  break;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryBreakLabel (tryBreak) =========================================
tryBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    break;
    #slist
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  break;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryCatchFinallyThrow (tryCatchFinallyThrow) =========================================
tryCatchFinallyThrow {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    throw #se;
    #slist
  } catch (#t #v0) {
    #slist1
  }#cs finally {
    #slist2
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (#se == null) {
    try {
      throw new java.lang.NullPointerException();
    } catch (#t #v0) {
      #slist1
    }#cs finally {
      #slist2
    }
  } else if (#se instanceof #t) {
    try {
      #t #v0;
      #v0 = (#t) #se;
      #slist1
    } finally {
      #slist2
    }
  } else {
    try {
      throw #se;
    }#cs finally {
      #slist2
    }
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryCatchThrow (tryCatchThrow) =========================================
tryCatchThrow {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    throw #se;
    #slist
  } catch (#t #v0) {
    #slist1
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (#se == null) {
    try {
      throw new java.lang.NullPointerException();
    } catch (#t #v0) {
      #slist1
    }
  } else if (#se instanceof #t) {
    #t #v0;
    #v0 = (#t) #se;
    #slist1
  } else {
    throw #se;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryEmpty (tryEmpty) =========================================
tryEmpty {
\find(#allmodal ( (modal operator))\[{ ..
  try {}#cs
... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryFinallyBreak (tryBreak) =========================================
tryFinallyBreak {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    break;
    #slist
  }#cs finally {
    #slist2
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist2
  }
  break;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryFinallyBreakLabel (tryBreak) =========================================
tryFinallyBreakLabel {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    break;
    #slist
  }#cs finally {
    #slist2
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist2
  }
  break;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryFinallyEmpty (tryEmpty) =========================================
tryFinallyEmpty {
\find(#allmodal ( (modal operator))\[{ ..
  try {}#cs finally {
    #slist2
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist2
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryFinallyReturn (tryReturn) =========================================
tryFinallyReturn {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    return #se;
    #slist
  }#cs finally {
    #slist2
  }
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#se (program SimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #typeof(#se) #v0 = #se;
  {
    #slist2
  }
  return #v0;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryFinallyReturnNoValue (tryReturn) =========================================
tryFinallyReturnNoValue {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    return;
    #slist
  }#cs finally {
    #slist2
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist2
  }
  return;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryFinallyThrow (tryFinallyThrow) =========================================
tryFinallyThrow {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    throw #se;
    #slist
  } finally {
    #slist2
  }
... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#se (program SimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (#se == null) {
    {
      #slist2
    }
    throw new java.lang.NullPointerException();
  } else {
    #typeof(#se) #v0 = #se;
    {
      #slist2
    }
    throw #v0;
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryMultipleCatchThrow (tryCatchThrow) =========================================
tryMultipleCatchThrow {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    throw #se;
    #slist
  } catch (#t #v0) {
    #slist1
  } catch (#t2 #v1) {
    #slist3
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  if (#se == null) {
    try {
      throw new java.lang.NullPointerException();
    } catch (#t #v0) {
      #slist1
    } catch (#t2 #v1) {
      #slist3
    }#cs
  } else if (#se instanceof #t) {
    #t #v0;
    #v0 = (#t) #se;
    #slist1
  } else {
    try {
      throw #se;
    } catch (#t2 #v1) {
      #slist3
    }#cs
  }
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryReturn (tryReturn) =========================================
tryReturn {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    return #se;
    #slist
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  return #se;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== tryReturnNoValue (tryReturn) =========================================
tryReturnNoValue {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    return;
    #slist
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  return;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== try_continue_1 (try_continue) =========================================
try_continue_1 {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    continue;
    #slist
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  continue;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== try_continue_2 (try_continue) =========================================
try_continue_2 {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    continue;
    #slist
  }#cs
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  continue;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== try_finally_continue_1 (try_continue) =========================================
try_finally_continue_1 {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    continue;
    #slist
  }#cs finally {
    #slist2
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist2
  }
  continue;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== try_finally_continue_2 (try_continue) =========================================
try_finally_continue_2 {
\find(#allmodal ( (modal operator))\[{ ..
  try {
    continue;
    #slist
  }#cs finally {
    #slist2
  }
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  {
    #slist2
  }
  continue;
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== typeEq (typeEq) =========================================
typeEq {
\find(equals(s,t1)==>)
\add [equals(H::instance(s),TRUE),equals(G::instance(t1),TRUE)]==>[] 

Choices: true}
-----------------------------------------------------
== typeEqDerived (typeEq) =========================================
typeEqDerived {
\assumes ([equals(s,t1)]==>[]) 
\find(H::instance(s))
\sameUpdateLevel\replacewith(TRUE) 
\heuristics(concrete, simplify)
Choices: true}
-----------------------------------------------------
== typeEqDerived2 (typeEq) =========================================
typeEqDerived2 {
\assumes ([equals(s,t1)]==>[]) 
\find(G::instance(t1))
\sameUpdateLevel\replacewith(TRUE) 
\heuristics(concrete, simplify)
Choices: true}
-----------------------------------------------------
== typeStatic (typeStatic) =========================================
typeStatic {
\find(s)
\sameUpdateLevel\add [equals(G::instance(s),TRUE)]==>[] 

Choices: true}
-----------------------------------------------------
== unaryMinusBigint (unaryMinus) =========================================
unaryMinusBigint {
\find(#allmodal ( (modal operator))\[{ ..
  #loc = -#seBigint;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(neg(#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== unaryMinusDouble (unaryMinus) =========================================
unaryMinusDouble {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = -#seDouble;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaUnaryMinusDouble(#seDouble)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== unaryMinusFloat (unaryMinus) =========================================
unaryMinusFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = -#seFloat;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaUnaryMinusFloat(#seFloat)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== unaryMinusInt (unaryMinus) =========================================
unaryMinusInt {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = -#seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaUnaryMinusInt(#seCharByteShortInt)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== unaryMinusLong (unary_minus) =========================================
unaryMinusLong {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = -#seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaUnaryMinusLong(#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== unionEqualsEmpty (unionEqualsEmpty) =========================================
unionEqualsEmpty {
\find(equals(union(s,s2),empty))
\replacewith(and(equals(s,empty),equals(s2,empty))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== unionEqualsEmptyEQ (unionEqualsEmptyEQ) =========================================
unionEqualsEmptyEQ {
\assumes ([equals(union(s,s2),EQ)]==>[]) 
\find(equals(EQ,empty))
\sameUpdateLevel\replacewith(and(equals(s,empty),equals(s2,empty))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== unionIntersectItself (unionIntersectItself) =========================================
unionIntersectItself {
\find(union(intersect(s1,s2),s1))
\replacewith(s1) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== unionIntersectItself_2 (unionIntersectItself_2) =========================================
unionIntersectItself_2 {
\find(union(intersect(s2,s1),s1))
\replacewith(s1) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== unionIntersectItself_3 (unionIntersectItself_3) =========================================
unionIntersectItself_3 {
\find(union(union(s,intersect(s1,s2)),s1))
\replacewith(union(s,s1)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== unionIntersectItself_4 (unionIntersectItself_4) =========================================
unionIntersectItself_4 {
\find(union(union(s,intersect(s2,s1)),s1))
\replacewith(union(s,s1)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== unionIntersectItself_5 (unionIntersectItself_5) =========================================
unionIntersectItself_5 {
\find(union(union(intersect(s1,s2),s),s1))
\replacewith(union(s,s1)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== unionIntersectItself_6 (unionIntersectItself_6) =========================================
unionIntersectItself_6 {
\find(union(union(intersect(s2,s1),s),s1))
\replacewith(union(s,s1)) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== unionWithAllLocs (unionWithAllLocs) =========================================
unionWithAllLocs {
\find(union(allLocs,s))
\replacewith(allLocs) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== unionWithAllLocsRight (unionWithAllLocs) =========================================
unionWithAllLocsRight {
\find(union(s,allLocs))
\replacewith(allLocs) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== unionWithEmpty (unionWithEmpty) =========================================
unionWithEmpty {
\find(union(empty,s))
\replacewith(s) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== unionWithEmptyRight (unionWithEmpty) =========================================
unionWithEmptyRight {
\find(union(s,empty))
\replacewith(s) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== unionWithItself (unionWithItself) =========================================
unionWithItself {
\find(union(s,s))
\replacewith(s) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== unionWithSingletonEqualsUnionWithSingleton (unionWithSingletonEqualsUnionWithSingleton) =========================================
unionWithSingletonEqualsUnionWithSingleton {
\find(equals(union(s1,singleton(o,f)),union(s2,singleton(o,f))))
\replacewith(equals(setMinus(s1,singleton(o,f)),setMinus(s2,singleton(o,f)))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== unionWithSingletonEqualsUnionWithSingleton_2 (unionWithSingletonEqualsUnionWithSingleton_2) =========================================
unionWithSingletonEqualsUnionWithSingleton_2 {
\find(equals(union(singleton(o,f),s1),union(singleton(o,f),s2)))
\replacewith(equals(setMinus(s1,singleton(o,f)),setMinus(s2,singleton(o,f)))) 
\heuristics(simplify)
Choices: programRules:Java}
-----------------------------------------------------
== unsignedShiftRightJintDef (unsignedShiftRightJintDef) =========================================
unsignedShiftRightJintDef {
\find(unsignedshiftrightJint(left,right))
\replacewith(if-then-else(geq(left,Z(0(#))),shiftrightJint(left,right),addJint(shiftrightJint(left,right),shiftleftJint(Z(2(#)),sub(Z(1(3(#))),mod(right,Z(2(3(#))))))))) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== unusedLabel (unusedLabel) =========================================
unusedLabel {
\find(#allmodal ( (modal operator))\[{ ..
  #lb:
  #s
... }\] (post))
\varcond(\not\freeLabelIn (#lb,#s), )
\replacewith(#allmodal ( (modal operator))\[{ ..
  #s
... }\] (post)) 
\heuristics(simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== unwindLoopScope (unwindLoopScope) =========================================
unwindLoopScope {
\find(#allmodal ( (modal operator))\[{ ..
  while (#nse) #body
... }\] (post))
\varcond(\new(#x (program Variable), (type, sort): (boolean,boolean)))
\replacewith(#allmodal ( (modal operator))\[{ ..
  boolean #x;
  loop-scope (#x) {
    if (#nse) {
      #body
      continue;
    } else {
      break;
    }
  }
... }\] (and(imp(equals(#x<<loopScopeIndex>>,TRUE),post),imp(equals(#x<<loopScopeIndex>>,FALSE),#allmodal ( (modal operator))\[{ ..
  #reattachLoopInvariant(while (#nse) #body)
... }\] (post))))) 
\heuristics(loop_scope_expand)
Choices: programRules:Java}
-----------------------------------------------------
== variableDeclaration (variableDeclaration) =========================================
variableDeclaration {
\find(#allmodal ( (modal operator))\[{ ..
  #t #v0;
... }\] (post))
\addprogvars {#v0 (program Variable)} \replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== variableDeclarationAssign (variableDeclaration) =========================================
variableDeclarationAssign {
\find(#allmodal ( (modal operator))\[{ ..
  #t #v0 = #vi;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #t #v0;
  #v0 = #vi;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== variableDeclarationFinal (variableDeclaration) =========================================
variableDeclarationFinal {
\find(#allmodal ( (modal operator))\[{ ..
  final #t #v0;
... }\] (post))
\addprogvars {#v0 (program Variable)} \replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== variableDeclarationFinalAssign (variableDeclaration) =========================================
variableDeclarationFinalAssign {
\find(#allmodal ( (modal operator))\[{ ..
  final #t #v0 = #vi;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  final #t #v0;
  #v0 = #vi;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== variableDeclarationGhost (ghostDeclaration) =========================================
variableDeclarationGhost {
\find(#allmodal ( (modal operator))\[{ ..
  ghost #t #v0;
... }\] (post))
\addprogvars {#v0 (program Variable)} \replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== variableDeclarationGhostAssign (ghostDeclaration) =========================================
variableDeclarationGhostAssign {
\find(#allmodal ( (modal operator))\[{ ..
  ghost #t #v0 = #vi;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  ghost #t #v0;
  #v0 = #vi;
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== variableDeclarationMult (variableDeclaration) =========================================
variableDeclarationMult {
\find(#allmodal ( (modal operator))\[{ ..
  #multvardecl
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  multiple-var-decl(#multvardecl)
... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedAnon (wellFormedAnon) =========================================
wellFormedAnon {
\find(wellFormed(anon(h,s,h2)))
\succedentPolarity\replacewith(and(wellFormed(h),wellFormed(h2))) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedAnonEQ (wellFormedAnonEQ) =========================================
wellFormedAnonEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==>[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\replacewith(and(wellFormed(h),wellFormed(h2))) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedCreate (wellFormedCreate) =========================================
wellFormedCreate {
\find(wellFormed(create(h,o)))
\succedentPolarity\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedMemsetArrayObject (wellFormedMemsetArrayObject) =========================================
wellFormedMemsetArrayObject {
\find(wellFormed(memset(h,arrayRange(ar,lo,up),x)))
\succedentPolarity\varcond(\hasSort(\elemSort(ar (java.lang.Object term)), alpha), )
\replacewith(and(wellFormed(h),or(equals(x,null),and(equals(boolean::select(h,x,java.lang.Object::<created>),TRUE),arrayStoreValid(ar,x))))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedMemsetArrayPrimitive (wellFormedMemsetArrayPrimitive) =========================================
wellFormedMemsetArrayPrimitive {
\find(wellFormed(memset(h,arrayRange(ar,lo,up),x)))
\succedentPolarity\varcond(\hasSort(\elemSort(ar (java.lang.Object term)), alpha), \not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), \sub(beta, alpha), )
\replacewith(wellFormed(h)) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedStoreArray (wellFormedStoreArray) =========================================
wellFormedStoreArray {
\find(wellFormed(store(h,o,arr(idx),x)))
\succedentPolarity\varcond(\hasSort(\elemSort(o (java.lang.Object term)), alpha), )
\replacewith(and(wellFormed(h),or(equals(x,null),and(equals(boolean::select(h,x,java.lang.Object::<created>),TRUE),arrayStoreValid(o,x))))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedStoreLocSet (wellFormedStoreLocSet) =========================================
wellFormedStoreLocSet {
\find(wellFormed(store(h,o,f,x)))
\succedentPolarity\varcond(\fieldType(f (Field term), alpha), \sub(LocSet, alpha), )
\replacewith(and(wellFormed(h),createdInHeap(x,h))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedStoreLocSetEQ (wellFormedStoreLocSetEQ) =========================================
wellFormedStoreLocSetEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==>[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\replacewith(and(wellFormed(h),createdInHeap(x,h))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedStoreObject (wellFormedStoreObject) =========================================
wellFormedStoreObject {
\find(wellFormed(store(h,o,f,x)))
\succedentPolarity\varcond(\fieldType(f (Field term), alpha), )
\replacewith(and(wellFormed(h),or(equals(x,null),and(equals(boolean::select(h,x,java.lang.Object::<created>),TRUE),equals(alpha::instance(x),TRUE))))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedStoreObjectEQ (wellFormedStoreObjectEQ) =========================================
wellFormedStoreObjectEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==>[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\varcond(\fieldType(f (Field term), alpha), )
\replacewith(and(wellFormed(h),or(equals(x,null),and(equals(boolean::select(h,x,java.lang.Object::<created>),TRUE),equals(alpha::instance(x),TRUE))))) 
\heuristics(simplify_enlarging)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedStorePrimitive (wellFormedStorePrimitive) =========================================
wellFormedStorePrimitive {
\find(wellFormed(store(h,o,f,x)))
\succedentPolarity\varcond(\fieldType(f (Field term), alpha), \not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), \sub(beta, alpha), )
\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedStorePrimitiveArray (wellFormedStorePrimitiveArray) =========================================
wellFormedStorePrimitiveArray {
\find(wellFormed(store(h,o,arr(idx),x)))
\succedentPolarity\varcond(\hasSort(\elemSort(o (java.lang.Object term)), alpha), \not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), \sub(beta, alpha), )
\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== wellFormedStorePrimitiveEQ (wellFormedStorePrimitiveEQ) =========================================
wellFormedStorePrimitiveEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==>[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), )
\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: programRules:Java}
-----------------------------------------------------
== wideningCastIntToFloat (cast) =========================================
wideningCastIntToFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (float) #seCharByteShortInt;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(float::cast(#seCharByteShortInt)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== wideningCastLongToFloat (cast) =========================================
wideningCastLongToFloat {
\find(#normalassign ( (modal operator))\[{ ..
  #loc = (float) #seLong;
... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(float::cast(#seLong)),#normalassign(post))) 
\heuristics(executeFloatAssignment)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_1 (cast) =========================================
widening_identity_cast_1 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (byte) #seByte;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seByte;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_10 (cast) =========================================
widening_identity_cast_10 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (long) #seByteShortInt;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seByteShortInt;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_11 (cast) =========================================
widening_identity_cast_11 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (long) #seLong;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seLong;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_12 (cast) =========================================
widening_identity_cast_12 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (int) #seChar;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seChar;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_13 (cast) =========================================
widening_identity_cast_13 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (long) #seChar;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seChar;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_2 (cast) =========================================
widening_identity_cast_2 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (short) #seByte;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seByte;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_3 (cast) =========================================
widening_identity_cast_3 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (char) #seChar;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seChar;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_4 (cast) =========================================
widening_identity_cast_4 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (short) #seShort;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seShort;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_5 (cast) =========================================
widening_identity_cast_5 {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (int) #seByteShortInt;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seByteShortInt;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: programRules:Java}
-----------------------------------------------------
== widening_identity_cast_bigint (cast) =========================================
widening_identity_cast_bigint {
\find(#allmodal ( (modal operator))\[{ ..
  #lhs = (\bigint) #seAny;
... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..
  #lhs = #seAny;
... }\] (post)) 
\heuristics(simplify_expression)
Choices: (programRules:Java & bigint:on)}
-----------------------------------------------------
== writePermission (writePermission) =========================================
writePermission {
\find(writePermission(p))
\replacewith(writePermissionObject(currentThread,p)) 
\heuristics(simplify_enlarging)
Choices: true}
-----------------------------------------------------
== writePermissionObject (writePermissionObject) =========================================
writePermissionObject {
\find(writePermissionObject(o,p))
\replacewith(true) 
\heuristics(concrete)
Choices: permissions:off}
-----------------------------------------------------
== xorJIntDef (xorJIntDef) =========================================
xorJIntDef {
\find(xorJint(left,right))
\replacewith(moduloInt(binaryXOr(left,right))) 
\heuristics(simplify)
Choices: true}
-----------------------------------------------------
== zadd_left_cancel0 (zadd_left_cancel0) =========================================
zadd_left_cancel0 {
\find(equals(i0,add(i0,i1)))
\replacewith(equals(i1,Z(0(#)))) 

Choices: true}
-----------------------------------------------------
== zero_leq_mult_iff (zero_leq_mult_iff) =========================================
zero_leq_mult_iff {
\find(leq(Z(0(#)),mul(i0,i1)))
\replacewith(or(and(leq(Z(0(#)),i0),leq(Z(0(#)),i1)),and(leq(i0,Z(0(#))),leq(i1,Z(0(#)))))) 

Choices: true}
-----------------------------------------------------
== zero_less_mult_iff (zero_less_mult_iff) =========================================
zero_less_mult_iff {
\find(lt(Z(0(#)),mul(i0,i1)))
\replacewith(or(and(lt(Z(0(#)),i0),lt(Z(0(#)),i1)),and(lt(i0,Z(0(#))),lt(i1,Z(0(#)))))) 

Choices: true}
-----------------------------------------------------
