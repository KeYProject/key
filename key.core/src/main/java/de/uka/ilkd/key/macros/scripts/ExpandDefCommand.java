package de.uka.ilkd.key.macros.scripts;

import java.util.Map;

import de.uka.ilkd.key.control.AbstractUserInterfaceControl;
import de.uka.ilkd.key.logic.PosInOccurrence;
import de.uka.ilkd.key.logic.PosInTerm;
import de.uka.ilkd.key.logic.SequentFormula;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.macros.scripts.meta.Option;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.rulefilter.TacletFilter;
import de.uka.ilkd.key.rule.PosTacletApp;
import de.uka.ilkd.key.rule.Taclet;
import de.uka.ilkd.key.rule.TacletApp;

import org.key_project.util.collection.ImmutableList;

public class ExpandDefCommand extends AbstractCommand<ExpandDefCommand.Parameters> {

    private static final ExpansionFilter FILTER = new ExpansionFilter();

    public ExpandDefCommand() {
        super(Parameters.class);
    }

    @Override
    public String getName() {
        return "expand";
    }

    @Override
    public Parameters evaluateArguments(EngineState state, Map<String, String> arguments)
            throws Exception {
        return state.getValueInjector().inject(this, new Parameters(), arguments);
    }

    @Override
    public void execute(AbstractUserInterfaceControl uiControl, Parameters args, EngineState state)
            throws ScriptException, InterruptedException {
        Goal g = state.getFirstOpenAutomaticGoal();
        TacletApp theApp = makeRuleApp(args, state);

        ImmutableList<TacletApp> completions =
            theApp.findIfFormulaInstantiations(g.sequent(), g.proof().getServices());
        if (completions == null || completions.isEmpty()) {
            throw new ScriptException("Cannot complete the rule app");
        }

        g.apply(completions.head());
    }

    private TacletApp makeRuleApp(Parameters p, EngineState state) throws ScriptException {

        Goal g = state.getFirstOpenAutomaticGoal();
        Proof proof = state.getProof();

        ImmutableList<TacletApp> apps = ImmutableList.of();
        for (SequentFormula anteForm : g.sequent().antecedent()) {
            apps = apps.prepend(g.ruleAppIndex().getTacletAppAtAndBelow(FILTER,
                new PosInOccurrence(anteForm, PosInTerm.getTopLevel(), true), proof.getServices()));
        }

        for (SequentFormula succForm : g.sequent().succedent()) {
            apps = apps.prepend(g.ruleAppIndex().getTacletAppAtAndBelow(FILTER,
                new PosInOccurrence(succForm, PosInTerm.getTopLevel(), false),
                proof.getServices()));
        }

        apps = apps.filter(
            it -> it instanceof PosTacletApp && it.posInOccurrence().subTerm().equals(p.on));

        if (apps.size() == 0) {
            throw new ScriptException("There is no expansion rule app that matches 'on'");
        } else if (p.occ >= 0) {
            if (p.occ >= apps.size()) {
                throw new ScriptException(
                    "The 'occ' parameter is beyond the number of occurrences.");
            }
            return apps.get(p.occ);
        } else {
            if (apps.size() != 1) {
                throw new ScriptException("The 'on' parameter is not unique");
            }
            return apps.head();
        }

    }

    public static class Parameters {
        @Option(value = "on", required = false)
        public Term on;
        @Option(value = "occ", required = false)
        public int occ = -1;
    }

    private static class ExpansionFilter extends TacletFilter {

        @Override
        protected boolean filter(Taclet taclet) {
            String name = taclet.name().toString();
            return name.startsWith("Class_invariant_axiom_for") ||
                    name.startsWith("Definition_axiom_for");
        }
    }

}
