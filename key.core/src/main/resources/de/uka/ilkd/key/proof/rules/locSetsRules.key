/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains the RULES for location sets.
// Find the DECLARATIONS in file locSet.key
\sorts {
   \generic U \extends java.lang.Object;
}

\rules(programRules:Java) {

    // --------------------------------------------------------------------------
    // axioms for elementOf
    // --------------------------------------------------------------------------

    elementOfEmpty {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(elementOf(o, f, empty))

        \replacewith(false)

        \heuristics(concrete)
    };

    elementOfAllLocs {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(elementOf(o, f, allLocs))

        \replacewith(true)

        \heuristics(concrete)
    };

    elementOfSingleton {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;

        \find(elementOf(o, f, singleton(o2, f2)))

        \replacewith(o = o2 & f = f2)

        \heuristics(simplify)
    };

    elementOfUnion {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, union(s, s2)))

        \replacewith(elementOf(o, f, s) | elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfIntersect {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, intersect(s, s2)))

        \replacewith(elementOf(o, f, s) & elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfSetMinus {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, setMinus(s, s2)))

        \replacewith(elementOf(o, f, s) & !elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfInfiniteUnion {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables alpha av;
        \schemaVar \term LocSet s;

        \find(elementOf(o, f, infiniteUnion{av;}(s)))
        \varcond(\notFreeIn(av, o, f))

        \replacewith(\exists av; elementOf(o, f, s))

        \heuristics(simplify)
    };

    elementOfInfiniteUnion2Vars {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables alpha av;
        \schemaVar \variables beta bv;
        \schemaVar \term LocSet s;

        \find(elementOf(o, f, infiniteUnion{av, bv;}(s)))
        \varcond(\notFreeIn(av, o, f), \notFreeIn(bv, o, f))

        \replacewith(\exists av; \exists bv; elementOf(o, f, s))

        \heuristics(simplify)
    };

    elementOfAllFields {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;

        \find(elementOf(o, f, allFields(o2)))

        \replacewith(o = o2)

        \heuristics(concrete)
    };

    allFieldsEq {
        \schemaVar \term Object o1, o2;
        \find(allFields(o1) = allFields(o2))
        \replacewith(o1 = o2)
        \heuristics(simplify)
    };

    elementOfAllObjects {
        \schemaVar \term Object o;
        \schemaVar \term Field f, f2;

        \find(elementOf(o, f, allObjects(f2)))

        \replacewith(f = f2)

        \heuristics(concrete)
    };

    // change upper to exclusive (in line with other definitions?)
    elementOfArrayRange {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term int lower, upper;
        \schemaVar \variables int iv;

        \find(elementOf(o, f, arrayRange(o2, lower, upper)))
        \varcond(\notFreeIn(iv, f, lower, upper))

        \replacewith(o = o2 & \exists iv; (f = arr(iv) & lower <= iv & iv <= upper))

        \heuristics(simplify_enlarging)
    };

    // change upper to exclusive (in line with other definitions?)
    elementOfArrayRangeConcrete {
        \schemaVar \term Object o, o2;
        \schemaVar \term int idx, lower, upper;

        \find(elementOf(o, arr(idx), arrayRange(o2, lower, upper)))

        \replacewith(o = o2 & lower <= idx & idx <= upper)

        \heuristics(simplify)
    };

    elementOfFreshLocs {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(elementOf(o, f, freshLocs(h)))

        \replacewith(o != null & !boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(concrete)
    };


    //--------------------------------------------------------------------------
    //EQ versions of axioms (these are lemmata)
    //--------------------------------------------------------------------------
     elementOfSingletonEQ {
            \schemaVar \term Object o, o2;
            \schemaVar \term Field f, f2;
            \schemaVar \term LocSet EQ;

    		\assumes (singleton(o2, f2) = EQ ==>)
            \find(elementOf(o, f, EQ))
    		\sameUpdateLevel

            \replacewith(o = o2 & f = f2)

            \heuristics(simplify)
        };

    elementOfUnionEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) | elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfIntersectEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) & elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfSetMinusEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) & !elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfInfiniteUnionEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables alpha av;
        \schemaVar \term LocSet s;
        \schemaVar \term LocSet EQ;

        \assumes(infiniteUnion{av;}(s) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(av, o, f))

        \replacewith(\exists av; elementOf(o, f, s))

        \heuristics(simplify)
    };

    elementOfInfiniteUnion2VarsEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables alpha av;
        \schemaVar \variables beta bv;
        \schemaVar \term LocSet s;
        \schemaVar \term LocSet EQ;

        \assumes(infiniteUnion{av, bv;}(s) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(av, o, f), \notFreeIn(bv, o, f))

        \replacewith(\exists av; \exists bv; elementOf(o, f, s))

        \heuristics(simplify)
    };

    elementOfArrayRangeEQ {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term int lower, upper;
        \schemaVar \variables int iv;
        \schemaVar \term LocSet EQ;

        \assumes(arrayRange(o2, lower, upper) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(iv, f, lower, upper))

        \replacewith(o = o2 & \exists iv; (f = arr(iv) & lower <= iv & iv <= upper))

        \heuristics(simplify)
    };

    // --------------------------------------------------------------------------
    // axioms for set predicates (reduce to elementOf)
    // --------------------------------------------------------------------------

    equalityToElementOf {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(s = s2)
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) <-> elementOf(ov, fv, s2)))

        \heuristics(semantics_blasting)
    };

    // proven with KeY (CS)
    equalityToElementOfRight {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find( ==> s = s2)
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith( ==> \forall ov; \forall fv; (elementOf(ov, fv, s) <-> elementOf(ov, fv, s2)))

        \heuristics(setEqualityBlastingRight)
    };

    emptyEqualsSingleton {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(empty = singleton(o, f))

        \replacewith(false)

        \heuristics(concrete)
    };

    singletonEqualsEmpty {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(singleton(o, f) = empty)
        \replacewith(false)

        \heuristics(concrete)
    };

    unionWithSingletonEqualsUnionWithSingleton {
        \schemaVar \term LocSet s1, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(union(s1, singleton(o, f)) = union(s2, singleton(o, f)))

        \replacewith(setMinus(s1, singleton(o, f)) = setMinus(s2, singleton(o, f)))
        // TODO: why is this a simplification? (DB)
        \heuristics(simplify)
    };

    unionWithSingletonEqualsUnionWithSingleton_2 {
        \schemaVar \term LocSet s1, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(union(singleton(o, f), s1) = union(singleton(o, f), s2))

        \replacewith(setMinus(s1, singleton(o, f)) = setMinus(s2, singleton(o, f)))

        \heuristics(simplify)
    };

    subsetToElementOf {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(subset(s, s2))
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) -> elementOf(ov, fv, s2)))
        \heuristics(semantics_blasting)
        //        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetToElementOfRight {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find( ==> subset(s, s2))
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith( ==> \forall ov; \forall fv; (elementOf(ov, fv, s) -> elementOf(ov, fv, s2)))

        \heuristics(setEqualityBlastingRight)
    };

    // proven with KeY (CS)
    elementOfSubsetImpliesElementOfSuperset {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(s, s2) ==>)

        \find(elementOf(o, f, s) ==>)

        \add(elementOf(o, f, s2) ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    noElementOfSupersetImpliesNoElementOfSubset {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(s, s2) ==>)
        \find( ==> elementOf(o, f, s2))
        \add( ==> elementOf(o, f, s))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetSingletonLeft {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(subset(singleton(o, f), s))

        \replacewith(elementOf(o, f, s))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonLeftEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(subset(EQ, s))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonRight {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(subset(s, singleton(o, f)))

        \replacewith(s = empty | s = singleton(o, f))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonRightEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(s = empty | s = singleton(o, f))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetUnionLeft {
        \schemaVar \term LocSet s, s2, s3;

        \find(subset(union(s, s2), s3))

        \replacewith(subset(s, s3) & subset(s2, s3))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetUnionLeftEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(subset(EQ, s3))
        \sameUpdateLevel

        \replacewith(subset(s, s3) & subset(s2, s3))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelf1 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, union(s, s2)))

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelfEQ1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelf2 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, union(s2, s)))

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelfEQ2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s2, s) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelf1 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, intersect(s, s2)))

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelfEQ1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s, s2) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelf2 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, intersect(s2, s)))

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelfEQ2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s2, s) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    allFieldsSubsetOf {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(allFields(o), s) ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    elementOfSubsetOfUnion1 {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \assumes(subset(s, union(s2, s3)),
            ==> elementOf(o, f, s2))
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \add(elementOf(o, f, s) <-> elementOf(o, f, intersect(s, s3)) ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    elementOfSubsetOfUnion2 {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \assumes(subset(s, union(s2, s3)),
            ==> elementOf(o, f, s3))
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \add(elementOf(o, f, s) <-> elementOf(o, f, intersect(s, s2)) ==>)

        \heuristics(simplify_enlarging)
    };

    disjointToElementOf {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(disjoint(s, s2))
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith(\forall ov; \forall fv; (!elementOf(ov, fv, s) | !elementOf(ov, fv, s2)))
        \heuristics(semantics_blasting)
        //        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointDefinition {
        \schemaVar \term LocSet s, s2;

        \find(disjoint(s, s2))

        \replacewith(intersect(s, s2) = empty)
        // \heuristics(semantics_blasting)
        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointNotInOtherLocset1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(s, s2) = empty ==>)
        \find(elementOf(o, f, s) ==>)

        \add( ==> elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointNotInOtherLocset2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(s, s2) = empty ==>)
        \find(elementOf(o, f, s2) ==>)

        \add( ==> elementOf(o, f, s))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset1 {
        \schemaVar \term LocSet s, s2, s3;

        \assumes(intersect(s2, s3) = empty ==>)
        \find(subset(s, s2) ==>)

        \add(intersect(s, s3) = empty ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset2 {
        \schemaVar \term LocSet s, s2, s3;

        \assumes(intersect(s2, s3) = empty ==>)
        \find(subset(s, s3) ==>)

        \add(intersect(s, s2) = empty ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAllFields {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(allFields(o), s) = empty ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \replacewith(false)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointAllFields_2 {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;

        \find(intersect(allFields(o), allFields(o2)) = empty)

        \replacewith(o != o2)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointAllObjects {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(allObjects(f), s) = empty ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \replacewith(false)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointInfiniteUnion {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables int iv;

        \find(intersect(infiniteUnion{iv;}(s2), s) = empty)
        \varcond(\notFreeIn(iv, s))

        \replacewith(\forall iv; (intersect(s2, s) = empty))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointInfiniteUnion_2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables int iv;

        \find(intersect(s, infiniteUnion{iv;}(s2)) = empty)
        \varcond(\notFreeIn(iv, s))

        \replacewith(\forall iv; (intersect(s, s2) = empty))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    intersectAllFieldsFreshLocs {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(intersect(allFields(o), freshLocs(h)) = empty)
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointAndSubset_3 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s1, s2) = empty ==>)
        \find(subset(s4, union(s2, s3)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_4 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s1, s2) = empty ==>)
        \find(subset(s4, union(s3, s2)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_5 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s2, s1) = empty ==>)
        \find(subset(s4, union(s2, s3)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_6 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s2, s1) = empty ==>)
        \find(subset(s4, union(s3, s2)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    createdInHeapToElementOf {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(createdInHeap(s, h))
        \varcond(\notFreeIn(ov, s, h), \notFreeIn(fv, s, h))

        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s)
                -> ov = null
                | boolean::select(h, ov, java.lang.Object::<created>) = TRUE))
        \heuristics(classAxiom)
    };

    // --------------------------------------------------------------------------
    // lemmata for empty and allLocs
    // --------------------------------------------------------------------------

    unionWithEmpty {
        \schemaVar \term LocSet s;

        \find(union(empty, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    unionWithAllLocs {
        \schemaVar \term LocSet s;

        \find(union(allLocs, s))

        \replacewith(allLocs)

        \heuristics(concrete)
    };

    intersectWithEmpty {
        \schemaVar \term LocSet s;

        \find(intersect(empty, s))

        \replacewith(empty)

        \heuristics(concrete)
    };

    intersectWithAllLocs {
        \schemaVar \term LocSet s;

        \find(intersect(allLocs, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    // the following set of rules should be the only one needed
    // for empty elimination as the strategies take care to commute the
    // the empty set always on the second place
    // the other rules are left for backward proof loading copatibility
    // begin
    unionWithEmptyRight {
        \schemaVar \term LocSet s;

        \find(union(s, empty))

        \replacewith(s)

        \displayname "unionWithEmpty"
        \heuristics(concrete)
    };

    unionWithAllLocsRight {
        \schemaVar \term LocSet s;

        \find(union(s, allLocs))

        \replacewith(allLocs)

        \displayname "unionWithAllLocs"
        \heuristics(concrete)
    };

    intersectWithEmptyRight {
        \schemaVar \term LocSet s;

        \find(intersect(s, empty))

        \replacewith(empty)

        \displayname "intersectWithEmpty"
        \heuristics(concrete)
    };

    intersectWithAllLocsRight {
        \schemaVar \term LocSet s;

        \find(intersect(s, allLocs))

        \replacewith(s)

        \displayname "intersectWithAllLocs"

        \heuristics(concrete)
    };

    //  end

    setMinusWithEmpty1 {
        \schemaVar \term LocSet s;

        \find(setMinus(s, empty))

        \replacewith(s)

        \displayname "setMinusWithEmpty"
        \heuristics(concrete)
    };

    setMinusWithEmpty2 {
        \schemaVar \term LocSet s;

        \find(setMinus(empty, s))

        \replacewith(empty)

        \displayname "setMinusWithEmpty"
        \heuristics(concrete)
    };

    setMinusWithAllLocs {
        \schemaVar \term LocSet s;

        \find(setMinus(s, allLocs))

        \replacewith(empty)

        \displayname "setMinusWithAllLocs"
        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // lemmata for subset
    // --------------------------------------------------------------------------

    subsetWithEmpty {
        \schemaVar \term LocSet s;

        \find(subset(empty, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    subsetOfEmpty {
        \schemaVar \term LocSet s;

        \find(subset(s, empty))

        \replacewith(s = empty)

        \heuristics(concrete)
    };

    subsetWithAllLocs {
        \schemaVar \term LocSet s;

        \find(subset(s, allLocs))

        \replacewith(true)

        \displayname "subsetOfAllLocs" // should be the name, but for backward compatibility only displayname
        \heuristics(concrete)
    };

    subsetWithAllLocs2 {
        \schemaVar \term LocSet s;

        \find(subset(allLocs, s))
        \replacewith(s = allLocs)

        \displayname "subsetWithAllLocs"
        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // lemmata for disjoint
    // --------------------------------------------------------------------------

    disjointWithEmpty {
        \schemaVar \term LocSet s;

        \find(disjoint(empty, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    disjointWithSingleton1 {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \find(intersect(s, singleton(o, f)) = empty)
        \replacewith(!elementOf(o, f, s))
        \heuristics(simplify)
        \displayname "disjointWithSingleton"
    };

    \lemma
    disjointWithSingleton2 {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \find(intersect(singleton(o, f), s) = empty)
        \replacewith(!elementOf(o, f, s))
        \heuristics(simplify)
        \displayname "disjointWithSingleton"
    };

    \lemma
    disjointArrayRanges {
        \schemaVar \term Object o1, o2;
        \schemaVar \term int lower1, upper1, lower2, upper2;
        \find(intersect(arrayRange(o1, lower1, upper1), arrayRange(o2, lower2, upper2)) = empty)
        \replacewith(!(o1 = o2 & lower1 <= upper1 & lower2 <= upper2 & ((lower1 <= lower2 & lower2 <= upper1) | (lower2 <= lower1 & lower1 <= upper2))))
        \heuristics(simplify)
    };

    \lemma
    disjointArrayRangeAllFields1 {
        \schemaVar \term Object o1, o2;
        \schemaVar \term int lower2, upper2;
        \find(intersect(allFields(o1), arrayRange(o2, lower2, upper2)) = empty)
        \replacewith(!(o1 = o2 & lower2 <= upper2))
        \heuristics(simplify)
        \displayname "disjointArrayRangeAllFields"
    };

    \lemma
    disjointArrayRangeAllFields2 {
        \schemaVar \term Object o1, o2;
        \schemaVar \term int lower1, upper1;
        \find(intersect(arrayRange(o1, lower1, upper1), allFields(o2)) = empty)
        \replacewith(!(o1 = o2 & lower1 <= upper1))
        \heuristics(simplify)
        \displayname "disjointArrayRangeAllFields"
    };

    // --------------------------------------------------------------------------
    // lemmata for createdInHeap
    // --------------------------------------------------------------------------

    createdInHeapWithEmpty {
        \schemaVar \term Heap h;

        \find(createdInHeap(empty, h))

        \replacewith(true)

        \heuristics(concrete)
    };

    createdInHeapWithSingleton {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(createdInHeap(singleton(o, f), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithUnion {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Heap h;

        \find( ==> createdInHeap(union(s, s2), h))

        \replacewith( ==> createdInHeap(s, h));
        \replacewith( ==> createdInHeap(s2, h))

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithSetMinusFreshLocs {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;

        \find(createdInHeap(setMinus(s, freshLocs(h)), h))

        \replacewith(true)

        \heuristics(concrete)
    };

    createdInHeapWithAllFields {
        \schemaVar \term Object o;
        \schemaVar \term Heap h;

        \find(createdInHeap(allFields(o), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithArrayRange {
        \schemaVar \term Object o;
        \schemaVar \term int lower, upper;
        \schemaVar \term Heap h;

        \find(createdInHeap(arrayRange(o, lower, upper), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE | upper < lower)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithSelect {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find( ==> createdInHeap(LocSet::select(h, o, f), h))

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    createdInHeapWithObserver {
        \schemaVar \term LocSet obs;
        \schemaVar \term Heap h;

        \find( ==> createdInHeap(obs, h))
        \varcond(\isObserver(obs, h))

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // EQ versions of lemmata for createdInHeap
    // --------------------------------------------------------------------------


    createdInHeapWithSingletonEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithUnionEQ {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find( ==> createdInHeap(EQ, h))

        \replacewith( ==> createdInHeap(s, h));
        \replacewith( ==> createdInHeap(s2, h))

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithSetMinusFreshLocsEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, freshLocs(h)) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    createdInHeapWithAllFieldsEQ {
        \schemaVar \term Object o;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(allFields(o) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithArrayRangeEQ {
        \schemaVar \term Object o;
        \schemaVar \term int lower, upper;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(arrayRange(o, lower, upper) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE | upper < lower)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithSelectEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(LocSet::select(h, o, f) = EQ ==>)
        \find( ==> createdInHeap(EQ, h))

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    createdInHeapWithObserverEQ {
        \schemaVar \term LocSet obs;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(obs = EQ ==>)
        \find( ==> createdInHeap(EQ, h))
        \varcond(\isObserver(obs, h))

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // other lemmata for proving createdness
    // --------------------------------------------------------------------------

    referencedObjectIsCreatedRight {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes( ==> deltaObject::select(h, o, f) = null)
        \find( ==> boolean::select(h,
                deltaObject::select(h, o, f),
                java.lang.Object::<created>) = TRUE)

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    referencedObjectIsCreatedRightEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Object EQ;

        \assumes(deltaObject::select(h, o, f) = EQ ==> EQ = null)
        \find( ==> boolean::select(h,
                EQ,
                java.lang.Object::<created>) = TRUE)

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // some other lemmata
    // --------------------------------------------------------------------------

    // proven with KeY (CS)
    unionEqualsEmpty {
        \schemaVar \term LocSet s, s2, s3;

        \find(union(s, s2) = empty)

        \replacewith(s = empty & s2 = empty)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    unionEqualsEmptyEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(EQ = empty)
        \sameUpdateLevel

        \replacewith(s = empty & s2 = empty)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    setMinusOfUnion {
        \schemaVar \term LocSet s, s2, s3;

        \find(setMinus(union(s, s2), s3))

        \replacewith(union(setMinus(s, s3), setMinus(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    setMinusOfUnionEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(setMinus(EQ, s3))
        \sameUpdateLevel

        \replacewith(union(setMinus(s, s3), setMinus(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetWithSetMinusLeft {
        \schemaVar \term LocSet s, s2, s3;

        \find(subset(setMinus(s, s2), s3))

        \replacewith(subset(s, union(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetWithSetMinusLeftEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, s2) = EQ ==>)
        \find(subset(EQ, s3))
        \sameUpdateLevel

        \replacewith(subset(s, union(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    unionWithItself {
        \schemaVar \term LocSet s;

        \find(union(s, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    intersectWithItself {
        \schemaVar \term LocSet s;

        \find(intersect(s, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    // one of the two below should be obsolete after completing term ordering (not yet done)
    distributeIntersection {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(s1, union(s2, s3)))

        \replacewith(union(intersect(s1, s2), intersect(s1, s3)))

        \heuristics(simplify_enlarging)
    };

    distributeIntersection_2 {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(union(s2, s3), s1))

        \replacewith(union(intersect(s2, s1), intersect(s3, s1)))

        \heuristics(simplify_enlarging)
    };

    intersectWithSingleton {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(intersect(singleton(o, f), s))

        \replacewith(\if(elementOf(o, f, s)) \then(singleton(o, f)) \else(empty))

        \heuristics(simplify_enlarging)
    };

    setMinusItself {
        \schemaVar \term LocSet s;

        \find(setMinus(s, s))

        \replacewith(empty)

        \heuristics(concrete)
    };

    setMinusSingleton {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes( ==> elementOf(o, f, s))

        \find(setMinus(s, singleton(o, f)))

        \replacewith(s)

        \heuristics(simplify)
    };

    intersectionSetMinusItself {
        \schemaVar \term LocSet s1, s2;

        \find(intersect(setMinus(s1, s2), s2))

        \replacewith(empty)

        \heuristics(concrete)
    };

    intersectionSetMinusItself_2 {
        \schemaVar \term LocSet s1, s2;

        \find(intersect(s2, setMinus(s1, s2)))

        \replacewith(empty)

        \heuristics(concrete)
    };

    unionIntersectItself {
        \schemaVar \term LocSet s1, s2;

        \find(union(intersect(s1, s2), s1))

        \replacewith(s1)

        \heuristics(simplify)
    };

    unionIntersectItself_2 {
        \schemaVar \term LocSet s1, s2;

        \find(union(intersect(s2, s1), s1))

        \replacewith(s1)

        \heuristics(simplify)
    };

    unionIntersectItself_3 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(s, intersect(s1, s2)), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_4 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(s, intersect(s2, s1)), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_5 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(intersect(s1, s2), s), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_6 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(intersect(s2, s1), s), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    infiniteUnionUnused {
        \schemaVar \variables alpha av;
        \schemaVar \term LocSet s;

        \find(infiniteUnion{av;}(s))
        \varcond(\notFreeIn(av, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    subsetOfItself {
        \schemaVar \term LocSet s;

        \find(subset(s, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    // really needed for efficiency?
    elementOfGuardedSet {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \formula phi;
        \schemaVar \term LocSet s;

        \find(elementOf(o, f, \if(phi) \then(s) \else(empty)))

        \replacewith(phi & elementOf(o, f, s))

        \heuristics(concrete)
    };

    commuteDisjoint {
        \schemaVar \term LocSet commLeft, commRight;

        \find(disjoint(commLeft, commRight))
        \replacewith(disjoint(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteUnion {
        \schemaVar \term LocSet commLeft, commRight;

        \find(union(commLeft, commRight))

        \replacewith(union(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteUnion_2 {
        \schemaVar \term LocSet commLeft, commRight, s;

        \find(union(union(s, commLeft), commRight))

        \replacewith(union(union(s, commRight), commLeft))

        \heuristics(cnf_setComm)
    };

    commuteIntersection {
        \schemaVar \term LocSet commLeft, commRight;

        \find(intersect(commLeft, commRight))

        \replacewith(intersect(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteIntersection_2 {
        \schemaVar \term LocSet commLeft, commRight, s;

        \find(intersect(intersect(s, commLeft), commRight))

        \replacewith(intersect(intersect(s, commRight), commLeft))

        \heuristics(cnf_setComm)
    };

    associativeLawUnion {
        \schemaVar \term LocSet s1, s2, s3;

        \find(union(s1, union(s2, s3)))

        \replacewith(union(union(s1, s2), s3))

        \heuristics(conjNormalForm)
    };

    associativeLawIntersect {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(s1, intersect(s2, s3)))

        \replacewith(intersect(intersect(s1, s2), s3))

        \heuristics(conjNormalForm)
    };




    //--------------------------------------------------------------------------
    // work-a-round to use \infinite_union in JML set statements
    // --------------------------------------------------------------------------

    definitionAllElementsOfArray {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArray(h, array, singleton(o, f)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array), \notFreeIn(j, o, f))

        \replacewith(infiniteUnion{j;}(\if(0 <= j & j < length(array))
                    \then(singleton(Object::select(h, array, arr(j)), f))
                    \else(empty)))
        \heuristics(simplify)
    };

    definitionAllElementsOfArray2 {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArray(h, array, allFields(o)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array))

        \replacewith(infiniteUnion{j;}(\if(0 <= j & j < length(array))
                    \then(allFields(Object::select(h, array, arr(j))))
                    \else(empty)))
        \heuristics(simplify)
    };

    definitionAllElementsOfArrayLocsets {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArrayLocsets(h, array, singleton(o, f)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array), \notFreeIn(j, o, f))

        \replacewith(infiniteUnion{j;}(\if(0 <= j & j < length(array))
                    \then(LocSet::select(h, Object::select(h, array, arr(j)), f))
                    \else(empty)))
        \heuristics(simplify)
    };

  //====================================================================================================
  //===============================Asma: Axioms and Lemmas for arrayRanges and singletons ============================
  //====================================================================================================
  //=============================== Axioms:
    arrayRangeSingleton{
    	\schemaVar \term Object a;
    	\schemaVar \term int low, high, index;

    	\find(arrayRange(a, low, high) = singleton(a,arr(index)))
    	\replacewith(low = high & high = index)
    	\heuristics(simplify)
    };

    singletonNegativeIndexEqualsEmpty {
		\schemaVar \term Object o;
		\schemaVar \term int index;

		\find(singleton(o, arr(index)) = empty)
	   	\replacewith(\if(index < 0) \then(true) \else(false))

	    \heuristics(concrete)
    };

    arrayRangeEmptySet{
    	\schemaVar \term Object a;
    	\schemaVar \term int low, high;

    	\find(arrayRange(a, low, high) = empty)
    	\replacewith(low > high)
    	\heuristics(simplify)
    };

    arrayRangeSubset {
    	\schemaVar \term Object a,b;
    	\schemaVar \term int lowA, highA, lowB, highB;

    	\find(subset(arrayRange(a,lowA,highA), arrayRange(b,lowB,highB)))
    	\replacewith(\if (a = b & lowA >= lowB & highA <= highB ) \then (true) \else (false) )
    	\heuristics(simplify)
    };

    singletonEquals {
		\schemaVar \term Object o,u;
		\schemaVar \term Field f,g;

		\find(singleton(o,f) = singleton(u,g))
		\replacewith(o = u & f = g)

		\heuristics(simplify)
	};

	singletonEquals2 {
		\schemaVar \term Object o;
		\schemaVar \term Field f, g;
		\schemaVar \formula result;

		\find(singleton(o,f) = singleton(o,g))
		\varcond(\equalUnique(f, g, result))
		\replacewith(result)

		\heuristics(concrete)
	};

    //=============================== Lemmas:
    // Proven with KeY (AHT)
    singletonIntersectarrayRange { //Do we also need this?
    	\schemaVar \term Object a,b;
    	\schemaVar \term int lowA, highA, indexB;

    	\find(intersect(singleton(b,arr(indexB)), arrayRange(a,lowA,highA)))
    	\replacewith(\if (a = b & lowA <= indexB & indexB <= highA) \then (singleton(b,arr(indexB))) \else (empty))
    	\heuristics(simplify)
    };

    // Proven with KeY (AHT)
    arrayRangeOfOne {
        \schemaVar \term Object a;
        \schemaVar \term int low;

        \find(arrayRange(a, low, low))
        \replacewith(singleton(a, arr(low)))
        \heuristics(concrete)
    };

    // Proven with KeY (AHT)
	arrayRangeLowGTHigh {
		\schemaVar \term Object a;
    	\schemaVar \term int low;

		\find(arrayRange(a, low + 1, low))
		\replacewith(empty)

		\heuristics(concrete)
	};

	arrayRangeLowGTHighGeneral {
		\schemaVar \term Object a;
    	\schemaVar \term int low, high;

		\find(arrayRange(a, low, high))
		\replacewith(\if (low > high) \then(empty) \else (arrayRange(a,low,high)<<nonEmpty>>))

		\heuristics(arrayRange_known_empty)
	};


    // Proven with KeY (AHT)
	arrayRangeLowGTHigh2 {
		\schemaVar \term Object a;
    	\schemaVar \term int low;

		\find(arrayRange(a, low, low - 1))
		\replacewith(empty)

		\heuristics(concrete)
	};

	arrayRangeLowGTHigh22 {
        \schemaVar \term Object a;
        \schemaVar \term int low;

        \find(arrayRange(a, 0, -1))
        \replacewith(empty)

        \heuristics(concrete)
    };

     /*arrayRangeMinusLowOrHigh {
         \schemaVar \term Object a;
         \schemaVar \term int low, high;

         \find(arrayRange(a, low, high))
         \replacewith(low < 0 | high < 0 -> empty)

         \heuristics(concrete)
     };*/



	// Proven with KeY (AHT)
     arrayRangeSetMinusSingleton {
    	\schemaVar \term Object a,b;
    	\schemaVar \term int lowA, highA, indexB;

    	\find(setMinus(arrayRange(a,lowA,highA),singleton(b,arr(indexB))))
    	\replacewith(\if (a = b & lowA <= indexB & indexB <= highA) \then (union(arrayRange(a,lowA, indexB-1), arrayRange(a,indexB+1, highA))) \else (arrayRange(a,lowA,highA)))
    	\heuristics(simplify)
    };

    // Proven with KeY (AHT)
    arrayRangeSetMinusSingletonEQ {
    	\schemaVar \term Object a,b;
    	\schemaVar \term int lowA, highA, indexB;
    	\schemaVar \term LocSet EQ;


    	\assumes(arrayRange(a,lowA,highA) = EQ ==>)
    	\find(setMinus(EQ,singleton(b,arr(indexB))))
    	\sameUpdateLevel
    	\replacewith(\if (a = b & lowA <= indexB & indexB <= highA) \then (union(arrayRange(a,lowA, indexB-1), arrayRange(a,indexB+1, highA))) \else (arrayRange(a,lowA,highA)))
    	\heuristics(simplify)
    };

    // Proven with KeY (AHT)
    singletonSetMinusSet {
    	\schemaVar \term Object a,b;
    	\schemaVar \term LocSet set;
    	\schemaVar \term int indexB;

    	\find(setMinus(singleton(b,arr(indexB)), set))
    	\replacewith(\if (subset(singleton(b,arr(indexB)),set)) \then (empty) \else (singleton(b,arr(indexB))))
    	\heuristics(simplify)
    };

    // Proven with KeY (AHT)
    setMinusSimplify1 {
   	    \schemaVar \term LocSet s, t;

        \find(setMinus(setMinus(s, t), t))

        \replacewith(setMinus(s, t))

        \heuristics(simplify)
   };

   // not yet proven
   setMinusTriple {
   	    \schemaVar \term LocSet s, t, u;

        \find(setMinus(s, setMinus(t, u)))
        \replacewith(union(setMinus(s,t), intersect(s,u)))

        \heuristics(simplify_enlarging)
   };

   // Proven with KeY (AHT)
   setMinusSimplify2 {
   	   \schemaVar \term LocSet s, t;

        \find(setMinus(s, setMinus(s, t)))

        \replacewith(intersect(s, t))

        \heuristics(simplify)
	};

	// Proven with KeY (AHT)
	setMinusSimplify3 {
   	   \schemaVar \term LocSet s;

        \find(setMinus(s, s))

        \replacewith(empty)

        \heuristics(simplify)
	};

	// Proven with KeY (AHT)
	setMinusSwitch {
  	 	\schemaVar \term LocSet s, commEqLeft, commEqRight;

       \find(setMinus(setMinus(s, commEqLeft), commEqRight))


       \replacewith(setMinus(setMinus(s, commEqRight), commEqLeft))

       \heuristics(order_terms)
  };

  // Proven with KeY (AHT)
  arrayRangeIntersect {
  	\schemaVar \term Object a,b;
  	\schemaVar \term int lowA, highA;
  	\schemaVar \term int lowB, highB;

  	\find(intersect(arrayRange(a,lowA,highA), arrayRange(b,lowB,highB)))
  	\replacewith(\if (a = b) \then (arrayRange(a,
  	                                    \if (lowA > lowB) \then (lowA) \else (lowB),
  	                    			    \if (highA < highB) \then (highA) \else (highB)))
  	             \else (empty) )
  	\heuristics(simplify)
  };

  // Proven with KeY (AHT)
  arrayRangeIntersectSingleton {
  	\schemaVar \term Object a,b;
  	\schemaVar \term int lowA, highA, indexB;

  	\find(intersect(arrayRange(a,lowA,highA), singleton(b,arr(indexB))))
  	\replacewith(\if (a = b & lowA <= indexB & indexB <= highA) \then (singleton(b,arr(indexB))) \else (empty))
  	\heuristics(simplify)
  };

  // Proven with KeY (AHT)
  singletonIntersectSingleton { //Do we also need this?
  	\schemaVar \term Object a,b;
  	\schemaVar \term int indexA, indexB;

  	\find(intersect(singleton(a,arr(indexA)), singleton(b,arr(indexB))))
  	\replacewith(\if (a = b & indexA = indexB) \then (singleton(a,arr(indexA))) \else (empty))
  	\heuristics(simplify)
  };

  // Proven with KeY (AHT)
  singletonSubsetArrayRange {
  	\schemaVar \term Object a,b;
  	\schemaVar \term int lowA, highA, indexB;

  	\find(subset(singleton(b,arr(indexB)), arrayRange(a,lowA,highA)))
  	\replacewith(a = b & lowA <= indexB & indexB <= highA)
  	\heuristics(simplify)
  };

  // Proven with KeY (AHT)
  singletonSetMinusArrayRange {
  	\schemaVar \term Object a,b;
  	\schemaVar \term int lowA, highA, indexB;

  	\find(setMinus(singleton(b,arr(indexB)), arrayRange(a,lowA,highA)))
  	\replacewith(\if (a = b & lowA <= indexB & indexB <= highA) \then (empty) \else (singleton(b,arr(indexB))))
  	\heuristics(simplify)
  };

  // Proven with KeY (AHT)
  SetMinusSplitCup {
  	\schemaVar \term LocSet loc1, loc2, loc3;

  	\find(setMinus(loc1,union(loc2,loc3)))
  	\replacewith(setMinus(setMinus(loc1,loc2),loc3))
  	\heuristics(simplify)
  };

  //Proven with KeY (AHT)
  SingletonSetMinusSingleton {
  	\schemaVar \term Object a,b;
  	\schemaVar \term int indexB, indexA;

  	\find(setMinus(singleton(a,arr(indexA)),singleton(b,arr(indexB))))
  	\replacewith(\if(a = b & indexA = indexB) \then (empty) \else (singleton(a,arr(indexA))))
  	\heuristics(simplify)
  };
//===============================================Subset===========================================

//  singletonSubsetArrayRangeEq {
//	\schemaVar \term Object a,b;
//	\schemaVar \term int lowA, highA, indexB;
//	\schemaVar \term LocSet Eq;
//
//	\assumes(arrayRange(a,lowA,highA) = Eq ==>)
//	\find(subset(singleton(b,arr(indexB)), Eq))
//	\replacewith(a = b & lowA <= indexB & indexB <= highA)
//	\heuristics(simplify)
//  };

//    singletonEqSubsetArrayRange {
//    	\schemaVar \term Object a,b;
//    	\schemaVar \term int lowA, highA, indexB;
//    	\schemaVar \term LocSet Eq;
//
//    	\assumes(singleton(b,arr(indexB)) = Eq ==>)
//    	\find(subset(Eq, arrayRange(a,lowA,highA)))
//    	\replacewith(a = b & lowA <= indexB & indexB <= highA)
//    	\heuristics(simplify)
//    };

//    singletonEqSubsetArrayRangeEq {
//    	\schemaVar \term Object a,b;
//    	\schemaVar \term int lowA, highA, indexB;
//    	\schemaVar \term LocSet Eq1,Eq2;
//
//    	\assumes(arrayRange(a,lowA,highA) = Eq1, singleton(b,arr(indexB)) = Eq2 ==>)
//    	\find(subset(Eq2, Eq1))
//    	\replacewith(a = b & lowA <= indexB & indexB <= highA)
//    	\heuristics(simplify)
//    };

//    arrayRangeSubsetSingleton {
//    	\schemaVar \term Object a,b;
//    	\schemaVar \term int lowA, highA, indexB;
//
//    	\find(subset(arrayRange(a,lowA,highA), singleton(b,arr(indexB))))
//    	\replacewith(a = b & indexB = lowA & indexB = highA)
//    	\heuristics(simplify)
//    };



 //===============================================SetMinus on ArrayRange===========================================
  //Proven with KeY (AHT)
  arrayRangeSetMinusArrayRange {
	\schemaVar \term Object a,b;
	\schemaVar \term int lowA, highA;
	\schemaVar \term int lowB, highB;

	\find(setMinus(arrayRange(a,lowA,highA), arrayRange(b,lowB,highB)))

	\replacewith(
			\if(lowA > highA) \then(empty) \else( \if(lowB > highB) \then(arrayRange(a,lowA,highA)) \else(
			\if (a != b) \then (arrayRange(a,lowA,highA))
								\else (\if(lowA>lowB) \then(\if(highA>highB)\then(\if(highB<lowA)\then(arrayRange(a,lowA,highA))
																								\else(arrayRange(a,highB+1,highA)))
																			\else(empty))
													\else(\if(lowA=lowB)\then(\if(highA>highB)\then(arrayRange(a,highB+1,highA))
																								\else(empty))
																		\else(\if(highA>highB)\then(union(arrayRange(a,lowA,lowB-1),arrayRange(a,highB+1,highA)))
																								\else(\if(lowB > highA) \then(arrayRange(a,lowA,highA)) \else (arrayRange(a,lowA,lowB-1)))))))))
		\heuristics(locset_expand_setMinus)
   };

  //Proven with KeY (AHT)
  arrayRangeEqSetMinusArrayRange {
	\schemaVar \term Object a,b;
	\schemaVar \term int lowA, highA;
	\schemaVar \term int lowB, highB;
	\schemaVar \term LocSet Eq;

	\assumes(arrayRange(a,lowA,highA) = Eq ==>)
	\find(setMinus(Eq, arrayRange(b,lowB,highB))) \sameUpdateLevel
	\replacewith(
			\if(lowA > highA) \then(empty) \else( \if(lowB > highB) \then(arrayRange(a,lowA,highA)) \else(
			\if (a != b) \then (arrayRange(a,lowA,highA))
								\else (\if(lowA>lowB) \then(\if(highA>highB)\then(\if(highB<lowA)\then(arrayRange(a,lowA,highA))
																								\else(arrayRange(a,highB+1,highA)))
																			\else(empty))
													\else(\if(lowA=lowB)\then(\if(highA>highB)\then(arrayRange(a,highB+1,highA))
																								\else(empty))
																		\else(\if(highA>highB)\then(union(arrayRange(a,lowA,lowB-1),arrayRange(a,highB+1,highA)))
																								\else(\if(lowB > highA) \then(arrayRange(a,lowA,highA)) \else (arrayRange(a,lowA,lowB-1)))))))))

		\heuristics(locset_expand_setMinus)
  };

  //Proven with KeY (AHT)
  arrayRangeSetMinusArrayRangeEq {
	\schemaVar \term Object a,b;
	\schemaVar \term int lowA, highA;
	\schemaVar \term int lowB, highB;
	\schemaVar \term LocSet Eq;

	\assumes(arrayRange(b,lowB,highB)=Eq ==>)
	\find(setMinus(arrayRange(a,lowA,highA), Eq)) \sameUpdateLevel
	\replacewith(
			\if(lowA > highA) \then(empty) \else( \if(lowB > highB) \then(arrayRange(a,lowA,highA)) \else(
			\if (a != b) \then (arrayRange(a,lowA,highA))
								\else (\if(lowA>lowB) \then(\if(highA>highB)\then(\if(highB<lowA)\then(arrayRange(a,lowA,highA))
																								\else(arrayRange(a,highB+1,highA)))
																			\else(empty))
													\else(\if(lowA=lowB)\then(\if(highA>highB)\then(arrayRange(a,highB+1,highA))
																								\else(empty))
																		\else(\if(highA>highB)\then(union(arrayRange(a,lowA,lowB-1),arrayRange(a,highB+1,highA)))
																								\else(\if(lowB > highA) \then(arrayRange(a,lowA,highA)) \else (arrayRange(a,lowA,lowB-1)))))))))
		\heuristics(locset_expand_setMinus)
  };

  //Proven with KeY (AHT)
  arrayRangeEqSetMinusArrayRangeEq {
	\schemaVar \term Object a,b;
	\schemaVar \term int lowA, highA;
	\schemaVar \term int lowB, highB;
	\schemaVar \term LocSet EqA, EqB;

	\assumes(arrayRange(b,lowB,highB)=EqB , arrayRange(a,lowA,highA)=EqA ==>)
	\find(setMinus(EqA, EqB)) \sameUpdateLevel
	\replacewith(
			\if(lowA > highA) \then(empty) \else( \if(lowB > highB) \then(arrayRange(a,lowA,highA)) \else(
			\if (a != b) \then (arrayRange(a,lowA,highA))
								\else (\if(lowA>lowB) \then(\if(highA>highB)\then(\if(highB<lowA)\then(arrayRange(a,lowA,highA))
																								\else(arrayRange(a,highB+1,highA)))
																			\else(empty))
													\else(\if(lowA=lowB)\then(\if(highA>highB)\then(arrayRange(a,highB+1,highA))
																								\else(empty))
																		\else(\if(highA>highB)\then(union(arrayRange(a,lowA,lowB-1),arrayRange(a,highB+1,highA)))
																								\else(\if(lowB > highA) \then(arrayRange(a,lowA,highA)) \else (arrayRange(a,lowA,lowB-1)))))))))
	\heuristics(locset_expand_setMinus)
  };


  arrayRangeSetMinusArrayRangeSameLowerBound {
  	\schemaVar \term Object a;
  	\schemaVar \term int low;
  	\schemaVar \term int high1, high2;

  	\find(setMinus(arrayRange(a,low,high1), arrayRange(a,low,high2)))

  	\replacewith(
  			\if(low > high1 ) \then(empty)
                              \else(\if(high1>high2) \then(arrayRange(a,high2 + 1, high1))
                                                     \else(empty)))

  		\heuristics(locset_expand_setMinus)
  };
  arrayRangeSetMinusArrayRangeSameLowerBoundWithEq {
    \schemaVar \term LocSet Eq;
  	\schemaVar \term Object a;
  	\schemaVar \term int low;
  	\schemaVar \term int high1, high2;

    \assumes(arrayRange(a,low,high2)=Eq ==>)
  	\find(setMinus(arrayRange(a,low,high1), Eq))
    \sameUpdateLevel
  	\replacewith(
  			\if(low > high1 ) \then(empty)
                              \else(\if(high1>high2) \then(arrayRange(a,high2 + 1, high1))
                                                     \else(empty)))

  		\heuristics(locset_expand_setMinus_known)
  };

  arrayRangeSetMinusArrayRangeSameUpperBound {
  	\schemaVar \term Object a;
  	\schemaVar \term int low1, low2;
  	\schemaVar \term int high;

  	\find(setMinus(arrayRange(a,low1,high), arrayRange(a,low2,high)))

  	\replacewith(
  			\if(low1 > high ) \then(empty)
                              \else(\if(low2>low1) \then(arrayRange(a,low1, low2 - 1))
                                                     \else(empty)))

  		\heuristics(locset_expand_setMinus)
  };

  arrayRangeSetMinusArrayRangeSameUpperBoundWithEq {
    \schemaVar \term LocSet Eq;
    \schemaVar \term Object a;
    \schemaVar \term int low1, low2;
    \schemaVar \term int high;

    \assumes(arrayRange(a,low2,high)=Eq ==>)
    \find(setMinus(arrayRange(a,low1,high), Eq))

    \replacewith(
            \if(low1 > high ) \then(empty)
                            \else(\if(low2>low1) \then(arrayRange(a,low1, low2 - 1))
                                                   \else(empty)))

        \heuristics(locset_expand_setMinus)
};


  arrayRangeSetMinusArrayRangeSameCrossBound1 {
  	\schemaVar \term Object a;
  	\schemaVar \term int low;
  	\schemaVar \term int high1, high2;

  	\find(setMinus(arrayRange(a,low,high1), arrayRange(a,high1,high2)))

  	\replacewith(arrayRange(a,low, high1 - 1))

  		\heuristics(locset_expand_setMinus)
  };

  arrayRangeSetMinusArrayRangeSameCrossBound2 {
  	\schemaVar \term Object a;
  	\schemaVar \term int low1, low2;
  	\schemaVar \term int high;

  	\find(setMinus(arrayRange(a,low1,high), arrayRange(a,low2,low1)))

  	\replacewith(arrayRange(a,low1 + 1, high))

  		\heuristics(locset_expand_setMinus)
  };

    pullOutSetMinusWithTwoLocs{
        \schemaVar \term LocSet arrLoc1, arrLoc2;
        \schemaVar \skolemTerm LocSet setMinusPulled;

        \find(setMinus(arrLoc1, arrLoc2))
        \sameUpdateLevel
        \varcond(\newDependingOn(setMinusPulled, arrLoc1),
                \newDependingOn(setMinusPulled, arrLoc2))

        \replacewith(setMinusPulled)
        \add(setMinus(arrLoc1, arrLoc2) = setMinusPulled ==>)

        \heuristics(pullOutLocSet)
    };

     //===============================================SetMinus on InfiniteUnion===========================================

  arrayRangeSetMinusInfiniteUnion1D {
    \schemaVar \term Object a,b;
    \schemaVar \term int lowA, highA;
    \schemaVar \term int lowB, highB;
    \schemaVar \variable int k;

    \find(infiniteUnion{k;}(setMinus(arrayRange(a,lowA,highA),
                   (\if (k>=lowB & k<=highB)
                                     \then(singleton(b,arr(k)))
                                     \else(empty)))))
    \varcond(\notFreeIn(k, lowB, highB, b, a), \notFreeIn(k, lowA, highA))
    \replacewith(
            \if(lowA > highA) \then(empty) \else( \if(lowB > highB) \then(arrayRange(a,lowA,highA)) \else(
            \if (a != b) \then (arrayRange(a,lowA,highA))
                                \else (\if(lowA>lowB) \then(\if(highA>highB)\then(\if(highB<lowA)\then(arrayRange(a,lowA,highA))
                                                                                                \else(arrayRange(a,highB+1,highA)))
                                                                            \else(empty))
                                                    \else(\if(lowA=lowB)\then(\if(highA>highB)\then(arrayRange(a,highB+1,highA))
                                                                                                \else(empty))
                                                                        \else(\if(highA>highB)\then(union(arrayRange(a,lowA,lowB-1),arrayRange(a,highB+1,highA)))
                                                                                                \else(\if(lowB > highA) \then(arrayRange(a,lowA,highA)) \else (arrayRange(a,lowA,lowB-1)))))))))
        \heuristics(locset_expand_setMinus)
   };


  infiniteUnion1DSetMinusArrayRange {//b-a
      \schemaVar \term Object a,b;
      \schemaVar \term int lowA, highA;
      \schemaVar \term int lowB, highB;
      \schemaVar \variable int k;

      \find(setMinus(infiniteUnion{k;}(\if (k>=lowB & k<=highB)
                                                            \then(singleton(b,arr(k)))
                                                            \else(empty)),arrayRange(a,lowA,highA)))
      \varcond(\notFreeIn(k, lowB, highB, b))
      \replacewith(
          \if(lowB > highB)
               \then(empty)
               \else( \if(lowA > highA)
                   \then(arrayRange(b,lowB,highB))
                   \else(
              \if (a != b) \then (arrayRange(b,lowB,highB))
                           \else (\if(lowB>lowA)
                                  \then(\if(highB>highA)\then(\if(highA<lowB)\then(arrayRange(b,lowB,highB))
                                                                             \else(arrayRange(b,highA+1,highB)))
                                                        \else(empty))
                                  \else(\if(lowA=lowB)\then(\if(highB>highA)\then(arrayRange(b,highA+1,highB))
                                                                            \else(empty))
                                                      \else(\if(highB>highA)\then(union(arrayRange(b,lowB,lowA-1),arrayRange(b,highA+1,highB)))
                                                                            \else(\if(lowA > highB) \then(arrayRange(b,lowB,highB)) \else (arrayRange(b,lowB,lowA-1)))))))))
          \heuristics(locset_expand_setMinus)
     };


  infiniteUnion1DSetMinusSingleton {
        \schemaVar \term Object a,b;
        \schemaVar \term int lowB, highB, indexA;
        \schemaVar \variable int k;

        \find(setMinus(infiniteUnion{k;}(\if(k>=lowB & k<=highB)\then(singleton(b,arr(k))) \else(empty)),singleton(a,arr(indexA))))
        \varcond(\notFreeIn(k, lowB, highB, b, indexA))

        \replacewith(\if (a = b & lowB <= indexA & indexA <= highB) \then (union(arrayRange(a,lowB, indexA-1), arrayRange(a,indexA+1, highB))) \else (arrayRange(b,lowB,highB)))
        \heuristics(simplify)
  };

   /*infiniteUnion2DSetMinusSingleton {
          \schemaVar \term Object a,b;
          \schemaVar \term int lowB1, highB1, lowB2, highB2, indexA;
          \schemaVar \variable int k, l;
          \schemaVar \term Heap heapSV;

          \find(setMinus(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))\else(empty)),singleton(a,arr(indexA))))
          \varcond(\notFreeIn(k, lowB1, highB1, lowB2, highB2, heapSV, a, b, indexA, l),
                   \notFreeIn(l, lowB1, highB1, lowB2, highB2, heapSV, a, b, indexA, k))

          \replacewith(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))\else(empty)))
          \add(\forall k; ! subset(singleton(a,arr(indexA)), arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))==>);

          \replacewith(union(//union(
                                   infiniteUnion{l,k;}(\if (l>=lowB1 & l<=k-1)\then(arrayRange(U::select(heapSV, b, arr(l)),lowB2, highB2))\else(empty)),
                                   infiniteUnion{l,k;}(\if (l>=k+1 & l<=highB1)\then(arrayRange(U::select(heapSV, b, arr(l)),lowB2, highB2))\else(empty))//),
                             //setMinus(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2),singleton(a,arr(indexA)))
                             ))
          \add(\exists k; subset(singleton(a,arr(indexA)), arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))==>)

          \heuristics(simplify)
    };*/


  infiniteUnion1DSetMinusInfiniteUnion1D{ //b - a
        \schemaVar \term Object a,b;
        \schemaVar \term int lowA, highA;
        \schemaVar \term int lowB, highB;
        \schemaVar \variable int k,l;

        \find(setMinus(infiniteUnion{k;}(\if (k>=lowB & k<=highB)\then(singleton(b,arr(k)))\else(empty)),
                       infiniteUnion{l;}(\if (l>=lowA & l<=highA)\then(singleton(a,arr(l)))\else(empty))))
        \varcond(\notFreeIn(k, lowB, highB, b),
                 \notFreeIn(l, lowA, highA, a))

        \replacewith(
            \if(lowB > highB)
                \then(empty)
                \else(\if(lowA > highA)
                          \then(arrayRange(b,lowB,highB))
                          \else(\if (a != b) \then (arrayRange(b,lowB,highB))
                                             \else (\if(lowB>lowA)
                                                        \then(\if(highB>highA)\then(\if(highA<lowB)
                                                                                        \then(arrayRange(b,lowB,highB))
                                                                                        \else(arrayRange(b,highA+1,highB)))
                                                                               \else(empty))
                                                       \else(\if(lowA=lowB)
                                                                 \then(\if(highB>highA)
                                                                           \then(arrayRange(b,highA+1,highB))
                                                                           \else(empty))
                                                                 \else(\if(highB>highA)
                                                                           \then(union(arrayRange(b,lowB,lowA-1),arrayRange(b,highA+1,highB)))
                                                                           \else(\if(lowA > highB)
                                                                                     \then(arrayRange(b,lowB,highB))
                                                                                     \else (arrayRange(b,lowB,lowA-1)))))))))
            \heuristics(locset_expand_setMinus)

  };

 infiniteUnionSetMinusInfiniteUnionDetailed{
     \schemaVar \term Object a,b;
     \schemaVar \term Heap heapSV;
     \schemaVar \term int lowA1, highA1, lowA2, highA2;
     \schemaVar \term int lowB1, highB1, lowB2, highB2;
     \schemaVar \variable int k, l;

     \find(setMinus(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))\else(empty)),
                    infiniteUnion{l;}(\if (l>=lowA1 & l<=highA1)\then(arrayRange(U::select(heapSV, a, arr(l)),lowA2, highA2))\else(empty))))
     \varcond(\notFreeIn(k, lowB1, highB1, lowB2, highB2), \notFreeIn(k, lowA1, highA1, lowA2, highA2), \notFreeIn(k, a, b, heapSV),
              \notFreeIn(l, lowB1, highB1, lowB2, highB2), \notFreeIn(l, lowA1, highA1, lowA2, highA2), \notFreeIn(l, a, b, heapSV))

     \replacewith(
         \if(lowB1 > highB1 | lowB2 > highB2)
             \then(empty)
             \else(\if(lowA1 > highA1 | lowA2 > highA2)
                       \then(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))\else(empty)))
                       \else(\if (a != b)
                                  \then (infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))\else(empty)))
                                  \else(\if(lowB1=lowA1 & highB1=highA1)
                                            \then(\if(lowB2>lowA2)
                                                      \then(\if(highB2>highA2)
                                                                \then(\if(highA2<lowB2)
                                                                          \then(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))\else(empty)))
                                                                          \else(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowA2 + 1, highB2))\else(empty))))
                                                                \else(empty))
                                                      \else(\if(lowA2=lowB2)
                                                                \then(\if(highB2>highA2)
                                                                          \then(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowA2 + 1, highB2))\else(empty)))
                                                                          \else(empty))
                                                                \else(\if(highB2>highA2)
                                                                         \then(union(
                                                                               infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highA2 - 1))\else(empty)),
                                                                               infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)), highA2 + 1, highB2))\else(empty))))
                                                                         \else(\if(lowA2 > highB2)
                                                                                  \then(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2))\else(empty)))
                                                                                  \else(infiniteUnion{k;}(\if (k>=lowB1 & k<=highB1)\then(arrayRange(U::select(heapSV, b, arr(k)),lowB2, highB2 -1))\else(empty)))))))
                                            \else(empty)))))
     \heuristics(locset_expand_setMinus)
 };

 puttingSetMinusUnderQuantifier{
     \schemaVar \term LocSet loc1, loc2;
     \schemaVar \variable int k;

     \find(setMinus(infiniteUnion{k;}(loc1), loc2))
     \varcond(\notFreeIn(k, loc2))

     \replacewith(\if (\forall k; intersect(loc1, loc2) = empty)
                        \then(infiniteUnion{k;}(loc1))
                        \else(infiniteUnion{k;}(setMinus(loc1,loc2))))

     \heuristics(self_app_prevention)
 };
/*
 puttingSetMinusUnderQuantifier_2{
      \schemaVar \term LocSet loc1, loc2;
      \schemaVar \variable int k;

      \find(setMinus(loc1, infiniteUnion{k;}(loc2)))
      \varcond(\notFreeIn(k, loc1))

      \replacewith(\if (\forall k; intersect(loc1, loc2) = empty)
                         \then(loc1)
                         \else(infiniteUnion{k;}(setMinus(loc1,loc2))))

      \heuristics(self_app_prevention)
  };*/

  nestedUniversalQuantifiersSimplification{
      \schemaVar \term LocSet loc1, loc2, loc3, loc4;
      \schemaVar \formula b, c;
      \schemaVar \variable int k, l;


      \find(\forall k;\forall l;(intersect(
                                        (\if(b) \then(loc1) \else(loc2)),
                                        (\if(c) \then(loc3) \else(loc4))) = empty))

      \varcond(\notFreeIn(k, l, loc1, loc2, loc3, loc4),
               \notFreeIn(l, k, loc1, loc2, loc3, loc4))

      \replacewith(\forall k;\forall l;(
                                         \if(b & c) \then(intersect(loc1, loc3))
                                                    \else(\if(b & !c) \then(intersect(loc1, loc4))
                                                                      \else(\if(!b & c) \then(intersect(loc2, loc3))
                                                                                        \else(intersect(loc2, loc4))))=empty))
   //   \heuristics(lateSimplification)
  };

  allLeftLoc1{
      \schemaVar \term LocSet loc1, loc2, loc3, loc4;
      \schemaVar \variable int k, l;
      \schemaVar \term int lowerK, upperK, lowerL, upperL, kInst, lInst;


      \find(\forall k;\forall l;(intersect(
                                        (\if(k>=lowerK & k<=upperK) \then(loc1) \else(loc2)),
                                        (\if(l>=lowerL & l<=upperL) \then(loc3) \else(loc4))) = empty) ==>)

      \varcond(\notFreeIn(k, loc1, loc2, loc3, loc4), \notFreeIn(k, lowerK, upperK, lowerL, upperL),
               \notFreeIn(l, loc1, loc2, loc3, loc4), \notFreeIn(l, lowerK, upperK, lowerL, upperL))

      \add({\subst k; lowerK}{\subst l; lowerL}
                                 (intersect(
                                        (\if(k>=lowerK & k<=upperK) \then(loc1) \else(loc2)),
                                         (\if(l>=lowerL & l<=upperL) \then(loc3) \else(loc4))) = empty) ==>)
      \heuristics(lateSimplification)
  };

  allLeftLoc2{
      \schemaVar \term LocSet loc1, loc2, loc3, loc4;
      \schemaVar \variable int k, l;
      \schemaVar \term int lowerK, upperK, lowerL, upperL, kInst, lInst;


      \find(\forall k;\forall l;(intersect(
                                        (\if(k>=lowerK & k<=upperK) \then(loc1) \else(loc2)),
                                        (\if(l>=lowerL & l<=upperL) \then(loc3) \else(loc4))) = empty) ==>)

      \varcond(\notFreeIn(k, loc1, loc2, loc3, loc4), \notFreeIn(k, lowerK, upperK, lowerL, upperL),
               \notFreeIn(l, loc1, loc2, loc3, loc4), \notFreeIn(l, lowerK, upperK, lowerL, upperL))

      \add({\subst k; upperK}{\subst l; lowerL}
                                 (intersect(
                                        (\if(k>=lowerK & k<=upperK) \then(loc1) \else(loc2)),
                                         (\if(l>=lowerL & l<=upperL) \then(loc3) \else(loc4))) = empty) ==>)
      \heuristics(lateSimplification)
  };

  allLeftLoc3{
      \schemaVar \term LocSet loc1, loc2, loc3, loc4;
      \schemaVar \variable int k, l;
      \schemaVar \term int lowerK, upperK, lowerL, upperL, kInst, lInst;


      \find(\forall k;\forall l;(intersect(
                                        (\if(k>=lowerK & k<=upperK) \then(loc1) \else(loc2)),
                                        (\if(l>=lowerL & l<=upperL) \then(loc3) \else(loc4))) = empty) ==>)

      \varcond(\notFreeIn(k, loc1, loc2, loc3, loc4), \notFreeIn(k, lowerK, upperK, lowerL, upperL),
                     \notFreeIn(l, loc1, loc2, loc3, loc4), \notFreeIn(l, lowerK, upperK, lowerL, upperL))

      \add({\subst k; lowerK}{\subst l; upperL}
                                 (intersect(
                                        (\if(k>=lowerK & k<=upperK) \then(loc1) \else(loc2)),
                                         (\if(l>=lowerL & l<=upperL) \then(loc3) \else(loc4))) = empty) ==>)
      \heuristics(lateSimplification)
  };

  allLeftLoc4{
      \schemaVar \term LocSet loc1, loc2, loc3, loc4;
      \schemaVar \variable int k, l;
      \schemaVar \term int lowerK, upperK, lowerL, upperL, kInst, lInst;


      \find(\forall k;\forall l;(intersect(
                                        (\if(k>=lowerK & k<=upperK) \then(loc1) \else(loc2)),
                                        (\if(l>=lowerL & l<=upperL) \then(loc3) \else(loc4))) = empty) ==>)

      \varcond(\notFreeIn(k, loc1, loc2, loc3, loc4), \notFreeIn(k, lowerK, upperK, lowerL, upperL),
                     \notFreeIn(l, loc1, loc2, loc3, loc4), \notFreeIn(l, lowerK, upperK, lowerL, upperL))

      \add({\subst k; upperK}{\subst l; upperL}
                                 (intersect(
                                        (\if(k>=lowerK & k<=upperK) \then(loc1) \else(loc2)),
                                         (\if(l>=lowerL & l<=upperL) \then(loc3) \else(loc4))) = empty) ==>)
      \heuristics(lateSimplification)
  };

 /*arrayRangeIntersectSingletonUnderInfiniteUnion {
   	\schemaVar \term Object a,b;
   	\schemaVar \term int lowA, highA, lowB, highB;
   	\schemaVar \variable int k;

   	\find(infiniteUnion{k;}(intersect(arrayRange(a,lowA,highA), \if(k>=lowB & k<=highB)\then(singleton(b,arr(k)))\else(empty)))
   	)
   	\varcond(\notFreeIn(k, a, lowA, highA, lowB), \notFreeIn(k, highB))
   	\replacewith(infiniteUnion{k;}(\if (a = b & lowA <= k & k <= highA) \then (singleton(b,arr(k))) \else (empty)))
   	\heuristics(simplify)
   };*/

}



\include matrixRangeRules;
