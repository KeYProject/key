\rules(programRules:Java) {
    \lemma
    dominatesSetElement {
        \schemaVar \term LocSet s;
        \schemaVar \term Object x, o;
        \schemaVar \term Field f;

        \assumes(dominatesSet(x, s) ==>)
        \find(elementOf(o, f, s) ==>)

        \add(dominates(x, o) ==>)
        \heuristics(inReachableStateImplication)
    };

    \lemma
    dominatesSetNotElement {
        \schemaVar \term LocSet s;
        \schemaVar \term Object x;
        \schemaVar \term Field f;

        \assumes(dominatesSet(x, s) ==>)
        \find(elementOf(x, f, s))

        \sameUpdateLevel

        \replacewith(false)
        \heuristics(simplify)
    };

    \lemma
    dominatesNotEqual {
        \schemaVar \term Object x, y;

        \assumes(dominates(x, y) ==>)
        \find(x = y)

        \sameUpdateLevel

        \replacewith(false)

        \heuristics(simplify)
    };

    \lemma
    dominatesNotEqualLeft {
        \schemaVar \term Object x, y;

        \assumes(dominates(x, y) ==>)
        \find(y = x)

        \sameUpdateLevel

        \replacewith(false)

        \heuristics(simplify)
        \displayname "dominatesNotEqual"
    };

    \lemma
    undomRefl {
        \schemaVar \term Object x, y;

        \find(undom(x, y))

        \replacewith(undom(y, x))
    };

    \lemma
    dominatesDepthTransitive {
        \schemaVar \term Object x, y, z;
        \schemaVar \term int n1, n2;

        \assumes(dominatesDepth(x, y, n1) ==>)
        \find(dominatesDepth(y, z, n2) ==>)
        \add(dominatesDepth(x, z, n1 + n2) ==>)
    };

    \lemma
    dominatesDepth2Dominates {
        \schemaVar \term int n;
        \schemaVar \term Object x, y;

        \find(dominatesDepth(x, y, n) ==>)

        \add(n > 0 & dominates(x, y) ==>)
    };

    \lemma
    dominatesSameDepth {
        \schemaVar \term Object x, y, z;
        \schemaVar \term int n;
    
        \assumes(dominatesDepth(x, z, n) ==>)
        \find(dominatesDepth(y, z, n) ==>)
        \add(x = y ==>)
    };

    \lemma
    dominatesLargerDepth {
        \schemaVar \term Object x, y, z;
        \schemaVar \term int n, m;
    
        \assumes(m > n, dominatesDepth(x, z, n) ==>)
        \find(dominatesDepth(y, z, m) ==>)
        \add(dominatesDepth(y, x, m - n) ==>)
    };

    \lemma
    dominatesSingleDepth {
        \schemaVar \term Object x, y, z;
        \schemaVar \term int n;
        \schemaVar \variables int m;
    
        \find(dominatesDepth(x, y, n) ==>)
    
        \varcond(\notFreeIn(m, n, x, y))
        \add(\forall m; (dominatesDepth(x, y, m) -> m = n) ==>)
    };

    \lemma
    dominatesTransitive {
        \schemaVar \term Object x, y, z;
        \assumes(dominates(x, y) ==>)
        \find(dominates(y, z) ==>)
        \add(dominates(x, z) ==>)
        \heuristics(inReachableStateImplication)
    };

    \lemma
    dominatesSetAllLocs {
        \schemaVar \term Object o;

        \find(dominatesSet(o, allLocs))

        \replacewith(false)

        \heuristics(concrete)
    };

    \lemma
    dominatesSetEmpty {
        \schemaVar \term Object o;

        \find(dominatesSet(o, empty))

        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    closePeerDominate {
        \schemaVar \term Object x, y;

        \assumes(dominates(y, x) ==>)
        \find(dominates(x, y) ==>)
        \closegoal
        \heuristics(simplify)
    };

    \lemma
    dominatesAntisymm {
        \schemaVar \term Object x, y;
        \find(dominates(x, y) ==>)
        \add(==> x = y, dominates(y, x))
    };

    \lemma
    dominatesSetTransitive {
        \schemaVar \term Object x, y;
        \schemaVar \term LocSet s;
        \assumes(dominates(x, y) ==>)
        \find(dominatesSet(y, s) ==>)
        \add(dominatesSet(x, s) ==>)
        \heuristics(inReachableStateImplication)
    };

    \lemma
    dominatesSetUnion {
        \schemaVar \term LocSet s1, s2;
        \schemaVar \term Object o;

        \find(dominatesSet(o, union(s1, s2)))

        \replacewith(dominatesSet(o, s1) & dominatesSet(o, s2))
        \heuristics(simplify)
    };

    \lemma
    dominatesSetSubset {
        \schemaVar \term LocSet s1, s2;
        \schemaVar \term Object o;

        \assumes(subset(s2, s1) ==>)
        \find(dominatesSet(o, s1) ==>)

        \add(dominatesSet(o, s2) ==>)
        \heuristics(inReachableStateImplication)
    };

    \lemma
    owns2Dominates {
        \schemaVar \term Object x, y;

        \find(x = owner(y) ==>)

        \add(dominates(x, y) ==>)
        \heuristics(inReachableStateImplication)
    };

    \lemma
    owns2DominatesLeft {
        \schemaVar \term Object x, y;

        \find(owner(y) = x ==>)

        \add(dominates(x, y) ==>)
        \heuristics(inReachableStateImplication)
        \displayname "owns2Dominates"
    };

    \lemma
    ownsSelf {
        \schemaVar \term Object o;

        \find(o = owner(o))
        
        \replacewith(false)

        \heuristics(simplify)
    };


    \lemma
    closePeerOwn {
        \schemaVar \term Object x, y;

        \assumes(y = owner(x) ==>)
        \find(x = owner(y) ==>)
        \closegoal

        \heuristics(simplify)
    };

    \lemma
    dominatesSetDisjoint {
        \schemaVar \term Object o1, o2;
        \schemaVar \term LocSet s1, s2;

        \assumes(dominatesSet(o1, s1), dominatesSet(o2, s2) ==>)
        \find(undom(o1, o2) ==>)
        \add(disjoint(s1, s2) ==>)
        \heuristics(inReachableStateImplication)
    };

    \lemma
    sameLevelUndom {
        \schemaVar \term Object o, x, y;

        \assumes(o = owner(x), o = owner(y) ==>)
        \find(==> x = y)

        \add(undom(x, y) ==>)
        \heuristics(inReachableStateImplication)
    };

    \lemma
    domfpDepthEquivDominates {
        \schemaVar \term Object x;
        \schemaVar \term int n;
        \schemaVar \variables Object y;

        \find(domfpDepth(x, n))

        \varcond(\notFreeIn(y, x, n))
        
        \replacewith(infiniteUnion{y;}(\if(dominatesDepth(x, y, n)) \then(y.*) \else(empty)))
    };

    \lemma
    domfpFinalDepth {
        \schemaVar \term Object x;
        \schemaVar \variables int n, m;

        \find(x)

        \varcond(\notFreeIn(n, x), \notFreeIn(m, x))
        \add(\exists n; (n >= 0 & \forall m; (m >= n -> domfpDepth(x, m) = empty)) ==>)
    };

    \lemma
    domfpEqdomfpDepthUnion {
        \schemaVar \term Object x;
        \schemaVar \variables int n;

        \find(domfp(x))

        \varcond(\notFreeIn(n, x))
        \replacewith(infiniteUnion{n;}(domfpDepth(x, n)))
    };

    \lemma
    domfpEquivDominates {
        \schemaVar \term Object x;
        \schemaVar \variables Object y;

        \find(domfp(x))
        \varcond(\notFreeIn(y, x))
        \replacewith(infiniteUnion{y;}(\if(dominates(x, y)) \then(y.*) \else(empty)))
    };

    \lemma 
    domfpElement {
        \schemaVar \term Object x, y;
        \schemaVar \term Field f;

        \find(elementOf(x, f, domfp(y)))
        \replacewith(dominates(y, x))
        \heuristics(simplify)
    };

    \lemma 
    repfpElement {
        \schemaVar \term Object x, y;
        \schemaVar \term Field f;

        \find(elementOf(x, f, repfp(y)))
        \replacewith(dominates(y, x) | x = y)
        \heuristics(simplify)
    };

    \lemma 
    dominatesInverse {
        \schemaVar \term Object x, y;

        \assumes(dominates(x, y) ==>)

        \find(dominates(y, x))

        \sameUpdateLevel

        \replacewith(false)
        \heuristics(simplify)
    };

    //\lemma
    //selectOfDominatedAnon {
    //    \schemaVar \term Heap h, h2;
    //    \schemaVar \term LocSet s;
    //    \schemaVar \term Object o;
    //    \schemaVar \term Field f;
    //
    //    \find(beta::select(anon(h, s, h2), o, f))
    //
    //    \replacewith(beta::select(\if(dominatesSet(o, s) & !elementOf(o, f, freshLocs(h)))
    //            \then(h)
    //            \else(anon(h, s, h2)), o, f))
    //    \heuristics(semantics_blasting)
    //};
    //
    //\lemma
    //selectOfDominatedAnonEQ {
    //    \schemaVar \term Heap h, h2;
    //    \schemaVar \term LocSet s;
    //    \schemaVar \term Object o;
    //    \schemaVar \term Field f;
    //    \schemaVar \term Heap EQ;
    //
    //    \assumes(anon(h, s, h2) = EQ ==>)
    //    \find(beta::select(EQ, o, f))
    //    \sameUpdateLevel
    //
    //    \replacewith(beta::select(\if(dominatesSet(o, s) & !elementOf(o, f, freshLocs(h)))
    //            \then(h)
    //            \else(EQ), o, f))
    //    \heuristics(simplify_heap_high_costs)
    //};
    //
    //\lemma
    //selectOfDominatedStore {
    //    \schemaVar \term Heap h, h2;
    //    \schemaVar \term LocSet s;
    //    \schemaVar \term Object o, o2;
    //    \schemaVar \term Field f, f2;
    //    \schemaVar \term alpha x;
    //
    //    \find(beta::select(store(h, o, f, x), o2, f2))
    //    \sameUpdateLevel
    //
    //    \replacewith(beta::select(\if(dominates(o2, o) | dominates(o, o2))
    //            \then(h)
    //            \else(store(h, o, f, x)), o2, f2))
    //    \heuristics(semantics_blasting)
    //};
    //
    //\lemma
    //selectOfDominatedStoreEQ {
    //    \schemaVar \term Heap h, h2;
    //    \schemaVar \term LocSet s;
    //    \schemaVar \term Object o, o2;
    //    \schemaVar \term Field f, f2;
    //    \schemaVar \term Heap EQ;
    //    \schemaVar \term alpha x;
    //
    //    \assumes(store(h, o, f, x) = EQ ==>)
    //    \find(beta::select(EQ, o2, f2))
    //
    //    \sameUpdateLevel
    //
    //    \replacewith(beta::select(\if(dominates(o2, o) | dominates(o, o2))
    //            \then(h)
    //            \else(EQ), o2, f2))
    //    \heuristics(simplify_heap_high_costs)
    //};
}
