\schemaVariables {
    \term int left, right;
    \term int signedBitIndex; // E.g., 31 for Java ints, 63 for Java longs.
}

\rules {
    // wrappers for positive numbers to prevent shiftRightDef -> shiftLeftDef mutual recursion
    shiftRightPositiveShiftDef {
        \find(shiftrightPositiveShift(left, right))
        \replacewith(div(left, pow(2, right)))

        \heuristics(simplify)
    };

    shiftLeftPositiveShiftDef {
        \find(shiftleftPositiveShift(left, right))
        \replacewith(mul(left, pow(2, right)))

        \heuristics(simplify)
    };

    // arbitrary fixed length bitvector operations
    shiftRightDef {
        \find(shiftright(left, right))
        \replacewith(\if(right < 0)
                \then(shiftleftPositiveShift(left, -right))
                \else(shiftrightPositiveShift(left, right))
        )

        \heuristics(simplify_enlarging)
    };

    shiftLeftDef {
        \find(shiftleft(left, right))
        \replacewith(\if(right < 0)
                \then(shiftrightPositiveShift(left, -right))
                \else(shiftleftPositiveShift(left, right))
        )

        \heuristics(simplify_enlarging)
    };

    javaShiftRightIntDef {
        \find(shiftrightJint(left, right))
        // usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
        \replacewith(moduloInt(shiftright(left, mod(right, 32))))
        \heuristics(simplify_enlarging)
    };

    javaShiftRightLongDef {
        \find(shiftrightJlong(left, right))
        // usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
        \replacewith(moduloLong(shiftright(left, mod(right, 64))))

        \heuristics(simplify_enlarging)
    };

    javaShiftLeftIntDef {
        \find(shiftleftJint(left, right))
        // usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
        \replacewith(moduloInt(shiftleft(left, mod(right, 32))))
        \heuristics(simplify_enlarging)
    };

    javaShiftLeftLongDef {
        \find(shiftleftJlong(left, right))
        // usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
        \replacewith(moduloLong(shiftleft(left, mod(right, 64))))

        \heuristics(simplify_enlarging)
    };

    unsignedShiftRightJintDef {
        \find(unsignedshiftrightJint(left, right))
        \replacewith(\if(left >= 0) \then(shiftrightJint(left, right))
                \else(addJint(shiftrightJint(left, right), shiftleftJint(2, 31 - mod(right, 32)))))
        \heuristics(simplify_enlarging)
    };

    xorJIntDef {
        \find(xorJint(left, right))
        \replacewith(moduloInt(binaryXOr(left, right)))

        \heuristics(simplify)
    };

    orJIntDef {
        \find(orJint(left, right))
        \replacewith(moduloInt(binaryOr(left, right)))

        \heuristics(simplify)
    };

    andJIntDef {
        \find(andJint(left, right))
        \replacewith(moduloInt(binaryAnd(left, right)))

        \heuristics(simplify)
    };

    // Definitions for binaryAnd, binaryOr, and binaryXOr. Each function has
    // three definitions: One for Java ints (32-bit), one for Java longs
    // (64-bit), and one general one based on a user-specified sign-bit index.

    bitAtDef {
        \schemaVar \term int number, index;
        \find(bitAt(number, index))
        \replacewith(\if(0 <= index)
                \then(mod(div(number, pow(2, index)), 2))
                \else(0))
        \heuristics(simplify)
    };

    binaryAndDef {
        \find(binaryAnd(left, right))
        \replacewith(
            bsum{int i;}(0, signedBitIndex, pow(2, i) * bitAt(left, i) * bitAt(right, i))
            - \if(left < 0 & right < 0)
                \then(pow(2, signedBitIndex))
                \else(0));
        \add( ==> left >= -pow(2, signedBitIndex) & left < pow(2, signedBitIndex)
            & right >= -pow(2, signedBitIndex) & right < pow(2, signedBitIndex))
    };

    binaryAndIntDef {
        \find(binaryAnd(left, right))
        \replacewith(
            bsum{int i;}(0, 31, pow(2, i) * bitAt(left, i) * bitAt(right, i))
            - \if(left < 0 & right < 0)
                \then(pow(2, 31))
                \else(0));
        \add( ==> inRangeInt(left), inRangeInt(right))
    };

    binaryAndLongDef {
        \find(binaryAnd(left, right))
        \replacewith(
            bsum{int i;}(0, 63, pow(2, i) * bitAt(left, i) * bitAt(right, i))
            - \if(left < 0 & right < 0)
                \then(pow(2, 63))
                \else(0));
        \add( ==> inRangeLong(left), inRangeLong(right))
    };

    binaryOrDef {
        \find(binaryOr(left, right))
        \replacewith(
            bsum{int i;}(0, signedBitIndex,
                pow(2, i) * (bitAt(left, i) + bitAt(right, i)
                    - (bitAt(left, i) * bitAt(right, i))))
            - \if(left < 0 | right < 0)
                \then(pow(2, signedBitIndex))
                \else(0));
        \add( ==> left >= -pow(2, signedBitIndex) & left < pow(2, signedBitIndex)
            & right >= -pow(2, signedBitIndex) & right < pow(2, signedBitIndex))
    };

    binaryOrIntDef {
        \find(binaryOr(left, right))
        \replacewith(
            bsum{int i;}(0, 31,
                pow(2, i) * (bitAt(left, i) + bitAt(right, i)
                    - (bitAt(left, i) * bitAt(right, i))))
            - \if(left < 0 | right < 0)
                \then(pow(2, 31))
                \else(0));
        \add( ==> inRangeInt(left), inRangeInt(right))
    };

    binaryOrLongDef {
        \find(binaryOr(left, right))
        \replacewith(
            bsum{int i;}(0, 63,
                pow(2, i) * (bitAt(left, i) + bitAt(right, i)
                    - (bitAt(left, i) * bitAt(right, i))))
            - \if(left < 0 | right < 0)
                \then(pow(2, 63))
                \else(0));
        \add( ==> inRangeLong(left), inRangeLong(right))
    };

    binaryXOrDef {
        \find(binaryXOr(left, right))
        \replacewith(
            bsum{int i;}(0, signedBitIndex,
                pow(2, i) * mod(bitAt(left, i) + bitAt(right, i), 2))
            - \if(!(left < 0 <-> right < 0))
                \then(pow(2, signedBitIndex))
                \else(0));
        \add( ==> left >= -pow(2, signedBitIndex) & left < pow(2, signedBitIndex)
            & right >= -pow(2, signedBitIndex) & right < pow(2, signedBitIndex))
    };

    binaryXOrIntDef {
        \find(binaryXOr(left, right))
        \replacewith(
            bsum{int i;}(0, 31,
                pow(2, i) * mod(bitAt(left, i) + bitAt(right, i), 2))
            - \if(!(left < 0 <-> right < 0))
                \then(pow(2, 31))
                \else(0));
        \add( ==> inRangeInt(left), inRangeInt(right))
    };

    binaryXOrLongDef {
        \find(binaryXOr(left, right))
        \replacewith(
            bsum{int i;}(0, 63,
                pow(2, i) * mod(bitAt(left, i) + bitAt(right, i), 2))
            - \if(!(left < 0 <-> right < 0))
                \then(pow(2, 63))
                \else(0));
        \add( ==> inRangeLong(left), inRangeLong(right))
    };
}
