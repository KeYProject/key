\rules {
   // wrappers for positive numbers to prevent shiftRightDef -> shiftLeftDef mutual recursion
   shiftRightPositiveShiftDef {
    \schemaVar \term int left, right;

   	\find ( shiftrightPositiveShift(left, right) )
   	\replacewith ( div (left, pow(2, right) ) )

   	 \heuristics (simplify)
   };

   shiftLeftPositiveShiftDef {
    \schemaVar \term int left, right;

   	\find ( shiftleftPositiveShift(left, right) )
   	\replacewith ( mul (left, pow(2, right) ) )

   	 \heuristics (simplify)
   };

   // arbitrary fixed length bitvector operations
   shiftRightDef {
   	\schemaVar \term int left, right;

	\find ( shiftright(left, right) )
	\replacewith ( \if ( right < 0 )
		       \then ( shiftleftPositiveShift(left, -right) )
		       \else ( shiftrightPositiveShift(left, right) )
     )

	 \heuristics (simplify_enlarging)
   };

   shiftLeftDef {
   	\schemaVar \term int left, right;

	\find ( shiftleft(left, right) )
	\replacewith ( \if ( right < 0 )
		       \then ( shiftrightPositiveShift(left, -right) )
		       \else ( shiftleftPositiveShift(left, right) )
     )

	 \heuristics (simplify_enlarging)
   };


	javaShiftRightIntDef {
	   	\schemaVar \term int left, right;

		\find ( shiftrightJint(left, right) )
		// usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
		\replacewith ( moduloInt(shiftright(left, mod(right,32) ) ) )
	    \heuristics (simplify_enlarging)
	};

	javaShiftRightIntConstantDef {
       \schemaVar \term int left;
       \schemaVar \term numbers iz;

       \find ( shiftrightJint(left, Z(iz)) )
       // usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
       // expand mod axiom here to prevent other rules happening before this constant is calculated
       \replacewith ( moduloInt(shiftright(left, Z(iz) + (Z(iz)/32)*(-1)*32 ) ) )
       \heuristics (simplify_enlarging)
   };

	javaShiftRightLongDef {
	   	\schemaVar \term int left, right;

		\find ( shiftrightJlong(left, right) )
		// usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
		\replacewith ( moduloLong(shiftright(left, mod(right, 64) ) ) )

	    \heuristics (simplify_enlarging)
	};

	javaShiftRightLongConstantDef {
	   	\schemaVar \term int left;
	   	\schemaVar \term numbers iz;

		\find ( shiftrightJlong(left, Z(iz)) )
		// usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
		// expand mod axiom here to prevent other rules happening before this constant is calculated
		\replacewith ( moduloLong(shiftright(left, Z(iz) + (Z(iz)/64)*(-1)*64 ) ) )

	    \heuristics (simplify_enlarging)
	};

	javaShiftLeftIntDef {
	   	\schemaVar \term int left, right;

		\find ( shiftleftJint(left, right) )
		// usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
		\replacewith ( moduloInt(shiftleft(left, mod(right,32) ) ) )
	    \heuristics (simplify_enlarging)
	};

	javaShiftLeftIntConstantDef {
        \schemaVar \term int left;
        \schemaVar \term numbers iz;

        \find ( shiftleftJint(left, Z(iz)) )
        // usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
        // expand mod axiom here to prevent other rules happening before this constant is calculated
        \replacewith ( moduloInt(shiftleft(left, Z(iz) + (Z(iz)/32)*(-1)*32 ) ) )
        \heuristics (simplify_enlarging)
    };

	javaShiftLeftLongDef {
	   	\schemaVar \term int left, right;

		\find ( shiftleftJlong(left, right) )
		// usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
		\replacewith ( moduloLong(shiftleft(left, mod(right, 64) ) ) )

	    \heuristics (simplify_enlarging)
	};

	javaShiftLeftLongDef {
	   	\schemaVar \term int left;
	   	\schemaVar \term numbers iz;

		\find ( shiftleftJlong(left, Z(iz)) )
		// usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
		// expand mod axiom here to prevent other rules happening before this constant is calculated
		\replacewith ( moduloLong(shiftleft(left, Z(iz) + (Z(iz)/64)*(-1)*64 ) ) )

	    \heuristics (simplify_enlarging)
	};


   unsignedShiftRightJintDef {
   	 \schemaVar \term int left, right;
	 \find ( unsignedshiftrightJint(left, right) )
	 \replacewith ( \if (left >= 0) \then (shiftrightJint(left, right))
	 			    \else (addJint(shiftrightJint(left, right), shiftleftJint(2,31-mod(right, 32))) ))
	 \heuristics (simplify_enlarging)
   };


   xorJIntDef {
   	 \schemaVar \term int left, right;

   	 \find ( xorJint(left, right) )
   	 \replacewith ( moduloInt( binaryXOr(left,right) ) )

     \heuristics(simplify)
   };

   orJIntDef {
   	 \schemaVar \term int left, right;

   	 \find ( orJint(left, right) )
   	 \replacewith ( moduloInt( binaryOr(left,right) ) )

     \heuristics(simplify)
   };


   andJIntDef {
   	 \schemaVar \term int left, right;
   	 \find ( andJint(left, right) )
   	 \replacewith ( moduloInt( binaryAnd(left, right) ) )

     \heuristics(simplify)
   };

}
