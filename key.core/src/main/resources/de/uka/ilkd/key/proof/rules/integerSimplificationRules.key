/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    Integer simplification rules.

    See intRules.key for an overview of the integer files.
*/

\schemaVariables {

    \term int i, i0, i1, i2, i3, i4, j, j0, j1, t, t1, t2;
    \term [rigid] int ir, i0r;
    \variables int k, j2, c, nv;
    \skolemTerm int sk, sk2;

    \term numbers iz, jz;
    \formula b, psi, phi, post, inv;

    \term int commLeft, commRight;
    \term int distSummand0, distSummand1, distCoeff;
    \term int invertLeft, invertRight;
    \term int pullOutCommon, pullOutLeft, pullOutRight;
    \term int homoLeft, homoRight;
    \term int addAssocMono, addAssocPoly0, addAssocPoly1;
    \term int mulAssocAtom, mulAssocMono0, mulAssocMono1;
    \term int applyEqDividend, applyEqDivisor;
    \term [rigid] int applyEqDivisorr;
    \term int cpLeft1, cpLeft2, cpRight1, cpRight2;
    \term int esLeft, esRight1, esRight2, esCoeff1, esCoeff2;
    \term int sepPosMono, sepNegMono, sepResidue;
    \term int multLeft, multRight, multFac;
    \term int multFacLeft, multFacRight;
    \term int divX, divXBoundPos, divXBoundNonPos, divXBoundNeg, divXBoundNonNeg;
    \term int divY;
    \term int divProd, divProdBoundPos, divProdBoundNonPos;
    \term int divProdBoundNeg, divProdBoundNonNeg;
    \term int squareFac;
    \term int subsumLeft, subsumRightBigger, subsumRightSmaller,
    subsumCoeffBigger, subsumCoeffSmaller;
    \term int contradLeft, contradRightBigger, contradRightSmaller,
    contradCoeffBigger, contradCoeffSmaller;
    \term int strengthenLeft, strengthenRight;
    \term int splitEqLeft, splitEqRight;
    \term int signCasesLeft;
    \term int elimGcdLeft, elimGcdRight, elimGcd;

    \term int elimGcdLeftDiv, elimGcdRightDiv;
    \term int divNum, divDenom, polyDivCoeff;
    \term int modNumLeft, modNumRight, modDenom;
    \term int newSymLeft, newSymLeftCoeff, newSymRight, newSymDef;
    \skolemTerm int l, quotient;
    \term int applyEqLeft, applyEqRight, applyEqOther;
    \term int tautLeft, tautRightBigger, tautRightSmaller;
    \term int weakenLeft, weakenRightSmaller, weakenRightBigger;
    \term int antiSymmLeft, antiSymmRightSmaller, antiSymmRightBigger;
    \term int aePseudoLeft, aePseudoLeftCoeff, aePseudoRight;
    \term int aePseudoTargetLeft, aePseudoTargetRight, aePseudoTargetFactor;

    // attention strategy depends on this var.name
    \term int castedTerm;

    \variables int uSub, uSub1, uSub2;
    \term int tInt;
}

\rules {

    // --------------------------------------------------------------------
    // some of these taclets are from Isabelle theory IntArith
    // --------------------------------------------------------------------

    // reviewed 04/16/2004, St.S.
    less_iff_diff_less_0 {
        \find(lt(i0, i1))
        \replacewith(lt(sub(i0, i1), 0))
    };

    // reviewed 04/16/2004, St.S.
    leq_iff_diff_leq_0 {
        \find(leq(i0, i1))
        \replacewith(leq(sub(i0, i1), 0))
    };

    // reviewed 04/16/2004, St.S.
    minus_distribute_1 {
        \find(neg(add(i, i1)))
        \replacewith(add(neg(i), neg(i1)))
        \heuristics(simplify_int)
        \displayname "minus_distribute"
    };
    // reviewed 04/16/2004, St.S.
    minus_distribute_2 {
        \find(neg(sub(i, i1)))
        \replacewith(add(neg(i), i1))
        \heuristics(simplify_int)
        \displayname "minus_distribute"
    };

    // reviewed 04/16/2004, St.S.
    left_add_mult_distrib {
        \find(add(mul(i0, i1), add(mul(i2, i1), i3)))
        \replacewith(add(mul(add(i0, i2), i1), i3))
    };

    // reviewed 04/16/2004, St.S.
    eq_add_iff1 {
        \find(add(mul(i0, i1), i2) = add(mul(i3, i1), i4))
        \replacewith(add(mul(sub(i0, i3), i1), i2) = i4)
    };

    // reviewed 04/16/2004, St.S.
    eq_add_iff2 {
        \find(add(mul(i0, i1), i2) = add(mul(i3, i1), i4))
        \replacewith(i2 = add(mul(sub(i3, i0), i1), i4))
    };

    // reviewed 04/16/2004, St.S.
    less_add_iff1 {
        \find(lt(add(mul(i0, i1), i2), add(mul(i3, i1), i4)))
        \replacewith(lt(add(mul(sub(i0, i3), i1), i2), i4))
    };

    // reviewed 04/16/2004, St.S.
    less_add_iff2 {
        \find(lt(add(mul(i0, i1), i2), add(mul(i3, i1), i4)))
        \replacewith(lt(i2, add(mul(sub(i3, i0), i1), i4)))
    };

    // reviewed 04/16/2004, St.S.
    leq_add_iff1 {
        \find(leq(add(mul(i0, i1), i2), add(mul(i3, i1), i4)))
        \replacewith(leq(add(mul(sub(i0, i3), i1), i2), i4))
    };

    // reviewed 04/16/2004, St.S.
    leq_add_iff2 {
        \find(leq(add(mul(i0, i1), i2), add(mul(i3, i1), i4)))
        \replacewith(leq(i2, add(mul(sub(i3, i0), i1), i4)))
    };

    // reviewed 04/16/2004, St.S.
    leq_diff1_eq {
        \find(leq(i0, sub(i1, 1)))
        \replacewith(lt(i0, i1))
        \heuristics(simplify_int)
    };

    // reviewed 04/16/2004, St.S.
    le1_add1_eq_le {
        \find(lt(i0, add(i1, 1)))
        \replacewith(leq(i0, i1))
        \heuristics(simplify_int)
    };

    // reviewed 04/16/2004, St.S.
    zadd_left_cancel0 {
        \find(i0 = add(i0, i1))
        \replacewith(i1 = 0)
    };

    // reviewed 04/16/2004, St.S.
    int_diff_minus_eq {
        \find(sub(i0, neg(i1)))
        \replacewith(add(i0, i1))
    };

    // reviewed 04/16/2004, St.S.
    mult_pos {
        \find(lt(0, i0) & lt(0, i1))
        \replacewith(lt(0, mul(i0, i1)))
    };

    // reviewed 04/16/2004, St.S.
    mult_neg {
        \find(lt(i0, 0) & lt(i1, 0))
        \replacewith(lt(0, mul(i0, i1)))
    };

    // reviewed 04/16/2004, St.S.
    mult_pos_neg {
        \find(lt(i0, 0) & lt(0, i1))
        \replacewith(lt(mul(i0, i1), 0))
    };

    // reviewed 04/16/2004, St.S.
    zero_less_mult_iff {
        \find(lt(0, mul(i0, i1)))
        \replacewith(lt(0, i0) & lt(0, i1) | lt(i0, 0) & lt(i1, 0))
    };

    // reviewed 04/16/2004, St.S.
    zero_leq_mult_iff {
        \find(leq(0, mul(i0, i1)))
        \replacewith(leq(0, i0) & leq(0, i1) | leq(i0, 0) & leq(i1, 0))
    };

    // reviewed 04/16/2004, St.S.
    mult_less_0_iff {
        \find(lt(mul(i0, i1), 0))
        \replacewith(lt(i0, 0) & lt(0, i1) | lt(0, i0) & lt(i1, 0))
    };

    // reviewed 04/16/2004, St.S.
    mult_leq_0_iff {
        \find(leq(mul(i0, i1), 0))
        \replacewith(leq(i0, 0) & leq(0, i1) | leq(0, i0) & leq(i1, 0))
    };

    // reviewed 04/16/2004, St.S.
    square_nonneg {
        \find(leq(0, mul(i0, i0)))
        \replacewith(true) \heuristics(simplify_int)
    };

    // reviewed 04/16/2004, St.S.
    mult_eq_self_iff {
        \find(i0 = mul(i0, i1))
        \replacewith(i0 = 0 | i1 = 1)
    };

    // reviewed 04/16/2004, St.S.
    less_1_mult {
        \find(lt(1, i0) & lt(1, i1))
        \replacewith(lt(1, mul(i0, i1)))
    };

    // reviewed 04/16/2004, St.S.
    pos_mult_eq_1_iff {
        \find(lt(0, i0) -> mul(i0, i1) = 1)
        \replacewith(i0 = 1 & i1 = 1)
    };

    // reviewed 04/16/2004, St.S.
    mult_eq_1_iff {
        \find(mul(i0, i1) = 1)
        \replacewith(i0 = 1 & i1 = 1 | i0 = Z(neglit(1(#))) & i1 = Z(neglit(1(#))))
    };

    // reviewed 04/16/2004, St.S.
    multiply_distribute_1 {
        \find(mul(add(i0, i1), add(j0, j1)))
        \replacewith
        (add(add(mul(i0, j0), mul(i0, j1)), add(mul(i1, j0), mul(i1, j1))))
        \displayname "multiply_distribute"
    };

    // reviewed 04/16/2004, St.S.
    multiply_distribute_2 {
        \find(mul(add(i0, i1), sub(j0, j1)))
        \replacewith
        (add(sub(mul(i0, j0), mul(i0, j1)), sub(mul(i1, j0), mul(i1, j1))))
        \displayname "multiply_distribute"
    };

    // reviewed 04/16/2004, St.S.
    multiply_distribute_3 {
        \find(mul(sub(i0, i1), sub(j0, j1)))
        \replacewith
        (add(sub(mul(i0, j0), mul(i0, j1)), sub(mul(i1, j1), mul(i1, j0))))
        \displayname "multiply_distribute"
    };

    // reviewed 12/21/2004, St.S.
    mul_distribute_4 {
        \find(mul(i0, add(i1, i2)))
        \replacewith(add(mul(i0, i1), mul(i0, i2)))
        \displayname "multiply_distribute"
    };

    // reviewed 12/21/2004, St.S.
    mul_distribute_5 {
        \find(mul(add(i1, i2), i0))
        \replacewith(add(mul(i0, i1), mul(i0, i2)))
        \displayname "multiply_distribute"
    };

    // reviewed 12/21/2004, St.S.
    theorem_of_archimedes {
        \assumes(gt(i0, sub(i1, 1)) ==>)
        \find(lt(i0, i1) ==>)
        \replacewith(false ==>)
    };

    // reviewed 04/16/2004, St.S.
    collect_same_terms_1 {
        \find(add(mul(i, j), mul(i, j)))
        \replacewith(mul(2, mul(i, j)))
        \displayname "collect_same_terms"
    };

    // reviewed 04/16/2004, St.S.
    collect_same_terms_2 {
        \find(add(add(mul(i, j), mul(i0, i1)), add(mul(i, j), mul(j0, j1))))
        \replacewith(add(mul(2, mul(i, j)), add(mul(i0, i1), mul(j0, j1))))
        \displayname "collect_same_terms"
    };

    // reviewed 04/16/2004, St.S.
    collect_same_terms_3 {
        \find(add(add(neg(mul(i, j)), mul(i0, i1)), add(neg(mul(i, j)), mul(j0, j1))))
        \replacewith(add(neg(mul(2, mul(i, j))), add(mul(i0, i1), mul(j0, j1))))
        \displayname "collect_same_terms"
    };

    // reviewed 04/16/2004, St.S.
    addition_associative {
        \find(add(add(i0, i1), add(j0, j1)))
        \replacewith(add(add(j0, i1), add(i0, j1)))
    };

    // reviewed 04/16/2004, St.S.
    leq_add_one {
        \find(leq(i0, i1))
        \replacewith(leq(add(i0, 1), add(i1, 1)))
    };

    // reviewed 04/16/2004, St.S.
    less_add_one {
        \find(lt(i0, i1))
        \replacewith(lt(add(i0, 1), add(i1, 1)))
    };

    // reviewed 04/16/2004, St.S.
    geq_add_one {
        \find(geq(i0, i1))
        \replacewith(geq(add(i0, 1), add(i1, 1)))
    };

    // reviewed 04/16/2004, St.S.
    greater_add_one {
        \find(gt(i0, i1))
        \replacewith(gt(add(i0, 1), add(i1, 1)))
    };
    // reviewed 04/16/2004, St.S.
    equal_add_one {
        \find(i0 = i1)
        \replacewith(add(i0, 1) = add(i1, 1))
    };

    // reviewed 04/16/2004, St.S.
    leq_add {
        \find( ==> leq(i0, i1))
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; leq(add(i0, j2), add(i1, j2)))
    };

    // reviewed 04/16/2004, St.S.
    less_add {
        \find( ==> lt(i0, i1))
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; lt(add(i0, j2), add(i1, j2)))
    };

    // reviewed 04/16/2004, St.S.
    geq_add {
        \find( ==> geq(i0, i1))
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; geq(add(i0, j2), add(i1, j2)))
    };

    // reviewed 04/16/2004, St.S.
    greater_add {
        \find( ==> gt(i0, i1))
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; gt(add(i0, j2), add(i1, j2)))
    };

    // reviewed 04/16/2004, St.S.
    equal_add {
        \find( ==> i0 = i1)
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; add(i0, j2) = add(i1, j2))
    };

    // reviewed 04/16/2004, St.S.
    leq_diff_1 {
        \find(leq(i0, add(i0, 1)))
        \replacewith(true)
        \heuristics(int_arithmetic)
    };

    // reviewed 04/16/2004, St.S.
    lt_diff_1 {
        \find(lt(i0, add(i0, 1)))
        \replacewith(true)
        \heuristics(int_arithmetic)
    };

    // reviewed 04/16/2004, St.S.
    geq_diff_1 {
        \find(geq(add(i0, 1), i0))
        \replacewith(true)
        \heuristics(int_arithmetic)
    };

    // reviewed 04/16/2004, St.S.
    gt_diff_1 {
        \find(gt(add(i0, 1), i0))
        \replacewith(true)
        \heuristics(int_arithmetic)
    };

    // reviewed 04/16/2004, St.S.
    i_minus_i_is_zero {
        \find(sub(i, i))
        \replacewith(0) \heuristics(simplify_int)
    };

    // reviewed 04/16/2004, St.S.
    add_two_inequations_1 {
        \assumes(lt(i, i0) ==>)
        \find(lt(j, j0) ==>)
        \add(lt(add(i, j), add(i0, j0)) ==>)
    };
    // reviewed 04/16/2004, St.S.
    add_two_inequations_2 {
        \assumes(leq(i, i0) ==>)
        \find(leq(j, j0) ==>)
        \add(leq(add(i, j), add(i0, j0)) ==>)
    };

    // reviewed 04/16/2004, St.S.
    partition_inequation {
        \assumes( ==> lt(i, i0))
        \find(lt(i, i1) ==>)
        \add( ==> lt(i1, i0))
    };

    // reviewed 04/16/2004, St.S.
    eq_sides {
        \find(i = j)
        \replacewith(sub(i, j) = 0)
    };

    // reviewed 04/15/2004, St.S.
    times_one_1 {
        \find(mul(i, 1))
        \replacewith(i)
        \heuristics(simplify_int)
        \displayname "times_one"
    };
    // reviewed 04/15/2004, St.S.
    times_one_2 {
        \find(mul(1, i))
        \replacewith(i)
        \heuristics(simplify_int)
        \displayname "times_one"
    };
    // reviewed 04/15/2004, St.S.
    times_minus_one_1 {
        \find(mul(i, -1))
        \replacewith(neg(i))
        \heuristics(simplify_int)
        \displayname "times_minus_one"
    };
    // reviewed 04/15/2004, St.S.
    times_minus_one_2 {
        \find(mul(-1, i))
        \replacewith(neg(i))
        \heuristics(simplify_int)
        \displayname "times_minus_one"
    };
    // reviewed 04/15/2004, St.S.
    times_zero_1 {
        \find(mul(i, 0))
        \replacewith(0)
        \heuristics(simplify_literals)
        \displayname "times_zero"
    };
    // reviewed 04/15/2004, St.S.
    times_zero_2 {
        \find(mul(0, i))
        \replacewith(0) \heuristics(simplify_literals)
        \displayname "times_zero"
    };

    // reviewed 04/15/2004, St.S.
    leq_to_gt {
        \find(leq(i, j))
        \replacewith(!gt(i, j))
    };

    // reviewed 04/15/2004, St.S.
    geq_to_lt {
        \find(geq(i, j))
        \replacewith(!lt(i, j))
    };

    // reviewed 04/15/2004, St.S.
    leq_to_gt_alt {
        \find(leq(i, j))
        \replacewith(lt(i, j) | i = j)
    };

    // reviewed 04/15/2004, St.S.
    geq_to_lt_alt {
        \find(geq(i, j))
        \replacewith(gt(i, j) | i = j)
    };

    // reviewed 04/15/2004, St.S.
    greater {
        \find(gt(i, i0))
        \replacewith(lt(i0, i))
    };

    // reviewed 04/15/2004, St.S.
    less_is_total_heu {
        \assumes( ==> lt(i, i0), (i = i0), lt(i0, i)) \closegoal
    };
    // reviewed 04/15/2004, St.S.
    less_is_total {
        \find(i)
        \sameUpdateLevel
        \add(lt(i, i0) ==>);
        \add((i = i0) ==>);
        \add(lt(i0, i) ==>)
    };
    // reviewed 04/15/2004, St.S.
    less_zero_is_total {
        \find(i)
        \sameUpdateLevel
        \add(lt(i, 0) ==>);
        \add(i = 0 ==>);
        \add(lt(0, i) ==>)
    };

    // reviewed 04/15/2004, St.S.
    less_is_alternative_1 {
        \assumes(lt(i, i0), lt(i0, i) ==>) \closegoal
    };
    // reviewed 04/15/2004, St.S.
    less_is_alternative_2 {
        \assumes( ==> lt(i, i0))
        \find( ==> lt(i0, i))
        \add((i = i0) ==>)
    };

    // reviewed 04/15/2004, St.S.
    less_trans {
        \assumes(lt(i, i0) ==>)
        \find(lt(i0, i1) ==>)
        \add(lt(i, i1) ==>)
    };
    // reviewed 04/15/2004, St.S.
    leq_trans {
        \assumes(leq(i, i0) ==>)
        \find(leq(i0, i1) ==>)
        \add(leq(i, i1) ==>)
    };

    // reviewed 04/15/2004, St.S.
    less_neg {
        \find(lt(i, i0))
        \replacewith(!(lt(i0, i + 1)))
    };

    // reviewed 04/15/2004, St.S.
    less_base {
        \find(lt(i, i))
        \replacewith(false) \heuristics(simplify_int)
    };

    // reviewed 04/15/2004, St.S.
    add_zero_left {
        \find(add(0, i))
        \replacewith(i) \heuristics(simplify_literals)
    };
    // reviewed 04/15/2004, St.S.
    add_zero_right {
        \find(add(i, 0))
        \replacewith(i) \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    switch_brackets {
        \find(add(add(i, i0), i1))
        \replacewith(add(i, add(i0, i1)))
    };
    // reviewed 04/15/2004, St.S.
    switch_params {
        \find(add(i0, i1))
        \replacewith(add(i1, i0))
    };

    // reviewed 04/15/2004, St.S.
    mul_assoc {
        \find(mul(mul(i, i0), i1))
        \replacewith(mul(i, mul(i0, i1)))
    };
    // reviewed 04/15/2004, St.S.
    mul_comm {
        \find(mul(i0, i1))
        \replacewith(mul(i1, i0))
    };

    // reviewed 04/15/2004, St.S.
    pull_out_neg_1 {
        \find(mul(neg(i0), i1))
        \replacewith(neg(mul(i0, i1)))
        \displayname "pull_out_minus"
    };
    // reviewed 04/15/2004, St.S.
    pull_out_neg_2 {
        \find(mul(i0, neg(i1)))
        \replacewith(neg(mul(i0, i1)))
        \displayname "pull_out_minus"
    };

    // reviewed 04/15/2004, St.S.
    rotate_params {
        \find(add(i, add(i0, i1)))
        \replacewith(add(i0, add(i, i1)))
    };

    // TODO: review;  added 04/19/05 RB
    add_equations {
        \assumes(i = i0 ==>)
        \find(j = j0 ==>)
        \add(add(i, j) = add(i0, j0) ==>)
    };
    add_equations_right {
        \assumes(i = i0 ==>)
        \find( ==> j = j0)
        \add( ==> add(i, j) = add(i0, j0))
    };

    sub_equations_left {
        \assumes(i = i0 ==>)
        \find(j = j0 ==>)
        \add(sub(j, i) = sub(j0, i0) ==>)
    };
    sub_equations_right {
        \assumes(i = i0 ==>)
        \find( ==> j = j0)
        \add( ==> sub(j, i) = sub(j0, i0))
    };

    // reviewed 04/15/2004, St.S.
    add_eq {
        \find(i0 = i1)
        \replacewith(add(i, i0) = add(i, i1))
    };

    // reviewed 04/15/2004, St.S.
    add_eq_back {
        \find(add(i1, i) = add(i1, i0))
        \replacewith(i = i0)
        \heuristics(simplify_int)
    };

    // new, not reviewed but proven: see ../proof/rules/proven_rules/add_eq_back_2.proof
    add_eq_back_2 {
        \find(add(i, i1) = add(i0, i1))
        \replacewith(i = i0)
        \heuristics(simplify_int)
        \displayname "add_eq_back"
    };

    // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_eq_back_2_fst_comm.proof
    add_eq_back_2_fst_comm {
        \find(add(i1, i) = add(i0, i1))
        \replacewith(i = i0)
        \heuristics(simplify_int)
        \displayname "add_eq_back"
    };

    // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_eq_back_3.proof
    add_eq_back_3 {
        \find(i1 = add(i1, i0))
        \replacewith(0 = i0)
        \heuristics(simplify_int)
        \displayname "add_eq_back"
    };

    // reviewed 04/15/2004, St.S.
    add_less {
        \find(lt(i, i0))
        \replacewith(lt(add(i1, i), add(i1, i0)))
    };

    // added 08/02/2019 PHS
    add_greater {
        \find(gt(i, i0))
        \replacewith(gt(add(i1, i), add(i1, i0)))
    };

    // added 08/02/2019 PHS
    add_lesseq {
        \find(leq(i, i0))
        \replacewith(leq(add(i1, i), add(i1, i0)))
    };

    // added 08/02/2019 PHS
    add_greatereq {
        \find(geq(i, i0))
        \replacewith(geq(add(i1, i), add(i1, i0)))
    };

    // reviewed 04/15/2004, St.S.
    add_less_back {
        \find(lt(add(i1, i), add(i1, i0)))
        \replacewith(lt(i, i0))
        \heuristics(simplify_int)
    };

    // reviewed 04/15/2004, St.S.
    add_less_back_zero_1 {
        \find(lt(i, add(i, i1)))
        \replacewith(lt(0, i1))
        \heuristics(simplify_int)
        \displayname "add_less_back"
    };

    // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_less_back_zero_1_comm.proof
    add_less_back_zero_1_comm {
        \find(lt(i, add(i1, i)))
        \replacewith(lt(0, i1))
        \heuristics(simplify_int)
        \displayname "add_less_back"
    };

    // reviewed 04/15/2004, St.S.
    add_less_back_zero_2 {
        \find(lt(add(i, i1), i))
        \replacewith(lt(i1, 0))
        \heuristics(simplify_int)
        \displayname "add_less_back"
    };

    // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_less_back_zero_2_comm.proof
    add_less_back_zero_2_comm {
        \find(lt(add(i1, i), i))
        \replacewith(lt(i1, 0))
        \heuristics(simplify_int)
        \displayname "add_less_back"
    };

    // reviewed 04/15/2004, St.S.
    sub {
        \find(sub(i, i0))
        \replacewith(add(i, neg(i0))) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    sub_zero_1 {
        \find(Z(neglit(0(#))))
        \replacewith(Z(0(#)))
        \heuristics(simplify_literals)
    };
    // reviewed 04/15/2004, St.S.
    sub_zero_2 {
        \find(sub(i, 0))
        \replacewith(i) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    add_sub_elim_left {
        \find(add(neg(i), i))
        \replacewith(0) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    add_sub_elim_right {
        \find(add(i, neg(i)))
        \replacewith(0) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    add_sub_step {
        \find(add(neg(i), neg(i0)))
        \replacewith(neg(add(i, i0)))
    };
    // reviewed 04/15/2004, St.S.
    sub_sub_elim {
        \find(neg(neg(i)))
        \replacewith(i) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    less_sub {
        \find(lt(i, i0))
        \replacewith(lt(neg(i0), neg(i)))
    };

    // reviewed 04/15/2004, St.S.
    less_plus {
        \find(lt(0, add(i0, i1)))
        \replacewith(lt(neg(i0), i1))
    };

    // reviewed 04/15/2004, St.S.
    close_by_lt_leq {
        \assumes(lt(i, j) ==>)
        \find( ==> leq(add(i, 1), j))
        \replacewith( ==> true)
    };

    // reviewed 04/15/2004, St.S.
    lt_to_leq_1 {
        \find(lt(i, j) | i = j)
        \replacewith(leq(i, j)) \heuristics(simplify_int)
    };

    // reviewed 04/15/2004, St.S.
    lt_to_leq_2 {
        \assumes( ==> lt(i, j))
        \find( ==> i = j)
        \replacewith( ==> leq(i, j))
        \heuristics(simplify_int)
    };

    // reviewed 04/15/2004, St.S.
    lt_to_gt {
        \find(lt(i, i0))
        \replacewith(gt(i0, i))
    };
    // reviewed 04/15/2004, St.S.
    gt_to_lt {
        \find(gt(i, i0))
        \replacewith(lt(i0, i))
    };
    // reviewed 04/15/2004, St.S.
    leq_to_geq {
        \find(leq(i, i0))
        \replacewith(geq(i0, i))
    };
    // reviewed 04/15/2004, St.S.
    geq_to_leq {
        \find(geq(i, i0))
        \replacewith(leq(i0, i))
    };

    // -------------------------------------------------------
    // ------------- Rules for integer literals --------------
    // -------------------------------------------------------

    // reviewed 04/20/2004, St.S.
    double_unary_minus_literal {
        \find(Z(neglit(neglit(iz))))
        \replacewith(Z(iz))
        \heuristics(simplify_literals)
        \displayname "double_unary_minus"
    };

    // reviewed 04/16/2004, St.S.
    charLiteral_to_int {
        \find(C(iz))
        \replacewith(Z(iz)) \heuristics(charLiteral_to_intLiteral)
    };

    // reviewed 04/15/2004, St.S.
    add_literals {
        \find(add(Z(iz), Z(jz)))
        \replacewith(#add(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    sub_literals {
        \find(sub(Z(iz), Z(jz)))
        \replacewith(#sub(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    mul_literals {
        \find(mul(Z(iz), Z(jz)))
        \replacewith(#mul(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    div_literals {
        \find(div(Z(iz), Z(jz)))
        \replacewith(#div(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    less_literals {
        \find(lt(Z(iz), Z(jz)))
        \replacewith(#less(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    greater_literals {
        \find(gt(Z(iz), Z(jz)))
        \replacewith(#greater(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    leq_literals {
        \find(leq(Z(iz), Z(jz)))
        \replacewith(#leq(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    qeq_literals {
        \find(geq(Z(iz), Z(jz)))
        \replacewith(#geq(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    equal_literals {
        \find(Z(iz) = Z(jz))
        \replacewith(#eq(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    neg_literal {
        \find(neg(Z(iz)))
        \replacewith(Z(neglit(iz)))
        \heuristics(simplify_literals)
    };

    pow_literals {
        \find(pow(Z(iz), Z(jz)))
        \replacewith(#pow(Z(iz), Z(jz)))
        \heuristics(simplify_literals, nonDuplicateAppCheckEq)
    };

}

// ---------------------------------------------------------
// - multiply both sides of an (in)equation with some term -
// ---------------------------------------------------------

\rules(integerSimplificationRules:full) {
    multiply_inEq0 {
        \find(multLeft <= multRight ==>)
        \add(\if(multFac >= 0)
                \then(multLeft * multFac <= multRight * multFac)
                \else(multLeft * multFac >= multRight * multFac) ==>)
    };

    multiply_inEq1 {
        \find(multLeft >= multRight ==>)
        \add(\if(multFac >= 0)
                \then(multLeft * multFac >= multRight * multFac)
                \else(multLeft * multFac <= multRight * multFac) ==>)
    };

    multiply_eq {
        \find(multLeft = multRight ==>)
        \add(multLeft * multFac = multRight * multFac ==>)
    };

    multiply_2_inEq0 {
        \assumes(multFacLeft <= multFacRight ==>)
        \find(multLeft <= multRight ==>)
        \add(multLeft * multFacLeft >=
            -multRight * multFacRight
            + multRight * multFacLeft
            + multLeft * multFacRight ==>)
        \heuristics(inEqSimp_nonLin,
            inEqSimp_nonLin_multiply)
    };

    multiply_2_inEq1 {
        \assumes(multFacLeft >= multFacRight ==>)
        \find(multLeft <= multRight ==>)
        \add(multLeft * multFacLeft <=
            -multRight * multFacRight
            + multRight * multFacLeft
            + multLeft * multFacRight ==>)
        \heuristics(inEqSimp_nonLin,
            inEqSimp_nonLin_multiply)
    };

    multiply_2_inEq2 {
        \assumes(multFacLeft <= multFacRight ==>)
        \find(multLeft >= multRight ==>)
        \add(multLeft * multFacLeft <=
            -multRight * multFacRight
            + multRight * multFacLeft
            + multLeft * multFacRight ==>)
        \heuristics(inEqSimp_nonLin,
            inEqSimp_nonLin_multiply)
    };

    multiply_2_inEq3 {
        \assumes(multFacLeft >= multFacRight ==>)
        \find(multLeft >= multRight ==>)
        \add(multLeft * multFacLeft >=
            -multRight * multFacRight
            + multRight * multFacLeft
            + multLeft * multFacRight ==>)
        \heuristics(inEqSimp_nonLin,
            inEqSimp_nonLin_multiply)
    };

    divide_inEq0 {
        \assumes(divX >= divXBoundPos ==>)
        \find(divProd <= divProdBoundNonNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundPos >= 1 ->
            divProdBoundNonNeg >= 0 ->
            divY <= divProdBoundNonNeg/divXBoundPos ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_inEq1 {
        \assumes(divX >= divXBoundNonNeg ==>)
        \find(divProd <= divProdBoundNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNonNeg >= 0 ->
            divProdBoundNeg <= -1 ->
            divY <= -1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_neg)
    };

    divide_inEq2 {
        \assumes(divX >= divXBoundPos ==>)
        \find(divProd >= divProdBoundNonPos ==>)
        \add(divProd = divX * divY ->
            divXBoundPos >= 1 ->
            divProdBoundNonPos <= 0 ->
            divY >= (divProdBoundNonPos + divXBoundPos - 1)
            /divXBoundPos ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_inEq3 {
        \assumes(divX >= divXBoundNonNeg ==>)
        \find(divProd >= divProdBoundPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNonNeg >= 0 ->
            divProdBoundPos >= 1 ->
            divY >= 1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_pos)
    };

    divide_inEq4 {
        \assumes(divX <= divXBoundNeg ==>)
        \find(divProd >= divProdBoundNonPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNeg <= -1 ->
            divProdBoundNonPos <= 0 ->
            divY <= divProdBoundNonPos/divXBoundNeg ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_inEq5 {
        \assumes(divX <= divXBoundNonPos ==>)
        \find(divProd >= divProdBoundPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNonPos <= 0 ->
            divProdBoundPos >= 1 ->
            divY <= -1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_neg)
    };

    divide_inEq6 {
        \assumes(divX <= divXBoundNeg ==>)
        \find(divProd <= divProdBoundNonNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNeg <= -1 ->
            divProdBoundNonNeg >= 0 ->
            divY >= divProdBoundNonNeg/divXBoundNeg ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_inEq7 {
        \assumes(divX <= divXBoundNonPos ==>)
        \find(divProd <= divProdBoundNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNonPos <= 0 ->
            divProdBoundNeg <= -1 ->
            divY >= 1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_pos)
    };

    divide_eq0 {
        \assumes(divX >= divXBoundPos ==>)
        \find(divProd = divProdBoundNonNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundPos >= 1 ->
            divProdBoundNonNeg >= 0 ->
            divY <= divProdBoundNonNeg/divXBoundPos ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_eq1 {
        \assumes(divX >= divXBoundNonNeg ==>)
        \find(divProd = divProdBoundNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNonNeg >= 0 ->
            divProdBoundNeg <= -1 ->
            divY <= -1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_neg)
    };

    divide_eq2 {
        \assumes(divX >= divXBoundPos ==>)
        \find(divProd = divProdBoundNonPos ==>)
        \add(divProd = divX * divY ->
            divXBoundPos >= 1 ->
            divProdBoundNonPos <= 0 ->
            divY >= (divProdBoundNonPos + divXBoundPos - 1)
            /divXBoundPos ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_eq3 {
        \assumes(divX >= divXBoundNonNeg ==>)
        \find(divProd = divProdBoundPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNonNeg >= 0 ->
            divProdBoundPos >= 1 ->
            divY >= 1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_pos)
    };

    divide_eq4 {
        \assumes(divX <= divXBoundNeg ==>)
        \find(divProd = divProdBoundNonPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNeg <= -1 ->
            divProdBoundNonPos <= 0 ->
            divY <= divProdBoundNonPos/divXBoundNeg ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_eq5 {
        \assumes(divX <= divXBoundNonPos ==>)
        \find(divProd = divProdBoundPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNonPos <= 0 ->
            divProdBoundPos >= 1 ->
            divY <= -1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_neg)
    };

    divide_eq6 {
        \assumes(divX <= divXBoundNeg ==>)
        \find(divProd = divProdBoundNonNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNeg <= -1 ->
            divProdBoundNonNeg >= 0 ->
            divY >= divProdBoundNonNeg/divXBoundNeg ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_eq7 {
        \assumes(divX <= divXBoundNonPos ==>)
        \find(divProd = divProdBoundNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNonPos <= 0 ->
            divProdBoundNeg <= -1 ->
            divY >= 1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_pos)
    };
}

// ##########################################################################################################
// ------------- integer induction rules    --------------
// ##########################################################################################################

\rules {
    // reviewed 04/15/2004, St.S.
    int_induction {
        "Base Case":
            \add( ==> {\subst nv; 0}(b));
        "Step Case":
            \add( ==> \forall nv; ((geq(nv, 0) & b) -> {\subst nv; (nv + 1)}b));
        "Use Case":
            \add(\forall nv; (geq(nv, 0) -> b) ==>)
    };
}

// -------------------------------------------------------------------------------------
// Automatic induction rules. Ch.G.
// Universal quantification in the succedent
// -------------------------------------------------------------------------------------

\rules(integerSimplificationRules:full) {

    // basic pattern,
    auto_int_induction_geqZero {
        \find( ==> \forall uSub; b)
        \varcond(\newDependingOn(sk, b))
        "Base Case":
            \replacewith( ==> {\subst uSub; 0}b);
        "Step Case (positive)":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; sk}b) ->
                    {\subst uSub; sk + 1}b));
        "Step Case (negative)":
            \replacewith( ==> ((leq(sk, 0) & {\subst uSub; sk}b) ->
                    {\subst uSub; sk - 1}b))
        \displayname "auto_induction"
    };

    // -------------------------------------------------------------------------------------
    // auto induction for: variable greater or equal to some term
    auto_int_induction_geq_1 {
        \find( ==> \forall uSub; (t <= uSub -> b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_geq_2 {
        \find( ==> \forall uSub; (t > uSub | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_geq_3 {
        \find( ==> \forall uSub; (uSub < t | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // auto induction for: variable greater or equal to some term and a second bound psi

    auto_int_induction_geq_5 {
        \find( ==> \forall uSub; ((t > uSub | psi) | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}(psi | b), true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_geq_6 {
        \find( ==> \forall uSub; ((uSub < t | psi) | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}(psi | b), true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // -------------------------------------------------------------------------------------
    // auto induction for: variable greater than some term
    auto_int_induction_gt_1 {
        \find( ==> \forall uSub; (t < uSub -> b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_gt_2 {
        \find( ==> \forall uSub; (t >= uSub | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_gt_3 {
        \find( ==> \forall uSub; (uSub <= t | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // auto induction for: variable greater than some term and a second bound psi

    auto_int_induction_gt_5 {
        \find( ==> \forall uSub; ((t >= uSub | psi) | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}(psi | b), true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_gt_6 {
        \find( ==> \forall uSub; ((uSub <= t | psi) | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}(psi | b), true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // -------------------------------------------------------------------------------------
    // Automatic induction rules and lemma generation rule. The inductively proved formula is
    //  used as a lemma for consecutive formulas in a conjunction. Ch.G.
    // -------------------------------------------------------------------------------------

    // basic pattern
    autoInduct_Lemma {
        \find( ==> (\forall uSub; b) & phi)
        \varcond(\newDependingOn(sk, b))
        "Base Case":
            \replacewith( ==> {\subst uSub; 0}b);
        "Step Case (positive)":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; sk}b) ->
                    {\subst uSub; sk + 1}b));
        "Step Case (negative)":
            \replacewith( ==> ((leq(sk, 0) & {\subst uSub; sk}b) ->
                    {\subst uSub; sk - 1}b));
        "Use Case":
            \replacewith(\forall uSub; b ==> phi)
    };

    // ---------------------------------------------------------------------------------------------------------------------------------
    // auto induction for: variable greater or equal to some term
    autoInductGEQ_Lemma_1 {
        \find( ==> (\forall uSub; (t <= uSub -> b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGEQ_Lemma_2 {
        \find( ==> (\forall uSub; (t > uSub | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGEQ_Lemma_3 {
        \find( ==> (\forall uSub; (uSub < t | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    // auto induction for: variable greater or equal to some term and a second bound psi.

    autoInductGEQ_Lemma_5 {
        \find( ==> (\forall uSub; ((t > uSub | psi) | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi | b), true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> (psi | b)) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGEQ_Lemma_6 {
        \find( ==> (\forall uSub; ((uSub < t | psi) | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi | b), true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> (psi | b)) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    // ---------------------------------------------------------------------------------------------------------------------------------
    // auto induction for: variable greater than some term

    autoInductGT_Lemma_1 {
        \find( ==> (\forall uSub; (t < uSub -> b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGT_Lemma_2 {
        \find( ==> (\forall uSub; (t >= uSub | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGT_Lemma_3 {
        \find( ==> (\forall uSub; (uSub <= t | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    // auto induction for: variable greater than some term and a second bound psi.

    autoInductGT_Lemma_5 {
        \find( ==> (\forall uSub; ((t >= uSub | psi) | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi | b), true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> (psi | b)) ==> phi)
        \heuristics(auto_induction_lemma)
        \displayname "auto_induction_lemma"
    };

    autoInductGT_Lemma_6 {
        \find( ==> (\forall uSub; ((uSub <= t | psi) | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi | b), true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> (psi | b)) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    // -------------------------------------------------------------------------------------
    // Automatic induction rules. Ch.G.
    // Existential quantification in the antecedent
    // -------------------------------------------------------------------------------------

    // basic pattern,
    auto_int_induction_geqZeroLeft {
        \find(\exists uSub; b ==>)
        \varcond(\newDependingOn(sk, b))
        "Base Case":
            \replacewith( ==> {\subst uSub; 0}!b);
        "Step Case (positive)":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; sk}!b) ->
                    {\subst uSub; (sk + 1)}!b));
        "Step Case (negative)":
            \replacewith( ==> ((leq(sk, 0) & {\subst uSub; sk}!b) ->
                    {\subst uSub; (sk - 1)}!b))
        \displayname "auto_induction"
    };

    // auto induction for: variable greater or equal to some term
    auto_int_induction_geq_Left1 {
        \find(\exists uSub; (t <= uSub & b) ==>)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}!b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}!b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_geq_Left2 {
        \find(\exists uSub; (uSub >= t & b) ==>)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}!b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}!b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // auto induction for: variable greater than some term
    auto_int_induction_gt_Left1 {
        \find(\exists uSub; (t < uSub & b) ==>)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}!b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}!b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_gt_Left2 {
        \find(\exists uSub; (uSub > t & b) ==>)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}!b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}!b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // ##########################################################################################################


    // ##########################################################################################################

}

// ---------------------------------------------------------
// ------------- split an equation into inequations --------
// ---------------------------------------------------------

\rules {

    splitEquation {
        \find(splitEqLeft = splitEqRight)
        \replacewith(splitEqLeft >= splitEqRight & splitEqLeft <= splitEqRight)
    };

    splitEquationSucc {
        \find( ==> splitEqLeft = splitEqRight)
        \replacewith( ==> splitEqLeft >= splitEqRight);
        \replacewith( ==> splitEqLeft <= splitEqRight)
        \heuristics(inEqSimp_nonLin, inEqSimp_split_eq, notHumanReadable)
    };
}

// ---------------------------------------------------------
// ------------- normalisation of polynomials --------------
// ---------------------------------------------------------

\rules {

    polySimp_elimSub {
        \find(sub(i, i0))
        \replacewith(add(i, mul(i0, -1)))
        \heuristics(polySimp_expand, polySimp_elimSubNeg)
    };

    polySimp_elimNeg {
        \find(neg(i))
        \replacewith(mul(i, -1))
        \heuristics(polySimp_expand, polySimp_elimSubNeg)
    };

    polySimp_elimOne {
        \find(mul(i, 1))
        \replacewith(i)
        \heuristics(polySimp_expand, polySimp_elimOneRight)
    };

    polySimp_elimOneLeft0 {
        \find(mul(1, i))
        \replacewith(i)
        \heuristics(polySimp_expand, polySimp_elimOneLeft)
    };

    polySimp_elimOneLeft1 {
        \find(mul(mul(i0, 1), i))
        \replacewith(mul(i0, i))
        \heuristics(polySimp_expand, polySimp_elimOneLeft)
    };

    polySimp_homoEq {
        \find(homoLeft = homoRight)
        \replacewith(add(homoRight, mul(homoLeft, -1)) = 0)
        \heuristics(polySimp_expand, polySimp_homo, notHumanReadable)
    };

    polySimp_rightDist {
        \find(mul(distCoeff, add(distSummand0, distSummand1)))
        \replacewith(add(mul(distCoeff, distSummand0),
                mul(distSummand1, distCoeff)))
        \heuristics(polySimp_expand, polySimp_dist)
    };

    polySimp_addAssoc {
        \find(add(addAssocPoly0, add(addAssocPoly1, addAssocMono)))
        \replacewith(add(add(addAssocPoly0, addAssocPoly1), addAssocMono))
        \heuristics(polySimp_expand, polySimp_addAssoc)
    };

    polySimp_mulAssoc {
        \find(mul(mulAssocMono0, mul(mulAssocMono1, mulAssocAtom)))
        \replacewith(mul(mul(mulAssocMono0, mulAssocMono1), mulAssocAtom))
        \heuristics(polySimp_expand, polySimp_mulAssoc)
    };

    polySimp_addComm0 {
        \find(add(commLeft, commRight))
        \replacewith(add(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    polySimp_addComm1 {
        \find(add(add(i0, commLeft), commRight))
        \replacewith(add(add(i0, commRight), commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    polySimp_mulComm0 {
        \find(mul(commLeft, commRight))
        \replacewith(mul(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_mulOrder)
    };

    polySimp_mulComm1 {
        \find(mul(mul(i0, commLeft), commRight))
        \replacewith(mul(mul(i0, commRight), commLeft))
        \heuristics(polySimp_expand, polySimp_mulOrder)
    };

    polySimp_addLiterals {
        \find(add(add(i, Z(iz)), Z(jz)))
        \replacewith(add(i, #add(Z(iz), Z(jz))))
        \heuristics(simplify_literals)
    };

    polySimp_mulLiterals {
        \find(mul(mul(i, Z(iz)), Z(jz)))
        \replacewith(mul(i, #mul(Z(iz), Z(jz))))
        \heuristics(simplify_literals)
    };

    polySimp_pullOutFactor0 {
        \find(add(mul(pullOutCommon, pullOutLeft),
                mul(pullOutCommon, pullOutRight)))
        \replacewith(mul(pullOutCommon,
                add(pullOutLeft, pullOutRight)))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor1 {
        \find(add(pullOutCommon,
                mul(pullOutCommon, pullOutRight)))
        \replacewith(mul(pullOutCommon,
                add(1, pullOutRight)))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor2 {
        \find(add(mul(pullOutCommon, pullOutLeft),
                pullOutCommon))
        \replacewith(mul(pullOutCommon,
                add(pullOutLeft, 1)))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor3 {
        \find(add(pullOutCommon, pullOutCommon))
        \replacewith(mul(pullOutCommon, 2))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor0b {
        \find(add(add(i0, mul(pullOutCommon, pullOutLeft)),
                mul(pullOutCommon, pullOutRight)))
        \replacewith(add(i0, mul(pullOutCommon,
                    add(pullOutLeft, pullOutRight))))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor1b {
        \find(add(add(i0, pullOutCommon),
                mul(pullOutCommon, pullOutRight)))
        \replacewith(add(i0, mul(pullOutCommon,
                    add(1, pullOutRight))))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor2b {
        \find(add(add(i0, mul(pullOutCommon, pullOutLeft)),
                pullOutCommon))
        \replacewith(add(i0, mul(pullOutCommon,
                    add(pullOutLeft, 1))))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor3b {
        \find(add(add(i0, pullOutCommon), pullOutCommon))
        \replacewith(add(i0, mul(pullOutCommon, 2)))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_invertEq {
        \find(invertLeft = invertRight)
        \replacewith(invertLeft * (-1) = invertRight * (-1))
        \heuristics(polySimp_directEquations, polySimp_normalise)
    };

    polySimp_sepPosMonomial {
        \find(add(sepResidue, sepPosMono) = 0)
        \replacewith(sepPosMono = mul(sepResidue, -1))
        \heuristics(polySimp_directEquations, polySimp_balance, notHumanReadable)
    };

    polySimp_sepNegMonomial {
        \find(add(sepResidue, sepNegMono) = 0)
        \replacewith(mul(sepNegMono, -1) = sepResidue)
        \heuristics(polySimp_directEquations, polySimp_balance)
    };

    apply_eq_monomials {
        \assumes(applyEqDivisor = i0 ==>)
        \find(applyEqDividend)
        \sameUpdateLevel
        \replacewith(#divideMonomials(applyEqDividend, applyEqDivisor) *
            (i0 + applyEqDivisor * -1)
            + applyEqDividend)
        \heuristics(polySimp_applyEq, apply_equations, notHumanReadable)
    };

    apply_eq_monomials_rigid {
        \assumes(applyEqDivisorr = i0r ==>)
        \find(applyEqDividend)
        \replacewith(#divideMonomials(applyEqDividend, applyEqDivisorr) *
            (i0r + applyEqDivisorr * -1)
            + applyEqDividend)
        \heuristics(polySimp_applyEqRigid, apply_equations, notHumanReadable)
    };

    apply_eq_pseudo_eq {
        \assumes(aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==>)
        \find(aePseudoTargetLeft = aePseudoTargetRight)
        \sameUpdateLevel
        \replacewith(\if(aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                & aePseudoLeftCoeff != 0)
                \then(aePseudoRight * aePseudoTargetFactor
                    = aePseudoTargetRight * aePseudoLeftCoeff)
                \else(aePseudoTargetLeft = aePseudoTargetRight))
        \heuristics(polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable, notHumanReadable)
    };

    apply_eq_pseudo_leq {
        \assumes(aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==>)
        \find(aePseudoTargetLeft <= aePseudoTargetRight)
        \sameUpdateLevel
        \replacewith(\if(aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                & aePseudoLeftCoeff > 0)
                \then(aePseudoRight * aePseudoTargetFactor
                    <= aePseudoTargetRight * aePseudoLeftCoeff)
                \else(aePseudoTargetLeft <= aePseudoTargetRight))
        \heuristics(polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable)
    };

    apply_eq_pseudo_geq {
        \assumes(aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==>)
        \find(aePseudoTargetLeft >= aePseudoTargetRight)
        \sameUpdateLevel
        \replacewith(\if(aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                & aePseudoLeftCoeff > 0)
                \then(aePseudoRight * aePseudoTargetFactor
                    >= aePseudoTargetRight * aePseudoLeftCoeff)
                \else(aePseudoTargetLeft >= aePseudoTargetRight))
        \heuristics(polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable)
    };

    polySimp_critPair {
        \assumes(cpLeft1 = cpRight1 ==>)
        \find(cpLeft2 = cpRight2 ==>)
        \add(#divideLCRMonomials(cpLeft2, cpLeft1)
            * (-1 * cpRight1 + cpLeft1)
            +
            #divideLCRMonomials(cpLeft1, cpLeft2)
            * (cpRight2 + -1 * cpLeft2)
            = 0 ==>)
        \heuristics(polySimp_saturate, polySimp_critPair, notHumanReadable)
    };

}

// ---------------------------------------------------------
// ------------- normalisation of inequations --------------
// ---------------------------------------------------------

\rules {

    inEqSimp_ltRight {
        \find( ==> i < i0)
        \replacewith((-1) * i0 + i >= 0 ==>)
        \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
    };

    inEqSimp_gtRight {
        \find( ==> i > i0)
        \replacewith((-1) * i0 + i <= 0 ==>)
        \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
    };

    inEqSimp_leqRight {
        \find( ==> i <= i0)
        \replacewith((-1) + (-1) * i0 + i >= 0 ==>)
        \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
    };

    inEqSimp_geqRight {
        \find( ==> i >= i0)
        \replacewith(1 + (-1) * i0 + i <= 0 ==>)
        \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
    };

    inEqSimp_ltToLeq {
        \find(i < i0)
        \replacewith(1 + (-1) * i0 + i <= 0)
        \heuristics(inEqSimp_expand, inEqSimp_makeNonStrict, notHumanReadable)
    };

    inEqSimp_gtToGeq {
        \find(i > i0)
        \replacewith((-1) + (-1) * i0 + i >= 0)
        \heuristics(inEqSimp_expand, inEqSimp_makeNonStrict, notHumanReadable)
    };

    inEqSimp_commuteLeq {
        \find(commLeft <= commRight)
        \replacewith(commRight >= commLeft)
        \heuristics(inEqSimp_expand, inEqSimp_commute)
    };

    inEqSimp_commuteGeq {
        \find(commLeft >= commRight)
        \replacewith(commRight <= commLeft)
        \heuristics(inEqSimp_expand, inEqSimp_commute)
    };

    inEqSimp_homoInEq0 {
        \find(homoLeft <= homoRight)
        \replacewith(add(homoRight, mul(homoLeft, -1)) >= 0)
        \heuristics(inEqSimp_expand, inEqSimp_homo, notHumanReadable)
    };

    inEqSimp_homoInEq1 {
        \find(homoLeft >= homoRight)
        \replacewith(add(homoRight, mul(homoLeft, -1)) <= 0)
        \heuristics(inEqSimp_expand, inEqSimp_homo, notHumanReadable)
    };

    inEqSimp_invertInEq0 {
        \find(invertLeft <= invertRight)
        \replacewith(invertLeft * (-1) >= invertRight * (-1))
        \heuristics(inEqSimp_directInEquations, inEqSimp_normalise, notHumanReadable)
    };

    inEqSimp_invertInEq1 {
        \find(invertLeft >= invertRight)
        \replacewith(invertLeft * (-1) <= invertRight * (-1))
        \heuristics(inEqSimp_directInEquations, inEqSimp_normalise, notHumanReadable)
    };

    inEqSimp_sepPosMonomial0 {
        \find(add(sepResidue, sepPosMono) <= 0)
        \replacewith(sepPosMono <= mul(sepResidue, -1))
        \heuristics(inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
    };

    inEqSimp_sepNegMonomial0 {
        \find(add(sepResidue, sepNegMono) <= 0)
        \replacewith(mul(sepNegMono, -1) >= sepResidue)
        \heuristics(inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
    };

    inEqSimp_sepPosMonomial1 {
        \find(add(sepResidue, sepPosMono) >= 0)
        \replacewith(sepPosMono >= mul(sepResidue, -1))
        \heuristics(inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
    };

    inEqSimp_sepNegMonomial1 {
        \find(add(sepResidue, sepNegMono) >= 0)
        \replacewith(mul(sepNegMono, -1) <= sepResidue)
        \heuristics(inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
    };

    inEqSimp_antiSymm {
        \assumes(i <= i0 ==>)
        \find(i >= i0 ==>)
        \add(i = i0 ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_antiSymm)
    };

    inEqSimp_exactShadow0 {
        \assumes(mul(esLeft, esCoeff1) <= esRight1 ==>)
        \find(mul(esLeft, esCoeff2) >= esRight2 ==>)
        \add((esCoeff1 > 0 & esCoeff2 > 0)
            ->
            (-1) * mul(esCoeff1, esRight2)
            + mul(esCoeff2, esRight1) >= 0
            ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable)
    };

    inEqSimp_exactShadow1 {
        \assumes(esLeft <= esRight1 ==>)
        \find(mul(esLeft, esCoeff2) >= esRight2 ==>)
        \add((esCoeff2 > 0)
            ->
            (-1) * esRight2 + mul(esCoeff2, esRight1) >= 0
            ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable)
    };

    inEqSimp_exactShadow2 {
        \assumes(mul(esLeft, esCoeff1) <= esRight1 ==>)
        \find(esLeft >= esRight2 ==>)
        \add((esCoeff1 > 0)
            ->
            (-1) * mul(esCoeff1, esRight2) + esRight1 >= 0
            ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable)
    };

    inEqSimp_exactShadow3 {
        \assumes(esLeft <= esRight1 ==>)
        \find(esLeft >= esRight2 ==>)
        \add((-1) * esRight2 + esRight1 >= 0 ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable)
    };

    inEqSimp_subsumption0 {
        \assumes(subsumLeft <= subsumRightSmaller ==>)
        \find(subsumLeft <= subsumRightBigger)
        \sameUpdateLevel
        \replacewith(subsumRightSmaller <= subsumRightBigger |
            subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption1 {
        \assumes(subsumLeft >= subsumRightBigger ==>)
        \find(subsumLeft >= subsumRightSmaller)
        \sameUpdateLevel
        \replacewith(subsumRightSmaller <= subsumRightBigger |
            subsumLeft >= subsumRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption2 {
        \assumes(subsumLeft * subsumCoeffSmaller <= subsumRightSmaller ==>)
        \find(subsumLeft * subsumCoeffBigger <= subsumRightBigger)
        \sameUpdateLevel
        \replacewith((subsumCoeffSmaller > 0
                & subsumCoeffBigger > 0
                & subsumCoeffBigger * subsumRightSmaller <=
                subsumCoeffSmaller * subsumRightBigger) |
            subsumLeft * subsumCoeffBigger <= subsumRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption4 {
        \assumes(subsumLeft <= subsumRightSmaller ==>)
        \find(subsumLeft * subsumCoeffBigger <= subsumRightBigger)
        \sameUpdateLevel
        \replacewith((subsumCoeffBigger > 0
                & subsumCoeffBigger * subsumRightSmaller <=
                subsumRightBigger) |
            subsumLeft * subsumCoeffBigger <= subsumRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption5 {
        \assumes(subsumLeft * subsumCoeffBigger >= subsumRightBigger ==>)
        \find(subsumLeft * subsumCoeffSmaller >= subsumRightSmaller)
        \sameUpdateLevel
        \replacewith((subsumCoeffSmaller > 0
                & subsumCoeffBigger > 0
                & subsumCoeffBigger * subsumRightSmaller <=
                subsumCoeffSmaller * subsumRightBigger) |
            subsumLeft * subsumCoeffSmaller >= subsumRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption6 {
        \assumes(subsumLeft >= subsumRightBigger ==>)
        \find(subsumLeft * subsumCoeffSmaller >= subsumRightSmaller)
        \sameUpdateLevel
        \replacewith((subsumCoeffSmaller > 0
                & subsumRightSmaller <=
                subsumCoeffSmaller * subsumRightBigger) |
            subsumLeft * subsumCoeffSmaller >= subsumRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_contradInEq0 {
        \assumes(contradLeft <= contradRightSmaller ==>)
        \find(contradLeft >= contradRightBigger)
        \sameUpdateLevel
        \replacewith(contradRightSmaller >= contradRightBigger &
            contradLeft >= contradRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq1 {
        \assumes(contradLeft >= contradRightBigger ==>)
        \find(contradLeft <= contradRightSmaller)
        \sameUpdateLevel
        \replacewith(contradRightSmaller >= contradRightBigger &
            contradLeft <= contradRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq2 {
        \assumes(contradLeft * contradCoeffSmaller <= contradRightSmaller ==>)
        \find(contradLeft * contradCoeffBigger >= contradRightBigger)
        \sameUpdateLevel
        \replacewith((contradCoeffSmaller > 0 ->
                contradCoeffBigger > 0 ->
                contradCoeffBigger * contradRightSmaller >=
                contradCoeffSmaller * contradRightBigger) &
            contradLeft * contradCoeffBigger >= contradRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq3 {
        \assumes(contradLeft <= contradRightSmaller ==>)
        \find(contradLeft * contradCoeffBigger >= contradRightBigger)
        \sameUpdateLevel
        \replacewith((contradCoeffBigger > 0 ->
                contradCoeffBigger * contradRightSmaller >=
                contradRightBigger) &
            contradLeft * contradCoeffBigger >= contradRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq4 {
        \assumes(contradLeft * contradCoeffBigger >= contradRightBigger ==>)
        \find(contradLeft * contradCoeffSmaller <= contradRightSmaller)
        \sameUpdateLevel
        \replacewith((contradCoeffSmaller > 0 ->
                contradCoeffBigger > 0 ->
                contradCoeffBigger * contradRightSmaller >=
                contradCoeffSmaller * contradRightBigger) &
            contradLeft * contradCoeffSmaller <= contradRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq5 {
        \assumes(contradLeft >= contradRightBigger ==>)
        \find(contradLeft * contradCoeffSmaller <= contradRightSmaller)
        \sameUpdateLevel
        \replacewith((contradCoeffSmaller > 0 ->
                contradRightSmaller >=
                contradCoeffSmaller * contradRightBigger) &
            contradLeft * contradCoeffSmaller <= contradRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_strengthen0 {
        \assumes( ==> strengthenLeft = strengthenRight)
        \find(strengthenLeft <= strengthenRight ==>)
        \replacewith(strengthenLeft <= -1 + strengthenRight ==>)
        \heuristics(inEqSimp_propagation, inEqSimp_strengthen, notHumanReadable)
    };

    inEqSimp_strengthen1 {
        \assumes( ==> strengthenLeft = strengthenRight)
        \find(strengthenLeft >= strengthenRight ==>)
        \replacewith(strengthenLeft >= 1 + strengthenRight ==>)
        \heuristics(inEqSimp_propagation, inEqSimp_strengthen, notHumanReadable)
    };

    inEqSimp_contradEq3 {
        \assumes(contradLeft <= contradRightSmaller ==>)
        \find(contradLeft = contradRightBigger)
        \sameUpdateLevel
        \replacewith(contradRightSmaller + (-1) * contradRightBigger >= 0 &
            contradLeft = contradRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_contradEqs, notHumanReadable)
    };

    inEqSimp_contradEq7 {
        \assumes(contradLeft >= contradRightBigger ==>)
        \find(contradLeft = contradRightSmaller)
        \sameUpdateLevel
        \replacewith(contradRightBigger + (-1) * contradRightSmaller <= 0 &
            contradLeft = contradRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_contradEqs, notHumanReadable)
    };

    \lemma
    irrflConcrete1 {
        \find(i < i ==>)
        \replacewith(false ==>)
        \heuristics(concrete)
    };
    \lemma
    irrflConcrete2 {
        \find(i > i ==>)
        \replacewith(false ==>)
        \heuristics(concrete)
    };

    // PHS 13.03.2019
    // This taclet appears here because its proof uses  induction
    \lemma
    cancel_gtPos {
        \schemaVar \term int Less, More, Fac;
        \assumes(Fac > 0 ==>)
        \find(Less < More ==>)
        \add(Less * Fac < More * Fac ==>)
    };

    // PHS 14.03.2019
    // This taclet appears here because its proof uses  induction
    \lemma
    cancel_gtNeg {
        \schemaVar \term int Less, More, Fac;
        \assumes(Fac < 0 ==>)
        \find(Less < More ==>)
        \add(Less * Fac > More * Fac ==>)
    };

}

// ---------------------------------------------------------------------------
// ------------- formula normalisation ---------------------------------------
// ---------------------------------------------------------------------------

// conjunctions and disjunctions are normalised so that they are left-associative,
// <= is left of >= is left of = (provided that the left sides are equal)

\rules {

    inEqSimp_notLeq {
        \find(!(i <= i0))
        \replacewith((-1) + (-1) * i0 + i >= 0)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)
    };

    inEqSimp_notGeq {
        \find(!(i >= i0))
        \replacewith(1 + (-1) * i0 + i <= 0)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)
    };

    inEqSimp_and_antiSymm0 {
        \find(i <= i0 & i >= i0)
        \replacewith(i = i0)
        \heuristics(inEqSimp_forNormalisation)
    };

    inEqSimp_and_antiSymm1 {
        \find((b & i <= i0) & i >= i0)
        \replacewith(b & i = i0)
        \heuristics(inEqSimp_forNormalisation)
    };

    inEqSimp_and_contradInEq0 {
        \find(contradLeft <= contradRightSmaller
            & contradLeft >= contradRightBigger)
        \replacewith((contradLeft <= contradRightSmaller
                & contradLeft >= contradRightBigger)
            & contradRightSmaller >= contradRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_contradInEqs,
            notHumanReadable)
    };

    inEqSimp_and_contradInEq1 {
        \find((b & contradLeft <= contradRightSmaller)
            & contradLeft >= contradRightBigger)
        \replacewith(((b & contradLeft <= contradRightSmaller)
                & contradLeft >= contradRightBigger)
            & contradRightSmaller >= contradRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_contradInEqs,
            notHumanReadable)
    };

    inEqSimp_and_strengthen0 {
        \find(strengthenLeft <= strengthenRight
            & strengthenLeft != strengthenRight)
        \replacewith(strengthenLeft <= -1 + strengthenRight)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)

    };

    inEqSimp_and_strengthen1 {
        \find(strengthenLeft >= strengthenRight
            & strengthenLeft != strengthenRight)
        \replacewith(strengthenLeft >= 1 + strengthenRight)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)
    };

    inEqSimp_and_strengthen2 {
        \find((b & strengthenLeft <= strengthenRight)
            & strengthenLeft != strengthenRight)
        \replacewith(b & strengthenLeft <= -1 + strengthenRight)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)

    };

    inEqSimp_and_strengthen3 {
        \find((b & strengthenLeft >= strengthenRight)
            & strengthenLeft != strengthenRight)
        \replacewith(b & strengthenLeft >= 1 + strengthenRight)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)
    };

    inEqSimp_and_subsumption0 {
        \find(subsumLeft <= subsumRightSmaller
            & subsumLeft <= subsumRightBigger)
        \replacewith(subsumLeft <= subsumRightSmaller
            & (subsumRightSmaller <= subsumRightBigger
                | subsumLeft <= subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption, notHumanReadable)
    };

    inEqSimp_and_subsumption1 {
        \find((b & subsumLeft <= subsumRightSmaller)
            & subsumLeft <= subsumRightBigger)
        \replacewith((b & subsumLeft <= subsumRightSmaller)
            & (subsumRightSmaller <= subsumRightBigger
                | subsumLeft <= subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption, notHumanReadable)
    };

    inEqSimp_and_subsumption2 {
        \find(subsumLeft >= subsumRightSmaller
            & subsumLeft >= subsumRightBigger)
        \replacewith((subsumRightSmaller <= subsumRightBigger
                | subsumLeft >= subsumRightSmaller)
            & subsumLeft >= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption, notHumanReadable)
    };

    inEqSimp_and_subsumption3 {
        \find((b & subsumLeft >= subsumRightSmaller)
            & subsumLeft >= subsumRightBigger)
        \replacewith((b & (subsumRightSmaller <= subsumRightBigger
                    | subsumLeft >= subsumRightSmaller))
            & subsumLeft >= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption, notHumanReadable)
    };

    inEqSimp_and_subsumption4 {
        \find(subsumLeft <= subsumRightSmaller
            & subsumLeft != subsumRightBigger)
        \replacewith(subsumLeft <= subsumRightSmaller
            & (subsumRightSmaller < subsumRightBigger
                | subsumLeft != subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_subsumptionEq, notHumanReadable)
    };

    inEqSimp_and_subsumption5 {
        \find((b & subsumLeft <= subsumRightSmaller)
            & subsumLeft != subsumRightBigger)
        \replacewith((b & subsumLeft <= subsumRightSmaller)
            & (subsumRightSmaller < subsumRightBigger
                | subsumLeft != subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_subsumptionEq, notHumanReadable)
    };

    inEqSimp_and_subsumption6 {
        \find(subsumLeft >= subsumRightBigger
            & subsumLeft != subsumRightSmaller)
        \replacewith(subsumLeft >= subsumRightBigger
            & (subsumRightSmaller < subsumRightBigger
                | subsumLeft != subsumRightSmaller))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_subsumptionEq, notHumanReadable)
    };

    inEqSimp_and_subsumption7 {
        \find((b & subsumLeft >= subsumRightBigger)
            & subsumLeft != subsumRightSmaller)
        \replacewith((b & subsumLeft >= subsumRightBigger)
            & (subsumRightSmaller < subsumRightBigger
                | subsumLeft != subsumRightSmaller))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_subsumptionEq, notHumanReadable)
    };

    inEqSimp_or_antiSymm0 {
        \find(antiSymmLeft <= antiSymmRightSmaller
            | antiSymmLeft >= antiSymmRightBigger)
        \replacewith(\if(2 + antiSymmRightSmaller
                = antiSymmRightBigger)
                \then(antiSymmLeft != 1 + antiSymmRightSmaller)
                \else(antiSymmLeft <= antiSymmRightSmaller
                    | antiSymmLeft >= antiSymmRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_antiSymm, notHumanReadable)
    };

    inEqSimp_or_antiSymm1 {
        \find((b | antiSymmLeft <= antiSymmRightSmaller)
            | antiSymmLeft >= antiSymmRightBigger)
        \replacewith(b |
            \if(2 + antiSymmRightSmaller
                = antiSymmRightBigger)
                \then(antiSymmLeft != 1 + antiSymmRightSmaller)
                \else(antiSymmLeft <= antiSymmRightSmaller
                    | antiSymmLeft >= antiSymmRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_antiSymm, notHumanReadable)
    };

    inEqSimp_or_tautInEq0 {
        \find(tautLeft <= tautRightBigger
            | tautLeft >= tautRightSmaller)
        \replacewith((tautLeft <= tautRightBigger
                | tautLeft >= tautRightSmaller)
            | tautRightBigger >= (-1) + tautRightSmaller)
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable)
    };

    inEqSimp_or_tautInEq1 {
        \find((b | tautLeft <= tautRightBigger)
            | tautLeft >= tautRightSmaller)
        \replacewith(((b | tautLeft <= tautRightBigger)
                | tautLeft >= tautRightSmaller)
            | tautRightBigger >= (-1) + tautRightSmaller)
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable)
    };

    inEqSimp_or_tautInEq2 {
        \find(tautLeft >= tautRightSmaller
            | tautLeft <= tautRightBigger)
        \replacewith((tautLeft >= tautRightSmaller
                | tautLeft <= tautRightBigger)
            | tautRightBigger >= (-1) + tautRightSmaller)
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable)
    };

    inEqSimp_or_tautInEq3 {
        \find((b | tautLeft >= tautRightSmaller)
            | tautLeft <= tautRightBigger)
        \replacewith(((b | tautLeft >= tautRightSmaller)
                | tautLeft <= tautRightBigger)
            | tautRightBigger >= (-1) + tautRightSmaller)
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable)
    };

    inEqSimp_or_weaken0 {
        \find(weakenLeft <= weakenRightSmaller
            | weakenLeft = weakenRightBigger)
        \replacewith(\if(weakenRightBigger = 1 + weakenRightSmaller)
                \then(weakenLeft <= weakenRightBigger)
                \else(weakenLeft <= weakenRightSmaller
                    | weakenLeft = weakenRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable)
    };

    inEqSimp_or_weaken1 {
        \find(weakenLeft = weakenRightSmaller
            | weakenLeft >= weakenRightBigger)
        \replacewith(\if(weakenRightBigger = 1 + weakenRightSmaller)
                \then(weakenLeft >= weakenRightSmaller)
                \else(weakenLeft = weakenRightSmaller
                    | weakenLeft >= weakenRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable)
    };

    inEqSimp_or_weaken2 {
        \find((b | weakenLeft <= weakenRightSmaller)
            | weakenLeft = weakenRightBigger)
        \replacewith(b |
            \if(weakenRightBigger = 1 + weakenRightSmaller)
                \then(weakenLeft <= weakenRightBigger)
                \else(weakenLeft <= weakenRightSmaller
                    | weakenLeft = weakenRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable)
    };

    inEqSimp_or_weaken3 {
        \find((b | weakenLeft = weakenRightSmaller)
            | weakenLeft >= weakenRightBigger)
        \replacewith(b |
            \if(weakenRightBigger = 1 + weakenRightSmaller)
                \then(weakenLeft >= weakenRightSmaller)
                \else(weakenLeft = weakenRightSmaller
                    | weakenLeft >= weakenRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable)
    };

    inEqSimp_or_subsumption0 {
        \find(subsumLeft <= subsumRightSmaller
            | subsumLeft <= subsumRightBigger)
        \replacewith((subsumRightSmaller >= subsumRightBigger
                & subsumLeft <= subsumRightSmaller)
            | subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption1 {
        \find((b | subsumLeft <= subsumRightSmaller)
            | subsumLeft <= subsumRightBigger)
        \replacewith((b | (subsumRightSmaller >= subsumRightBigger
                    & subsumLeft <= subsumRightSmaller))
            | subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption2 {
        \find(subsumLeft >= subsumRightSmaller
            | subsumLeft >= subsumRightBigger)
        \replacewith(subsumLeft >= subsumRightSmaller
            | (subsumRightSmaller >= subsumRightBigger
                & subsumLeft >= subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption3 {
        \find((b | subsumLeft >= subsumRightSmaller)
            | subsumLeft >= subsumRightBigger)
        \replacewith((b | subsumLeft >= subsumRightSmaller)
            | (subsumRightSmaller >= subsumRightBigger
                & subsumLeft >= subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption4 {
        \find(subsumLeft = subsumRightSmaller
            | subsumLeft <= subsumRightBigger)
        \replacewith((subsumRightSmaller > subsumRightBigger
                & subsumLeft = subsumRightSmaller)
            | subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption5 {
        \find((b | subsumLeft = subsumRightSmaller)
            | subsumLeft <= subsumRightBigger)
        \replacewith((b | (subsumRightSmaller > subsumRightBigger
                    & subsumLeft = subsumRightSmaller))
            | subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption6 {
        \find(subsumLeft >= subsumRightSmaller
            | subsumLeft = subsumRightBigger)
        \replacewith(subsumLeft >= subsumRightSmaller
            | (subsumRightSmaller > subsumRightBigger
                & subsumLeft = subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption7 {
        \find((b | subsumLeft >= subsumRightSmaller)
            | subsumLeft = subsumRightBigger)
        \replacewith((b | subsumLeft >= subsumRightSmaller)
            | (subsumRightSmaller > subsumRightBigger
                & subsumLeft = subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    applyEq_and_int0 {
        \find(applyEqLeft >= applyEqOther
            & applyEqLeft = applyEqRight)
        \replacewith(applyEqRight >= applyEqOther
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int1 {
        \find((b & applyEqLeft >= applyEqOther)
            & applyEqLeft = applyEqRight)
        \replacewith((b & applyEqRight >= applyEqOther)
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int2 {
        \find(applyEqLeft <= applyEqOther
            & applyEqLeft = applyEqRight)
        \replacewith(applyEqRight <= applyEqOther
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int3 {
        \find((b & applyEqLeft <= applyEqOther)
            & applyEqLeft = applyEqRight)
        \replacewith((b & applyEqRight <= applyEqOther)
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int4 {
        \find(applyEqLeft = applyEqRight
            & applyEqLeft >= applyEqOther)
        \replacewith(applyEqLeft = applyEqRight
            & applyEqRight >= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int5 {
        \find((b & applyEqLeft = applyEqRight)
            & applyEqLeft >= applyEqOther)
        \replacewith((b & applyEqLeft = applyEqRight)
            & applyEqRight >= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int6 {
        \find(applyEqLeft = applyEqRight
            & applyEqLeft <= applyEqOther)
        \replacewith(applyEqLeft = applyEqRight
            & applyEqRight <= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int7 {
        \find((b & applyEqLeft = applyEqRight)
            & applyEqLeft <= applyEqOther)
        \replacewith((b & applyEqLeft = applyEqRight)
            & applyEqRight <= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int0 {
        \find(applyEqLeft >= applyEqOther
            | applyEqLeft != applyEqRight)
        \replacewith(applyEqRight >= applyEqOther
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int1 {
        \find((b | applyEqLeft >= applyEqOther)
            | applyEqLeft != applyEqRight)
        \replacewith((b | applyEqRight >= applyEqOther)
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int2 {
        \find(applyEqLeft <= applyEqOther
            | applyEqLeft != applyEqRight)
        \replacewith(applyEqRight <= applyEqOther
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int3 {
        \find((b | applyEqLeft <= applyEqOther)
            | applyEqLeft != applyEqRight)
        \replacewith((b | applyEqRight <= applyEqOther)
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int4 {
        \find(applyEqLeft != applyEqRight
            | applyEqLeft >= applyEqOther)
        \replacewith(applyEqLeft != applyEqRight
            | applyEqRight >= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int5 {
        \find((b | applyEqLeft != applyEqRight)
            | applyEqLeft >= applyEqOther)
        \replacewith((b | applyEqLeft != applyEqRight)
            | applyEqRight >= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int6 {
        \find(applyEqLeft != applyEqRight
            | applyEqLeft <= applyEqOther)
        \replacewith(applyEqLeft != applyEqRight
            | applyEqRight <= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int7 {
        \find((b | applyEqLeft != applyEqRight)
            | applyEqLeft <= applyEqOther)
        \replacewith((b | applyEqLeft != applyEqRight)
            | applyEqRight <= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

}

// ---------------------------------------------------------------------------
// ------------- dividing equations and inequations by literals --------------
// ---------------------------------------------------------------------------

\rules(integerSimplificationRules:full) {

    cancel_equation {
        \schemaVar \term int eqLeft, eqRight, Fac;
        \find(eqLeft * Fac = eqRight * Fac)
        \replacewith(eqLeft = eqRight);
        \add( ==> Fac != 0)
        \heuristics(simplify_enlarging)
    };

    divide_equation {
        \find(elimGcdLeft = elimGcdRight)
        \replacewith(\if(elimGcd >= 1
                & elimGcdLeft % elimGcd = 0
                & elimGcdRight % elimGcd <= (-1) + elimGcd)
                \then(elimGcdRight % elimGcd = 0
                    & div(elimGcdLeft, elimGcd) = div(elimGcdRight, elimGcd))
                \else(elimGcdLeft = elimGcdRight))
    };

    divide_leq {
        \find(elimGcdLeft <= elimGcdRight)
        \replacewith(\if(elimGcd >= 1
                & elimGcdLeft % elimGcd = 0
                & elimGcdRight % elimGcd <= (-1) + elimGcd)
                \then(div(elimGcdLeft, elimGcd) <= div(elimGcdRight, elimGcd))
                \else(elimGcdLeft <= elimGcdRight))
    };

    divide_geq {
        \find(elimGcdLeft >= elimGcdRight)
        \replacewith(\if(elimGcd >= 1
                & elimGcdLeft % elimGcd = 0
                & elimGcdRight % elimGcd <= (-1) + elimGcd)
                \then(div(elimGcdLeft, elimGcd) >=
                    1 + div((-1) + elimGcdRight, elimGcd))
                \else(elimGcdLeft >= elimGcdRight))
    };

    elimGcdEq {
        \find(elimGcdLeft = elimGcdRight)
        \replacewith(\if(elimGcdLeftDiv * elimGcd = elimGcdLeft
                & elimGcdRight + (elimGcd * (-1)) * elimGcdRightDiv
                <= (-1) + elimGcd
                & elimGcdRight + (elimGcd * (-1)) * elimGcdRightDiv
                >= 0)
                \then(elimGcdRight + (elimGcd * (-1)) * elimGcdRightDiv = 0
                    & elimGcdLeftDiv = elimGcdRightDiv)
                \else(elimGcdLeft = elimGcdRight))
        \heuristics(polySimp_pullOutGcd, notHumanReadable)
    };

    elimGcdLeq {
        \find(elimGcdLeft <= elimGcdRight)
        \replacewith(\if(1 - elimGcd
                + (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
                + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                <= 0
                & (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
                + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                >= 0)
                \then(elimGcdLeftDiv <= elimGcdRightDiv)
                \else(elimGcdLeft <= elimGcdRight))
        \heuristics(inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_leq, notHumanReadable)
    };

    elimGcdGeq {
        \find(elimGcdLeft >= elimGcdRight)
        \replacewith(\if(elimGcd - 1
                + (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
                + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                >= 0
                & (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
                + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                <= 0)
                \then(elimGcdLeftDiv >= elimGcdRightDiv)
                \else(elimGcdLeft >= elimGcdRight))
        \heuristics(inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_geq, notHumanReadable)
    };

    elimGcdLeq_antec {
        \find(elimGcdLeft <= elimGcdRight ==>)
        \replacewith(elimGcd <= 0
            | -elimGcd
            + (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
            + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
            >= 0
            | elimGcdLeftDiv <= elimGcdRightDiv ==>)
        \heuristics(inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_leq, inEqSimp_pullOutGcd_antec, notHumanReadable)
    };

    elimGcdGeq_antec {
        \find(elimGcdLeft >= elimGcdRight ==>)
        \replacewith(elimGcd <= 0
            | elimGcd
            + (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
            + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
            <= 0
            | elimGcdLeftDiv >= elimGcdRightDiv ==>)
        \heuristics(inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_geq, inEqSimp_pullOutGcd_antec, notHumanReadable)
    };

}

// ---------------------------------------------------------------------------
// ------------- case distinctions on the sign of a term ---------------------
// ---------------------------------------------------------------------------

\rules {
    sign_case_distinction {
        "#signCasesLeft is negative":
            \add(signCasesLeft <= -1 ==>);
        "#signCasesLeft is zero":
            \add(signCasesLeft = 0 ==>);
        "#signCasesLeft is positive":
            \add(signCasesLeft >= 1 ==>)
        \heuristics(inEqSimp_signCases)
    };

    // ---------------------------------------------------------------------------
    // ------------- squares are always non-negative -----------------------------
    // ---------------------------------------------------------------------------

    add_non_neg_square {
        \add(squareFac * squareFac >= 0 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonNegSquares)
    };

    // ---------------------------------------------------------------------------
    // -------- operations defined using polynomials (division, modulo) ----------
    // ---------------------------------------------------------------------------


    //
    // Useful lemmas for elimination of inInt moduloInt chains
    //

    \lemma
    moduloIntIsInInt {
        \find(inInt(moduloInt(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    moduloLongIsInLong {
        \find(inLong(moduloLong(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    moduloShortIsInShort {
        \find(inShort(moduloShort(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    moduloByteIsInByte {
        \find(inByte(moduloByte(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    moduloCharIsInChar {
        \find(inChar(moduloChar(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

}

// ---------------------------------------------------------------------------
// ------------- introduce new symbols for basis transformations -------------
// ---------------------------------------------------------------------------

\rules(integerSimplificationRules:full) {
    newSym_eq {
        \find(newSymLeft * newSymLeftCoeff = newSymRight ==>)
        \varcond(\newDependingOn(l, newSymDef),
            \newDependingOn(l, newSymLeft))
        \add(newSymLeft = l + newSymDef ==>)
        \heuristics(polySimp_leftNonUnit,
            polySimp_newSym, polySimp_newSmallSym)
    };

}
