/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains the DECLARATIONS for heaps
// To find the RULES for heaps, please visit heapRules.key

\sorts {
    Field;
    Heap;
    \generic alphaObj \extends Object;
}

\functions {
    // select/store
    alpha alpha::select(Heap, Object, Field);


    /*! This function modifies a heap by changing the value in one location. It takes four arguments:

        1. The heap h which is to be modified
        2. The object o reference of the location which is to be modified
        3. The field of the location which is to be modified
        4. The value v which is to be written in the designated location.

        The result is a heap which coincides with h in all locations but in (o,f), where v is stored.
        In the theory of arrays, store is somtimes called "write".
        The field java.lang.Object::&lt;created&gt; cannot be updated using store; use "create". */
    Heap store(Heap, Object, Field, any);

    /*! This function modifies a heap by changing the createdness of one object.
        It takes two arguments:
        1. The heap h which is to be modified
        2. The object reference o for the object which is to be set created.
        The result is a heap which coincides with h in all locations but in (o,java.lang.Object::<created>),
        which has been set to true. There is no means to modify a heap by setting the createdness of an object to false.
    */
    Heap create(Heap, Object);
    Heap anon(Heap, LocSet, Heap);

    /*! This function modifies a heap by changing the value in one location. It takes three arguments:
        1. The heap h which is to be modified
        2. The location set s whose locations are to be modified
        3. The value v which is to be written in the designated locations.

        The result is a heap which coincides with h in all locations but in the locations in s where v is stored.
        The field java.lang.Object::&lt;created&gt; cannot be updated using memset; use "create". */
    Heap memset(Heap, LocSet, any);

    // default value for a field
    alpha alpha::defaultValue;

    // reading from final attributes (corresponds to select for non-final fields)
    alpha alpha::final(Object, Field);

    // fields

    /*!
        This function turns an integer into a field reference.

        Integers are used to access the entries of entries within arrays stored on the heap. This
        function provides the injection of the integer domain into that of the type Field. It is
        ensured that this image of arr is disjoint from any defined field constant.

        The array access a[i], for instance for an int-array a, becomes int::select(heap, a, arr(i)).
    */
    \unique Field arr(int);
    \unique Field java.lang.Object::<transient>;
    \unique Field java.lang.Object::<transactionConditionallyUpdated>;
    \unique Field java.lang.Object::<created>;
    \unique Field java.lang.Object::<initialized>;
    \unique Field alpha::<classPrepared>; // static
    \unique Field alpha::<classInitialized>; // static
    \unique Field alpha::<classInitializationInProgress>; // static
    \unique Field alpha::<classErroneous>; // static

    /*! array length

        The length of an array is not stored on the heap but is an inherent property of the object reference which denotes the array.
        Hence, this functions takes only one argument: the object reference whose length (as an array) is to be retrieved.
        This function always results in a non-negative value.
    */
    int length(Object);

    /*! A constant holding the object reference pointing to the Java null object.
        Quite the same as the keyword "null" in Java. */
    Null null;
}

\predicates {
    /*! This predicate takes an argument of type Heap. It is true if the following conditions hold for its the argument:
        1. Every location contains a reference to a created (in this heap) object or null.
        2. Every location set stored on the heap contains only created objects.
        3. Every location belonging to a declared Java field holds a value compatible with its type.
        4. Only finitely many objects are created on the heap.
    */
    wellFormed(Heap);

    /*!
        This predicate is true if the described array update is valid in Java.

        Java has the peculiarity of covariant array types. They allow an array assignment to fail at runtime (with an ArrayStoreException). This predicate deals with the issue in the logic.

        (tbd)
    */
    arrayStoreValid(any, any);


    nonNull(Heap, Object, int);

    // can be used to formulate assignable proof obligations in JML assert statements (via \dl_ escapes)
    assignable(Heap, Heap, LocSet);
}

\programVariables {
    Heap
    /*! This program variable holds to the current heap state.
        Its type is Heap. Any assignment statement in a modality modifies the value of this program variable
        and any expression reading from the heap within a Java modality refers to the heap stored
        in this program variable. */
    heap,
    savedHeap, permissions;
}
