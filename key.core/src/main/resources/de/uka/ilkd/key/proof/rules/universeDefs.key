\rules(programRules:Java) {
    // ---------------------------------------------------
    //   Introduction Rules
    // ---------------------------------------------------

    variableDeclarationPeer {
        \schemaVar \formula post;
        \schemaVar \program Variable #v, #v0;
        \schemaVar \program Type #t, #t0;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \schemaVar \program ProgramMethod #pm;

        \find(\modality{#allmodal}{.#pm@#t(#v).. @universe.qual.Peer #t0 #v0; ...}\endmodality (post))
        \sameUpdateLevel

        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \add(#v0 != null -> owner(#v) = owner(#v0) ==>)
        \addprogvars(#v0)

        \heuristics(simplify_prog, simplify_prog_subset)
        //\displayname "variableDeclaration"
    };

    variableDeclarationPeerAssign {
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \schemaVar \formula post;
        \schemaVar \program Variable #v0;
        \schemaVar \program Type #t;
        \schemaVar \program VariableInitializer #vi;
   
        \find(\modality{#allmodal}{.. @universe.qual.Peer #t #v0 = #vi; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. @universe.qual.Peer #t #v0; #v0 = #vi; ...}\endmodality (post))
   
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "variableDeclaration"
    };

    variableDeclarationRep {
        \schemaVar \formula post;
        \schemaVar \program Variable #v, #v0;
        \schemaVar \program Type #t, #t0;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \schemaVar \program ProgramMethod #pm;

        \find(\modality{#allmodal}{.#pm@#t(#v).. @universe.qual.Rep #t0 #v0; ...}\endmodality (post))

        \sameUpdateLevel
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \add(#v0 != null -> #v = owner(#v0) ==>)
        \addprogvars(#v0)

        \heuristics(simplify_prog, simplify_prog_subset)
        //\displayname "variableDeclaration"
    };

    variableDeclarationRepAssign {
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \schemaVar \formula post;
        \schemaVar \program Variable #v0;
        \schemaVar \program Type #t;
        \schemaVar \program VariableInitializer #vi;
   
        \find(\modality{#allmodal}{.. @universe.qual.Rep #t #v0 = #vi; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. @universe.qual.Rep #t #v0; #v0 = #vi; ...}\endmodality (post))
   
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "variableDeclaration"
    };


    //instanceCreationAssignmentRep {
    //    \schemaVar \modalOperator {diamond, box} #normal;
    //    \schemaVar \program LeftHandSide #lhs;
    //    \schemaVar \program SimpleInstanceCreation #n;
    //    \schemaVar \formula post;
    //    \schemaVar \program Variable #v0;
    //
    //    \find(==> \modality{#normal}{.. #lhs = #n; ...}\endmodality (post))
    //    \varcond(\newTypeOf(#v0, #lhs))
    //    \replacewith(==> \modality{#normal}{.. #typeof(#v0) #v0 = #create-object(#n);
    //                #constructor-call(#v0, #n);
    //                        #post-work(#v0);
    //            #lhs = #v0;
    //            ...}\endmodality (post))
    //    \heuristics(method_expand)
    //};
    instanceCreationAssignmentRep {
        \schemaVar \modalOperator {diamond} #diamond;
        \schemaVar \modalOperator {diamond, box} #normal;
        \schemaVar \formula post;
        \schemaVar \program ProgramMethod #pm;
        \schemaVar \program Type #t;
        \schemaVar \program SimpleInstanceCreation #n;
        \schemaVar \program LeftHandSide #lhs;
        \schemaVar \program Variable #v0, #v;
    
        \find(\modality{#normal}{.#pm@#t(#v).. #lhs = #n; ...}\endmodality (post))
        \sameUpdateLevel
    
        \varcond(\newTypeOf(#v0, #lhs), \hasAnnotation(#n, Rep))
    
        \replacewith(\modality{#normal}{.. #typeof(#v0) #v0 = #create-object(#n);
                    #constructor-call(#v0, #n);
                            #post-work(#v0);
                #lhs = #v0;
                ...}\endmodality (post))
        \add(#v0 != null -> #v = owner(#v0) ==>)
        \heuristics(method_expand)
    };

    peerField {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
    
        \find(alpha::select(h, o, f))
        \varcond(\hasAnnotation(f, Peer))
        \add(alpha::select(h, o, f) != null -> owner(Object::cast(o)) = owner(Object::cast(alpha::select(h, o, f))) ==>)
        \heuristics(simplify)
    };

    ownsField {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
    
        \find(alpha::select(h, o, f))
        \varcond(\hasAnnotation(f, Rep))
        \add(alpha::select(h, o, f) != null -> o = owner(Object::cast(alpha::select(h, o, f))) ==>)
        \heuristics(simplify)
    };

    //methodArgRep {
    //    \schemaVar \formula post;
    //    \schemaVar \modalOperator {diamond, diamond_transaction} #diamond;
    //    \schemaVar \program Variable #v0, #v1;
    //    \schemaVar \program MethodName #mn;
    //    \schemaVar \program [list] Expression #elist0, #elist1;
    //
    //    \find(==> \modality{#diamond}{.. #v0.#mn(#elist0, #v1, #elist1); ...}\endmodality (post))
    //    \replacewith(#v0 = owner(#v1) ==> \modality{#diamond}{.. #v0.#mn(#elist0, #v1, #elist1); ...}\endmodality (post))
    //};

    //ownsParameter {
    //    \schemaVar \term Object o;
    //    \schemaVar \term 
    //};


    // ---------------------------------------------------
    //    Predicate and Function definitions
    // ---------------------------------------------------

    dominatesDepthDef {
        \schemaVar \term Object x, y;
        \schemaVar \variables Object ov;
        \schemaVar \term int n;

        \find(dominatesDepth(x, y, n))
        \varcond(\notFreeIn(ov, x, y, n))
        \replacewith(\if (n <= 0) 
            \then(false)
            \else(\if (n = 1) \then(x = owner(y)) \else(\exists ov; (x = owner(ov) & dominatesDepth(ov, y, n - 1)))))
    };

    dominatesDef {
        \schemaVar \term Object x, y;
        \schemaVar \variables int n;

        \find(dominates(x, y))

        \varcond(\notFreeIn(n, x, y))
        \replacewith(\exists n; (dominatesDepth(x, y, n)))
    };


    undomDef {
        \schemaVar \term Object x, y;

        \find(undom(x, y))

        \replacewith(!dominates(x, y) & !dominates(y, x) & !(x = y))
    };

    dominatesSetDef {
        \schemaVar \term LocSet s;
        \schemaVar \term Object x;
        \schemaVar \variables Object o;
        \schemaVar \variables Field f;

        \find(dominatesSet(x, s))

        \varcond(\notFreeIn(o, s, x), \notFreeIn(f, s, x))
        \replacewith(\forall o; (\forall f; (elementOf(o, f, s) -> dominates(x, o))))
    };

    domfpDef {
        \schemaVar \term Object x;
        \schemaVar \variables Object y;

        \find(domfp(x))
        \varcond(\notFreeIn(y, x))
        \replacewith(infiniteUnion{y;}(\if(x = owner(y)) \then(repfp(y)) \else(empty)))
    };

    repfpDef {
        \schemaVar \term Object x;

        \find(repfp(x))
        \replacewith(union(domfp(x), x.*))
    };

    domfpDepthDef {
        \schemaVar \term Object x;
        \schemaVar \term int n;
        \schemaVar \variables Object y;

        \find(domfpDepth(x, n))

        \varcond(\notFreeIn(y, x, n))
        
        \replacewith(\if(n <= 0) \then(empty) \else(infiniteUnion{y;}(\if(x = owner(y)) \then(\if(n = 1) \then(y.*) \else(domfpDepth(y, n - 1))) \else(empty))))
    };

  
    // ---------------------------------------------------
    //    axioms for ownership
    // ---------------------------------------------------

    dominatesSelf {
        \schemaVar \term Object o;

        \find(dominates(o, o))

        \replacewith(false)

        \heuristics(concrete)
    };

    dominatesMaxDepth {
        \schemaVar \term Object x;  
        \schemaVar \variables Object y;  
        \schemaVar \variables int m, n;  

        \find(x)

        \varcond(\notFreeIn(y, x), \notFreeIn(m, x), \notFreeIn(n, x))

        \add(\exists n; (n >= 0 & (\forall y; (dominates(x, y) -> 
              (\exists m; (dominatesDepth(x, y, m) & m < n))))) ==>)
    };
}
