/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term any a, b;
    \term Set s, t, EQ;
}

\rules {

    // --------------------------------------------------------------------------
    // axioms for elementOf
    // --------------------------------------------------------------------------

    sEelementOfEmpty {
        \find(sElementOf(a, sEmpty))
        \replacewith(false)
        \heuristics(concrete)
    };

    sElementOfSingleton {
        \find(sElementOf(a, sSingleton(b)))
        \replacewith(a = b)
        \heuristics(simplify)
    };

    sElementOfUnion {
        \find(sElementOf(a, sUnion(s, t)))
        \replacewith(sElementOf(a, s) | sElementOf(a, t))
        \heuristics(simplify_enlarging)
    };

    sElementOfIntersect {
        \find(sElementOf(a, sIntersect(s, t)))
        \replacewith(sElementOf(a, s) & sElementOf(a, t))
        \heuristics(simplify_enlarging)
    };

    sElementOfSetMinus {
        \find(sElementOf(a, sSetMinus(s, t)))
        \replacewith(sElementOf(a, s) & !sElementOf(a, t))
        \heuristics(simplify_enlarging)
    };

    sElementOfInfiniteUnion {
        \schemaVar \variables alpha av;
        \find(sElementOf(a, sInfiniteUnion{av;}(s)))
        \varcond(\notFreeIn(av, a))
        \replacewith(\exists av; sElementOf(a, s))
        \heuristics(simplify)
    };

    // --------------------------------------------------------------------------
    // EQ versions of axioms (these are lemmata)
    // --------------------------------------------------------------------------
    sElementOfUnionEQ {
        \assumes(sUnion(s, t) = EQ ==>)
        \find(sElementOf(a, EQ))
        \sameUpdateLevel
        \replacewith(sElementOf(a, s) | sElementOf(a, t))
        \heuristics(simplify_enlarging)
    };

    sElementOfIntersectEQ {
        \assumes(sIntersect(s, t) = EQ ==>)
        \find(sElementOf(a, EQ))
        \sameUpdateLevel
        \replacewith(sElementOf(a, s) & sElementOf(a, t))
        \heuristics(simplify_enlarging)
    };

    sElementOfSetMinusEQ {
        \assumes(sSetMinus(s, t) = EQ ==>)
        \find(sElementOf(a, EQ))
        \sameUpdateLevel
        \replacewith(sElementOf(a, s) & !sElementOf(a, t))
        \heuristics(simplify_enlarging)
    };

    sElementOfInfiniteUnionEQ {
        \schemaVar \variables alpha av;
        \assumes(sInfiniteUnion{av;}(s) = EQ ==>)
        \find(sElementOf(a, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(av, a))
        \replacewith(\exists av; sElementOf(a, s))
        \heuristics(simplify)
    };

    //
    // axioms for cardinality
    //
    sCardNonNegative {
        \find(sCard(s))
        \sameUpdateLevel
        \add(sCard(s) >= 0 ==>)
        \heuristics(inReachableStateImplication)
    };

    sCardEmpty {
        \find(sCard(sEmpty))
        \replacewith(0)
        \heuristics(concrete)
    };

    sCardSingleton {
        \find(sCard(sSingleton(b)))
        \replacewith(1)
        \heuristics(simplify)
    };


    // --------------------------------------------------------------------------
    // axioms for set predicates (reduce to sElementOf)
    // --------------------------------------------------------------------------

    equalityTosElementOf {
        \schemaVar \variables any av;
        \find(s = t)
        \varcond(\notFreeIn(av, s, t))
        \replacewith(\forall av; (sElementOf(av, s) <-> sElementOf(av, t)))
        \heuristics(semantics_blasting)
    };

    sEmptyEqualsSingleton {
        \find(sEmpty = sSingleton(a))
        \replacewith(false)
        \heuristics(concrete)
    };

    sSingletonEqualsEmpty {
        \find(sSingleton(a) = sEmpty)
        \replacewith(false)
        \heuristics(concrete)
    };

    unionWithSingletonEqualsUnionWithSingleton {
        \find(sUnion(s, sSingleton(a)) = sUnion(t, sSingleton(a)))

        \replacewith(sSetMinus(s, sSingleton(a)) = sSetMinus(t, sSingleton(a)))
        // TODO: why is this a simplification? (DB)
        \heuristics(simplify)
    };

    unionWithSingletonEqualsUnionWithSingleton_2 {
        \find(sUnion(sSingleton(a), s) = sUnion(sSingleton(a), t))
        \replacewith(sSetMinus(s, sSingleton(a)) = sSetMinus(t, sSingleton(a)))
        \heuristics(simplify)
    };

    subsetTosElementOf {
        \schemaVar \variables any av;
        \find(sSubset(s, t))
        \varcond(\notFreeIn(av, s, t))
        \replacewith(\forall av; (sElementOf(av, s) -> sElementOf(av, t)))
        \heuristics(semantics_blasting)
        //        \heuristics(simplify)
    };

    /*
    // proven with KeY (CS)
    subsetTosElementOfRight {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find( ==> subset(s, s2))
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith( ==> \forall ov; \forall fv; (sElementOf(ov, fv, s) -> sElementOf(ov, fv, s2)))

        \heuristics(setEqualityBlastingRight)
    };

    // proven with KeY (CS)
    elementOfSubsetImpliesElementOfSuperset {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(s, s2) ==>)

        \find(elementOf(o, f, s) ==>)

        \add(elementOf(o, f, s2) ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    noElementOfSupersetImpliesNoElementOfSubset {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(s, s2) ==>)
        \find( ==> elementOf(o, f, s2))
        \add( ==> elementOf(o, f, s))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetSingletonLeft {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(subset(singleton(o, f), s))

        \replacewith(elementOf(o, f, s))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonLeftEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(subset(EQ, s))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonRight {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(subset(s, singleton(o, f)))

        \replacewith(s = empty | s = singleton(o, f))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonRightEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(s = empty | s = singleton(o, f))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetUnionLeft {
        \schemaVar \term LocSet s, s2, s3;

        \find(subset(union(s, s2), s3))

        \replacewith(subset(s, s3) & subset(s2, s3))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetUnionLeftEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(subset(EQ, s3))
        \sameUpdateLevel

        \replacewith(subset(s, s3) & subset(s2, s3))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelf1 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, union(s, s2)))

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelfEQ1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelf2 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, union(s2, s)))

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelfEQ2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s2, s) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelf1 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, intersect(s, s2)))

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelfEQ1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s, s2) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelf2 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, intersect(s2, s)))

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelfEQ2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s2, s) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    elementOfSubsetOfUnion1 {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \assumes(subset(s, union(s2, s3)),
            ==> elementOf(o, f, s2))
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \add(elementOf(o, f, s) <-> elementOf(o, f, intersect(s, s3)) ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    elementOfSubsetOfUnion2 {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \assumes(subset(s, union(s2, s3)),
            ==> elementOf(o, f, s3))
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \add(elementOf(o, f, s) <-> elementOf(o, f, intersect(s, s2)) ==>)

        \heuristics(simplify_enlarging)
    };

    disjointToElementOf {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(disjoint(s, s2))
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith(\forall ov; \forall fv; (!elementOf(ov, fv, s) | !elementOf(ov, fv, s2)))
        \heuristics(semantics_blasting)
        //        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointDefinition {
        \schemaVar \term LocSet s, s2;

        \find(disjoint(s, s2))

        \replacewith(intersect(s, s2) = empty)
        // \heuristics(semantics_blasting)
        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointNotInOtherLocset1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(s, s2) = empty ==>)
        \find(elementOf(o, f, s) ==>)

        \add( ==> elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointNotInOtherLocset2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(s, s2) = empty ==>)
        \find(elementOf(o, f, s2) ==>)

        \add( ==> elementOf(o, f, s))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset1 {
        \schemaVar \term LocSet s, s2, s3;

        \assumes(intersect(s2, s3) = empty ==>)
        \find(subset(s, s2) ==>)

        \add(intersect(s, s3) = empty ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset2 {
        \schemaVar \term LocSet s, s2, s3;

        \assumes(intersect(s2, s3) = empty ==>)
        \find(subset(s, s3) ==>)

        \add(intersect(s, s2) = empty ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointInfiniteUnion {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables int iv;

        \find(intersect(infiniteUnion{iv;}(s2), s) = empty)
        \varcond(\notFreeIn(iv, s))

        \replacewith(\forall iv; (intersect(s2, s) = empty))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointInfiniteUnion_2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables int iv;

        \find(intersect(s, infiniteUnion{iv;}(s2)) = empty)
        \varcond(\notFreeIn(iv, s))

        \replacewith(\forall iv; (intersect(s, s2) = empty))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointAndSubset_3 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s1, s2) = empty ==>)
        \find(subset(s4, union(s2, s3)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_4 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s1, s2) = empty ==>)
        \find(subset(s4, union(s3, s2)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_5 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s2, s1) = empty ==>)
        \find(subset(s4, union(s2, s3)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_6 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s2, s1) = empty ==>)
        \find(subset(s4, union(s3, s2)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    createdInHeapToElementOf {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(createdInHeap(s, h))
        \varcond(\notFreeIn(ov, s, h), \notFreeIn(fv, s, h))

        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s)
                -> ov = null
                | boolean::select(h, ov, java.lang.Object::<created>) = TRUE))
        \heuristics(classAxiom)
    };

    // --------------------------------------------------------------------------
    // equality rules
    // --------------------------------------------------------------------------

    // Proven in KeY (DD: 2025-02-20)
    \lemma
    equalityOfSingleton {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Field f1, f2;

        \find(singleton(o1, f1) = singleton(o2, f2))

        \replacewith(o1 = o2 & f1 = f2)

        \heuristics(simplify)
    };

    // --------------------------------------------------------------------------
    // lemmata for empty and allLocs
    // --------------------------------------------------------------------------

    unionWithEmpty {
        \schemaVar \term LocSet s;

        \find(union(empty, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    unionWithAllLocs {
        \schemaVar \term LocSet s;

        \find(union(allLocs, s))

        \replacewith(allLocs)

        \heuristics(concrete)
    };

    intersectWithEmpty {
        \schemaVar \term LocSet s;

        \find(intersect(empty, s))

        \replacewith(empty)

        \heuristics(concrete)
    };

    intersectWithAllLocs {
        \schemaVar \term LocSet s;

        \find(intersect(allLocs, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    // the following set of rules should be the only one needed
    // for empty elimination as the strategies take care to commute the
    // the empty set always on the second place
    // the other rules are left for backward proof loading copatibility
    // begin
    unionWithEmptyRight {
        \schemaVar \term LocSet s;

        \find(union(s, empty))

        \replacewith(s)

        \displayname "unionWithEmpty"
        \heuristics(concrete)
    };

    unionWithAllLocsRight {
        \schemaVar \term LocSet s;

        \find(union(s, allLocs))

        \replacewith(allLocs)

        \displayname "unionWithAllLocs"
        \heuristics(concrete)
    };

    intersectWithEmptyRight {
        \schemaVar \term LocSet s;

        \find(intersect(s, empty))

        \replacewith(empty)

        \displayname "intersectWithEmpty"
        \heuristics(concrete)
    };

    intersectWithAllLocsRight {
        \schemaVar \term LocSet s;

        \find(intersect(s, allLocs))

        \replacewith(s)

        \displayname "intersectWithAllLocs"

        \heuristics(concrete)
    };

    //  end

    setMinusWithEmpty1 {
        \schemaVar \term LocSet s;

        \find(setMinus(s, empty))

        \replacewith(s)

        \displayname "setMinusWithEmpty"
        \heuristics(concrete)
    };

    setMinusWithEmpty2 {
        \schemaVar \term LocSet s;

        \find(setMinus(empty, s))

        \replacewith(empty)

        \displayname "setMinusWithEmpty"
        \heuristics(concrete)
    };

    setMinusWithAllLocs {
        \schemaVar \term LocSet s;

        \find(setMinus(s, allLocs))

        \replacewith(empty)

        \displayname "setMinusWithAllLocs"
        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // lemmata for subset
    // --------------------------------------------------------------------------

    subsetWithEmpty {
        \schemaVar \term LocSet s;

        \find(subset(empty, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    subsetOfEmpty {
        \schemaVar \term LocSet s;

        \find(subset(s, empty))

        \replacewith(s = empty)

        \heuristics(concrete)
    };

    subsetWithAllLocs {
        \schemaVar \term LocSet s;

        \find(subset(s, allLocs))

        \replacewith(true)

        \displayname "subsetOfAllLocs" // should be the name, but for backward compatibility only displayname
        \heuristics(concrete)
    };

    subsetWithAllLocs2 {
        \schemaVar \term LocSet s;

        \find(subset(allLocs, s))
        \replacewith(s = allLocs)

        \displayname "subsetWithAllLocs"
        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // lemmata for disjoint
    // --------------------------------------------------------------------------

    disjointWithEmpty {
        \schemaVar \term LocSet s;

        \find(disjoint(empty, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    disjointWithSingleton1 {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \find(intersect(s, singleton(o, f)) = empty)
        \replacewith(!elementOf(o, f, s))
        \heuristics(simplify)
        \displayname "disjointWithSingleton"
    };

    \lemma
    disjointWithSingleton2 {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \find(intersect(singleton(o, f), s) = empty)
        \replacewith(!elementOf(o, f, s))
        \heuristics(simplify)
        \displayname "disjointWithSingleton"
    };

    // --------------------------------------------------------------------------
    // other lemmata for proving createdness
    // --------------------------------------------------------------------------

    referencedObjectIsCreatedRight {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes( ==> deltaObject::select(h, o, f) = null)
        \find( ==> boolean::select(h,
                deltaObject::select(h, o, f),
                java.lang.Object::<created>) = TRUE)

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    referencedObjectIsCreatedRightEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Object EQ;

        \assumes(deltaObject::select(h, o, f) = EQ ==> EQ = null)
        \find( ==> boolean::select(h,
                EQ,
                java.lang.Object::<created>) = TRUE)

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    referencedObjectIsCreatedRightFinal {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes( ==> deltaObject::final(o, f) = null)
        \find( ==> boolean::select(h,
                deltaObject::final(o, f),
                java.lang.Object::<created>) = TRUE )

        \replacewith( ==> boolean::select(h, o, java.lang.Object::<created>) = TRUE | o = null )

        \heuristics(simplify_enlarging)
    };

    referencedObjectIsCreatedRighFinalEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Object EQ;

        \assumes(deltaObject::final(o, f) = EQ ==> EQ = null)
        \find( ==> boolean::select(h,
                EQ,
                java.lang.Object::<created>) = TRUE)

        \add( ==> boolean::select(h, o, java.lang.Object::<created>) = TRUE | o = null )

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // some other lemmata
    // --------------------------------------------------------------------------

    // proven with KeY (CS)
    unionEqualsEmpty {
        \schemaVar \term LocSet s, s2, s3;

        \find(union(s, s2) = empty)

        \replacewith(s = empty & s2 = empty)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    unionEqualsEmptyEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(EQ = empty)
        \sameUpdateLevel

        \replacewith(s = empty & s2 = empty)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    setMinusOfUnion {
        \schemaVar \term LocSet s, s2, s3;

        \find(setMinus(union(s, s2), s3))

        \replacewith(union(setMinus(s, s3), setMinus(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    setMinusOfUnionEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(setMinus(EQ, s3))
        \sameUpdateLevel

        \replacewith(union(setMinus(s, s3), setMinus(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetWithSetMinusLeft {
        \schemaVar \term LocSet s, s2, s3;

        \find(subset(setMinus(s, s2), s3))

        \replacewith(subset(s, union(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetWithSetMinusLeftEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, s2) = EQ ==>)
        \find(subset(EQ, s3))
        \sameUpdateLevel

        \replacewith(subset(s, union(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    unionWithItself {
        \schemaVar \term LocSet s;

        \find(union(s, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    intersectWithItself {
        \schemaVar \term LocSet s;

        \find(intersect(s, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    // one of the two below should be obsolete after completing term ordering (not yet done)
    distributeIntersection {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(s1, union(s2, s3)))

        \replacewith(union(intersect(s1, s2), intersect(s1, s3)))

        \heuristics(simplify_enlarging)
    };

    distributeIntersection_2 {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(union(s2, s3), s1))

        \replacewith(union(intersect(s2, s1), intersect(s3, s1)))

        \heuristics(simplify_enlarging)
    };

    intersectWithSingleton {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(intersect(singleton(o, f), s))

        \replacewith(\if(elementOf(o, f, s)) \then(singleton(o, f)) \else(empty))

        \heuristics(simplify_enlarging)
    };

    setMinusItself {
        \schemaVar \term LocSet s;

        \find(setMinus(s, s))

        \replacewith(empty)

        \heuristics(concrete)
    };

    setMinusSingleton {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes( ==> elementOf(o, f, s))

        \find(setMinus(s, singleton(o, f)))

        \replacewith(s)

        \heuristics(simplify)
    };

    intersectionSetMinusItself {
        \schemaVar \term LocSet s1, s2;

        \find(intersect(setMinus(s1, s2), s2))

        \replacewith(empty)

        \heuristics(concrete)
    };

    intersectionSetMinusItself_2 {
        \schemaVar \term LocSet s1, s2;

        \find(intersect(s2, setMinus(s1, s2)))

        \replacewith(empty)

        \heuristics(concrete)
    };

    unionIntersectItself {
        \schemaVar \term LocSet s1, s2;

        \find(union(intersect(s1, s2), s1))

        \replacewith(s1)

        \heuristics(simplify)
    };

    unionIntersectItself_2 {
        \schemaVar \term LocSet s1, s2;

        \find(union(intersect(s2, s1), s1))

        \replacewith(s1)

        \heuristics(simplify)
    };

    unionIntersectItself_3 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(s, intersect(s1, s2)), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_4 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(s, intersect(s2, s1)), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_5 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(intersect(s1, s2), s), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_6 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(intersect(s2, s1), s), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    infiniteUnionUnused {
        \schemaVar \variables alpha av;
        \schemaVar \term LocSet s;

        \find(infiniteUnion{av;}(s))
        \varcond(\notFreeIn(av, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    subsetOfItself {
        \schemaVar \term LocSet s;

        \find(subset(s, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    // really needed for efficiency?
    elementOfGuardedSet {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \formula phi;
        \schemaVar \term LocSet s;

        \find(elementOf(o, f, \if(phi) \then(s) \else(empty)))

        \replacewith(phi & elementOf(o, f, s))

        \heuristics(concrete)
    };

    commuteDisjoint {
        \schemaVar \term LocSet commLeft, commRight;

        \find(disjoint(commLeft, commRight))
        \replacewith(disjoint(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteUnion {
        \schemaVar \term LocSet commLeft, commRight;

        \find(union(commLeft, commRight))

        \replacewith(union(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteUnion_2 {
        \schemaVar \term LocSet commLeft, commRight, s;

        \find(union(union(s, commLeft), commRight))

        \replacewith(union(union(s, commRight), commLeft))

        \heuristics(cnf_setComm)
    };

    commuteIntersection {
        \schemaVar \term LocSet commLeft, commRight;

        \find(intersect(commLeft, commRight))

        \replacewith(intersect(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteIntersection_2 {
        \schemaVar \term LocSet commLeft, commRight, s;

        \find(intersect(intersect(s, commLeft), commRight))

        \replacewith(intersect(intersect(s, commRight), commLeft))

        \heuristics(cnf_setComm)
    };

    associativeLawUnion {
        \schemaVar \term LocSet s1, s2, s3;

        \find(union(s1, union(s2, s3)))

        \replacewith(union(union(s1, s2), s3))

        \heuristics(conjNormalForm)
    };

    associativeLawIntersect {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(s1, intersect(s2, s3)))

        \replacewith(intersect(intersect(s1, s2), s3))

        \heuristics(conjNormalForm)
    };
    */
}
