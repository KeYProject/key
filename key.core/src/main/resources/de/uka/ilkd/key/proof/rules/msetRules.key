\sorts {
    Mset;
    \generic alpha, beta;
}

\functions {
    // Getters
    int msetMul(Mset, any);
    int msetCard(Mset);

    // Constructors
    Mset msetEmpty;
    Mset msetSingle(any);
    Mset msetUnion(Mset, Mset);
    Mset msetIntersec(Mset, Mset);
    Mset msetDiff(Mset, Mset);
    Mset msetSum(Mset, Mset);
    Mset msetRange {false, false, true}(int, int, any);
}

\rules {

    mset_Empty {
        \schemaVar \term int left, right;
        \schemaVar \variables int uSub;
        \schemaVar \term beta t;

        \find(msetRange{uSub;}(left, right, t))
        \varcond(\notFreeIn(uSub, left))
        \replacewith(\if(right < left)
            \then(msetEmpty)
            \else(msetRange{uSub;}(left, right, t)))

        \heuristics(out_of_bounds)
    };

    mset_Single {
        \schemaVar \term int left;
        \schemaVar \variables int uSub;
        \schemaVar \term beta t;

        \find(msetRange{uSub;}(left, left, t))
        \sameUpdateLevel
        \replacewith(msetSingle({\subst uSub; left}(t)))
        \heuristics(simplify)
    };

    msetUnionWithMSetEmpty1 {
        \find(msetUnion(msetEmpty, msetEmpty))
        \replacewith(msetEmpty)
        \heuristics(simplify)
        \displayname "msetUnionWithEmpty"
    };

    msetUnionWithMSetEmpty2 {
        \schemaVar \term Mset m;
        \find(msetUnion(m, msetEmpty))
        \replacewith(m)
        \heuristics(simplify)
        \displayname "msetUnionWithEmpty"
    };

    msetUnionWithSameMSets {
        \schemaVar \term Mset m;
        \find(msetUnion(m, m))
        \replacewith(m)
        \heuristics(simplify)
    };

    msetUnionCommutativity {
        \schemaVar \term Mset commLeft, commRight;
        \find(msetUnion(commLeft, commRight))
        \replacewith(msetUnion(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    msetUnionAssociativity {
        \schemaVar \term Mset addAssocPoly0, addAssocPoly1, addAssocMono;
        \find(msetUnion(addAssocPoly0, msetUnion(addAssocPoly1, addAssocMono)))
        \replacewith(msetUnion(msetUnion(addAssocPoly0, addAssocPoly1), addAssocMono))
        \heuristics(polySimp_expand, polySimp_addAssoc)
    };

    msetUnionWithMSetIntersection {
        \schemaVar \term Mset m, s;
        \find(msetUnion(m, msetIntersec(m, s)))
        \replacewith(m)
        \heuristics(simplify)
    };

    msetUnionSubset {
        \schemaVar \term Mset m, s;
        \schemaVar \term any msetEl;

        \find(msetUnion(m, s))
        \replacewith(\if(msetMul(m, msetEl) > 0 & msetMul(s, msetEl) > 0 & msetIntersec(m, s) = s)
            \then(m)
            \else(msetUnion(m, s)))
        \heuristics(simplify)
    };

    msetIntersectionWithMSetEmpty1 {
        \find(msetIntersec(msetEmpty, msetEmpty))
        \replacewith(msetEmpty)
        \heuristics(simplify)
        \displayname "msetIntersecWithEmpty"
    };

    msetIntersectionWithMSetEmpty2 {
        \schemaVar \term Mset m;
        \find(msetIntersec(m, msetEmpty))
        \replacewith(msetEmpty)
        \heuristics(simplify)
        \displayname "msetIntersecWithEmpty"
    };

    msetIntersecWithSameMSets {
        \schemaVar \term Mset m;
        \find(msetIntersec(m, m))
        \replacewith(m)
        \heuristics(simplify)
    };

    msetIntersecCommutativity {
        \schemaVar \term Mset commLeft, commRight;
        \find(msetIntersec(commLeft, commRight))
        \replacewith(msetIntersec(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    msetIntersecDifferent {
        \schemaVar \term Mset m, s;
        \schemaVar \term any msetEl;

        \find(msetIntersec(m, s))
        \replacewith(\if(msetMul(m, msetEl) > 0 & msetMul(s, msetEl) = 0)
            \then(msetEmpty)
            \else(msetIntersec(m, s)))
        \heuristics(simplify)
    };

    msetIntersecSubset {
        \schemaVar \term Mset m, s;
        \schemaVar \term any msetEl;

        \find(msetIntersec(m, s))
        \replacewith(\if(msetMul(m, msetEl) > 0 & msetMul(s, msetEl) > 0 & msetUnion(m, s) = m)
            \then(s)
            \else(msetIntersec(m, s)))
        \heuristics(simplify)
    };

    msetIntersecWithMSetUnion {
        \schemaVar \term Mset m, s, t;
        \find(msetIntersec(m, msetUnion(s, t)))
        \replacewith(msetUnion(msetIntersec(m, s), msetIntersec(m, t)))
        \heuristics(simplify)
    };

    msetSumWithMSetEmpty1 {
        \schemaVar \term Mset m;
        \find(msetSum(msetEmpty, m))
        \replacewith(m)
        \heuristics(simplify)
        \displayname "msetSumWithEmpty"
    };

    msetSumWithMSetEmpty2 {
        \schemaVar \term Mset m;
        \find(msetSum(m, msetEmpty))
        \replacewith(m)
        \heuristics(simplify)
        \displayname "msetSumWithEmpty"
    };

    msetSumCommutativity {
        \schemaVar \term Mset commLeft, commRight;
        \find(msetSum(commLeft, commRight))
        \replacewith(msetSum(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    msetSumAssociativity {
        \schemaVar \term Mset addAssocPoly0, addAssocPoly1, addAssocMono;
        \find(msetSum(addAssocPoly0, msetSum(addAssocPoly1, addAssocMono)))
        \replacewith(msetSum(msetSum(addAssocPoly0, addAssocPoly1), addAssocMono))
        \heuristics(polySimp_expand, polySimp_addAssoc)
    };

    msetDiffWithMSetEmpty1 {
        \find(msetDiff(msetEmpty, msetEmpty))
        \replacewith(msetEmpty)
        \heuristics(simplify)
        \displayname "msetDiffWithEmpty"
    };

    msetDiffWithMSetEmpty2 {
        \schemaVar \term Mset m;
        \find(msetDiff(m, msetEmpty))
        \replacewith(m)
        \heuristics(simplify)
        \displayname "msetDiffWithEmpty"
    };

    msetDiffCommutativity {
        \schemaVar \term Mset commLeft, commRight;
        \find(msetDiff(commLeft, commRight))
        \replacewith(msetDiff(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    mset_split {
        \schemaVar \term int left, right;
        \schemaVar \term int middle;
        \schemaVar \variables int uSub;
        \schemaVar \term beta t;

        \find(msetRange{uSub;}(left, right, t))
        \varcond(\notFreeIn(uSub, left), \notFreeIn(uSub, middle), \notFreeIn(uSub, right))
        \replacewith(\if(left <= middle & middle <= right)
                     \then(msetSum(msetRange{uSub;}(left, middle-1, t),
                                   msetRange{uSub;}(middle, right, t)))
                     \else(msetRange{uSub;}(left, right, t)))
    };

    mset_extract_triggered {
        \schemaVar \term int left, right;
        \schemaVar \term int middle;
        \schemaVar \variables int uSub;
        \schemaVar \term Heap h;
        \schemaVar \term Object array;

        \find(msetRange{uSub;}(left, right, beta::select(h, array, arr(uSub))))
        \varcond(\notFreeIn(uSub, left), \notFreeIn(uSub, middle), \notFreeIn(uSub, right), \notFreeIn(uSub, h), \notFreeIn(uSub, array))
        \replacewith(\if(left <= middle & middle <= right)
                     \then(msetSum(msetSum(msetRange{uSub;}(left, middle-1, beta::select(h, array, arr(uSub))),
                                           msetSingle(beta::select(h, array, arr(middle)))),
                                   msetRange{uSub;}(middle+1, right, beta::select(h, array, arr(uSub)))))
                     \else(msetRange{uSub;}(left, right, beta::select(h, array, arr(uSub)))))
        \heuristics(comprehension_split, triggered)
        \trigger {middle} msetSingle(beta::select(h, array, arr(middle)))
        \avoid middle <= -1 + left, right <= -1 + middle;
    };

    mset_extract_array {
        \schemaVar \term int left, right;
        \schemaVar \term int middle;
        \schemaVar \term Heap h;
        \schemaVar \term Object array;
        \schemaVar \variables int uSub;
        \schemaVar \term alpha x;

        \find(msetRange{uSub;}(left, right, beta::select(store(h, array, arr(middle), x), array, arr(uSub))))
        \varcond(\notFreeIn(uSub, left), \notFreeIn(uSub, middle), \notFreeIn(uSub, right))
        \replacewith(\if(left <= middle & middle <= right)
                     \then(msetSum(msetSum(msetRange{uSub;}(left, middle-1, beta::select(h, array, arr(uSub))),
                                           msetSingle({\subst uSub; middle} x)),
                                   msetRange{uSub;}(middle+1, right, beta::select(h, array, arr(uSub)))))
                     \else(msetRange{uSub;}(left, right, beta::select(h, array, arr(uSub)))))
        \heuristics(simplify_ENLARGING)
    };

    mset_extract_array_front {
        \schemaVar \term int left, right;
        \schemaVar \variables int uSub;
        \schemaVar \term Heap h;
        \schemaVar \term Object array;
        \schemaVar \term alpha x;

        \find(msetRange{uSub;}(left, right, beta::select(store(h, array, arr(left), x), array, arr(uSub))))
        \varcond(\notFreeIn(uSub, left), \notFreeIn(uSub, right))
        \replacewith(msetSum(msetSingle({\subst uSub; left} x),
                             msetRange{uSub;}(left+1, right, beta::select(h, array, arr(uSub)))))
        \heuristics(simplify_enlarging)
    };

    mset_extract_array_back {
        \schemaVar \term int left, right;
        \schemaVar \variables int uSub;
        \schemaVar \term Heap h;
        \schemaVar \term Object array;
        \schemaVar \term alpha x;

        \find(msetRange{uSub;}(left, right, beta::select(store(h, array, arr(right), x), array, arr(uSub))))
        \varcond(\notFreeIn(uSub, left), \notFreeIn(uSub, right))
        \replacewith(msetSum(msetRange{uSub;}(left, right-1, beta::select(h, array, arr(uSub))),
                             msetSingle({\subst uSub; right} x)))
        \heuristics(simplify_enlarging)
    };

    mset_extract_triggered_front {
        \schemaVar \term int low, high;
        \schemaVar \variables int uSub;
        \schemaVar \term Heap h;
        \schemaVar \term Object array;

        \find(msetRange{uSub;}(low, high, beta::select(h, array, arr(uSub))))
        \varcond(\notFreeIn(uSub, low), \notFreeIn(uSub, high), \notFreeIn(uSub, h), \notFreeIn(uSub, array))
        \replacewith(msetSum(msetSingle(beta::select(h, array, arr(low))),
                             msetRange{uSub;}(low+1, high, beta::select(h, array, arr(uSub)))))
        \heuristics(comprehension_split, triggered)
        \trigger {low} msetSingle(beta::select(h, array, arr(low)))
        \avoid low >= high, false;
    };

    mset_extract_triggered_back {
        \schemaVar \term int low, high;
        \schemaVar \variables int uSub;
        \schemaVar \term Heap h;
        \schemaVar \term Object array;

        \find(msetRange{uSub;}(low, high, beta::select(h, array, arr(uSub))))
        \varcond(\notFreeIn(uSub, low), \notFreeIn(uSub, high), \notFreeIn(uSub, h), \notFreeIn(uSub, array))
        \replacewith(msetSum(msetSingle(beta::select(h, array, arr(high))),
                             msetRange{uSub;}(low, high-1, beta::select(h, array, arr(uSub)))))
        \heuristics(comprehension_split, triggered)
        \trigger {high} msetSingle(beta::select(h, array, arr(high)))
        \avoid high <= low, false;
    };
}
