\sorts {
    Mset;
    \generic alpha, beta;
}

\functions {
    // Getters
    int msetMul(Mset, any);
    int msetCard(Mset);

    // Constructors
    Mset msetEmpty;
    Mset msetSingle(any);
    Mset msetUnion(Mset, Mset);
    Mset msetIntersec(Mset, Mset);
    Mset msetDiff(Mset, Mset);
    Mset msetSum(Mset, Mset);
    Mset msetRange {false, false, true}(int, int, any);
}

\rules {


    // Rule: mset_Empty
        mset_Empty {
                            \schemaVar \term int left, right;
                            \schemaVar \variables int uSub;
                             \schemaVar \term beta t;

            \find(msetRange{uSub;}(left, right ,t))
                            \varcond(\notFreeIn(uSub, left))
            \replacewith(\if(right < left)
            \then(msetEmpty)
            \else(msetRange{uSub;}(left, right, t)))

            \heuristics(out_of_bounds)

        };


    // Rule: mset_Single
    mset_Single {
                         \schemaVar \term int left;
                         \schemaVar \variables int uSub;
                         \schemaVar \term Heap h;
                         \schemaVar \term Object array;
        \find(msetRange{uSub;}(left, left, beta::select(h,array, arr(uSub))))
        \sameUpdateLevel
                        \varcond(\notFreeIn(uSub, left))
        \replacewith(msetSingle({\subst uSub; left}(beta::select(h,array, arr(uSub)))))
        \heuristics(simplify)
    };

    // Union Rules
    msetUnionWithMSetEmpty1 {
        \find(msetUnion(msetEmpty, msetEmpty))
        \replacewith(msetEmpty)
        \heuristics(simplify)
        \displayname "msetUnionWithEmpty"
    };

    msetUnionWithMSetEmpty2 {
        \schemaVar \term Mset m;
        \find(msetUnion(m, msetEmpty))
        \replacewith(m)
        \heuristics(simplify)
        \displayname "msetUnionWithEmpty"
    };

    msetUnionWithSameMSets {
        \schemaVar \term Mset m;
        \find(msetUnion(m, m))
        \replacewith(m)
        \heuristics(simplify)
    };

    msetUnionCommutativity {
        \schemaVar \term Mset commLeft, commRight;
        \find(msetUnion(commLeft, commRight))
        \replacewith(msetUnion(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    msetUnionAssociativity {
        \schemaVar \term Mset addAssocPoly0, addAssocPoly1, addAssocMono;
        \find(msetUnion(addAssocPoly0, msetUnion(addAssocPoly1, addAssocMono)))
        \replacewith(msetUnion(msetUnion(addAssocPoly0, addAssocPoly1), addAssocMono))
        \heuristics(polySimp_expand, polySimp_addAssoc)
    };

    msetUnionWithMSetIntersection {
        \schemaVar \term Mset m, s;
        \find(msetUnion(m, msetIntersec(m, s)))
        \replacewith(m)
        \heuristics(simplify)
    };

    msetUnionSubset {
        \schemaVar \term Mset m, s;
        \schemaVar \term any msetEl;

        \find(msetUnion(m, s))
        \replacewith(\if(msetMul(m, msetEl) > 0 & msetMul(s, msetEl) > 0 & msetIntersec(m, s) = s)
                     \then(m)
                     \else(msetUnion(m, s)))
        \heuristics(simplify)
    };

    // Intersection Rules
    msetIntersectionWithMSetEmpty1 {
        \find(msetIntersec(msetEmpty, msetEmpty))
        \replacewith(msetEmpty)
        \heuristics(simplify)
        \displayname "msetIntersecWithEmpty"
    };

    msetIntersectionWithMSetEmpty2 {
        \schemaVar \term Mset m;
        \find(msetIntersec(m, msetEmpty))
        \replacewith(msetEmpty)
        \heuristics(simplify)
        \displayname "msetIntersecWithEmpty"
    };

    msetIntersecWithSameMSets {
        \schemaVar \term Mset m;
        \find(msetIntersec(m, m))
        \replacewith(m)
        \heuristics(simplify)
    };

    msetIntersecCommutativity {
        \schemaVar \term Mset commLeft, commRight;
        \find(msetIntersec(commLeft, commRight))
        \replacewith(msetIntersec(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    msetIntersecDifferent {
        \schemaVar \term Mset m, s;
        \schemaVar \term any msetEl;

        \find(msetIntersec(m, s))
        \replacewith(\if(msetMul(m, msetEl) > 0 & msetMul(s, msetEl) = 0)
                     \then(msetEmpty)
                     \else(msetIntersec(m, s)))
        \heuristics(simplify)
    };

    msetIntersecSubset {
        \schemaVar \term Mset m, s;
        \schemaVar \term any msetEl;

        \find(msetIntersec(m, s))
        \replacewith(\if(msetMul(m, msetEl) > 0 & msetMul(s, msetEl) > 0 & msetUnion(m, s) = m)
                     \then(s)
                     \else(msetIntersec(m, s)))
        \heuristics(simplify)
    };

    msetIntersecWithMSetUnion {
        \schemaVar \term Mset m, s, t;
        \find(msetIntersec(m, msetUnion(s, t)))
        \replacewith(msetUnion(msetIntersec(m, s), msetIntersec(m, t)))
        \heuristics(simplify)
    };

    // Sum Rules
    msetSumWithMSetEmpty1 {
    \schemaVar \term Mset m;
        \find(msetSum(msetEmpty, m))
        \replacewith(m)
        \heuristics(simplify)
        \displayname "msetSumWithEmpty"
    };

    msetSumWithMSetEmpty2 {
        \schemaVar \term Mset m;
        \find(msetSum(m, msetEmpty))
        \replacewith(m)
        \heuristics(simplify)
        \displayname "msetSumWithEmpty"
    };

    msetSumCommutativity {
        \schemaVar \term Mset commLeft, commRight;
        \find(msetSum(commLeft, commRight))
        \replacewith(msetSum(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    msetSumAssociativity {
        \schemaVar \term Mset addAssocPoly0, addAssocPoly1, addAssocMono;
        \find(msetSum(addAssocPoly0, msetSum(addAssocPoly1, addAssocMono)))
        \replacewith(msetSum(msetSum(addAssocPoly0, addAssocPoly1), addAssocMono))
        \heuristics(polySimp_expand, polySimp_addAssoc)
    };

    // Difference Rules
    msetDiffWithMSetEmpty1 {
        \find(msetDiff(msetEmpty, msetEmpty))
        \replacewith(msetEmpty)
        \heuristics(simplify)
        \displayname "msetDiffWithEmpty"
    };

    msetDiffWithMSetEmpty2 {
        \schemaVar \term Mset m;
        \find(msetDiff(m, msetEmpty))
        \replacewith(m)
        \heuristics(simplify)
        \displayname "msetDiffWithEmpty"
    };

    msetDiffCommutativity {
        \schemaVar \term Mset commLeft, commRight;
        \find(msetDiff(commLeft, commRight))
        \replacewith(msetDiff(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    // Rule: mset_split
    mset_split {
        \schemaVar \term int left, right;
        \schemaVar \term int middle;
        \schemaVar \variables int uSub;
        \schemaVar \term beta t;

        \find(msetRange{uSub;}(left, right, t))
        \varcond(\notFreeIn(uSub, left),
                 \notFreeIn(uSub, middle),
                 \notFreeIn(uSub, right))
        \replacewith(\if(left <= middle & middle <= right)
                     \then(msetSum(msetRange{uSub;}(left, middle-1, t),
                                   msetRange{uSub;}(middle, right, t)))
                     \else(msetRange{uSub;}(left, right, t)))
    };


        mset_extract_triggered {
                \schemaVar \term int left, right;
                \schemaVar \term int middle;
                \schemaVar \variables int uSub;
                \schemaVar \term Heap h;
                \schemaVar \term Object array;

                \find(msetRange{uSub;}(left, right, beta::select(h,array, arr(uSub))))
                \varcond(\notFreeIn(uSub, left),
                         \notFreeIn(uSub, middle),
                         \notFreeIn(uSub, right),
                         \notFreeIn(uSub, h),
                         \notFreeIn(uSub, array))
                \replacewith(\if(left <= middle & middle <= right)
                             \then(msetSum(msetSum(msetRange{uSub;}(left, middle-1, beta::select(h,array, arr(uSub))),
                                                   msetSingle(beta::select(h,array, arr(middle)))),
                                           msetRange{uSub;}(middle+1, right, beta::select(h,array, arr(uSub)))))
                             \else(msetRange{uSub;}(left, right, beta::select(h,array, arr(uSub)))))
                \heuristics(comprehension_split, triggered)
                \trigger {middle} msetSingle(beta::select(h,array, arr(middle)))
               \avoid middle <= -1 + left, right <= -1 + middle;
            };



                       mset_extract_array {
                                \schemaVar \term int left, right;
                                \schemaVar \term int middle;
                                \schemaVar \term Heap h;
                                \schemaVar \term Object array;
                                \schemaVar \variables int uSub;
                                \schemaVar \term alpha x;

                                \find(msetRange{uSub;}(left, right, beta :: select(store(h, array, arr(middle), x), array, arr(uSub))))

                                \varcond(\notFreeIn(uSub, left),
                                         \notFreeIn(uSub, middle),
                                         \notFreeIn(uSub, right))

                                \replacewith(\if(left <= middle & middle <= right)
                                             \then(msetSum(msetSum(msetRange{uSub;}(left, middle-1, beta :: select(h, array, arr(uSub))),
                                                                   msetSingle({\subst uSub; middle}x)),
                                                           msetRange{uSub;}(middle+1, right, beta :: select(h, array, arr(uSub)))))
                                             \else(msetRange{uSub;}(left, right, beta :: select(h, array, arr(uSub)))))

                                \heuristics(simplify_ENLARGING)
                            };

                    mset_extract_array_front {
                        \schemaVar \term int left, right;
                        \schemaVar \variables int uSub;
                        \schemaVar \term Heap h;
                        \schemaVar \term Object array;
                            \schemaVar \term alpha x;

                           \find(msetRange{uSub;}(left, right, beta :: select(store(h, array, arr(left), x), array, arr(uSub))))

                        \varcond(\notFreeIn(uSub, left),
                                 \notFreeIn(uSub, right))

                        \replacewith(msetSum(msetSingle({\subst uSub; left}x),
                                             msetRange{uSub;}(left+1, right, beta::select(h, array, arr(uSub)))))

                        \heuristics(simplify_enlarging)
                    };

                    mset_extract_array_back {
                        \schemaVar \term int left, right;
                        \schemaVar \variables int uSub;
                        \schemaVar \term Heap h;
                        \schemaVar \term Object array;
                        \schemaVar \term alpha x;

                 \find(msetRange{uSub;}(left, right, beta :: select(store(h, array, arr(right), x), array, arr(uSub))))

                        \varcond(\notFreeIn(uSub, left),
                                 \notFreeIn(uSub, right))


                        \replacewith(msetSum(msetRange{uSub;}(left, right-1, beta::select(h, array, arr(uSub))),
                                             msetSingle({\subst uSub; right}x)))

                        \heuristics(simplify_enlarging)
                    };


            mset_extract_triggered_front {
                    \schemaVar \term int low, high;
                    \schemaVar \variables int uSub;
                    \schemaVar \term Heap h;
                    \schemaVar \term Object array;

                    \find(msetRange{uSub;}(low, high, beta::select(h,array, arr(uSub))))
                    \varcond(\notFreeIn(uSub, low),
                             \notFreeIn(uSub, high),
                             \notFreeIn(uSub, h),
                             \notFreeIn(uSub, array))
                    \replacewith(msetSum(msetSingle(beta::select(h,array, arr(low))),
                                         msetRange{uSub;}(low+1, high, beta :: select(h, array, arr(uSub)))))

                    \heuristics(comprehension_split, triggered)
                    \trigger {low} msetSingle(beta::select(h,array, arr(low)))
                    \avoid low >= high, false;
                };

                    mset_extract_triggered_back {
                        \schemaVar \term int low, high;
                        \schemaVar \variables int uSub;
                        \schemaVar \term Heap h;
                        \schemaVar \term Object array;

                        \find(msetRange{uSub;}(low, high, beta::select(h,array, arr(uSub))))
                        \varcond(\notFreeIn(uSub, low),
                                 \notFreeIn(uSub, high),
                                 \notFreeIn(uSub, h),
                                 \notFreeIn(uSub, array))
                        \replacewith(msetSum(msetSingle(beta::select(h,array, arr(high))),
                                             msetRange{uSub;}(low, high-1, beta :: select(h, array, arr(uSub)))))

                        \heuristics(comprehension_split, triggered)
                        \trigger {high} msetSingle(beta::select(h,array, arr(high)))
                        \avoid high <= low, false;
                    };



}
