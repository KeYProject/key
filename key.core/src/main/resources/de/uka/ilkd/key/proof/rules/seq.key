/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains only the DECLARATIONS.
// DEFINITIONS for the core theory of the sequence datatype are contained in
// seqCoreRules.key, further RULES in the files seqRules.key and seqPerm.key.
// The files seqRules.key and seqPerm.key also contain derivations from
// definitional rules, where applicable.

\sorts {
    Seq;
}

\predicates {
    seqPerm(Seq, Seq);
    seqNPerm(Seq);
}

\functions {
    // getters
    /*! Return the element at a position within a sequence. The type read from the sequence is part of the function name. */
    alpha alpha::seqGet(Seq, int);

    /*! Return the length of a sequence. */
    int seqLen(Seq);

    /*! Return the first index in a sequence that holds a value. */
    int seqIndexOf(Seq, any);
    /*! The underspecified error value if a sequence is accessed outside its idnex range. */
    any seqGetOutside;

    // constructors
    /*! The empty sequence. */
    Seq seqEmpty;
    /*! A singleton sequence that has the argument as only entry.*/
    Seq seqSingleton(any);

    /*! Concatenates two sequences. */
    Seq seqConcat(Seq, Seq);

    /*! Takes a subsequence from a sequence.
        The first argument is the original sequence,
        the second is the first index to consider (inclusive) and
        the third is the last index to consider (!exclusive!). */
    Seq seqSub(Seq, int, int);

    /*! Reverses a sequence. The result has the same entries as the argument but in reverse order. */
    Seq seqReverse(Seq);
    Seq seqUpd(Seq, int, any);

    /*! This function binds an integer variable and evaluates an expression over this variable
        for a range of values to obtain the entries of a sequence.

        The sequence
          `seqDef{int i;}(-2, 3, i*i)`
        has, for instance, the entries
          `[ 4, 1, 0, 1, 4 ]`.

        The first and second argument give the range over which the variable goes. Again, the right-hand bound is exclusive.

        seqDef is related to the lambda operator in lambda calculus. */
    Seq seqDef {false, false, true}(int, int, any);

    /*! Takes a sequence and two indices. The elements at the specified indices are exchanged in the resulting sequence. In case one of the indices is out of bounds, the sequence is left unchanged.*/
    Seq seqSwap(Seq, int, int);

    /*! Takes a sequence and removes the element at the specified index. In case the index is out of bounds, the sequence is left unchanged. */
    Seq seqRemove(Seq, int);

    /*! Takes a sequence of naturals (zero included) and treats it as a permutation. The resulting sequence is the inverse permutation of the original one. */
    Seq seqNPermInv(Seq);

    /*! Convert a Java array to a JavaDL sequence. */
    Seq array2seq(Heap, Object);

    // placeholder for values in enhanced for loop
    Seq values;

    // work-a-round to use \seq_def in JML set statements
    Seq seq_def_workaround(Heap, int, int, Object);
    Seq seq_def_workaround2(Heap, int, int, Object, LocSet);
}
