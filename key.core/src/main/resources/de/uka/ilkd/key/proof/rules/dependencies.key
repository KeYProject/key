\sorts {
   \generic U;
}

\schemaVariables{
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
}

//======================================================================================================================
// 												General Rules
//======================================================================================================================

\rules {

// to help with proving the loop invariant

  /* locSetAssSameRightDiffLeft{
        \schemaVar \term LocSet loc1, loc2, loc;

        \assumes(loc1 = loc ==>)
        \find(loc2 = loc ==>)
        \add(loc1 = loc2 ==>)

        \heuristics(simplify_ENLARGING)
    };*/


// unfold boundaries
	unfoldBounds {
		\schemaVar \term numbers a,b;
		\schemaVar \term int x;

		\assumes(x <= Z(b) ==>)
		\find(x >= Z(a) ==> )

		\replacewith( x=Z(a) ==>);

		\replacewith( x>=Z(a) + 1 ==>)

		\heuristics(dep_pred_unroll_fixed_bounds)

	};

	parallelUpdateAssociative {
	    \schemaVar \update u1, u2, u3;

	    \find (u1 || (u2 || u3))
	    \replacewith(u1 || u2 || u3)

	    \heuristics(simplify)

	};
}

//======================================================================================================================
//												Data Dependence Rules
//======================================================================================================================


\rules(programRules:Java, dependencies:on) {
  // Unwinding rules
   loopUnwind    {
            \schemaVar \program Statement #s;
            \schemaVar \program Expression #e;
            \schemaVar \formula post;
            \schemaVar \program Label #innerLabel, #outerLabel;


            \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
             \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
                 \replacewith ({timestamp := timestamp + 1}\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel,
                                       while(#e) #s); ...}\endmodality(post))
             \heuristics(loop_expand)
          };
}



\rules(programRules:Java, runtimeExceptions:ban, dependencies: on) {

//======================================================================================================================
//													Assignment Rules
//======================================================================================================================

	assignment  {
		\schemaVar \program Variable #loc;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
		\replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_read_attribute {
		\schemaVar \program Variable #v0, #v, #a;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
		\varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		\event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v=null))
		;
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_read_attribute_this {
		\schemaVar \program Variable #v0, #v, #a;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
		\varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		\replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		\event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	/* assignment_read_length {
	\schemaVar \program Variable #v0, #v;
	\schemaVar \formula post;

	\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
	\varcond(\not\isThisReference(#v))
	"Normal Execution (#v != null)":
	\replacewith(==> {#v0 := length(#v)}

	\modality{#allmodal}{.. ...}\endmodality(post))
	//\add (==>(#v=null))
	;
	"Null Reference (#v = null)":
	\replacewith(==> false)
	\add (#v=null ==>)
	\heuristics(simplify_prog, simplify_prog_subset)
	};*/


	assignment_write_attribute {

		\schemaVar \program Variable #v, #a;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
		\varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		\event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		//\add (==>(#v=null))
		;

		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment"
	};

	assignment_write_attribute_this {

		\schemaVar \program Variable #v, #a;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
		\varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		\replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		\event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentThis"
	};

//======================================================================================================================
//												Array Assignment Rules
//======================================================================================================================

	assignment_read_length {
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program ArrayLength #length;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {#v0 := length(#v)}
		//To Be Fixed. We need the LocSet here.
		/*{\event(read,singleton(length(#v)),timestamp)}
		{timestamp:=timestamp + 1}
		{\event(write,singleton(#v0),timestamp)}
		{timestamp:=timestamp + 1}*/
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v=null))
		;
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_array_read_EventUpdate{
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
		\varcond(\hasElementarySort(#v0, G))
		"Normal Execution (#v0 != null)":
		\replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}
		{\event(read,singleton(#v0,arr(#se)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
		;
		"Null Reference (#v0 = null)":
		\replacewith(==> false)
		\add (#v0=null ==>);
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
		\replacewith(==> false)
		\add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	//\rules(programRules:Java, runtimeExceptions:allow, dependencies:off) {
	//assignment_to_primitive_array_component {
	//\schemaVar \modalOperator { diamond, box } #normal;
	//\find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	//\varcond(\not \isReferenceArray(#v))
	//"Normal Execution (#v != null)":
	//\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
	//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
	//(permissions:on) {
	//"Write Permission to #v[#se]":
	//\replacewith(\modality{#normal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality(post))
	//\add(==> writePermission(Permission::select(permissions, #v, arr(#se))))
	//};
	//"Null Reference (#v = null)":
	//\replacewith(\modality{#normal}{..
	//throw new java.lang.NullPointerException();
	//...}\endmodality(post))
	//\add (#v=null ==>);
	//"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
	//\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
	//\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	//\heuristics(simplify_prog, simplify_prog_subset)
	//};
	//}

	assignment_to_primitive_array_component_EventUpdate {
		\schemaVar \program Variable #v;
		\schemaVar \program SimpleExpression #se,#se0;
		\schemaVar \formula post;

		\schemaVar \modalOperator { diamond, box } #normal;
		\find (==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
		\varcond(\not \isReferenceArray(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)}
		{\event(write,singleton(#v,arr(#se)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#normal}{.. ...}\endmodality(post))
		//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
		;
		(permissions:on) {
		"Write Permission to #v[#se]":
		\replacewith(==> writePermission(Permission::select(permissions, #v, arr(#se))))
		};
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>);
		"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		\replacewith(==> false)
		\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

//======================================================================================================================
//														Axioms
//======================================================================================================================

	noRaWOnEmptySet{

		\find(noRaW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaROnEmptySet{

		\find(noWaR(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaWOnEmptySet{

		\find(noWaW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWOnEmptySet{

		\find(noW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noROnEmptySet{

		\find(noR(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	rPredOnEmptySet{//New
		\schemaVar \term int id;

		\find(rPred(empty,id))
		\replacewith(false)

		\heuristics(concrete)
	};

	wPredOnEmptySet{//New
		\schemaVar \term int id;

		\find(wPred(empty,id))
		\replacewith(false)

		\heuristics(concrete)
	};

	noRAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noRAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noRaWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noRaWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaRAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWaRAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWaWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};
/*
    noRAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noRAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noRaWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noRaWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWaRAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWaRAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWaWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWaWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };*/
//======================================================================================================================
//	Update, Event Update, Inverse Event Update, Anon Update, and Inverse Anon Update  apply on each other
//======================================================================================================================
//-----------------------------------Apply UPDATE on
	applyUpdateOnEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term int ts;

	 	\find({u}(\event(rw, loc, ts)))

	 	\replacewith(\event({u}rw, {u}loc, {u}ts))

	 	\heuristics(update_apply_on_update)
	};

	applyUpdateOnInverseEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term int ts;

	 	\find({u}(\invEvUp(rw, loc, ts)))

	 	\replacewith(\invEvUp({u}rw, {u}loc, {u}ts))

	 	\heuristics(update_apply_on_update)
	};


    applyUpdateOnAnonEv {
        \schemaVar \update u;
        \schemaVar \term int counter;

        \find({u}\anonEvUp(counter))

        \replacewith(\anonEvUp({u}counter))

        \heuristics(update_apply_on_update)
    };

    applyUpdateOnInverseAnonEvent {
        \schemaVar \update u;
        \schemaVar \term int counter;

        \find({u}\invAnonEvUp(counter))

        \replacewith(\invAnonEvUp({u}counter))

        \heuristics(update_apply_on_update)
    };
//-----------------------------------Apply EVENT on
/*	applyEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term EventMarker rw;
        \schemaVar \term LocSet loc;
        \schemaVar \term int ts;

        \find({\event(rw, loc, ts)}(pv := t))

        \replacewith((pv := {\event(rw, loc, ts)}t))

        \heuristics(update_apply_on_update)
    };

    applyUpdateParallelToEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}(pv := t))

		\replacewith((pv := {u || \event(rw, loc, ts)}t))

		\heuristics(update_apply_on_update)//userTaclets1)
	};

	applyEventOnEvent {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term EventMarker rw1,rw2;
        \schemaVar \term int ts1,ts2;

        \find({\event(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))

        \replacewith(\event({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))

        \heuristics(update_apply_on_update)
    };

    applyEventOnInverseEvent {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term EventMarker rw1,rw2;
        \schemaVar \term int ts1,ts2;

        \find({\event(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))

        \replacewith(\invEvUp({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))

        \heuristics(update_apply_on_update)
    };

    applyEventOnInverseAnonEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\event(rw, loc, ts)}(\invAnonEvUp(counter)))

        \replacewith(\invAnonEvUp({\event(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

    applyEventOnAnonEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\event(rw, loc, ts)}(\anonEvUp(counter)))

        \replacewith(\anonEvUp({\event(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply INVERSE EVENT on
	applyInverseEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}(pv := t))

		\replacewith((pv := {\invEvUp(rw, loc, label)}t))

		\heuristics(update_apply_on_update)
	};

	applyUpdateParallelToInvEvUpOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \update u, invEvent;

		\find({u || invEvent}(pv := t))
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith((pv := {u || invEvent}t))

		\heuristics(update_apply_on_update)//userTaclets1)
	};

    applyInvEvUpParallelToUpdateOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \update u, invEvent;

        \find({invEvent || u}(pv := t))
        \varcond(\onlyInverseEventUpdates(invEvent))

        \replacewith((pv := {invEvent || u}t))

        \heuristics(update_apply_on_update)//userTaclets1)
    };

	applyInverseEventOnEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;

	 	\find({\invEvUp(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))

	 	\replacewith(\event({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))

	 	\heuristics(update_apply_on_update)
	};

	applyInverseEventOnInverseEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;

	 	\find({\invEvUp(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))

	 	\replacewith(\invEvUp({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))

	 	\heuristics(update_apply_on_update)
	};

    applyInverseEventOnAnonEv {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\invEvUp(rw, loc, ts)}(\anonEvUp(counter)))

        \replacewith(\anonEvUp({\invEvUp(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

    applyInverseEventOnInvAnonEv {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\invEvUp(rw, loc, ts)}(\invAnonEvUp(counter)))

        \replacewith(\invAnonEvUp({\invEvUp(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply ANON EVENT on

    applyAnonEventOnEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\anonEvUp(counter)}(\event(rw, loc, ts)))

        \replacewith(\event({\anonEvUp(counter)}rw, {\anonEvUp(counter)}loc, {\anonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };

    applyAnonEvOnInverseEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\anonEvUp(counter)}(\invEvUp(rw, loc, ts)))

        \replacewith(\invEvUp({\anonEvUp(counter)}rw, {\anonEvUp(counter)}loc, {\anonEvUp(counter)}ts ))

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnAnonEvent {
        \schemaVar \term int counter1, counter2;

        \find({\anonEvUp(counter1)}(\anonEvUp(counter2)))

        \replacewith(\anonEvUp({\anonEvUp(counter1)}counter2 ))

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnInvAnonEvent {//Replaced by two rules below to avoid to many branches
        \schemaVar \term int counter1, counter2;

        \find({\anonEvUp(counter1)}(\invAnonEvUp(counter2)))

        \replacewith(skip)
        \add(==>counter1=counter2);

        \replacewith(\invAnonEvUp({\anonEvUp(counter1)}counter2 + counter1))
        \add(==>counter1!=counter2)

        \heuristics(update_apply_on_update)
    };


    applyUpdateParallelToAnonEventOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({u||\anonEvUp(counter)}(pv := t))

        \replacewith(pv := {u||\anonEvUp(counter)}t)

        \heuristics(update_apply_on_update)
    };

    applyAnonEventParallelToUpdateOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({\anonEvUp(counter)||u}(pv := t))

        \replacewith(pv := {\anonEvUp(counter)||u}t)

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}(pv := t))

        \replacewith((pv := {\anonEvUp(counter)}t))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply INVERSE ANON EVENT on

    applyInverseAnonEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}(pv := t))

        \replacewith((pv := {\invAnonEvUp(counter)}t))

        \heuristics(update_apply_on_update)
    };

	applyInverseAnonEventOnEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\invAnonEvUp(counter)}(\event(rw, loc, ts)))

        \replacewith(\event({\invAnonEvUp(counter)}rw, {\invAnonEvUp(counter)}loc, {\invAnonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };

	applyInverseAnonEventOnInverseEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\invAnonEvUp(counter)}(\invEvUp(rw, loc, ts)))

        \replacewith(\invEvUp({\invAnonEvUp(counter)}rw, {\invAnonEvUp(counter)}loc, {\invAnonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };


    applyInvAnonEventOnAnonEventSameCounter {
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}(\anonEvUp(counter)))

        \replacewith(skip)

        \heuristics(update_apply_on_update)
    };



    applyInverseAnonEventOnAnonEvent {
        \schemaVar \term int counter1, counter2;

        \find({\invAnonEvUp(counter1)}(\anonEvUp(counter2)))

        \replacewith(\invAnonEvUp({\anonEvUp(counter1)}counter2))

        \heuristics(update_apply_on_update)
    };

    applyUpdateParallelToInverseAnonEventOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({u||\invAnonEvUp(counter)}(pv := t))

        \replacewith(pv := {u||\invAnonEvUp(counter)}t)

        \heuristics(update_apply_on_update)
    };

    applyInverseAnonEventParallelToUpdateOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({\invAnonEvUp(counter)||u}(pv := t))

        \replacewith(pv := {\invAnonEvUp(counter)||u}t)

        \heuristics(update_apply_on_update)
    };
*/
//======================================================================================================================
//					Event, Inverse Event, Anon Event, and Inverse Anon Event Update Elimination Rules
//======================================================================================================================
	//---------------------------------------------------> Events:

	/*elimUpdateOnRigidTerm1 {
	    \schemaVar \term[rigid] any t;
		\schemaVar \update u;

		\find({u}t)

		\replacewith(t)

		\heuristics(update_elim)
	};

	elimEventOnRigidTerm2 {
		\schemaVar \term any t, result;
		\schemaVar \update u;

		\find({u}t)
		\varcond(\applyEventUpdateOnRigid(u, t, result))

		\replacewith(result)

		\heuristics(update_elim)
	};

	elimEventOnRigidFormula1 {
	    \schemaVar \formula[rigid] phi;
		\schemaVar \update u;

		\find({u}phi)

		\replacewith(phi)

		\heuristics(update_elim)
	};

	elimEventOnRigidFormula2 {
		\schemaVar \formula phi, result;
		\schemaVar \update u;

		\find({u}phi)
		\varcond(\applyEventUpdateOnRigid(u, phi, result))

		\replacewith(result)

		\heuristics(update_elim)
	};*/


	elimEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({\event(rw, loc, ts)}pv)

		\replacewith(pv)

		\heuristics(update_elim)
	};

	elimEventOnSkip {
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({\event(rw, loc, ts)}skip)

		\replacewith(skip)

		\heuristics(update_elim)
	};

	applyUpdateParallelToEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}pv)

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	};

	applyUpdateParallelToEventOnSkip {
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}skip)

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	};
	//---------------------------------------------------> Inverse Events:
	/*elimInverseEventOnRigidTerm1 {
		\schemaVar \term[rigid] any t;
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)} t)

		\replacewith(t)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidTerm2 {
		\schemaVar \term any t, result;
		\schemaVar \update u;

		\find({u}t)
		\varcond(\applyInverseEventUpdateOnRigid(u, t, result))

		\replacewith(result)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidFormula1 {
		\schemaVar \formula[rigid] phi;
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}phi)

		\replacewith(phi)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidFormula2 {
		\schemaVar \formula phi, result;
		\schemaVar \update u;

		\find({u}phi)
		\varcond(\applyInverseEventUpdateOnRigid(u, phi, result))

		\replacewith(result)

		\heuristics(update_elim)
	};*/

	elimInverseEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}pv)

		\replacewith(pv)

		\heuristics(update_elim)
	};

	elimInverseEventOnSkip {
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}skip)

		\replacewith(skip)

		\heuristics(update_elim)
	};

	applyUpdateParallelToInvEvUpOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \update u, invEvent;

		\find({u || invEvent}pv)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	};

	 applyInvEvUpParallelToUpdateOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \update u, invEvent;

		\find({invEvent || u}pv)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	 };

	 applyUpdateParallelToInvEvUpOnSkip {
		\schemaVar \update u, invEvent;

		\find({u || invEvent}skip)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	 };

	applyInvEvUpParallelToUpdateOnSkip {
		\schemaVar \update u, invEvent;

		\find({invEvent || u}skip)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	};

//---------------------------------------------------> AnonEvents:

 /*   elimAnonEventOnRigidTerm1 {
        \schemaVar \term[rigid] any t;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} t)

        \replacewith(t)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidTerm2 {
        \schemaVar \term any t, result;
        \schemaVar \update anonEv;

        \find({anonEv}t)
        \varcond(\applyAnonEventUpdateOnRigid(anonEv, t, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidFormula1 {
        \schemaVar \formula[rigid] phi;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}phi)

        \replacewith(phi)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidFormula2 {
        \schemaVar \formula phi, result;
        \schemaVar \update anonEv;

        \find({anonEv}phi)
        \varcond(\applyAnonEventUpdateOnRigid(anonEv, phi, result))

        \replacewith(result)

        \heuristics(update_elim)
    };*/

    elimAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}pv)

        \replacewith(pv)

        \heuristics(update_elim)
    };

    elimAnonEventOnSkip {
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };

    applyUpdateParallelToAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)}pv)

        \replacewith({u}pv)

        \heuristics(update_apply)
    };

    applyUpdateParallelToAnonEventOnSkip {
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };
//---------------------------------------------------> InverseAnonEvents:

   /*elimInverseAnonEventOnRigidTerm1 {
       \schemaVar \term[rigid] any t;
       \schemaVar \term int counter;

       \find({\invAnonEvUp(counter)} t)

       \replacewith(t)

       \heuristics(update_elim)
   };

    elimInvAnonEventOnRigidTerm2 {
        \schemaVar \term any t, result;
        \schemaVar \update invAnonEv;

        \find({invAnonEv}t)
        \varcond(\applyInverseAnonEventUpdateOnRigid(invAnonEv, t, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    elimInverseAnonEventOnRigidFormula1 {
        \schemaVar \formula[rigid] phi;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}phi)

        \replacewith(phi)

        \heuristics(update_elim)
     };
  elimInvAnonEventOnRigidFormula2 {
        \schemaVar \formula phi, result;
        \schemaVar \update invAnonEv;

        \find({invAnonEv}phi)
        \varcond(\applyInverseAnonEventUpdateOnRigid(invAnonEv, phi, result))

        \replacewith(result)

        \heuristics(update_elim)
    };*/

    elimUpdateOnRigidTerm {

        \schemaVar \update u;
        \schemaVar \term[rigid] any t;

        \find({u}t)
        \replacewith(t)
        \heuristics(update_elim)

    };

    elimUpdateOnRigidFormula {

            \schemaVar \update u;
            \schemaVar \formula[rigid] phi;

            \find({u}phi)
            \replacewith(phi)
            \heuristics(update_elim)

        };

    elimInvAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}pv)

        \replacewith(pv)

        \heuristics(update_elim)
    };

    elimInvAnonEventOnSkip {
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };

    applyUpdateParallelToInvAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)}pv)

        \replacewith({u}pv)

        \heuristics(update_apply)
    };

    applyUpdateParallelToInvAnonEventOnSkip {
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)//userTaclets1)
    };
//======================================================================================================================
//													Splitting Rules
//======================================================================================================================
	//---------------------------------------------------> Dependence Predicates:
	splitNoRaW {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noRaW(union(loc1,loc2)))
	    \replacewith(noRaW(loc1) & noRaW(loc2))

	    \heuristics(simplify)
	};

	splitNoWaR {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noWaR(union(loc1,loc2)))
	    \replacewith(noWaR(loc1) & noWaR(loc2))

	    \heuristics(simplify)
	};

	splitNoWaW {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noWaW(union(loc1,loc2)))
	    \replacewith(noWaW(loc1) & noWaW(loc2))

	    \heuristics(simplify)
	};

	splitNoR {
		\schemaVar \term LocSet loc1, loc2;

	    \find(noR(union(loc1,loc2)))
	    \replacewith(noR(loc1) & noR(loc2))

	    \heuristics(simplify)
	};

	splitNoW {
		\schemaVar \term LocSet loc1, loc2;

		\find(noW(union(loc1,loc2)))
		\replacewith(noW(loc1) & noW(loc2))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> Dependence Predicates with EQ:
	splitNoRaWEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRaW(EQ)) \sameUpdateLevel
	    \replacewith(noRaW(loc1) & noRaW(loc2))

	    \heuristics(simplify)
	};

	splitNoWaREQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaR(EQ)) \sameUpdateLevel
	    \replacewith(noWaR(loc1) & noWaR(loc2))

	    \heuristics(simplify)
	};

	splitNoWaWEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaW(EQ)) \sameUpdateLevel
	    \replacewith(noWaW(loc1) & noWaW(loc2))

	    \heuristics(simplify)
	};

	splitNoREQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noR(EQ)) \sameUpdateLevel
	    \replacewith(noR(loc1) & noR(loc2))

	    \heuristics(simplify)
	};

	splitNoWEQ {
		\schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noW(EQ)) \sameUpdateLevel
	    \replacewith(noW(loc1) & noW(loc2))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> History Predicates:
	splitNoRaWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noRaWAtHistory(union(loc1,loc2), label))
	    \replacewith(noRaWAtHistory(loc1, label) & noRaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaRAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWaRAtHistory(union(loc1,loc2), label))
	    \replacewith(noWaRAtHistory(loc1, label) & noWaRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWaWAtHistory(union(loc1,loc2), label))
	    \replacewith(noWaWAtHistory(loc1, label) & noWaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoRAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noRAtHistory(union(loc1,loc2), label))
	    \replacewith(noRAtHistory(loc1, label) & noRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWAtHistory(union(loc1,loc2), label))
	    \replacewith(noWAtHistory(loc1, label) & noWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> History Predicates with EQ:
	splitNoRaWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRaWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noRaWAtHistory(loc1, label) & noRaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaRAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaRAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWaRAtHistory(loc1, label) & noWaRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWaWAtHistory(loc1, label) & noWaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoRAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noRAtHistory(loc1, label) & noRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWAtHistory(loc1, label) & noWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

//======================================================================================================================
//												Data Dependence Known
//======================================================================================================================
	//---------------------------------------------------> Data Dependence Predicates:
	// To Prove
	noRKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noR(loc1) ==> )
		\find(==> noR(loc2))
		\replacewith(==> noR(setMinus(loc2,loc1)), subset(loc2,loc1))
		\heuristics(dep_pred_known,noEqApp)
	};

	//--------------------------------------------
	// These rules (and similar ones for other predicates) were causing Loops:

	// noRKnownForSupersetOrSubsetDef{
	//	\schemaVar \term LocSet loc1, loc2;
	//
	//	\assumes(noR(loc1) ==> )
	//	\find(==> noR(loc2))
	//
	//	\replacewith(==>noR(setMinus(loc2,loc1)))
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations_def)
	//	};
	// noRKnownForSupersetOrSubset2{
	//	\schemaVar \term LocSet loc1, loc2;
	//
	//	\assumes(noR(loc1) ==> )
	//	\find(==> noR(loc2))
	//
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations)
	//	};
	//----------------------------------------------

	noWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noW(loc1) ==> )
		\find(==> noW(loc2))
		\replacewith(==> subset(loc2,loc1), noW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};

	noRaWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noRaW(loc1) ==> )
		\find(==> noRaW(loc2))

		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)//_3)
	};

	noWaRKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noWaR(loc1) ==> )
		\find(==> noWaR(loc2))

		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)//_3
	};

	noWaWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noWaW(loc1) ==> )
		\find(==> noWaW(loc2))

		\replacewith(==> subset(loc2,loc1), noWaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};

	// To Prove
	noRKnownForSupersetOrSubsetOfNoRaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noR(loc1) ==> )
		\find(==>noRaW(loc2))

		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};

	//Old Version:

	//noReadKnownForSupersetOrSubsetOfNoRaW2{
	//	\schemaVar \term LocSet loc1, loc2;
	//
	//	\assumes(noR(loc1) ==> )
	//	\find(==>noRaW(loc2))
	//
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations)
	//};

	noWKnownForSupersetOrSubsetOfNoRaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noW(loc1) ==> )
		\find(==>noRaW(loc2))

		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};

	noWKnownForSupersetOrSubsetOfNoWaR{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noW(loc1) ==> )
		\find(==>noWaR(loc2))

		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};

	noRKnownForSupersetOrSubsetOfNoWaR{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noR(loc1) ==> )
		\find(==>noWaR(loc2))

		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)) )
		\heuristics(dep_pred_known,noEqApp)
	};

	noWKnownForSupersetOrSubsetOfNoWaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noW(loc1) ==> )
		\find(==>noWaW(loc2))

		\replacewith(==> subset(loc2,loc1), noWaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};

	//---------------------------------------------------> History Data Dependence Predicates:
	/*noRAtHistoryOnBothSides{
		\schemaVar \term int id1, id2;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \update u;

		\assumes(noRAtHistory(loc1,id1)==>)
		\find(==>noRAtHistory(loc2,id2))
	//	\varcond(\different(id1,id2))
		\replacewith(==>\if (id1 <= id2 ) \then(noRAtHistory(setMinus(loc2,loc1),id2)) \else(noRAtHistory(loc2,id2)))

		\heuristics(dep_pred_known,noEqApp)
	};*/

	// To Prove
	noRAndNoRAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noR(loc1)==>)
		 \find(==>noRAtHistory(loc2,id2))
		 \replacewith(==>noRAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};

	/*noWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWAtHistory(loc1,id1)==>)
		 \find(==> noWAtHistory(loc2,id2))
	//	 \varcond(\different(id1,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWAtHistory(setMinus(loc2,loc1),id2)) \else(noWAtHistory(loc2,id2)))

		 \heuristics(dep_pred_known,noEqApp)
	};*/

	noWAndNoWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noW(loc1)==>)
		 \find(==>noWAtHistory(loc2,id2))
		 \replacewith(==>noWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};

	/*noRaWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noRaWAtHistory(loc1,id1)==>)
		 \find(==>noRaWAtHistory(loc2,id2))
	//	 \varcond(\different(id1,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noRaWAtHistory(setMinus(loc2,loc1),id2)) \else(noRaWAtHistory(loc2,id2)))

		 \heuristics(dep_pred_known,noEqApp)
	};*/

	noRaWAndNoRaWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noRaW(loc1)==>)
		 \find(==>noRaWAtHistory(loc2,id2))
		 \replacewith(==>noRaWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};

	/*noWaRAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWaRAtHistory(loc1,id1)==>)
		 \find(==>noWaRAtHistory(loc2,id2))
	//	 \varcond(\different(id1,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWaRAtHistory(setMinus(loc2,loc1),id2)) \else(noWaRAtHistory(loc2,id2)))

		 \heuristics(dep_pred_known,noEqApp)
	};*/

	noWaRAndNoWaRAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWaR(loc1)==>)
		 \find(==>noWaRAtHistory(loc2,id2))
		 \replacewith(==>noWaRAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};

	/*noWaWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWaWAtHistory(loc1,id1)==>)
		 \find(==>noWaWAtHistory(loc2,id2))
	//	 \varcond(\different(id1,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWaWAtHistory(setMinus(loc2,loc1),id2)) \else(noWaWAtHistory(loc2,id2)))


		 \heuristics(dep_pred_known,noEqApp)
	};*/

	noWaWAndNoWaWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWaW(loc1)==>)
		 \find(==>noWaWAtHistory(loc2,id2))
		 \replacewith(==>noWaWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};


//======================================================================================================================
//							Update and Event Update Application on Data Dependence Predicates
//======================================================================================================================
	//---------------------------------------------------> Eliminate State Updates:
	elimStateUpdatesBeforeNoRaW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noRaW(tr))
		\replacewith({u}noRaW(tr))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaR{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noWaR(tr))
		\replacewith({u}noWaR(tr))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noWaW(tr))
		\replacewith({u}noWaW(tr))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoR{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noR(tr))
		\replacewith({u}noR(tr))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noW(tr))
		\replacewith({u}noW(tr))
		\heuristics(update_elim)
	};

	//---------------------------------------------------> {event} Data Dependence Predicates:
	// To Prove
	writeEventBeforeNoRaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(write, loc1, ts)} noRaW(loc2))

		\replacewith(noRaW({\event(write, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	// To Prove
	readEventBeforeNoRaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find({\event(read, loc1, ts)} noRaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

		\replacewith(noRaW(tempVar))
		\add(tempVar = {\event(read, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );

		\replacewith(noW(intersect(loc1, tempVar)) & noRaW(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(read, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoWaR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find({\event(write, loc1, ts)} noWaR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

		\replacewith(noWaR(tempVar))
		\add(tempVar = {\event(write, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );

		\replacewith(noR(intersect(loc1, tempVar)) & noWaR(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(write, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoWaR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(read, loc1, ts)} noWaR(loc2))

		\replacewith( noWaR({\event(read, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoWaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find({\event(write, loc1, ts)} noWaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

		\replacewith(noWaW(tempVar))
		\add(tempVar = {\event(write, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );

		\replacewith(noW(intersect(loc1, tempVar)) & noWaW(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(write, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoWaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(read, loc1, ts)} noWaW(loc2))

		\replacewith( noWaW({\event(read, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find(==> {\event(write, loc1, ts)} noW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

	    \replacewith(==> noW(tempVar))
	    \add(tempVar = {\event(write, loc1, ts)}loc2,
	    	intersect(loc1, tempVar) = empty ==> );

	    \replacewith(==> false)
	    \add(tempVar = {\event(write, loc1, ts)}loc2,
	    	!(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(read, loc1, ts)} noW(loc2))

		\replacewith( noW({\event(read, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	// To Prove
	writeEventBeforeNoR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(write, loc1, ts)} noR(loc2))

		\replacewith(noR({\event(write, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	// To Prove
	readEventBeforeNoR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find(==> {\event(read, loc1, ts)} noR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

	    \replacewith(==> noR(tempVar))
	    \add(tempVar = {\event(read, loc1, ts)}loc2,
	    	intersect(loc1, tempVar) = empty ==> );

	    \replacewith(==> false)
	    \add(tempVar = {\event(read, loc1, ts)}loc2,
	    	!(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	//---------------------------------------------------> {u || event} Data Dependence Predicates:
	updateParallelToReadEventOnNoRaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noRaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noRaW(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2,
	          intersect(loc1, tempVar) = empty ==> );

	    \replacewith(==> ({u}noW(intersect(tempVar, loc1))) & {u}noRaW(setMinus(tempVar, loc1)))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2,
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToWriteEventOnNoRaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noRaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noRaW(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> ) //REMEMBER TODO check for others to take u and apply it on tempvar

	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToWriteEventOnNoWaR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noWaR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noWaR(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	     	intersect(tempVar, loc1) = empty ==> );

	     \replacewith(==> ({u}noR(intersect(tempVar, loc1))) & {u}noWaR(setMinus(tempVar, loc1)))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	     	!(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};
	updateParallelToReadEventOnNoWaR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noWaR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noWaR(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==>)
	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToWriteEventOnNoWaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noWaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noWaW(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	     	intersect(tempVar, loc1) = empty ==> );

	     \replacewith(==> {u}noW(intersect(tempVar, loc1)) & {u}noWaW(setMinus(tempVar, loc1)))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	     	!(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToReadEventOnNoWaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noWaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noWaW(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==> )
	     \heuristics(update_apply)//userTaclets1)
	 };

	updateParallelToReadEventOnNoR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))
	     \replacewith(==> {u}noR(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2,
	          intersect(loc1, tempVar) = empty ==> );

	     \replacewith(==> false)
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2,
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};

 	updateParallelToWriteEventOnNoR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noR(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> )

	     \heuristics(update_apply)//userTaclets1)
 	};

 	updateParallelToWriteEventOnNoW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))
	     \replacewith(==> {u}noW(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	          intersect(loc1, tempVar) = empty ==> );

	     \replacewith(==> false)
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
 	};

 	updateParallelToReadEventOnNoW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noW(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==> )

	     \heuristics(update_apply)//userTaclets1)
 	};

 	//---------------------------------------------------> {u} Data Dependence Predicates:
 	/*simplifyNONEventUpdateNoR {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noR(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noR(loc))

 		\heuristics(update_apply)
 	};

 	simplifyNONEventUpdateNoW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noW(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noW(loc))

 		\heuristics(update_apply)
 	};

 	simplifyNONEventUpdateNoRaW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noRaW(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noRaW(loc))

 		\heuristics(update_apply)
	};

 	simplifyNONEventUpdateNoWaR {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noWaR(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noWaR(loc))

 		\heuristics(update_apply)
 	};

 	simplifyNONEventUpdateNoWaW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noWaW(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noWaW(loc))

 		\heuristics(update_apply)
 	};*/

//======================================================================================================================
//										Non-Event and Non-InverseEvent Update Propagation Rules
//======================================================================================================================

	propagateNonEventUpdateONnoRaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noRaW(loc))
		\varcond(\onlyElementary(u))

		\replacewith(noRaW({u}loc))

		\heuristics(update_apply)
	};

	propagateNonEventUpdateONnoWaR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noWaR(loc))

		\varcond(\onlyElementary(u))

		\replacewith(noWaR({u}loc))

		\heuristics(update_apply)
	};

	propagateNonEventUpdateONnoWaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noWaW(loc))

		\varcond(\onlyElementary(u))

		\replacewith(noWaW({u}loc))

		\heuristics(update_apply)
	};

	propagateNonEventUpdateONnoR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noR(loc))

		\varcond(\onlyElementary(u))

		\replacewith(noR({u}loc))

		\heuristics(update_apply)
	};

	propagateNonEventUpdateONnoW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noW(loc))

		\varcond(\onlyElementary(u))

		\replacewith(noW({u}loc))

		\heuristics(update_apply)
	};

//======================================================================================================================
//							Event, Inverse Event, AnonEvent, and Inverse AnonEvent Shifting Rules
//======================================================================================================================
//-----------------------------------------------------------Events
	shiftEventParallelToUpdate {
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	\schemaVar \update u;

	 	\find(\event(rw, loc, ts) || u)

	 	\varcond(\onlyElementary(u))

	 	\replacewith(u || \event(rw, loc, ts))

	 	\heuristics(update_apply)
	};

	shiftEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(\event(rw, loc, ts) || pv:=t)

	 	\replacewith(pv:=t || \event(rw, loc, ts))

	 	\heuristics(update_apply)
	};

	shiftOnlyEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update evUp;

	 	\find(evUp || pv:=t)
	 	\varcond(\onlyEventUpdates(evUp))

	 	\replacewith(pv:=t || evUp)

	 	\heuristics(update_apply)
	};

	shiftEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(u || \event(rw, loc, ts) || pv:=t)

	 	\replacewith(u || pv:=t || \event(rw, loc, ts))

	 	\heuristics(update_apply)
	 };

	shiftEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find(\event(rw, loc, ts) || pv:=t || u)

		\replacewith(pv:=t || \event(rw, loc, ts) || u)

		\heuristics(update_apply)
	};

	shiftOnlyEventWithUpdateAtFirstPlace {
	 	\schemaVar \update evUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(u || evUp || pv:=t)
	 	\varcond(\onlyEventUpdates(evUp))

	 	\replacewith(u || pv:=t || evUp)

	 	\heuristics(update_apply)
	};

	shiftOnlyEventWithUpdateAtLastPlace {
	 	\schemaVar \update evUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find( pv:=t || evUp || u)
	 	\varcond(\onlyEventUpdates(evUp),\onlyElementary(u))
	 	\replacewith(pv:=t || u || evUp)

	 	\heuristics(update_apply)
	};
//-----------------------------------------------------------Inverse Events
    shiftInvEventParallelToUpdate {
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	\schemaVar \update u;

	 	\find(\invEvUp(rw, loc, ts) || u)

	 	\varcond(\onlyElementary(u))

	 	\replacewith(u || \invEvUp(rw, loc, ts))

	 	\heuristics(update_apply)
	};

	shiftInvEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(\invEvUp(rw, loc, ts) || pv:=t)

	 	\replacewith(pv:=t || \invEvUp(rw, loc, ts))

	 	\heuristics(update_apply)
	};

	shiftOnlyInvEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update invEvUp;

	 	\find(invEvUp || pv:=t)
	 	\varcond(\onlyInverseEventUpdates(invEvUp))

	 	\replacewith(pv:=t || invEvUp)

	 	\heuristics(update_apply)
	};

	shiftInvEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(u || \invEvUp(rw, loc, ts) || pv:=t)

	 	\replacewith(u || pv:=t || \invEvUp(rw, loc, ts))

	 	\heuristics(update_apply)
	 };

	shiftInvEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find(\invEvUp(rw, loc, ts) || pv:=t || u)

		\replacewith(pv:=t || \invEvUp(rw, loc, ts) || u)

		\heuristics(update_apply)
	};

	shiftOnlyInvEventWithUpdateAtFirstPlace {
	 	\schemaVar \update invEvUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(u || invEvUp || pv:=t)
	 	\varcond(\onlyInverseEventUpdates(invEvUp))

	 	\replacewith(u || pv:=t || invEvUp)

	 	\heuristics(update_apply)
	};

	shiftOnlyInvEventWithUpdateAtLastPlace {
	 	\schemaVar \update invEvUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find( pv:=t || invEvUp || u)
	 	\varcond(\onlyInverseEventUpdates(invEvUp),\onlyElementary(u))

	 	\replacewith(pv:=t || u || invEvUp)

	 	\heuristics(update_apply)
	};

//-----------------------------------------------------------Anon Events
	shiftAnonEventParallelToUpdate {
	 	\schemaVar \term int counter;
	 	\schemaVar \update u;

	 	\find(\anonEvUp(counter) || u)
        \varcond(\onlyElementary(u))

	 	\replacewith(u || \anonEvUp(counter))

	 	\heuristics(update_apply)
	};

	shiftAnonEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term int counter;

	 	\find(\anonEvUp(counter) || pv:=t)

	 	\replacewith(pv:=t || \anonEvUp(counter))

	 	\heuristics(update_apply)
	};

	shiftOnlyAnonEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update anonEvUp;

	 	\find(anonEvUp || pv:=t)
	 	\varcond(\onlyAnonEventUpdates(anonEvUp))

	 	\replacewith(pv:=t || anonEvUp)

	 	\heuristics(update_apply)
	};

	shiftAnonEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term int counter;

	 	\find(u || \anonEvUp(counter) || pv:=t)

	 	\replacewith(u || pv:=t || \anonEvUp(counter))

	 	\heuristics(update_apply)
	 };

	shiftAnonEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term int counter;

		\find(\anonEvUp(counter) || pv:=t || u)

		\replacewith(pv:=t || \anonEvUp(counter) || u)

		\heuristics(update_apply)
	};

	shiftOnlyAnonEventWithUpdateAtFirstPlace {
	 	\schemaVar \update anonEvUp, u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;

	 	\find(u || anonEvUp || pv:=t)
	 	\varcond(\onlyAnonEventUpdates(anonEvUp))

	 	\replacewith(u || pv:=t || anonEvUp)

	 	\heuristics(update_apply)
	};

	shiftOnlyAnonEventWithUpdateAtLastPlace {
	 	\schemaVar \update anonEvUp, u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;

	 	\find( pv:=t || anonEvUp || u)
	 	\varcond(\onlyAnonEventUpdates(anonEvUp),\onlyElementary(u))

	 	\replacewith(pv:=t || u || anonEvUp)

	 	\heuristics(update_apply)
	};
//-----------------------------------------------------------Inverse Anon Events
	shiftInverseAnonEventParallelToUpdate {
	 	\schemaVar \term int counter;
	 	\schemaVar \update u;

	 	\find(\invAnonEvUp(counter) || u)

        \varcond(\onlyElementary(u))

	 	\replacewith(u || \invAnonEvUp(counter))

	 	\heuristics(update_apply)
	};

	shiftInverseAnonEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term int counter;

	 	\find(\invAnonEvUp(counter) || pv:=t)

	 	\replacewith(pv:=t || \invAnonEvUp(counter))

	 	\heuristics(update_apply)
	};

	shiftOnlyInverseAnonEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update invAnonEvUp;

	 	\find(invAnonEvUp || pv:=t)
	 	\varcond(\onlyInverseAnonEventUpdates(invAnonEvUp))

	 	\replacewith(pv:=t || invAnonEvUp)

	 	\heuristics(update_apply)
	};

	shiftInverseAnonEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term int counter;

	 	\find(u || \invAnonEvUp(counter) || pv:=t)

	 	\replacewith(u || pv:=t || \invAnonEvUp(counter))

	 	\heuristics(update_apply)
	 };

	shiftInverseAnonEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term int counter;

		\find(\invAnonEvUp(counter) || pv:=t || u)

		\replacewith(pv:=t || \invAnonEvUp(counter) || u)

		\heuristics(update_apply)
	};

	shiftOnlyInverseAnonEventWithUpdateAtFirstPlace {
	 	\schemaVar \update invAnonEvUp, u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;

	 	\find(u || invAnonEvUp || pv:=t)
	 	\varcond(\onlyInverseAnonEventUpdates(invAnonEvUp))

	 	\replacewith(u || pv:=t || invAnonEvUp)

	 	\heuristics(update_apply)
	};

	shiftOnlyInverseAnonEventWithUpdateAtLastPlace {
	 	\schemaVar \update invAnonEvUp, u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;

	 	\find( pv:=t || invAnonEvUp || u)
	 	\varcond(\onlyInverseAnonEventUpdates(invAnonEvUp),\onlyElementary(u))

	 	\replacewith(pv:=t || u || invAnonEvUp)

	 	\heuristics(update_apply)
	};
//======================================================================================================================
//						Inverse Event, and Inverse Anon Event Update Application on History Predicates
//======================================================================================================================
	//simplifyNONInverseEventUpdateNoRAtHistory:
	simplifyElementaryOnNoRAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;

		\find({u1}noRAtHistory(loc, id))

		\varcond(\onlyElementary(u1))//, \noElementary(u2))

		\replacewith(noRAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};

    simplifyElementaryOnNoWAtHistory {
        \schemaVar \update u1,u2;
        \schemaVar \term LocSet loc;
        \schemaVar \term int id;

        \find({u1}noWAtHistory(loc, id))

        \varcond(\onlyElementary(u1))//, \noElementary(u2))

        \replacewith(noWAtHistory({u1}loc, {u1}id))

        \heuristics(update_apply)
    };

    simplifyElementaryOnNoRaWAtHistory {
        \schemaVar \update u1,u2;
        \schemaVar \term LocSet loc;
        \schemaVar \term int id;

        \find({u1}noRaWAtHistory(loc, id))

        \varcond(\onlyElementary(u1))//, \noElementary(u2))

        \replacewith(noRaWAtHistory({u1}loc, {u1}id))

        \heuristics(update_apply)
    };

    simplifyElementaryOnNoWaRAtHistory {
        \schemaVar \update u1,u2;
        \schemaVar \term LocSet loc;
        \schemaVar \term int id;

        \find({u1}noWaRAtHistory(loc, id))

        \varcond(\onlyElementary(u1))//, \noElementary(u2))

        \replacewith(noWaRAtHistory({u1}loc, {u1}id))

        \heuristics(update_apply)
    };

    simplifyElementaryOnNoWaWAtHistory {
        \schemaVar \update u1,u2;
        \schemaVar \term LocSet loc;
        \schemaVar \term int id;

        \find({u1}noWaWAtHistory(loc, id))

        \varcond(\onlyElementary(u1))//, \noElementary(u2))

        \replacewith(noWaWAtHistory({u1}loc, {u1}id))

        \heuristics(update_apply)
    };



/*	simplifyNONInverseEventUpdateNoWAtHistory {
	   \schemaVar \update u1,u2;
	   \schemaVar \term LocSet loc;
	   \schemaVar \term int id;

		\find({u1||u2}noWAtHistory(loc, id))

		\varcond(\noEventUpdate(u1))

		\replacewith({u2}noWAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};

	simplifyNONInverseEventUpdateNoRaWAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;

		\find({u1||u2}noRaWAtHistory(loc, id))

		\varcond(\noEventUpdate(u1))

		\replacewith({u2}noRaWAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};

	simplifyNONInverseEventUpdateNoWaRAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;

		\find({u1||u2}noWaRAtHistory(loc, id))

		\varcond(\noEventUpdate(u1))

		\replacewith({u2}noWaRAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};

	simplifyNONInverseEventUpdateNoWaWAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;

		\find({u1||u2}noWaWAtHistory(loc, id))

		\varcond(\noEventUpdate(u1))

		\replacewith({u2}noWaWAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};*/

//======================================================================================================================
//										Non-InverseEventUpdate Application on Read and Write Predicates
//======================================================================================================================
	simplifyUpdateOnReadPred {
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({u}rPred(loc, ts))
		\varcond(\noInverseEventUpdate(u), \noInverseAnonEventUpdate(u))

		\replacewith(rPred({u}loc, {u}ts))

		\heuristics(update_apply)
	};

	simplifyUpdateOnWritePred {
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({u}wPred(loc, ts))
		\varcond(\noInverseEventUpdate(u), \noInverseAnonEventUpdate(u))

		\replacewith(wPred({u}loc, {u}ts))

		\heuristics(update_apply)
	};

//======================================================================================================================
//								Read and Write Predicates in Relation to noX and noXAtHitory
//======================================================================================================================
	//---------------------------------------------------> With noX
	//To Prove
	rPredAndNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1;

		\assumes(rPred(loc1,label1) ==>)
		\find(==> noR(loc2))

		\replacewith(==>intersect(loc1,loc2)=empty);
		\add(intersect(loc1,loc2)=empty==>)

		\heuristics(dep_pred_known_2)//,simplify)
	};

	wPredAndNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1;

		\assumes(wPred(loc1,label1) ==>)
		\find(==> noW(loc2))

		\replacewith(==>intersect(loc1,loc2)=empty);

		\add(intersect(loc1,loc2)=empty==>)

		\heuristics(dep_pred_known_2)
	};

	wPredAndNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;

		\assumes(wPred(loc1,label1)==>)
		\find(==> noWaR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(loc2)))

		\replacewith(==> noWaR(setMinus(loc2,loc1)) & noRAtHistory(tempVar,label1 + 1))
		\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);


		\add(intersect(loc1,loc2)=empty==>)

		\heuristics(dep_pred_known_2)
	};

	//To Prove
	rPredAndNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;

		\assumes(rPred(loc1,label1)==>)
		\find(==> noRaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
		        \new(tempVar, \dependingOn(loc2)))

		\replacewith(==> noRaW(setMinus(loc2,loc1)) & noWAtHistory(tempVar, label1 + 1))

		\add(tempVar = intersect(loc1,loc2), !tempVar=empty ==>);

		\add(intersect(loc1,loc2)=empty==>)

		\heuristics(dep_pred_known_2)
	};

	//--------------SPECIAL TO NOWAW----------------------------
	//To Prove
	wPredAndWPred{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1,label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(wPred(loc2,label2) ==>  )
		\add( \if (label1 = label2) \then (loc1 = loc2)
		      \else (
		         !intersect(loc1,loc2)=empty -> !noWaW( intersect(loc1,loc2) ) ) ==>)

		\heuristics(no_self_application, dep_pred_known_2)//,simplify)
	};

	wPredAndNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;

		\assumes(wPred(loc1,label1)==>)
		\find(==> noWaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(loc2)),
	             \notFreeIn(label2, label1), \notFreeIn(loc3, label1))

		\replacewith(==> noWaW(setMinus(loc2, loc1)) & noWAtHistory(tempVar, label1 + 1)
//		&
//		  (\forall loc3; (\forall label2; (0<=label2 & label2<label1 &
//		      !(intersect(tempVar, loc3) = empty) -> !wPred(loc3,label2) ) ) )
		      )
		\add(tempVar=intersect(loc1,loc2)==>)

		\heuristics(dep_pred_known_2c)
	};

	//---------------------------------------------------> With noXAtHistory
	//---------------------------------------------------> A. Same Label --- 0. xPred(loc1, 0) ==> noXHistory(loc2, 0)
    	// To Prove
  /*  rPredANDNoRHistoryRightLabelZero{
        \schemaVar \term LocSet loc1, loc2;

        \assumes(rPred(loc1,0) ==>)
        \find(==> noRAtHistory(loc2,0))

        \replacewith(==> intersect(loc1,loc2)=empty & noRAtHistory(loc2,1))

        \heuristics(dep_pred_known_3,noEqApp)//,simplify)
    };

    	// To Prove
    rPredANDnoWHistoryRightLabelZero {
        \schemaVar \term LocSet loc1,loc2;

        \assumes(rPred(loc1,0) ==>)
        \find(==> noWAtHistory(loc2,0))
        \replacewith(==> noWAtHistory(loc2,1))

        \heuristics(simplify)
    };

    	// To Prove
    rPredANDnoRAWHistoryRightLabelZero {// add -> replace
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int label;

        \assumes(rPred(loc1,0) ==>)
        \find(==> noRaWAtHistory(loc2,0))
        \replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),1) & (intersect(loc1,loc2) != empty -> noWAtHistory(intersect(loc2,loc1),1)))
        \heuristics(simplify,noEqApp)
    };

    rPredANDNoWARHistoryRightLabelZero {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int label;

        \assumes(rPred(loc1,0) ==>)
        \find(==> noWaRAtHistory(loc2,0))
        \replacewith(==> noWaRAtHistory(loc2,1))

        \heuristics(simplify)
    };

    rPredANDnoWAWHistoryRightLabelZero {
        \schemaVar \term LocSet loc1,loc2;

        \assumes(rPred(loc1,0) ==>)
        \find(==> noWaWAtHistory(loc2,0))
        \replacewith(==> noWaWAtHistory(loc2,1))

        \heuristics(simplify)
    };

    wPredANDNoRHistoryRightLabelZero{
        \schemaVar \term LocSet loc1,loc2;

        \assumes(wPred(loc1,0) ==>)
        \find(==> noRAtHistory(loc2,0))
        \replacewith(==> noRAtHistory(loc2,1))

        \heuristics(simplify)
    };

    wPredANDNoWHistoryRightLabelZero {
        \schemaVar \term LocSet loc1, loc2;

        \assumes(wPred(loc1,0) ==>)
        \find(==> noWAtHistory(loc2,0))

        \replacewith(==> intersect(loc1,loc2)=empty & noWAtHistory(loc2, 1))

        \heuristics(dep_pred_known_3,noEqApp)//,simplify)
    };

    wPredANDNoRAWHistoryRightLabelZero {
        \schemaVar \term LocSet loc1,loc2;

        \assumes(wPred(loc1,0) ==>)
        \find(==> noRaWAtHistory(loc2,0))
        \replacewith(==> noRaWAtHistory(loc2,1))

        \heuristics(simplify)
    };

    wPredANDnoWARHistoryRightLabelZero {
        \schemaVar \term LocSet loc1,loc2;

        \assumes(wPred(loc1,0) ==>)
        \find(==> noWaRAtHistory(loc2,0))
        \add(==> noWaRAtHistory(setMinus(loc2,loc1),1) & (intersect(loc1,loc2) != empty -> noRAtHistory(intersect(loc2,loc1),1)))
        \heuristics(dep_pred_known_2b,noEqApp)
    };

    wPredANDnoWAWHistoryRightLabelZero {
        \schemaVar \term LocSet loc1,loc2;

        \assumes(wPred(loc1,0) ==>)
        \find(==> noWaWAtHistory(loc2,0))
        \add(==> noWaWAtHistory(setMinus(loc2,loc1),1) & (intersect(loc1,loc2) != empty -> noWAtHistory(intersect(loc2,loc1),1)))
        \heuristics(dep_pred_known_2b,noEqApp)
    };
*/

	//---------------------------------------------------> A. Same Label --- 1. xPred ==> noXHistory
	// To Prove
	rPredANDNoRHistoryRightSameLabel{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noRAtHistory(loc2,label))

		\replacewith(==> intersect(loc1,loc2)=empty & noRAtHistory(loc2,label + 1))

		\heuristics(simplify_dependency_predicates)
	};

	// To Prove
	rPredANDnoWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noWAtHistory(loc2,label))
		\replacewith(==> noWAtHistory(loc2,label+1))

		\heuristics(simplify_dependency_predicates)
	};

	// To Prove
	rPredANDnoRAWHistoryRightSameLabel {// add -> replace
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noWAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(rewriteDependenciesAfterArgumentSimplification, similarLocSetArguments)//dep_pred_known_2b)
	};

	rPredANDNoWARHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(loc2,label+1))

		\heuristics(simplify_dependency_predicates)
	};

	rPredANDnoWAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\replacewith(==> noWaWAtHistory(loc2,label+1))

		\heuristics(simplify_dependency_predicates)
	};

	wPredANDNoRHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noRAtHistory(loc2,label))
		\replacewith(==> noRAtHistory(loc2,label+1))

		\heuristics(simplify_dependency_predicates)
	};

	wPredANDNoWHistoryRightSameLabel{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noWAtHistory(loc2,label))

		\replacewith(==> intersect(loc1,loc2)=empty & noWAtHistory(loc2,label + 1))

		\heuristics(simplify_dependency_predicates)//,dep_pred_known_2b)
	};

	wPredANDNoRAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(loc2,label+1))

		\heuristics(simplify_dependency_predicates)
	};

	wPredANDnoWARHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noRAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(rewriteDependenciesAfterArgumentSimplification, similarLocSetArguments)//dep_pred_known_2b)
	};

	wPredANDnoWAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\replacewith(==> noWaWAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noWAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(rewriteDependenciesAfterArgumentSimplification, similarLocSetArguments)//dep_pred_known_2b)
	};

	//---------------------------------------------------> A. Same Label --- 2. xPred & noXHistory ==>
	rPredANDnoRAtHistorySameLabel {//necessary?
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(noRAtHistory(loc2,label)==>)
		\add(intersect(loc1,loc2) = empty ==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

//	rPredAndNoRaWAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//
//		\assumes(rPred(loc1,label)==>)
//		\find(noRaWAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//
//		\replacewith( noRaWAtHistory(setMinus(loc2, loc1),label) & noWAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};

	// To Prove
	rPredANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(noRaWAtHistory(loc2,label)==>)
		\add(noWAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

	wPredANDnoWAtHistorySameLabel {// necessary?
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(noWAtHistory(loc2,label)==>)
		\add(intersect(loc1,loc2) = empty ==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

//	wPredAndNoWaRAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//
//		\assumes(wPred(loc1,label)==>)
//		\find(noWaRAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//
//		\replacewith( noWaRAtHistory(setMinus(loc2, loc1),label) & noRAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};

	wPredANDnoWARHistSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(noWaRAtHistory(loc2,label)==>)
		\add(noRAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

//	wPredAndNoWaWAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//
//		\assumes(wPred(loc1,label)==>)
//		\find(noWaWAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//
//		\replacewith( noWaWAtHistory(setMinus(loc2, loc1),label) & noWAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};

	wPredANDnoWAWHistSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(noWaWAtHistory(loc2,label)==>)
		\add(noWAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

	//---------------------------------------------------> B. Different Label --- 1. xPred BEFORE noXAtHistory ==>
	// To Prove
	rPredBEFOREnoRaWAtHistory {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find   (noRaWAtHistory(loc2,label2)==>)
		\add( label1 = label2 + 1 -> noWAtHistory(intersect(loc1,loc2),  label1+1) ==>)
		\heuristics(dep_pred_known,accessAtEarlierTime,noEqApp)
	};
	//rPredBEFOREnoWaRHistory {// OLD
	//\schemaVar \term LocSet loc1,loc2;
	//\schemaVar \term int label1, label2;
	//
	//\assumes(rPred(loc1,label1) ==>)
	//\find(noWaRAtHistory(loc2,label2)==>)
	//\add(\if(label1=label2+1)
	//\then(noWAtHistory(intersect(loc1,loc2),label1+1))
	//\else(noWaRAtHistory(loc2,label2))==>)
	//\heuristics(dep_pred_known,noEqApp)
	//};
	wPredBEFOREnoWaRHistory {//NEW
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find   (noWaRAtHistory(loc2,label2)==>)
		\add( label1 = label2 + 1 -> noRAtHistory(intersect(loc1,loc2),  label1+1) ==>)
		\heuristics(dep_pred_known,accessAtEarlierTime,noEqApp)
	};

	wPredBEFOREnoWaWHist {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find   (noWaWAtHistory(loc2,label2)==>)
		\add( label1 = label2 + 1 -> noWAtHistory(intersect(loc1,loc2),  label1+1) ==>)
		\heuristics(dep_pred_known,accessAtEarlierTime,noEqApp)
	};

	//---------------------------------------------------> B. Different Label --- 2. xPred AFTER noXAtHistory ==>
	// To Prove
	rPredAFTERnoRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noRAtHistory(loc2,label2)==>)
		\add ( label2 = label1 + 1 -> noRAtHistory(setMinus(loc2,loc1),label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	// To Prove
	rPredAFTERnoWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noWAtHistory(loc2,label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	rPredAFTERnoRaWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noRaWAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noRaWAtHistory(setMinus(loc2,loc1),label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	rPredAFTERnoWaRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWaRAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noWaRAtHistory(loc2,label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	rPredAFTERnoWAWHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWaWAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noWaWAtHistory(loc2,label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	wPredAFTERnoRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noRAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noRAtHistory(loc2,label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	wPredAFTERnoWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noWAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noWAtHistory(setMinus(loc2,loc1),label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	wPredAFTERnoRaWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noRaWAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noRaWAtHistory(loc2,label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	wPredAFTERnoWaRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noWaRAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noWaRAtHistory(setMinus(loc2,loc1),label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime,noEqApp)
	};

	wPredAFTERnoWAWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noWaWAtHistory(loc2,label2)==>)
		\add( label2 = label1 + 1 -> noWaWAtHistory(setMinus(loc2,loc1),label1) ==>)
		\heuristics(dep_pred_known,accessAtLaterTime, noEqApp)
	};

	//---------------------------------------------------> B. Different Label --- 3. xPred BEFORE  ==> noXAtHistory
	// To Prove
	rPredBEFOREnoRAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find   (==> noRAtHistory(loc2, label2))
		\add(==> label1 >= label2 & (intersect(loc1, loc2) = empty))
		\heuristics(dep_pred_known,noEqApp,accessAtEarlierTime)
	};

	// To Prove
	rPredBEFOREnoRaWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find (==> noRaWAtHistory(loc2,label2))
		\replacewith(==>
		    \if (label1 = label2 + 1)
		    \then (
		        noRaWAtHistory(setMinus(loc2,loc1), label2)     &
		        noWAtHistory(intersect(loc1,loc2),  label1 + 1)
		    ) \else ( noRaWAtHistory(loc2, label2) )
		)
		\heuristics(dep_pred_known,noEqApp,accessAtEarlierTime)
	};

	wPredBEFOREnoWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find (==> noWAtHistory(loc2,label2))
		\add(==> label1 >= label2 & intersect(loc1, loc2) = empty) //TODO
		\heuristics(dep_pred_known, noEqApp, accessAtEarlierTime)
	};

	wPredBEFOREnoWaRAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find (==> noWaRAtHistory(loc2,label2))
		\replacewith(==>
		    \if (label1 = label2 + 1)
		    \then (
		        noWaRAtHistory(setMinus(loc2, loc1), label2)     &
		        noRAtHistory(intersect(loc1, loc2),  label1 + 1)
		    ) \else (
		        noWaRAtHistory(loc2, label2)
		    )
		)
		\heuristics(dep_pred_known,noEqApp, accessAtEarlierTime)
	};

	wPredBEFOREnoWaWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1, label1) ==>)
		\find   (==> noWaWAtHistory(loc2,label2))
		\replacewith(==>
		    \if (label1 = label2 + 1)
		    \then ( noWaWAtHistory(setMinus(loc2, loc1), label2)       &
		            noWAtHistory(intersect(loc1, loc2),  label1 + 1)
		    ) \else ( noWaWAtHistory(loc2,label2) )
		)
		\heuristics(dep_pred_known, noEqApp, accessAtEarlierTime)
	};


//======================================================================================================================
//											noXAtHistory & noXAtHistory Rules
//======================================================================================================================

	//---------------------------------------------------> Same Or Greater Label on Left
	noRAtHistoryANDnoRAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noRAtHistory(loc1,label1) ==>)
		\find(==> noRAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noRAtHistory(setMinus(loc2,loc1),label2)) \else(noRAtHistory(loc2,label2)))

		\heuristics(rewriteDependenciesAfterArgumentSimplification,
		            strictNoEqApp,
		            preventDisjointLocationSets,
		            similarLocSetArguments,
		            accessAtSameOrLaterTime)
	};

	noRAtHistoryANDnoRaWAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noRAtHistory(loc1,label1) ==>)
		\find(==> noRaWAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noRaWAtHistory(setMinus(loc2,loc1),label2)) \else(noRaWAtHistory(loc2,label2)))

		\heuristics(rewriteDependenciesAfterArgumentSimplification,
		            strictNoEqApp,
		            preventDisjointLocationSets,
		            similarLocSetArguments,
		            accessAtSameOrLaterTime)
	};

	noRAtHistoryANDnoWaRAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noRAtHistory(loc1,label1) ==>)
		\find(==> noWaRAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noWaRAtHistory(setMinus(loc2,loc1),label2)) \else(noWaRAtHistory(loc2,label2)))

		\heuristics(rewriteDependenciesAfterArgumentSimplification,
		            preventDisjointLocationSets,
		            similarLocSetArguments,
		            strictNoEqApp,
		            accessAtSameOrLaterTime)
	};

	noWAtHistoryANDnoWAtHistorySameOrGreatedLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noWAtHistory(loc1,label1) ==>)
		\find(==> noWAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noWAtHistory(setMinus(loc2,loc1),label2)) \else(noWAtHistory(loc2,label2)))

		\heuristics(rewriteDependenciesAfterArgumentSimplification,
		            strictNoEqApp,
		            preventDisjointLocationSets,
		            similarLocSetArguments,
		            accessAtSameOrLaterTime)
	};

	noWAtHistoryANDnoRaWAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noWAtHistory(loc1,label1) ==>)
		\find(==> noRaWAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noRaWAtHistory(setMinus(loc2,loc1),label2)) \else(noRaWAtHistory(loc2,label2)))

		\heuristics(rewriteDependenciesAfterArgumentSimplification,
		            strictNoEqApp,
		            preventDisjointLocationSets,
		            similarLocSetArguments,
		            accessAtSameOrLaterTime)
	};

	noWAtHistoryANDnoWaRAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noWAtHistory(loc1,label1) ==>)
		\find(==> noWaRAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noWaRAtHistory(setMinus(loc2,loc1),label2)) \else(noWaRAtHistory(loc2,label2)))

		\heuristics(rewriteDependenciesAfterArgumentSimplification,
		            strictNoEqApp,
		            preventDisjointLocationSets,
		            similarLocSetArguments,
		            accessAtSameOrLaterTime)
	};

	noWAtHistoryANDnoWaWAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noWAtHistory(loc1,label1) ==>)
		\find(==> noWaWAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noWaWAtHistory(setMinus(loc2,loc1),label2)) \else(noWaWAtHistory(loc2,label2)))

		\heuristics(rewriteDependenciesAfterArgumentSimplification,
        		    strictNoEqApp,
        		    preventDisjointLocationSets,
        		    similarLocSetArguments,
        		    accessAtSameOrLaterTime)
	};

	noRaWAtHistoryANDnoRaWAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noRaWAtHistory(loc1,label1) ==>)
		\find(==> noRaWAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noRaWAtHistory(setMinus(loc2,loc1),label2)) \else(noRaWAtHistory(loc2,label2)))

		\heuristics(rewriteDependenciesAfterArgumentSimplification,
        		    strictNoEqApp,
        		    preventDisjointLocationSets,
        		    similarLocSetArguments,
        		    accessAtSameOrLaterTime)
	};

	noWaRAtHistoryANDnoWaRAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noWaRAtHistory(loc1,label1) ==>)
		\find(==> noWaRAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then ( noWaRAtHistory(setMinus(loc2,loc1),label2)) \else(noWaRAtHistory(loc2,label2)))

         \heuristics(rewriteDependenciesAfterArgumentSimplification,
		             strictNoEqApp,
		             preventDisjointLocationSets,
		             similarLocSetArguments,
		             accessAtSameOrLaterTime)
    };

	noWaWAtHistoryANDnoWaWAtHistorySameOrGreaterLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(noWaWAtHistory(loc1,label1) ==>)
		\find(==> noWaWAtHistory(loc2,label2))
		\replacewith(==> \if(label1<=label2) \then (noWaWAtHistory(setMinus(loc2,loc1),label2)) \else(noWaWAtHistory(loc2,label2)))

         \heuristics(rewriteDependenciesAfterArgumentSimplification,
		             strictNoEqApp,
		             preventDisjointLocationSets,
		             similarLocSetArguments,
		             accessAtSameOrLaterTime)
    };

//======================================================================================================================
//										Read and Write Predicates Relation
//======================================================================================================================

	wPredrPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(rPred(loc2,label)) \sameUpdateLevel
		\replacewith(false)

	    \heuristics(concrete)
	};

	wPredwPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(wPred(loc2,label))  \sameUpdateLevel
		\replacewith(loc1=loc2)

	    \heuristics(simplify,no_self_application)
	};


	rPredrPred {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(rPred(loc2,label))  \sameUpdateLevel
		\replacewith(loc1=loc2)

	    \heuristics(simplify,no_self_application)
	};

	rPredwPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(wPred(loc2,label)) \sameUpdateLevel
		\replacewith(false)

	    \heuristics(concrete)
	};


//======================================================================================================================
//										Data Dependence Simplification rules for heuristics
//======================================================================================================================
 	//---------------------------------------------------> Same location sets
	rPredAndNoROnSameLocations{
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;

		\assumes(rPred(loc, label) ==>)
		\find(noR(loc)) \sameUpdateLevel
		\replacewith(false)
		\heuristics(concrete)
	};
	wPredAndNoWOnSameLocations{
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;

		\assumes(wPred(loc, label) ==>)
		\find(noW(loc)) \sameUpdateLevel
		\replacewith(false)
		\heuristics(concrete)
	};
	noRAndNoRaWOnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noR(loc) ==>)
		\find(noRaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

	noWAndNoRaWOnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noW(loc) ==>)
		\find(noRaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

	noRAndNoWaROnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noR(loc) ==>)
		\find(noWaR(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

	noWAndNoWaROnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noW(loc) ==>)
		\find(noWaR(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

	noWAndNoWaWOnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noW(loc) ==>)
		\find(noWaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

//======================================================================================================================
//											Update Application on noX At History Predicates
//======================================================================================================================

	elimStateUpdatesBeforeNoRaWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({pv:=t || u} noRaWAtHistory(tr, id))
		\replacewith({u}noRaWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoRaWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({u || pv:=t} noRaWAtHistory(tr, id))
		\replacewith({u}noRaWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaRAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({pv:=t || u} noWaRAtHistory(tr, id))
		\replacewith({u}noWaRAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaRAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({u || pv:=t} noWaRAtHistory(tr, id))
		\replacewith({u}noWaRAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({pv:=t || u} noWaWAtHistory(tr, id))
		\replacewith({u}noWaWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;

		\find({u || pv:=t} noWaWAtHistory(tr, id))
		\replacewith({u}noWaWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoRAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({pv:=t || u} noRAtHistory(tr, id))
		\replacewith({u}noRAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoRAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({u || pv:=t} noRAtHistory(tr, id))
		\replacewith({u}noRAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;

		\find({pv:=t || u} noWAtHistory(tr, id))
		\replacewith({u}noWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;

		\find({u || pv:=t} noWAtHistory(tr, id))
		\replacewith({u}noWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	/*updateOnNoRAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noRAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noRAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};

	updateOnNoWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noWAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};

	updateOnNoRaWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noRaWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noRaWAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};

	updateOnNoWaRAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noWaRAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noWaRAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};

	updateOnNoWaWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noWaWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noWaWAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};*/


//======================================================================================================================
//											Inverse Event Update Application
//======================================================================================================================
 	//---------------------------------------------------> Nothing Inverse Event Update
	nothingToSkip{
		\schemaVar \term LocSet loc1;
		\schemaVar \term int label;

		\find(\invEvUp(nothing, loc1, label))
		\replacewith(skip)
		\heuristics(update_apply)
	};

	nothingInverseOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noR(loc2))
		\replacewith(noR(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noW(loc2))
		\replacewith(noW(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noRaW(loc2))
		\replacewith(noRaW(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noWaR(loc2))
		\replacewith(noWaR(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noWaW(loc2))
		\replacewith(noWaW(loc2))
		\heuristics(update_apply)
	};

	nothingInverseLastInParallelOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noR(loc2))
		\replacewith({u}noR(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noW(loc2))
		\replacewith({u}noW(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noRaW(loc2))
		\replacewith({u}noRaW(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noWaR(loc2))
		\replacewith({u}noWaR(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noWaW(loc2))
		\replacewith({u}noWaW(loc2))
		\heuristics(update_apply)
	};

 	//---------------------------------------------------> {\invEvUp()} NoX
	//Rules here can also happen on the right side. So probably I have to delete the ==>.
	// Now they are part of To Prove rules. But I think they are just rewrite rules.
	readInverseEvUpOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noR(loc2)==>)

		\replacewith(noRAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	  };

	writeInverseEvUpOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noR(loc2)==>)

		\replacewith(noRAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	  };

	readInverseEvUpOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noW(loc2)==>)

		\replacewith(noWAtHistory({\invEvUp(read,loc1,label)}loc2, 1)==>)
		\heuristics(update_apply)
	 };

	 writeInverseEvUpOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noW(loc2)==>)

		\replacewith(noWAtHistory({\invEvUp(write,loc1,label)}loc2, 1)==>)
		\heuristics(update_apply)
	 };

	readInverseEvUpOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noRaW(loc2)==>)

		\replacewith(noRaWAtHistory({\invEvUp(read,loc1,label)}loc2, 1)==>)

		\heuristics(update_apply)
	 };

	 writeInverseEvUpOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noRaW(loc2)==>)

		\replacewith(noRaWAtHistory({\invEvUp(write,loc1,label)}loc2, 1)==>)

		\heuristics(update_apply)
	 };

	readInnverseEvUpOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noWaR(loc2)==>)

		\replacewith(noWaRAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	 };

	 writeInnverseEvUpOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noWaR(loc2)==>)

		\replacewith(noWaRAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	 };

	readInverseEvUpOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noWaW(loc2)==>)

		\replacewith(noWaWAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	 };

	 writeInverseEvUpOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noWaW(loc2)==>)

		\replacewith(noWaWAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	 };

	//---------------------------------------------------> { update || \invEvUp} noX
	updateParallelToReadInverseEvUpOnNoR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(read,loc1,label)} noR(loc2))
		/*\varcond(\new(tempVar, \dependingOn(loc1)),
                 \new(tempVar, \dependingOn(loc2)),
                 \new(tempVar, \dependingOn(label)))*/

		\replacewith({u}noRAtHistory({\invEvUp(read,loc1,label)}loc2,1))
		//\add(tempVar=intersect(loc1,loc2)==>)

		\heuristics(update_apply)
	 };
	 updateParallelToWriteInverseEvUpOnNoR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(write,loc1,label)} noR(loc2))

		\replacewith({u}noRAtHistory({\invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	 };

	updateParallelToReadInverseEvUpOnNoW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(read,loc1,label)} noW(loc2))

		\replacewith({u}noWAtHistory({\invEvUp(read,loc1,label)}loc2,1))

		\heuristics(update_apply)
	 };
	updateParallelToWriteInverseEvUpOnNoW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(write,loc1,label)} noW(loc2))

		\replacewith({u}noWAtHistory({\invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoRaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(read,loc1,label)} noRaW(loc2))

		\replacewith({u}noRaWAtHistory({\invEvUp(read,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoRaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(write,loc1,label)} noRaW(loc2))

		\replacewith({u}noRaWAtHistory({\invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	 };

	updateParallelToReadInverseEvUpOnNoWaR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(read,loc1,label)} noWaR(loc2))

		\replacewith({u}noWaRAtHistory({\invEvUp(read,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoWaR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(write,loc1,label)} noWaR(loc2))

		\replacewith({u}noWaRAtHistory({\invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoWaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({u || \invEvUp(read,loc1,label)} noWaW(loc2))

		\replacewith({u}noWaWAtHistory({\invEvUp(read,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoWaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({u || \invEvUp(write,loc1,label)} noWaW(loc2))

		\replacewith({u}noWaWAtHistory({\invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	//---------------------------------------------------> {\invEvUp()} noXAtHistory
	// To Prove, probably it should be a rewrite rule
	readInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noRAtHistory(loc2, label2)==>)

		\replacewith(noRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	// To Prove, probably it should be a rewrite rule
	writeInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noRAtHistory(loc2, label2)==>)

		\replacewith(noRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noWAtHistory(loc2, label2)==>)

		\replacewith(noWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noWAtHistory(loc2, label2)==>)

		\replacewith(noWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	readInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noRaWAtHistory(loc2, label2)==>)

		\replacewith(noRaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)	==>)

		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noRaWAtHistory(loc2, label2)==>)

		\replacewith(noRaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)	==>)

		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noWaRAtHistory(loc2, label2)==>)

		\replacewith(noWaRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noWaRAtHistory(loc2, label2)==>)

		\replacewith(noWaRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noWaWAtHistory(loc2, label2)==>)

		\replacewith(noWaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noWaWAtHistory(loc2, label2)==>)

		\replacewith(noWaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};
	//---------------------------------------------------> {u || \invEvUp()} noXAtHistory
	updateParallelToReadInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noRAtHistory(loc2, label2)==>)

		\replacewith({u}noRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};
	updateParallelToWriteInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noRAtHistory(loc2, label2)==>)

		\replacewith({u}noRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noWAtHistory(loc2, label2)==>)

		\replacewith({u}noWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};
	updateParallelToWriteInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noWAtHistory(loc2, label2)==>)

		\replacewith({u}noWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noRaWAtHistory(loc2, label2)==>)

		\replacewith({u}noRaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noRaWAtHistory(loc2, label2)==>)

		\replacewith({u}noRaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelReadInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noWaRAtHistory(loc2, label2)==>)

		\replacewith({u}noWaRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};
	updateParallelWriteInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noWaRAtHistory(loc2, label2)==>)

		\replacewith({u}noWaRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noWaWAtHistory(loc2, label2)==>)

		\replacewith({u}noWaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noWaWAtHistory(loc2, label2)==>)

		\replacewith({u}noWaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

//======================================================================================================================
//										Anonymization and Inverse Anonymization Event Update Application
//======================================================================================================================
//---------------------------------------------------> {\anonEvUp()} noX
 /*   anonEvUpOnNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} noR(loc))

        \replacewith(noRAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    anonEvUpOnNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} noW(loc))

        \replacewith(noWAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    anonEvUpOnNoRaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} noRaW(loc))

        \replacewith(noRaWAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWaR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} noWaR(loc))

        \replacewith(noWaRAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noWaW(loc))

        \replacewith(noWaWAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {u || \anonEvUp()} noX
    updateParallelToAnonEvUpOnNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noR(loc))

        \replacewith({u}noRAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noW(loc))

        \replacewith({u}noWAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoRaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noRaW(loc))
        \replacewith({u}noRaWAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };


    updateParallelToAnonEvUpOnNoWaR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWaR(loc))

        \replacewith({u}noWaRAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoWaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWaW(loc))

        \replacewith({u}noWaWAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {\invAnonEvUp()} noX
    inverseAnonEvUpOnNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noR(loc))

        \replacewith(noRAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noW(loc))

        \replacewith(noWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoRaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noRaW(loc))

        \replacewith(noRaWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };


    inverseAnonEvUpOnNoWaR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noWaR(loc))

        \replacewith(noWaRAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoWaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noWaW(loc))

        \replacewith(noWaWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {u || \invEvUp()} noX
    updateParallelToInverseAnonEvUpOnNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noR(loc))

        \replacewith({u}noRAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noW(loc))

        \replacewith({u}noWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoRaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noRaW(loc))

        \replacewith({u}noRaWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };


    updateParallelToInverseAnonEvUpOnNoWaR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWaR(loc))

        \replacewith({u}noWaRAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoWaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWaW(loc))

        \replacewith({u}noWaWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };
*/

//---------------------------------------------------> {\event} noXHistory
    eventOnNoRAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;


        \find({\event(rw, loc1, ts)}noRAtHistory(loc2, id))

        \replacewith(noRAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    eventOnNoWAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;


        \find({\event(rw, loc1, ts)}noWAtHistory(loc2, id))

        \replacewith(noWAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    eventOnNoRaWAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;

        \find({\event(rw, loc1, ts)}noRaWAtHistory(loc2, id))

        \replacewith(noRaWAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    eventOnNoWaRAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;


        \find({\event(rw, loc1, ts)}noWaRAtHistory(loc2, id))

        \replacewith(noWaRAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    eventOnNoWaWAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;

        \find({\event(rw, loc1, ts)}noWaWAtHistory(loc2, id))

        \replacewith(noWaWAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    //---------------------------------------------------> {u || \event} noXHistory
    /*updateParallelToEventOnNoRAtHistory{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int label, ts;
        \schemaVar \term EventMarker rw;
        \schemaVar \update u;
        \schemaVar \skolemTerm LocSet tempVarLoc;
        \schemaVar \skolemTerm int tempVarLabel;

        \find({u || \event(rw, loc1, ts)} noRAtHistory(loc2, label))
        \varcond(\new(tempVarLoc, \dependingOn(loc1)),
        	     \new(tempVarLoc, \dependingOn(ts)),
        	     \new(tempVarLoc, \dependingOn(loc2)),
        	     \new(tempVarLabel, \dependingOn(loc1)),
                 \new(tempVarLabel, \dependingOn(ts)),
                 \new(tempVarLabel, \dependingOn(label)))

        \replacewith({u}noRAtHistory(tempVarLoc, tempVarLabel - 1))
        \add(tempVarLoc = {\event(rw, loc1, ts)}loc2, tempVarLabel = {\event(rw, loc1, ts)}label ==> )

        \heuristics(update_apply)
    };

    updateParallelToEventOnNoWAtHistory{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int label, ts;
        \schemaVar \term EventMarker rw;
        \schemaVar \update u;
        \schemaVar \skolemTerm LocSet tempVarLoc;
        \schemaVar \skolemTerm int tempVarLabel;

        \find({u || \event(rw, loc1, ts)} noWAtHistory(loc2, label))
        \varcond(\new(tempVarLoc, \dependingOn(loc1)),
                 \new(tempVarLoc, \dependingOn(ts)),
                 \new(tempVarLoc, \dependingOn(loc2)),
                 \new(tempVarLabel, \dependingOn(loc1)),
                 \new(tempVarLabel, \dependingOn(ts)),
                 \new(tempVarLabel, \dependingOn(label)))

        \replacewith({u}noWAtHistory(tempVarLoc, tempVarLabel - 1))
        \add(tempVarLoc = {\event(rw, loc1, ts)}loc2, tempVarLabel = {\event(rw, loc1, ts)}label ==> )

        \heuristics(update_apply)
    };*/ //in case they are needed, write new ones
//---------------------------------------------------> {\anonEvUp()} noXHistory
    anonEvUpOnNoRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noRAtHistory(loc, label))

        \replacewith(noRAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noWAtHistory(loc, label))

        \replacewith(noWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))
        \heuristics(update_apply)
    };

    anonEvUpOnNoRaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noRaWAtHistory(loc, label))

        \replacewith(noRaWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWaRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noWaRAtHistory(loc, label))

        \replacewith(noWaRAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noWaWAtHistory(loc, label))

        \replacewith(noWaWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {u || \anonEvUp()} noXAtHistory
    updateParallelToAnonEvUpOnNoRAtHistory{//Update the rules pdf accordingly

        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noRAtHistory(loc, label))

        \replacewith({u}noRAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))


        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWAtHistory(loc, label))

        \replacewith({u}noWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoRaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noRaWAtHistory(loc, label))

        \replacewith({u}noRaWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };


    updateParallelToAnonEvUpOnNoWaRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWaRAtHistory(loc, label))

        \replacewith({u}noWaRAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)-anonLength(counter)))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoWaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWaWAtHistory(loc, label))

        \replacewith({u}noWaWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)-anonLength(counter)))

        \heuristics(update_apply)
    };
//---------------------------------------------------> {\invAnonEvUp()} noXAtHistory
    inverseAnonEvUpOnNoRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noRAtHistory(loc, label))

        \replacewith(noRAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noWAtHistory(loc, label))

        \replacewith(noWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoRaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noRaWAtHistory(loc, label))

       \replacewith(noRaWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };


    inverseAnonEvUpOnNoWaRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;


        \find({\invAnonEvUp(counter)} noWaRAtHistory(loc, label))

        \replacewith(noWaRAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoWaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;


        \find({\invAnonEvUp(counter)} noWaWAtHistory(loc, label))

        \replacewith(noWaWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {u || \invEvUp()} noXAtHistory
    updateParallelToInverseAnonEvUpOnNoRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noRAtHistory(loc, label))

        \replacewith({u}noRAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWAtHistory(loc, label))

        \replacewith({u}noWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoRaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noRaWAtHistory(loc, label))

        \replacewith({u}noRaWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoWaRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWaRAtHistory(loc, label))

         \replacewith({u}noWaRAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))

        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoWaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term[rigid] int label; // also to the others
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWaWAtHistory(loc, label))

        \replacewith({u}noWaWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))

        \heuristics(update_apply)
    };

    anonLengthPositive{//NEW
     \schemaVar \term int counter;
     \schemaVar \variables int x;

     \add(\forall x; anonLength(x)>=0 ==>)

    };

    anonLengthNotNegative {
        \schemaVar \term int o;

        \find(anonLength(o)) \sameUpdateLevel

        \add(anonLength(o) >= 0 ==>)

        \heuristics(inReachableStateImplication)
    };

    //=======================================================================Rules to deal with infiniteUnion
    /*noRAtHistoryOnLocSetSubtract{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int label;
        \schemaVar \variables LocSet loc;

        \find(noRAtHistory(setMinus(loc1,loc2), label))
        \varcond(\notFreeIn(loc, loc1, loc2, label))

        \replacewith(\forall loc;noRAtHistory(loc, label))
        \add(\forall loc; (subset(loc, loc1) & intersect(loc, loc2) = empty)==>)

        \heuristics(lateSimplification)
    };*/

//======================================================================================================================
//======================================================================================================================
//=========================================Rules only for generating loop invariant=====================================
//=====================================Only activated while generating loop invariant===================================
//=========================================Deactivate for proving loop invariant========================================
//======================================================================================================================
//======================================================================================================================


//======================================================================================================================
//												Converting noX To noXAtHistory
//======================================================================================================================

	// To Prove, probably it should be a rewrite rule
   noRtoNoRH {
	    \schemaVar \term LocSet loc;
		\find(noR(loc))
		\replacewith(noRAtHistory(loc, 0))
		\heuristics(concrete)
	};

	noWtoNoWH {
	    \schemaVar \term LocSet loc;
		\find(noW(loc))
		\replacewith(noWAtHistory(loc, 0))
		\heuristics(concrete)
	};

	noWaWtoNoWaWH {
	    \schemaVar \term LocSet loc;
		\find(noWaW(loc))
		\replacewith(noWaWAtHistory(loc, 0))
		\heuristics(concrete)
	};

	noWaRtoNoWaRH {
	    \schemaVar \term LocSet loc;
		\find(noWaR(loc))
		\replacewith(noWaRAtHistory(loc, 0))
		\heuristics(concrete)
	};

	noRaWtoNoRaWH {
	    \schemaVar \term LocSet loc;
		\find(noRaW(loc))
		\replacewith(noRaWAtHistory(loc, 0))
		\heuristics(concrete)
	};
}
