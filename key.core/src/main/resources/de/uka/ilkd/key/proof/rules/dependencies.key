\sorts {
   \generic U;
}

\schemaVariables{
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
}

//======================================================================================================================
// 												General Rules
//======================================================================================================================

\rules {

// to help with proving the loop invariant

  /* locSetAssSameRightDiffLeft{
        \schemaVar \term LocSet loc1, loc2, loc;

        \assumes(loc1 = loc ==>)
        \find(loc2 = loc ==>)
        \add(loc1 = loc2 ==>)

        \heuristics(simplify_ENLARGING)
    };*/


// unfold boundaries
	unfoldBounds {
		\schemaVar \term numbers a,b;
		\schemaVar \term int x;

		\assumes(x <= Z(b) ==>)
		\find(x >= Z(a) ==> )

		\replacewith( x=Z(a) ==>);

		\replacewith( x>=Z(a) + 1 ==>)

		\heuristics(dep_pred_unroll_fixed_bounds)

	};

	parallelUpdateAssociative {
	    \schemaVar \update u1, u2, u3;

	    \find (u1 || (u2 || u3))
	    \replacewith(u1 || u2 || u3)

	    \heuristics(simplify)

	};
}

//======================================================================================================================
//												Data Dependence Rules
//======================================================================================================================


\rules(programRules:Java, dependencies:on) {
  // Unwinding rules
   loopUnwind    {
            \schemaVar \program Statement #s;
            \schemaVar \program Expression #e;
            \schemaVar \formula post;
            \schemaVar \program Label #innerLabel, #outerLabel;


            \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
             \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
                 \replacewith ({timestamp := timestamp + 1}\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel,
                                       while(#e) #s); ...}\endmodality(post))
             \heuristics(loop_expand)
          };
}



\rules(programRules:Java, runtimeExceptions:ban, dependencies: on) {

//======================================================================================================================
//													Assignment Rules
//======================================================================================================================

	assignment  {
		\schemaVar \program Variable #loc;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
		\replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_read_attribute {
		\schemaVar \program Variable #v0, #v, #a;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
		\varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		\event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v=null))
		;
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_read_attribute_this {
		\schemaVar \program Variable #v0, #v, #a;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
		\varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		\replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		\event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	/* assignment_read_length {
	\schemaVar \program Variable #v0, #v;
	\schemaVar \formula post;

	\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
	\varcond(\not\isThisReference(#v))
	"Normal Execution (#v != null)":
	\replacewith(==> {#v0 := length(#v)}

	\modality{#allmodal}{.. ...}\endmodality(post))
	//\add (==>(#v=null))
	;
	"Null Reference (#v = null)":
	\replacewith(==> false)
	\add (#v=null ==>)
	\heuristics(simplify_prog, simplify_prog_subset)
	};*/


	assignment_write_attribute {

		\schemaVar \program Variable #v, #a;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
		\varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		\event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		//\add (==>(#v=null))
		;

		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment"
	};

	assignment_write_attribute_this {

		\schemaVar \program Variable #v, #a;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
		\varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		\replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		\event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentThis"
	};

//======================================================================================================================
//												Array Assignment Rules
//======================================================================================================================

	assignment_read_length {
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program ArrayLength #length;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {#v0 := length(#v)}
		//To Be Fixed. We need the LocSet here.
		/*{\event(read,singleton(length(#v)),timestamp)}
		{timestamp:=timestamp + 1}
		{\event(write,singleton(#v0),timestamp)}
		{timestamp:=timestamp + 1}*/
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v=null))
		;
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_array_read_EventUpdate{
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
		\varcond(\hasElementarySort(#v0, G))
		"Normal Execution (#v0 != null)":
		\replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}
		{\event(read,singleton(#v0,arr(#se)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
		;
		"Null Reference (#v0 = null)":
		\replacewith(==> false)
		\add (#v0=null ==>);
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
		\replacewith(==> false)
		\add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	//\rules(programRules:Java, runtimeExceptions:allow, dependencies:off) {
	//assignment_to_primitive_array_component {
	//\schemaVar \modalOperator { diamond, box } #normal;
	//\find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	//\varcond(\not \isReferenceArray(#v))
	//"Normal Execution (#v != null)":
	//\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
	//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
	//(permissions:on) {
	//"Write Permission to #v[#se]":
	//\replacewith(\modality{#normal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality(post))
	//\add(==> writePermission(Permission::select(permissions, #v, arr(#se))))
	//};
	//"Null Reference (#v = null)":
	//\replacewith(\modality{#normal}{..
	//throw new java.lang.NullPointerException();
	//...}\endmodality(post))
	//\add (#v=null ==>);
	//"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
	//\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
	//\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	//\heuristics(simplify_prog, simplify_prog_subset)
	//};
	//}

	assignment_to_primitive_array_component_EventUpdate {
		\schemaVar \program Variable #v;
		\schemaVar \program SimpleExpression #se,#se0;
		\schemaVar \formula post;

		\schemaVar \modalOperator { diamond, box } #normal;
		\find (==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
		\varcond(\not \isReferenceArray(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)}
		{\event(write,singleton(#v,arr(#se)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#normal}{.. ...}\endmodality(post))
		//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
		;
		(permissions:on) {
		"Write Permission to #v[#se]":
		\replacewith(==> writePermission(Permission::select(permissions, #v, arr(#se))))
		};
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>);
		"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		\replacewith(==> false)
		\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

//======================================================================================================================
//														Axioms
//======================================================================================================================

	noRaWOnEmptySet{

		\find(noRaW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaROnEmptySet{

		\find(noWaR(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaWOnEmptySet{

		\find(noWaW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWOnEmptySet{

		\find(noW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noROnEmptySet{

		\find(noR(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	rPredOnEmptySet{//New
		\schemaVar \term int id;

		\find(rPred(empty,id))
		\replacewith(false)

		\heuristics(concrete)
	};

	wPredOnEmptySet{//New
		\schemaVar \term int id;

		\find(wPred(empty,id))
		\replacewith(false)

		\heuristics(concrete)
	};

	noRAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noRAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noRaWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noRaWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaRAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWaRAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWaWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};
/*
    noRAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noRAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noRaWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noRaWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWaRAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWaRAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWaWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWaWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };*/
//======================================================================================================================
//	Update, Event Update, Inverse Event Update, Anon Update, and Inverse Anon Update  apply on each other
//======================================================================================================================
//-----------------------------------Apply UPDATE on
	applyUpdateOnEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term int ts;

	 	\find({u}(\event(rw, loc, ts)))

	 	\replacewith(\event({u}rw, {u}loc, {u}ts))

	 	\heuristics(update_apply_on_update)
	};

	applyUpdateOnInverseEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term int ts;

	 	\find({u}(\invEvUp(rw, loc, ts)))

	 	\replacewith(\invEvUp({u}rw, {u}loc, {u}ts))

	 	\heuristics(update_apply_on_update)
	};


    applyUpdateOnAnonEv {
        \schemaVar \update u;
        \schemaVar \term int counter;

        \find({u}\anonEvUp(counter))

        \replacewith(\anonEvUp({u}counter))

        \heuristics(update_apply_on_update)
    };

    applyUpdateOnInverseAnonEvent {
        \schemaVar \update u;
        \schemaVar \term int counter;

        \find({u}\invAnonEvUp(counter))

        \replacewith(\invAnonEvUp({u}counter))

        \heuristics(update_apply_on_update)
    };
//-----------------------------------Apply EVENT on
/*	applyEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term EventMarker rw;
        \schemaVar \term LocSet loc;
        \schemaVar \term int ts;

        \find({\event(rw, loc, ts)}(pv := t))

        \replacewith((pv := {\event(rw, loc, ts)}t))

        \heuristics(update_apply_on_update)
    };

    applyUpdateParallelToEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}(pv := t))

		\replacewith((pv := {u || \event(rw, loc, ts)}t))

		\heuristics(update_apply_on_update)//userTaclets1)
	};

	applyEventOnEvent {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term EventMarker rw1,rw2;
        \schemaVar \term int ts1,ts2;

        \find({\event(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))

        \replacewith(\event({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))

        \heuristics(update_apply_on_update)
    };

    applyEventOnInverseEvent {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term EventMarker rw1,rw2;
        \schemaVar \term int ts1,ts2;

        \find({\event(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))

        \replacewith(\invEvUp({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))

        \heuristics(update_apply_on_update)
    };

    applyEventOnInverseAnonEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\event(rw, loc, ts)}(\invAnonEvUp(counter)))

        \replacewith(\invAnonEvUp({\event(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

    applyEventOnAnonEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\event(rw, loc, ts)}(\anonEvUp(counter)))

        \replacewith(\anonEvUp({\event(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply INVERSE EVENT on
	applyInverseEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}(pv := t))

		\replacewith((pv := {\invEvUp(rw, loc, label)}t))

		\heuristics(update_apply_on_update)
	};

	applyUpdateParallelToInvEvUpOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \update u, invEvent;

		\find({u || invEvent}(pv := t))
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith((pv := {u || invEvent}t))

		\heuristics(update_apply_on_update)//userTaclets1)
	};

    applyInvEvUpParallelToUpdateOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \update u, invEvent;

        \find({invEvent || u}(pv := t))
        \varcond(\onlyInverseEventUpdates(invEvent))

        \replacewith((pv := {invEvent || u}t))

        \heuristics(update_apply_on_update)//userTaclets1)
    };

	applyInverseEventOnEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;

	 	\find({\invEvUp(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))

	 	\replacewith(\event({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))

	 	\heuristics(update_apply_on_update)
	};

	applyInverseEventOnInverseEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;

	 	\find({\invEvUp(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))

	 	\replacewith(\invEvUp({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))

	 	\heuristics(update_apply_on_update)
	};

    applyInverseEventOnAnonEv {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\invEvUp(rw, loc, ts)}(\anonEvUp(counter)))

        \replacewith(\anonEvUp({\invEvUp(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

    applyInverseEventOnInvAnonEv {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\invEvUp(rw, loc, ts)}(\invAnonEvUp(counter)))

        \replacewith(\invAnonEvUp({\invEvUp(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply ANON EVENT on

    applyAnonEventOnEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\anonEvUp(counter)}(\event(rw, loc, ts)))

        \replacewith(\event({\anonEvUp(counter)}rw, {\anonEvUp(counter)}loc, {\anonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };

    applyAnonEvOnInverseEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\anonEvUp(counter)}(\invEvUp(rw, loc, ts)))

        \replacewith(\invEvUp({\anonEvUp(counter)}rw, {\anonEvUp(counter)}loc, {\anonEvUp(counter)}ts ))

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnAnonEvent {
        \schemaVar \term int counter1, counter2;

        \find({\anonEvUp(counter1)}(\anonEvUp(counter2)))

        \replacewith(\anonEvUp({\anonEvUp(counter1)}counter2 ))

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnInvAnonEvent {//Replaced by two rules below to avoid to many branches
        \schemaVar \term int counter1, counter2;

        \find({\anonEvUp(counter1)}(\invAnonEvUp(counter2)))

        \replacewith(skip)
        \add(==>counter1=counter2);

        \replacewith(\invAnonEvUp({\anonEvUp(counter1)}counter2 + counter1))
        \add(==>counter1!=counter2)

        \heuristics(update_apply_on_update)
    };


    applyUpdateParallelToAnonEventOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({u||\anonEvUp(counter)}(pv := t))

        \replacewith(pv := {u||\anonEvUp(counter)}t)

        \heuristics(update_apply_on_update)
    };

    applyAnonEventParallelToUpdateOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({\anonEvUp(counter)||u}(pv := t))

        \replacewith(pv := {\anonEvUp(counter)||u}t)

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}(pv := t))

        \replacewith((pv := {\anonEvUp(counter)}t))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply INVERSE ANON EVENT on

    applyInverseAnonEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}(pv := t))

        \replacewith((pv := {\invAnonEvUp(counter)}t))

        \heuristics(update_apply_on_update)
    };

	applyInverseAnonEventOnEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\invAnonEvUp(counter)}(\event(rw, loc, ts)))

        \replacewith(\event({\invAnonEvUp(counter)}rw, {\invAnonEvUp(counter)}loc, {\invAnonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };

	applyInverseAnonEventOnInverseEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\invAnonEvUp(counter)}(\invEvUp(rw, loc, ts)))

        \replacewith(\invEvUp({\invAnonEvUp(counter)}rw, {\invAnonEvUp(counter)}loc, {\invAnonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };


    applyInvAnonEventOnAnonEventSameCounter {
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}(\anonEvUp(counter)))

        \replacewith(skip)

        \heuristics(update_apply_on_update)
    };



    applyInverseAnonEventOnAnonEvent {
        \schemaVar \term int counter1, counter2;

        \find({\invAnonEvUp(counter1)}(\anonEvUp(counter2)))

        \replacewith(\invAnonEvUp({\anonEvUp(counter1)}counter2))

        \heuristics(update_apply_on_update)
    };

    applyUpdateParallelToInverseAnonEventOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({u||\invAnonEvUp(counter)}(pv := t))

        \replacewith(pv := {u||\invAnonEvUp(counter)}t)

        \heuristics(update_apply_on_update)
    };

    applyInverseAnonEventParallelToUpdateOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({\invAnonEvUp(counter)||u}(pv := t))

        \replacewith(pv := {\invAnonEvUp(counter)||u}t)

        \heuristics(update_apply_on_update)
    };
*/
//======================================================================================================================
//					Event, Inverse Event, Anon Event, and Inverse Anon Event Update Elimination Rules
//======================================================================================================================
	//---------------------------------------------------> Events:

	/*elimUpdateOnRigidTerm1 {
	    \schemaVar \term[rigid] any t;
		\schemaVar \update u;

		\find({u}t)

		\replacewith(t)

		\heuristics(update_elim)
	};

	elimEventOnRigidTerm2 {
		\schemaVar \term any t, result;
		\schemaVar \update u;

		\find({u}t)
		\varcond(\applyEventUpdateOnRigid(u, t, result))

		\replacewith(result)

		\heuristics(update_elim)
	};

	elimEventOnRigidFormula1 {
	    \schemaVar \formula[rigid] phi;
		\schemaVar \update u;

		\find({u}phi)

		\replacewith(phi)

		\heuristics(update_elim)
	};

	elimEventOnRigidFormula2 {
		\schemaVar \formula phi, result;
		\schemaVar \update u;

		\find({u}phi)
		\varcond(\applyEventUpdateOnRigid(u, phi, result))

		\replacewith(result)

		\heuristics(update_elim)
	};*/


	elimEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({\event(rw, loc, ts)}pv)

		\replacewith(pv)

		\heuristics(update_elim)
	};

	elimEventOnSkip {
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({\event(rw, loc, ts)}skip)

		\replacewith(skip)

		\heuristics(update_elim)
	};

	applyUpdateParallelToEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}pv)

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	};

	applyUpdateParallelToEventOnSkip {
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}skip)

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	};
	//---------------------------------------------------> Inverse Events:
	/*elimInverseEventOnRigidTerm1 {
		\schemaVar \term[rigid] any t;
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)} t)

		\replacewith(t)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidTerm2 {
		\schemaVar \term any t, result;
		\schemaVar \update u;

		\find({u}t)
		\varcond(\applyInverseEventUpdateOnRigid(u, t, result))

		\replacewith(result)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidFormula1 {
		\schemaVar \formula[rigid] phi;
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}phi)

		\replacewith(phi)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidFormula2 {
		\schemaVar \formula phi, result;
		\schemaVar \update u;

		\find({u}phi)
		\varcond(\applyInverseEventUpdateOnRigid(u, phi, result))

		\replacewith(result)

		\heuristics(update_elim)
	};*/

	elimInverseEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}pv)

		\replacewith(pv)

		\heuristics(update_elim)
	};

	elimInverseEventOnSkip {
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}skip)

		\replacewith(skip)

		\heuristics(update_elim)
	};

	applyUpdateParallelToInvEvUpOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \update u, invEvent;

		\find({u || invEvent}pv)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	};

	 applyInvEvUpParallelToUpdateOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \update u, invEvent;

		\find({invEvent || u}pv)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	 };

	 applyUpdateParallelToInvEvUpOnSkip {
		\schemaVar \update u, invEvent;

		\find({u || invEvent}skip)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	 };

	applyInvEvUpParallelToUpdateOnSkip {
		\schemaVar \update u, invEvent;

		\find({invEvent || u}skip)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	};

//---------------------------------------------------> AnonEvents:

 /*   elimAnonEventOnRigidTerm1 {
        \schemaVar \term[rigid] any t;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} t)

        \replacewith(t)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidTerm2 {
        \schemaVar \term any t, result;
        \schemaVar \update anonEv;

        \find({anonEv}t)
        \varcond(\applyAnonEventUpdateOnRigid(anonEv, t, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidFormula1 {
        \schemaVar \formula[rigid] phi;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}phi)

        \replacewith(phi)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidFormula2 {
        \schemaVar \formula phi, result;
        \schemaVar \update anonEv;

        \find({anonEv}phi)
        \varcond(\applyAnonEventUpdateOnRigid(anonEv, phi, result))

        \replacewith(result)

        \heuristics(update_elim)
    };*/

    elimAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}pv)

        \replacewith(pv)

        \heuristics(update_elim)
    };

    elimAnonEventOnSkip {
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };

    applyUpdateParallelToAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)}pv)

        \replacewith({u}pv)

        \heuristics(update_apply)
    };

    applyUpdateParallelToAnonEventOnSkip {
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };
//---------------------------------------------------> InverseAnonEvents:

   /*elimInverseAnonEventOnRigidTerm1 {
       \schemaVar \term[rigid] any t;
       \schemaVar \term int counter;

       \find({\invAnonEvUp(counter)} t)

       \replacewith(t)

       \heuristics(update_elim)
   };

    elimInvAnonEventOnRigidTerm2 {
        \schemaVar \term any t, result;
        \schemaVar \update invAnonEv;

        \find({invAnonEv}t)
        \varcond(\applyInverseAnonEventUpdateOnRigid(invAnonEv, t, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    elimInverseAnonEventOnRigidFormula1 {
        \schemaVar \formula[rigid] phi;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}phi)

        \replacewith(phi)

        \heuristics(update_elim)
     };
  elimInvAnonEventOnRigidFormula2 {
        \schemaVar \formula phi, result;
        \schemaVar \update invAnonEv;

        \find({invAnonEv}phi)
        \varcond(\applyInverseAnonEventUpdateOnRigid(invAnonEv, phi, result))

        \replacewith(result)

        \heuristics(update_elim)
    };*/

    elimUpdateOnRigidTerm {

        \schemaVar \update u;
        \schemaVar \term[rigid] any t;

        \find({u}t)
        \replacewith(t)
        \heuristics(update_elim)

    };

    elimUpdateOnRigidFormula {

            \schemaVar \update u;
            \schemaVar \formula[rigid] phi;

            \find({u}phi)
            \replacewith(phi)
            \heuristics(update_elim)

        };

    elimInvAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}pv)

        \replacewith(pv)

        \heuristics(update_elim)
    };

    elimInvAnonEventOnSkip {
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };

    applyUpdateParallelToInvAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)}pv)

        \replacewith({u}pv)

        \heuristics(update_apply)
    };

    applyUpdateParallelToInvAnonEventOnSkip {
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)//userTaclets1)
    };
//======================================================================================================================
//													Splitting Rules
//======================================================================================================================
	//---------------------------------------------------> Dependence Predicates:
	splitNoRaW {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noRaW(union(loc1,loc2)))
	    \replacewith(noRaW(loc1) & noRaW(loc2))

	    \heuristics(simplify)
	};

	splitNoWaR {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noWaR(union(loc1,loc2)))
	    \replacewith(noWaR(loc1) & noWaR(loc2))

	    \heuristics(simplify)
	};

	splitNoWaW {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noWaW(union(loc1,loc2)))
	    \replacewith(noWaW(loc1) & noWaW(loc2))

	    \heuristics(simplify)
	};

	splitNoR {
		\schemaVar \term LocSet loc1, loc2;

	    \find(noR(union(loc1,loc2)))
	    \replacewith(noR(loc1) & noR(loc2))

	    \heuristics(simplify)
	};

	splitNoW {
		\schemaVar \term LocSet loc1, loc2;

		\find(noW(union(loc1,loc2)))
		\replacewith(noW(loc1) & noW(loc2))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> Dependence Predicates with EQ:
	splitNoRaWEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRaW(EQ)) \sameUpdateLevel
	    \replacewith(noRaW(loc1) & noRaW(loc2))

	    \heuristics(simplify)
	};

	splitNoWaREQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaR(EQ)) \sameUpdateLevel
	    \replacewith(noWaR(loc1) & noWaR(loc2))

	    \heuristics(simplify)
	};

	splitNoWaWEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaW(EQ)) \sameUpdateLevel
	    \replacewith(noWaW(loc1) & noWaW(loc2))

	    \heuristics(simplify)
	};

	splitNoREQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noR(EQ)) \sameUpdateLevel
	    \replacewith(noR(loc1) & noR(loc2))

	    \heuristics(simplify)
	};

	splitNoWEQ {
		\schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noW(EQ)) \sameUpdateLevel
	    \replacewith(noW(loc1) & noW(loc2))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> History Predicates:
	splitNoRaWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noRaWAtHistory(union(loc1,loc2), label))
	    \replacewith(noRaWAtHistory(loc1, label) & noRaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaRAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWaRAtHistory(union(loc1,loc2), label))
	    \replacewith(noWaRAtHistory(loc1, label) & noWaRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWaWAtHistory(union(loc1,loc2), label))
	    \replacewith(noWaWAtHistory(loc1, label) & noWaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoRAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noRAtHistory(union(loc1,loc2), label))
	    \replacewith(noRAtHistory(loc1, label) & noRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWAtHistory(union(loc1,loc2), label))
	    \replacewith(noWAtHistory(loc1, label) & noWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> History Predicates with EQ:
	splitNoRaWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRaWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noRaWAtHistory(loc1, label) & noRaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaRAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaRAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWaRAtHistory(loc1, label) & noWaRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWaWAtHistory(loc1, label) & noWaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoRAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noRAtHistory(loc1, label) & noRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWAtHistory(loc1, label) & noWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

//======================================================================================================================
//												Data Dependence Known
//======================================================================================================================
	//---------------------------------------------------> Data Dependence Predicates:
	// To Prove
	noRKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noR(loc1) ==> )
		\find(==> noR(loc2))
		\replacewith(==> noR(setMinus(loc2,loc1)), subset(loc2,loc1))
		\heuristics(dep_pred_known,noEqApp)
	};

	//--------------------------------------------
	// These rules (and similar ones for other predicates) were causing Loops:

	// noRKnownForSupersetOrSubsetDef{
	//	\schemaVar \term LocSet loc1, loc2;
	//
	//	\assumes(noR(loc1) ==> )
	//	\find(==> noR(loc2))
	//
	//	\replacewith(==>noR(setMinus(loc2,loc1)))
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations_def)
	//	};
	// noRKnownForSupersetOrSubset2{
	//	\schemaVar \term LocSet loc1, loc2;
	//
	//	\assumes(noR(loc1) ==> )
	//	\find(==> noR(loc2))
	//
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations)
	//	};
	//----------------------------------------------
}