/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains the RULES for heaps
// To find the DECLARATIONS for heaps, please visit heapRules.key


\rules(programRules:Java) {

    /*! Unrolls the definition of the assignable predicate. */
    assignableDefinition {
        \schemaVar \term Heap heapOld;
        \schemaVar \term Heap heapNew;
        \schemaVar \term LocSet locs;

        \schemaVar \variables Field f;
        \schemaVar \variables java.lang.Object o;

        \find(assignable(heapNew, heapOld, locs))
        \varcond(\notFreeIn(o, locs, heapOld, heapNew),
                 \notFreeIn(f, locs, heapOld, heapNew))

        \replacewith(\forall f;
                       (\forall o;
                         (  elementOf(o, f, locs)
                          | !o = null
                          & !boolean::select(heapOld, o, java.lang.Object::<created>) = TRUE
                          | any::select(heapNew, o, f) = any::select(heapOld, o, f))))
        \heuristics(delayedExpansion)
    };

    // --------------------------------------------------------------------------
    // axioms for select/store (here for manual use only)
    // --------------------------------------------------------------------------

    selectOfStore {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term alpha x;

        \find(beta::select(store(h, o, f, x), o2, f2))

        \replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o2, f2)))
        \heuristics(semantics_blasting)
    };

    selectOfCreate {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;

        \find(beta::select(create(h, o), o2, f))

        (permissions:off) {
            \replacewith(\if(o = o2 & o != null & f = java.lang.Object::<created>)
                    \then((beta)TRUE)
                    \else(beta::select(h, o2, f)))
        };
        (permissions:on) {
            // Permissions are not initialised by Java code when objects are constructed
            // so it is necessary to know the default value for permissions on freshly created objects
            // (applies to all selectOfCreate rules)
            \replacewith(\if(o = o2 & o != null)
                    \then(\if(f = java.lang.Object::<created>) \then((beta)TRUE) \else(beta::defaultValue))
                    \else(beta::select(h, o2, f)))
        }
        \heuristics(semantics_blasting)
    };

    selectOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(beta::select(anon(h, s, h2), o, f))

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>
                | elementOf(o, f, freshLocs(h)))
                \then(beta::select(h2, o, f))
                \else(beta::select(h, o, f)))
        \heuristics(semantics_blasting)
    };

    selectOfMemset {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(beta::select(memset(h, s, x), o, f))

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o, f)))
        \heuristics(semantics_blasting)
    };

    // CS: This is an implicit axiom which follows from the rules
    // selectCreatedOfAnon and selectOfAnon. I made the axiom explicit in this
    // rule. The rule is proven correct within KeY using the rules
    // selectCreatedOfAnon and selectOfAnon on the cut-formula
    // \forall Heap h2;
    // ( boolean::select(anon(v_h_0, empty, h2), null, java.lang.Object::<created>) =
    //   boolean::select(anon(v_h_0, empty, h2), null, java.lang.Object::<created>)   ) .
    // See comment on selectCreatedOfAnon.
    nullCreated {
        \schemaVar \variables Heap h;

        \add((\forall h; boolean::select(h, null, java.lang.Object::<created>) = TRUE) |
            (\forall h; boolean::select(h, null, java.lang.Object::<created>) = FALSE) ==>)
    };

    // --------------------------------------------------------------------------
    // EQ versions of axioms for select/store (here for manual use only)
    // --------------------------------------------------------------------------

    // proven with KeY for beta = Object using selectOfStore (CS)
    selectOfStoreEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term alpha x;
        \schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(beta::select(EQ, o2, f2))
        \sameUpdateLevel

        \replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o2, f2)))
        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY for beta = Object using selectOfCreate (CS)
    selectOfCreateEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term Heap EQ;

        \assumes(create(h, o) = EQ ==>)
        \find(beta::select(EQ, o2, f))
        \sameUpdateLevel

        (permissions:off) {
            \replacewith(\if(o = o2 & o != null & f = java.lang.Object::<created>)
                    \then((beta)TRUE)
                    \else(beta::select(h, o2, f)))
        };
        (permissions:on) {
            \replacewith(\if(o = o2 & o != null)
                    \then(\if(f = java.lang.Object::<created>) \then((beta)TRUE) \else(beta::defaultValue))
                    \else(beta::select(h, o2, f)))
        }
        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY for beta = Object using selectOfAnon (CS)
    selectOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>
                | elementOf(o, f, freshLocs(h)))
                \then(beta::select(h2, o, f))
                \else(beta::select(h, o, f)))
        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY for beta = Object using selectOfMemset (CS)
    selectOfMemsetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap EQ;

        \assumes(memset(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o, f)))
        \heuristics(simplify_heap_high_costs)
    };

    // --------------------------------------------------------------------------
    // Prevent exponetial term size explosion of select terms by introduction of
    // linear many equations.
    //
    // author: scheben
    //
    // When Daniel and I worked on a case study, we discovered
    // some serious performance issues with older KeY versions. One of the
    // problems was that the at this time current master had serious problems
    // with the simplification of select-terms. For instance, KeY was not able
    // to automatically find a proof for the method foo_2() in the following
    //  example within 20 minutes (using the contract of bar()):
    //
    // class AccessChain4 {
    //   AccessChain4 a;
    //   int x;
    //   int y;
    //
    //   //@ requires a != null && a.a != null && a.a.a != null && a.a.a.a != null;
    //   //@ requires a.a.a.a.x > 0;
    //   //@ ensures a.a.a.a.x > 0;
    //   void foo_2 () {
    //     a.a.a.a.x++; bar();
    //     a.a.a.a.x++; bar();
    //   }
    //
    //   //@ ensures true;
    //   //@ assignable y;
    //   void bar () {};
    // }
    //
    // This was caused by the inplace-simplification of select-terms. Starting
    // with a harmless select-term like  h2[h2[h2[h2[self.a].a].a].x]  we got
    // by the select-axioms in a first step (for instance)
    //
    //   \if ((h2[h2[h2[self.a].a].a], x) \in {(self, y)} & !x=<created> |
    //        (h2[h2[h2[self.a].a].a], x) \in freshLocs(store(h, self.a.a.a.a,
    // x, 1 + self.a.a.a.a.x)))
    //   \then (anon_h2[h2[h2[h2[self.a].a].a].x])
    //   \else (store(h, self.a.a.a.a, x, 1 +
    // self.a.a.a.a.x)[h2[h2[h2[self.a].a].a].x])
    //
    // Because the condition of the \if cannot be simplified easily in any case
    // (like in the case above), we got by recursive application of the
    // select-axioms a term whose size grows exponentially in the number of
    // nested selects. This on the other hand slowed KeY extremely down. The
    // problem appeared also in several other examples, for instance in the
    // following often used dynamic framing pattern:
    //
    // class DynamicGhost {
    //     int x;
    //     C c;
    //
    //     //@ public ghost \locset rep;
    //
    //     //@ public invariant \subset(\locset(rep), rep);
    //     //@ private invariant rep == this.*;
    //
    //     //@ private invariant \disjoint(rep, c.rep);
    //     //@ private invariant \invariant_for(c);
    //
    //     //@ normal_behavior
    //     //@ requires x > 0;
    //     //@ ensures x > 0;
    //
    //     void dynamicGhost_4 () {
    //         x++; c.helper();
    //         x++; c.helper();
    //         x++; c.helper();
    //         x++; c.helper();
    //     }
    //
    //     class C {
    //         int y;
    //
    //         //@ public ghost \locset rep;
    //         //@ public invariant \subset(\locset(rep), rep);
    //         //@ private invariant rep == this.*;
    //
    //         //@ accessible \inv: rep;
    //
    //         //@ normal_behavior
    //         //@ ensures \new_elems_fresh(rep);
    //         //@ assignable rep;
    //         public void helper() {}
    //     }
    // }
    //
    // The above method dynamicGhost_4() could not be proven by the old master
    // within 20 minutes.
    //
    // I addressed the problem by modifying the strategy such that a
    // select term is pulled out before it is simplified. This results in a set
    // of auxiliary-equations which are solved and applied backwards if the
    // result has been computed. After the backwards-application of the
    // auxiliary-equations, no longer needed equations are automatically
    // hidden, such that the sequent is not cluttered by auxiliary-equations.
    // With this strategy, the size of a sequent grows at most linearly with
    // the number of nested selects. Applied to the above examples, the
    // modified strategy can automatically find the proofs within 3 seconds.
    //
    // For testing the performance of KeY, Daniel and I created several test
    // series in the folder examples/performance-test/ which could also be
    // useful in the future.
    //
    // The main drawback of the new strategy that I see is that selects are
    // not simplified under quantifiers automatically any more (because here we
    // cannot do a pullout). However, in some cases it is indeed no good idea
    // to try to do so (because of the possibility of exponentially growing
    // terms).
    //
    // Additionally, the "look-and-feel" changed. I tried to implement
    // every step of the new strategy as transparent as possible for the user
    // (pullout, apply equality, simplify, apply equality reverse, hide
    // equality). However, on simple examples the inplace-simplification might
    // be better readable for humans. On complex examples on the other hand, I
    // think the pullout increases readability. Further one might get puzzled
    // that KeY now sometimes replaces a select term directly by its value.
    // That is because I store the value of each select term which has been
    // simplified once and insert that value directly if the select term occurs
    // again later on in the proof. First of all this increases performance
    // (why should we calculate the same value over and over again?) and
    // secondly I personally prefer to convince my self once that some select
    // term simplifies to a particular value and afterwards I don't want to see
    // the simplification again.
    //
    // --------------------------------------------------------------------------

    // this is a specialisation of the normal pull out rule which
    // matches only select-terms and introduces a skolem constant with a
    // particular label (which is used in the  strategy)
    pullOutSelect {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \skolemTerm beta selectSK;

        \find(beta::select(h, o, f))
        \sameUpdateLevel

        \replacewith(selectSK<<selectSK>>)
        \add(beta::select(h, o, f) = selectSK<<selectSK>> ==>)
        \heuristics(pull_out_select)
    };

    simplifySelectOfStore {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term alpha x;
        \schemaVar \term beta sk;

        \find(beta::select(store(h, o, f, x), o2, f2) = sk ==>)
        \inSequentState

        \replacewith(
            \if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o2, f2))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(store(h, o, f, x), o2, f2))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfStoreEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term alpha x;
        \schemaVar \term beta sk;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(beta::select(EQ, o2, f2) = sk ==>)
        \inSequentState

        \replacewith(
            \if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o2, f2))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(EQ, o2, f2))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfCreate {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \find(beta::select(create(h, o), o2, f) = sk ==>)
        \inSequentState

        (permissions:off) {
            \replacewith(
                \if(o = o2 & o != null & f = java.lang.Object::<created>)
                    \then((beta)TRUE)
                    \else(beta::select(h, o2, f))
                = sk ==>)
            \addrules(
                replaceKnownSelect {
                    \find(beta::select(create(h, o), o2, f))
                    \inSequentState
                    \replacewith(sk)
                    \heuristics(concrete)
                })
        };
        (permissions:on) {
            \replacewith(
                \if(o = o2 & o != null)
                    \then(\if(f = java.lang.Object::<created>) \then((beta)TRUE) \else(beta::defaultValue))
                    \else(beta::select(h, o2, f))
                = sk ==>)
            \addrules(
                replaceKnownSelect {
                    \find(beta::select(create(h, o), o2, f))
                    \inSequentState
                    \replacewith(sk)
                    \heuristics(concrete)
                })
        }

        \heuristics(simplify_select)
    };

    simplifySelectOfCreateEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(create(h, o) = EQ ==>)
        \find(beta::select(EQ, o2, f) = sk ==>)
        \inSequentState

        (permissions:off) {
            \replacewith(
                \if(o = o2 & o != null & f = java.lang.Object::<created>)
                    \then((beta)TRUE)
                    \else(beta::select(h, o2, f))
                = sk ==>)
            \addrules(
                replaceKnownSelect {
                    \find(beta::select(EQ, o2, f))
                    \inSequentState
                    \replacewith(sk)
                    \heuristics(concrete)
                }
            )
        };
        (permissions:on) {
            \replacewith(
                \if(o = o2 & o != null)
                    \then(\if(f = java.lang.Object::<created>) \then((beta)TRUE) \else(beta::defaultValue))
                    \else(beta::select(h, o2, f))
                = sk ==>)
            \addrules(
                replaceKnownSelect {
                    \find(beta::select(EQ, o2, f))
                    \inSequentState
                    \replacewith(sk)
                    \heuristics(concrete)
                })
        }
        \heuristics(simplify_select)
    };

    simplifySelectOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \find(beta::select(anon(h, s, h2), o, f) = sk ==>)
        \inSequentState

        \replacewith(
            \if(elementOf(o, f, s) & f != java.lang.Object::<created>
                | elementOf(o, f, freshLocs(h)))
                \then(beta::select(h2, o, f))
                \else(beta::select(h, o, f))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(anon(h, s, h2), o, f))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfAnonEQ {
        \schemaVar \term Heap h, h2, EQ;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f) = sk ==>)
        \inSequentState

        \replacewith(
            \if(elementOf(o, f, s) & f != java.lang.Object::<created>
                | elementOf(o, f, freshLocs(h)))
                \then(beta::select(h2, o, f))
                \else(beta::select(h, o, f))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(EQ, o, f))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfMemset {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \find(beta::select(memset(h, s, x), o, f) = sk ==>)
        \inSequentState

        \replacewith(
            \if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                \then(x)
                \else(beta::select(h, o, f))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(memset(h, s, x), o, f))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfMemsetEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(memset(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f) = sk ==>)
        \inSequentState

        \replacewith(
            \if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                \then(x)
                \else(beta::select(h, o, f))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(EQ, o, f))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    // ---
    // Rules for hiding auxiliary equations
    // ---

    hideAuxiliaryEq {
        \schemaVar \term any result, auxiliarySK;

        \find(result = auxiliarySK ==>)
        \inSequentState
        \replacewith( ==>)
        \addrules(
            replaceKnownAuxiliaryConstant {
                \find(auxiliarySK)
                \inSequentState
                \replacewith(result) \heuristics(concrete)
            })
        \heuristics(hide_auxiliary_eq)
    };

    hideAuxiliaryEqConcrete {
        \schemaVar \term any auxiliarySK;

        \find(auxiliarySK = TRUE ==>)
        \inSequentState
        \replacewith( ==>)
        \addrules(
            replaceKnownAuxiliaryConstant {
                \find(auxiliarySK)
                \inSequentState
                \replacewith(TRUE) \heuristics(concrete)
            })
        \heuristics(hide_auxiliary_eq_const)
    };

    hideAuxiliaryEqConcrete2 {
        \schemaVar \term any auxiliarySK;

        \find( ==> auxiliarySK = TRUE)
        \inSequentState
        \replacewith( ==>)
        \addrules(
            replaceKnownAuxiliaryConstant {
                \find(auxiliarySK)
                \inSequentState
                \replacewith(FALSE) \heuristics(concrete)
            })
        \heuristics(hide_auxiliary_eq_const)
    };

}

\rules(programRules:Java) {

    // --------------------------------------------------------------------------
    // lemmata for some common cases
    // --------------------------------------------------------------------------

    dismissNonSelectedField {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, u;
        \schemaVar \term Field f1, f2;
        \schemaVar \term any x;

        \find(alpha::select(store(h, o, f1, x), u, f2))

        \varcond(\differentFields(f1, f2))

        \replacewith(alpha::select(h, u, f2))

        \heuristics(simplify)
    };

    dismissNonSelectedFieldEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term Object o, u;
        \schemaVar \term Field f1, f2;
        \schemaVar \term any x;

        \assumes(store(h, o, f1, x) = EQ ==>)
        \find(alpha::select(EQ, u, f2))
        \sameUpdateLevel
        \varcond(\differentFields(f1, f2))

        \replacewith(alpha::select(h, u, f2))

        \heuristics(simplify)
    };

    dropEffectlessStores {
        \schemaVar \term Heap h, result;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term any x;

        \find(store(h, o, f, x))
        \varcond(\dropEffectlessStores(h, o, f, x, result))

        \replacewith(result)

        \heuristics(concrete)
    };

    memsetEmpty {
        \schemaVar \term Heap h;
        \schemaVar \term any x;

        \find(memset(h, empty, x))

        \replacewith(h)

        \heuristics(concrete)
    };

    // CS: This taclet is not a lemma. It does not follow from the axiom
    // selectOfAnon. The term
    // boolean::select(anon(h, s, h2), null, java.lang.Object::<created>)
    // equals beta::select(h, null, java.lang.Object::<created>) by the
    // definition selectOfAnon and freshLocs. This taclet replaces
    // boolean::select(anon(h, s, h2), null, java.lang.Object::<created>)
    // by beta::select(h, null, java.lang.Object::<created>) |
    //    beta::select(h2, null, java.lang.Object::<created>)   .
    // As a consequence we have forall heaps h, h2
    // beta::select(h, null, java.lang.Object::<created>) <->
    // ( beta::select(h, null, java.lang.Object::<created>) |
    //   beta::select(h2, null, java.lang.Object::<created>)  )
    // which is equivalent to
    // beta::select(h2, null, java.lang.Object::<created>) ->
    // beta::select(h, null, java.lang.Object::<created>)      forall h, h2.
    // Hence we only consider interpretations where (the underspecified)
    // location (null, java.lang.Object::<created>) equals TRUE on all heaps
    // or where it equals FALSE on all heaps. Since we "only" overspecify the
    // the underspecified here and since an adoption of the rule
    // selectCreatedOfAnon would complicate the rule, I chose to make the above
    // observation explicit in the lemma nullCreated instead of changing the
    // rule selectCreatedOfAnon.
    selectCreatedOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;

        \find(boolean::select(anon(h, s, h2), o, java.lang.Object::<created>))

        \replacewith(\if(boolean::select(h, o, java.lang.Object::<created>) = TRUE)
                \then(TRUE)
                \else(boolean::select(h2, o, java.lang.Object::<created>)))

        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonAsFormula {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;

        \find(boolean::select(anon(h, s, h2), o, java.lang.Object::<created>) = TRUE)

        \replacewith(boolean::select(h, o, java.lang.Object::<created>) = TRUE |
            boolean::select(h2, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_ENLARGING)
    };

    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(boolean::select(EQ, o, java.lang.Object::<created>))
        \sameUpdateLevel

        \replacewith(\if(boolean::select(h, o, java.lang.Object::<created>) = TRUE)
                \then(TRUE)
                \else(boolean::select(h2, o, java.lang.Object::<created>)))

        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonAsFormulaEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(boolean::select(EQ, o, java.lang.Object::<created>) = TRUE)
        \sameUpdateLevel

        \replacewith(boolean::select(h, o, java.lang.Object::<created>) = TRUE |
            boolean::select(h2, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_ENLARGING)
    };

    equalityToSelect {
        \schemaVar \term Heap h, h2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(h = h2)
        \varcond(\notFreeIn(ov, h, h2), \notFreeIn(fv, h, h2))

        \replacewith(\forall ov; \forall fv; (any::select(h, ov, fv) = any::select(h2, ov, fv)))

        \heuristics(semantics_blasting)

    };

    // --------------------------------------------------------------------------
    // axioms for using wellFormed
    // --------------------------------------------------------------------------

    onlyCreatedObjectsAreReferenced {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(wellFormed(h) ==>)
        \find(deltaObject::select(h, o, f))
        \sameUpdateLevel

        \add(deltaObject::select(h, o, f) = null
            | boolean::select(h,
                deltaObject::select(h, o, f),
                java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreInLocSets {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;

        \assumes(wellFormed(h) ==>)
        \find(elementOf(o2, f2, LocSet::select(h, o, f)) ==>)

        \add(o2 = null
            | boolean::select(h,
                o2,
                java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreInLocSetsEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term LocSet EQ;

        \assumes(wellFormed(h), LocSet::select(h, o, f) = EQ ==>)
        \find(elementOf(o2, f2, EQ) ==>)

        \add(o2 = null
            | boolean::select(h,
                o2,
                java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    arrayLengthNotNegative {
        \schemaVar \term Object o;

        \find(length(o))
        \sameUpdateLevel

        \add(length(o) >= 0 ==>)

        \heuristics(inReachableStateImplication)
    };

    /*
    enclosing_this_is_created {
        \assumes (obj.<created>@(java.lang.Object) = TRUE, wellFormed(heap) ==>)
        \find ( obj.#et )
        \sameUpdateLevel

        \add ((obj.#et).<created>@(java.lang.Object) = TRUE  ==> obj.#et=null)

        \heuristics(inReachableStateImplication)
    };
    */

    // --------------------------------------------------------------------------
    // axioms for proving wellFormed
    // --------------------------------------------------------------------------

    wellFormedStoreObject {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term deltaObject x;

        \find(wellFormed(store(h, o, f, x)))
        \succedentPolarity

        \varcond(\fieldType(f, alpha))

        \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE & alpha::instance(x) = TRUE))

        \heuristics(simplify_enlarging)
    };

    wellFormedStoreArray {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term int idx;
        \schemaVar \term deltaObject x;

        \find(wellFormed(store(h, o, arr(idx), x)))
        \succedentPolarity

        \varcond(\hasElementarySort(o, alpha))

        \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE & arrayStoreValid(o, x)))

        \heuristics(simplify_enlarging)
    };

    wellFormedStoreLocSet {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet x;

        \find(wellFormed(store(h, o, f, x)))
        \succedentPolarity

        \varcond(\fieldType(f, alpha), \sub(LocSet, alpha))

        \replacewith(wellFormed(h) & createdInHeap(x, h))

        \heuristics(simplify_enlarging)
    };

    wellFormedStorePrimitive {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta x;

        \find(wellFormed(store(h, o, f, x)))
        \succedentPolarity
        \varcond(
            \fieldType(f, alpha),
            \not \sub(beta, java.lang.Object),
            \not \sub(beta, LocSet),
            \sub(beta, alpha))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedStorePrimitiveArray {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term int idx;
        \schemaVar \term beta x;

        \find(wellFormed(store(h, o, arr(idx), x)))
        \succedentPolarity

        \varcond(
            \hasElementarySort(o, alpha),
            \not \sub(beta, java.lang.Object),
            \not \sub(beta, LocSet),
            \sub(beta, alpha))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedCreate {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;

        \find(wellFormed(create(h, o)))
        \succedentPolarity

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;

        \find(wellFormed(anon(h, s, h2)))
        \succedentPolarity

        \replacewith(wellFormed(h) & wellFormed(h2))

        \heuristics(concrete)
    };

    wellFormedMemsetArrayObject {
        \schemaVar \term Heap h;
        \schemaVar \term Object ar;
        \schemaVar \term int lo, up;
        \schemaVar \term deltaObject x;

        \find(wellFormed(memset(h, arrayRange(ar, lo, up), x)))
        \succedentPolarity

        \varcond(\hasElementarySort(ar, alpha))

        \replacewith(wellFormed(h) &
            (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE & arrayStoreValid(ar, x)))

        \heuristics(simplify_enlarging)
    };

    wellFormedMemsetArrayPrimitive {
        \schemaVar \term Heap h;
        \schemaVar \term Object ar;
        \schemaVar \term int lo, up;
        \schemaVar \term beta x;

        \find(wellFormed(memset(h, arrayRange(ar, lo, up), x)))
        \succedentPolarity

        \varcond(
            \hasElementarySort(ar, alpha),
            \not \sub(beta, java.lang.Object),
            \not \sub(beta, LocSet),
            \sub(beta, alpha))

        \replacewith(wellFormed(h))

        \heuristics(simplify_enlarging)
    };

    /*

    In the general case , memset can no longer maintain wellformedness :(

    For a heap h = memset(h2, s, x) to be wellFormed, it is necessary that all locations of h
    are correctly typed, particularly that each location in s is correctly typed.

    In pseudo-notation, the condition is something like this:

        forall (o, f) in s: fieldtype(f)::instance(x) = TRUE

    Since this can not be encoded currently, we uncommented these rules as well as their
    corresponding EQ versions below (see wellFormedMemsetObjectEQ).

    The two taclets wellFormedMemsetArrayObject/Primitive above work around this problem
    by restricting the location set to an arrayRange, in these special cases wellFormedness
    can be proven.

    wellFormedMemsetObject {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term deltaObject x;

        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity

    \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE))

        \heuristics(simplify_enlarging)
    };


    wellFormedMemsetLocSet {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s, x;

        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity

        \replacewith(wellFormed(h) & createdInHeap(x, h))

        \heuristics(simplify_enlarging)
    };


    wellFormedMemsetPrimitive {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term beta x;

        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity
        \varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };
    */

    // --------------------------------------------------------------------------
    // EQ versions of taclets for proving wellFormed (these are lemmata)
    // --------------------------------------------------------------------------

    wellFormedStoreObjectEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term deltaObject x;
        \schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \varcond(\fieldType(f, alpha))

        \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE & alpha::instance(x) = TRUE))

        \heuristics(simplify_enlarging)
    };

    wellFormedStoreLocSetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet x;
        \schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \replacewith(wellFormed(h) & createdInHeap(x, h))

        \heuristics(simplify_enlarging)
    };

    wellFormedStorePrimitiveEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta x;
        \schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity
        \varcond(\not \sub(beta, java.lang.Object), \not \sub(beta, LocSet))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \replacewith(wellFormed(h) & wellFormed(h2))

        \heuristics(concrete)
    };

    /*

    In the general case , memset can no longer maintain wellformedness :(
    See comments above (wellFormedMemsetObject) for more details.

    wellFormedMemsetObjectEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term deltaObject x;
    \schemaVar \term Heap EQ;

    \assumes(memset(h, s, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

    \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE))

        \heuristics(simplify_enlarging)
    };


    wellFormedMemsetLocSetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s, x;
    \schemaVar \term Heap EQ;

    \assumes(memset(h, s, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \replacewith(wellFormed(h) & createdInHeap(x, h))

        \heuristics(simplify_enlarging)
    };


    wellFormedMemsetPrimitiveEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term beta x;
    \schemaVar \term Heap EQ;

    \assumes(memset(h, s, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity
        \varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };
    */

    // --------------------------------------------------------------------------
    // axioms for observer symbols
    // --------------------------------------------------------------------------

    onlyCreatedObjectsAreObserved {
        \schemaVar \term Heap h;
        \schemaVar \term deltaObject obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(obs)
        \sameUpdateLevel
        \varcond(\isObserver(obs, h))

        \add(obs = null
            | boolean::select(h, obs, java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreObservedInLocSets {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(elementOf(o, f, obs) ==>)
        \varcond(\isObserver(obs, h))

        \add(o = null
            | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreObservedInLocSetsEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs, EQ;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(obs = EQ ==>)
        \find(elementOf(o, f, EQ) ==>)
        \varcond(\isObserver(obs, h))

        \add(o = null
            | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    // --------------------------------------------------------------------------
    // axioms based on definition of semantics for casts
    // --------------------------------------------------------------------------

    narrowSelectType {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(wellFormed(h) ==>)

        \find(beta::select(h, o, f))

        \varcond(\fieldType(f, alpha),
            \strict \sub(alpha, beta))

        \replacewith(alpha::select(h, o, f))

        \heuristics(simplify)
    };

    narrowSelectArrayType {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term int idx;

        \assumes(wellFormed(h) ==> o = null)

        \find(beta::select(h, o, arr(idx)))
        \sameUpdateLevel

        \varcond(\hasElementarySort(o, alpha),
            \strict \sub(alpha, beta))

        \replacewith(alpha::select(h, o, arr(idx)))

        \heuristics(simplify)
    };

    castTrueImpliesOriginalTrue {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(boolean::select(h, o, f) = TRUE ==>)
        \find( ==> any::select(h, o, f) = TRUE)

        \replacewith( ==> true)

        \heuristics(concrete)
    };
}

\rules(programRules:Java, JavaCard:on) {

    arrayLengthIsAShort {
        \schemaVar \term Object o;

        \find(length(o))
        \sameUpdateLevel

        \add(inShort(length(o)) ==>)

        \heuristics(inReachableStateImplication)
    };
}

\rules(programRules:Java, JavaCard:off) {

    arrayLengthIsAnInt {
        \schemaVar \term Object o;

        \find(length(o))
        \sameUpdateLevel

        \add(inInt(length(o)) ==>)

        \heuristics(inReachableStateImplication)
    };
}

\rules(programRules:Java) {

    observerDependencyEQ {
        \schemaVar \term any t1;
        \schemaVar \term any t2;

        \find(t1 = t2)
        \inSequentState
        \varcond(\sameObserver(t1, t2))

        \replacewith(true);
        \add( ==> #ObserverEquality(t1, t2))
    };

    observerDependencyEquiv {
        \schemaVar \formula t1;
        \schemaVar \formula t2;

        \find(t1 <-> t2)
        \inSequentState
        \varcond(\sameObserver(t1, t2))

        \replacewith(true);
        \add( ==> #ObserverEquality(t1, t2))
        \displayname "observerDependencyEQ"
    };

    observerDependency {
        \schemaVar \term any termWithLargeHeap;
        \schemaVar \term any termWithSmallHeap;

        \find(termWithLargeHeap)
        \inSequentState
        \varcond(\sameObserver(termWithLargeHeap, termWithSmallHeap))

        \replacewith(termWithSmallHeap);
        \add( ==> #ObserverEquality(termWithLargeHeap, termWithSmallHeap))
    };

    observerDependencyFormula {
        \schemaVar \formula termWithLargeHeap;
        \schemaVar \formula termWithSmallHeap;

        \find(termWithLargeHeap)
        \inSequentState
        \varcond(\sameObserver(termWithLargeHeap, termWithSmallHeap))

        \replacewith(termWithSmallHeap);
        \add( ==> #ObserverEquality(termWithLargeHeap, termWithSmallHeap))
        \displayname "observerDependency"
    };

    nonNull {
        \schemaVar \term Object o;
        \schemaVar \term Heap heapSV;
        \schemaVar \term int depth;
        \schemaVar \variables int i;
        \find(nonNull(heapSV, o, depth))
        \varcond(\isReferenceArray(o),
            \notFreeIn(i, o, heapSV, depth))
        \replacewith((
                o != null & (depth > 0 ->
                    \forall i; (0 <= i & i < length(o) ->
                        nonNull(heapSV, Object::select(heapSV, o, arr(i)), depth - 1))
                ))
        )
        \heuristics(simplify_enlarging)
    };

    nullIsNotNonNull {
        \schemaVar \term Object o;
        \schemaVar \term Heap heapSV;
        \schemaVar \term int depth;
        \find(nonNull(heapSV, null, depth))
        \replacewith(false)
        \heuristics(concrete)
    };

    nonNullZero {
        \schemaVar \term Object o;
        \schemaVar \term Heap heapSV;
        \find(nonNull(heapSV, o, 0))
        \replacewith(o != null)
        \heuristics(concrete)
    };
}
