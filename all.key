/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;

    \program SimpleExpression #se;
    \program Expression #e;
    \program AnyNumberTypeExpression #left, #right;

    \program AnyJavaTypeExpression #seByteShortIntLong;
    \program JavaShortIntLongExpression #seShortIntLong;
    \program JavaIntLongExpression #seIntLong;
    \program JavaLongExpression #seLong;

    \program Variable #loc;
    \program StaticVariable #sv, #sv1;

    \program LeftHandSide #lhs;
    \program Variable #v, #v0, #v1, #a;

    \formula post;
}

\rules(programRules:Java, initialisation:enableStaticInitialisation) {

    activeUseStaticFieldWriteAccess {
        \find(\modality{#allmodal}{.. #sv = #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#e) #v0 = #e;
                #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess2 {
        \find(\modality{#allmodal}{.. #v.#sv = #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#e) #v0 = #e;
                #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess3 {
        \schemaVar \program Expression #arr, #idx;
        \find(\modality{#allmodal}{.. #sv = #arr[#idx]; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#sv) #v0 = #arr[#idx];
                #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess4 {
        \schemaVar \program Expression #arr, #idx;
        \find(\modality{#allmodal}{.. #v.#sv = #arr[#idx]; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#sv) #v0 = #arr[#idx];
                #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess5 {
        \find(\modality{#allmodal}{.. #sv = #v1.#a; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #a))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#a) #v0 = #v1.#a;
                #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess6 {
        \find(\modality{#allmodal}{.. #v.#sv = #v1.#a; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #a))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#a) #v0 = #v1.#a;
                #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldReadAccess {
        \find(\modality{#allmodal}{.. #lhs = #sv; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                     #static-initialisation(#sv);
                     #lhs = @(#sv);
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldReadAccess2 {
        \find(\modality{#allmodal}{.. #lhs = #v.#sv; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                  #static-initialisation(#sv);
                  #lhs = @(#sv);
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

}

\rules(programRules:Java, initialisation:disableStaticInitialisation) {

    activeUseStaticFieldWriteAccess {
        \find(\modality{#allmodal}{.. #sv = #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#e) #v0 = #e;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess2 {
        \find(\modality{#allmodal}{.. #v.#sv = #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#e) #v0 = #e;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess3 {
        \schemaVar \program Expression #arr, #idx;
        \find(\modality{#allmodal}{.. #sv = #arr[#idx]; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#sv) #v0 = #arr[#idx];
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess4 {
        \schemaVar \program Expression #arr, #idx;
        \find(\modality{#allmodal}{.. #v.#sv = #arr[#idx]; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#sv) #v0 = #arr[#idx];
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess5 {
        \find(\modality{#allmodal}{.. #sv = #v1.#a; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #a))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#a) #v0 = #v1.#a;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldWriteAccess6 {
        \find(\modality{#allmodal}{.. #v.#sv = #v1.#a; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #a))
        \replacewith(
            \modality{#allmodal}{..
                    #typeof(#a) #v0 = #v1.#a;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldReadAccess {
        \find(\modality{#allmodal}{.. #lhs = #sv; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                     #lhs = @(#sv);
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };

    activeUseStaticFieldReadAccess2 {
        \find(\modality{#allmodal}{.. #lhs = #v.#sv; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                     #lhs = @(#sv);
                ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "activeUse"
    };
}

\rules(programRules:Java, initialisation:enableStaticInitialisation) {

    activeUseMultiplication {
        \find(\modality{#allmodal}{..
                    #sv = #left * #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(
            \modality{#allmodal}{..
                       #typeof(#sv) #v0 = #left * #right;
                       #static-initialisation(#sv);
                       @(#sv) = #v0;
                ...}\endmodality (post)
        )
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseDivision {
        \find(\modality{#allmodal}{..
                    #sv = #left / #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left / #right;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseModulo {
        \find(\modality{#allmodal}{..
                    #sv = #left % #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left % #right;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseSubtraction {
        \find(\modality{#allmodal}{..
                    #sv = #left - #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left - #right;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseAddition {
        \find(\modality{#allmodal}{..
                    #sv = #left + #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left + #right;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseBitwiseAnd {
        \find(\modality{#allmodal}{..
                     #sv = #left & #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                     #typeof(#sv) #v0 = #left & #right;
                     #static-initialisation(#sv);
                     @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseBitwiseOr {
        \find(\modality{#allmodal}{..
                     #sv=#left | #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                     #typeof(#sv) #v0 = #left | #right;
                     #static-initialisation(#sv);
                     @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseBitwiseXOr {
        \find(\modality{#allmodal}{..
                    #sv=#left ^ #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left ^ #right;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseShiftRight {
        \find(\modality{#allmodal}{..
                    #sv=#left >> #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left >> #right;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseShiftLeft {
        \find(\modality{#allmodal}{..
                    #sv=#left << #right; ...}
                \endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                   #typeof(#sv) #v0 = #left << #right;
                   #static-initialisation(#sv);
                   @(#sv) = #v0;
                ...} \endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseUnsignedShiftRight {
        \find(\modality{#allmodal}{..
                    #sv=#left >>> #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left >>> #right; ...}
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                \endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseMinus {
        \find(\modality{#allmodal}{..
                    #sv = - #left;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = - #left;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseBitwiseNegation {
        \find(\modality{#allmodal}{..
                    #sv = ~ #left;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = ~ #left;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseByteCast {
        \find(\modality{#allmodal}{..
                    #sv = (byte) #seShortIntLong;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = (byte) #seShortIntLong;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseShortCast {
        \find(\modality{#allmodal}{..
                    #sv = (short) #seIntLong;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                     #typeof(#sv) #v0 = (short) #seIntLong;
                     #static-initialisation(#sv);
                     @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseIntCast {
        \find(\modality{#allmodal}{..
                    #sv = (int) #seLong;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = (int) #seLong;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseCharCast {
        \find(\modality{#allmodal}{..
                    #sv = (char) #seByteShortIntLong;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = (char) #seByteShortIntLong;
                    #static-initialisation(#sv);
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

}

\rules(programRules:Java, initialisation:disableStaticInitialisation) {

    activeUseMultiplication {
        \find(\modality{#allmodal}{..
                    #sv = #left * #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(
            \modality{#allmodal}{..
                       #typeof(#sv) #v0 = #left * #right;
                       @(#sv) = #v0;
                ...}\endmodality (post)
        )
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseDivision {
        \find(\modality{#allmodal}{..
                    #sv = #left / #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left / #right;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseModulo {
        \find(\modality{#allmodal}{..
                    #sv = #left % #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left % #right;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseSubtraction {
        \find(\modality{#allmodal}{..
                    #sv = #left - #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left - #right;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseAddition {
        \find(\modality{#allmodal}{..
                    #sv = #left + #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left + #right;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseBitwiseAnd {
        \find(\modality{#allmodal}{..
                     #sv = #left & #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                     #typeof(#sv) #v0 = #left & #right;
                     @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseBitwiseOr {
        \find(\modality{#allmodal}{..
                     #sv=#left | #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                     #typeof(#sv) #v0 = #left | #right;
                     @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseBitwiseXOr {
        \find(\modality{#allmodal}{..
                    #sv=#left ^ #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left ^ #right;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseShiftRight {
        \find(\modality{#allmodal}{..
                    #sv=#left >> #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left >> #right;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseShiftLeft {
        \find(\modality{#allmodal}{..
                    #sv=#left << #right; ...}
                \endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                   #typeof(#sv) #v0 = #left << #right;
                   @(#sv) = #v0;
                ...} \endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseUnsignedShiftRight {
        \find(\modality{#allmodal}{..
                    #sv=#left >>> #right;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = #left >>> #right; ...}
                    @(#sv) = #v0;
                \endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseUnaryMinus {
        \find(\modality{#allmodal}{..
                    #sv = - #left;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = - #left;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseBitwiseNegation {
        \find(\modality{#allmodal}{..
                    #sv = ~ #left;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = ~ #left;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseByteCast {
        \find(\modality{#allmodal}{..
                    #sv = (byte) #seShortIntLong;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = (byte) #seShortIntLong;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseShortCast {
        \find(\modality{#allmodal}{..
                    #sv = (short) #seIntLong;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                     #typeof(#sv) #v0 = (short) #seIntLong;
                     @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseIntCast {
        \find(\modality{#allmodal}{..
                    #sv = (int) #seLong;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = (int) #seLong;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };

    activeUseCharCast {
        \find(\modality{#allmodal}{..
                    #sv = (char) #seByteShortIntLong;
                ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #sv))
        \replacewith(\modality{#allmodal}{..
                    #typeof(#sv) #v0 = (char) #seByteShortIntLong;
                    @(#sv) = #v0;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "activeUse"
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
    \modalOperator {diamond, diamond_transaction} #diamond;
    \modalOperator {box, box_transaction} #box;
}

// LocSet

\rules(programRules:Java) {

    setUnionUnfoldLeft {
        \schemaVar \program Variable #v, #vLeftNew;
        \schemaVar \program NonSimpleExpression #nseLeft;
        \schemaVar \program Expression #eRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \set_union(#nseLeft, #eRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vLeftNew, #nseLeft))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseLeft) #vLeftNew=#nseLeft; #v = \set_union(#vLeftNew, #eRight); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "setUnionUnfold"
    };

    setUnionUnfoldRight {
        \schemaVar \program Variable #v, #vRightNew;
        \schemaVar \program SimpleExpression #seLeft;
        \schemaVar \program NonSimpleExpression #nseRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \set_union(#seLeft, #nseRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vRightNew, #nseRight))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseRight) #vRightNew=#nseRight; #v = \set_union(#seLeft, #vRightNew); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "setUnionUnfold"
    };

    setIntersectUnfoldLeft {
        \schemaVar \program Variable #v, #vLeftNew;
        \schemaVar \program NonSimpleExpression #nseLeft;
        \schemaVar \program Expression #eRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \intersect(#nseLeft, #eRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vLeftNew, #nseLeft))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseLeft) #vLeftNew=#nseLeft; #v = \intersect(#vLeftNew, #eRight); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "setIntersectUnfold"
    };

    setIntersectUnfoldRight {
        \schemaVar \program Variable #v, #vRightNew;
        \schemaVar \program SimpleExpression #seLeft;
        \schemaVar \program NonSimpleExpression #nseRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \intersect(#seLeft, #nseRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vRightNew, #nseRight))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseRight) #vRightNew=#nseRight; #v = \intersect(#seLeft, #vRightNew); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "setIntersectUnfold"
    };

    setMinusUnfoldLeft {
        \schemaVar \program Variable #v, #vLeftNew;
        \schemaVar \program NonSimpleExpression #nseLeft;
        \schemaVar \program Expression #eRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \set_minus(#nseLeft, #eRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vLeftNew, #nseLeft))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseLeft) #vLeftNew=#nseLeft; #v = \set_minus(#vLeftNew, #eRight); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "setMinusUnfold"
    };

    setMinusUnfoldRight {
        \schemaVar \program Variable #v, #vRightNew;
        \schemaVar \program SimpleExpression #seLeft;
        \schemaVar \program NonSimpleExpression #nseRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \set_minus(#seLeft, #nseRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vRightNew, #nseRight))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseRight) #vRightNew=#nseRight; #v = \set_minus(#seLeft, #vRightNew); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "setMinusUnfold"
    };

    singletonUnfold {
        \schemaVar \program Variable #v, #a, #vObjNew;
        \schemaVar \program NonSimpleExpression #nseObj;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \singleton(#nseObj.#a); ...}\endmodality (post))
        \varcond(\newTypeOf(#vObjNew, #nseObj))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseObj) #vObjNew=#nseObj; #v = \singleton(#vObjNew.#a); ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "singletonUnfold"
    };

    singletonAssignment {
        \schemaVar \program Variable #v, #a;
        \schemaVar \program SimpleExpression #seObj;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \singleton(#seObj.#a); ...}\endmodality (post))
        \replacewith({#v := singleton(#seObj, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "singletonAssignment"
    };

    allObjectsAssignment {
        \schemaVar \program Variable #v, #a;
        \schemaVar \program Expression #eObj;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \all_objects(#eObj.#a); ...}\endmodality (post))
        \replacewith({#v := allObjects(#memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "allObjectsAssignment"
    };

    allFieldsUnfold {
        \schemaVar \program Variable #v, #vObjNew;
        \schemaVar \program NonSimpleExpression #nseObj;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \all_fields(#nseObj); ...}\endmodality (post))
        \varcond(\newTypeOf(#vObjNew, #nseObj))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseObj) #vObjNew=#nseObj; #v = \all_fields(#vObjNew); ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "allFieldsAssignment"
    };
}

// Sequent

\rules(programRules:Java) {

    seqConcatUnfoldLeft {
        \schemaVar \program Variable #v, #vLeftNew;
        \schemaVar \program NonSimpleExpression #nseLeft;
        \schemaVar \program Expression #eRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_concat(#nseLeft, #eRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vLeftNew, #nseLeft))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseLeft) #vLeftNew=#nseLeft; #v = \seq_concat(#vLeftNew, #eRight); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqConcatUnfold"
    };

    seqConcatUnfoldRight {
        \schemaVar \program Variable #v, #vRightNew;
        \schemaVar \program SimpleExpression #seLeft;
        \schemaVar \program NonSimpleExpression #nseRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_concat(#seLeft, #nseRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vRightNew, #nseRight))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseRight) #vRightNew=#nseRight; #v = \seq_concat(#seLeft, #vRightNew); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqConcatUnfold"
    };

    seqGetUnfoldLeft {
        \schemaVar \program Variable #v, #vLeftNew;
        \schemaVar \program NonSimpleExpression #nseLeft;
        \schemaVar \program Expression #eRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_get(#nseLeft, #eRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vLeftNew, #nseLeft))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseLeft) #vLeftNew=#nseLeft; #v = \seq_get(#vLeftNew, #eRight); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqGetUnfold"
    };

    seqGetUnfoldRight {
        \schemaVar \program Variable #v, #vRightNew;
        \schemaVar \program SimpleExpression #seLeft;
        \schemaVar \program NonSimpleExpression #nseRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_get(#seLeft, #nseRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vRightNew, #nseRight))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseRight) #vRightNew=#nseRight; #v = \seq_get(#seLeft, #vRightNew); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqGetUnfold"
    };

    seqIndexOfUnfoldLeft {
        \schemaVar \program Variable #v, #vLeftNew;
        \schemaVar \program NonSimpleExpression #nseLeft;
        \schemaVar \program Expression #eRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \indexOf(#nseLeft, #eRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vLeftNew, #nseLeft))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseLeft) #vLeftNew=#nseLeft; #v = \indexOf(#vLeftNew, #eRight); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqIndexOfUnfold"
    };

    seqIndexOfUnfoldRight {
        \schemaVar \program Variable #v, #vRightNew;
        \schemaVar \program SimpleExpression #seLeft;
        \schemaVar \program NonSimpleExpression #nseRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \indexOf(#seLeft, #nseRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vRightNew, #nseRight))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseRight) #vRightNew=#nseRight; #v = \indexOf(#seLeft, #vRightNew); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqIndexOfUnfold"
    };

    seqSubUnfoldLeft {
        \schemaVar \program Variable #v, #vLeftNew;
        \schemaVar \program NonSimpleExpression #nseLeft;
        \schemaVar \program Expression #eMiddle, #eRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_sub(#nseLeft, #eMiddle, #eRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vLeftNew, #nseLeft))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseLeft) #vLeftNew=#nseLeft; #v = \seq_sub(#vLeftNew, #eMiddle, #eRight); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqSubUnfold"
    };

    seqSubUnfoldMiddle {
        \schemaVar \program Variable #v, #vMiddleNew;
        \schemaVar \program SimpleExpression #seLeft;
        \schemaVar \program NonSimpleExpression #nseMiddle;
        \schemaVar \program Expression #eRight;

        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_sub(#seLeft, #nseMiddle, #eRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vMiddleNew, #nseMiddle))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseMiddle) #vMiddleNew=#nseMiddle; #v = \seq_sub(#seLeft, #vMiddleNew, #eRight); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqSubUnfold"
    };

    seqSubUnfoldRight {
        \schemaVar \program Variable #v, #vRightNew;
        \schemaVar \program SimpleExpression #seLeft, #seMiddle;
        \schemaVar \program NonSimpleExpression #nseRight;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_sub(#seLeft, #seMiddle, #nseRight); ...}\endmodality (post))
        \varcond(\newTypeOf(#vRightNew, #nseRight))
        \replacewith(\modality{#allmodal}{.. #typeof(#nseRight) #vRightNew=#nseRight; #v = \seq_sub(#seLeft, #seMiddle, #vRightNew); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "seqSubUnfold"
    };

    seqSingletonUnfold {
        \schemaVar \program Variable #v, #vNew;
        \schemaVar \program NonSimpleExpression #nse;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_singleton(#nse); ...}\endmodality (post))
        \varcond(\newTypeOf(#vNew, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #vNew=#nse; #v = \seq_singleton(#vNew); ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "seqSingletonUnfold"
    };

    seqLengthUnfold {
        \schemaVar \program Variable #v, #vNew;
        \schemaVar \program NonSimpleExpression #nse;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_length(#nse); ...}\endmodality (post))
        \varcond(\newTypeOf(#vNew, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #vNew=#nse; #v = \seq_length(#vNew); ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "seqLengthUnfold"
    };

    seqReverseUnfold {
        \schemaVar \program Variable #v, #vNew;
        \schemaVar \program NonSimpleExpression #nse;
        \schemaVar \formula post;

        \find(\modality{#allmodal}{.. #v = \seq_reverse(#nse); ...}\endmodality (post))
        \varcond(\newTypeOf(#vNew, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #vNew=#nse; #v = \seq_reverse(#vNew); ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "seqReverseUnfold"
    };

    // seq_upd had some rules here too. But since set statements were refactored,
    // they are not needed anymore anyway.
    }
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \program Expression #e, #e1, #e2;
    \program NonSimpleExpression #nse1, #nse2;
    \program SimpleExpression #se1, #se2;
    \program Variable #condition, #message;
    \program ExecutionContext #ex;

    \formula b;

    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
}

\rules(programRules:Java, assertions:on) {

    evaluateAssertCondition_1 {
        \find(\modality{#allmodal}{.. assert #nse1; ...}\endmodality (b))
        \varcond(\newTypeOf(#condition, #nse1))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse1) #condition = #nse1;
                assert #condition; ...}\endmodality (b))
        \heuristics(simplify_prog)
        \displayname "evaluate assert condition"
    };

    evaluateAssertCondition_2 {
        \find(\modality{#allmodal}{.. assert #nse1 : #e; ...}\endmodality (b))
        \varcond(\newTypeOf(#condition, #nse1))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse1) #condition = #nse1;
                assert #condition : #e; ...}\endmodality (b))
        \heuristics(simplify_prog)
        \displayname "evaluate assert condition"
    };

    evaluateAssertMessage {
        \find(\modality{#allmodal}{.. assert #se1 : #nse2; ...}\endmodality (b))
        \varcond(\newTypeOf(#message, #nse2))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse2) #message = #nse2;
                assert #se1 : #message; ...}\endmodality (b))
        \heuristics(simplify_prog)
        \displayname "evaluate assert condition"
    };

    assert {
        \find(\modality{#allmodal}{.. assert #se1; ...}\endmodality (b))
        \sameUpdateLevel
        "Assertion (#se1) OK":
            \replacewith(\modality{#allmodal}{..  ...}\endmodality (b)) \add(#se1 = TRUE ==>);
        "Assertion (#se1) Failure":
            \replacewith(\modality{#allmodal}{.. throw new java.lang.AssertionError(); ...}\endmodality (b)) \add(#se1 = FALSE ==>)
        \heuristics(simplify_prog)
        \displayname "assert"
    };

    assertWithReferenceMessage {
        \find(\modality{#allmodal}{.. assert #se1 : #se2; ...}\endmodality (b))
        \sameUpdateLevel
        \varcond(\isReference [non_null](\typeof(#se2)))
        "Assertion (#se1) OK":
            \replacewith(\modality{#allmodal}{..  ...}\endmodality (b)) \add(#se1 = TRUE ==>);
        "Assertion (#se1) Failure":
            \replacewith(\modality{#allmodal}{.. throw new java.lang.AssertionError(#se2); ...}\endmodality (b)) \add(#se1 = FALSE ==>)
        \heuristics(simplify_prog)
        \displayname "assert"
    };

    assertWithReferenceMessageNull {
        \find(\modality{#allmodal}{.. assert #se1 : null; ...}\endmodality (b))
        \sameUpdateLevel
        "Assertion (#se1) OK":
            \replacewith(\modality{#allmodal}{..  ...}\endmodality (b)) \add(#se1 = TRUE ==>);
        "Assertion (#se1) Failure":
            \replacewith(\modality{#allmodal}{..
                    throw new java.lang.AssertionError((java.lang.Object)null); ...}\endmodality (b)) \add(#se1 = FALSE ==>)
        \heuristics(simplify_prog)
        \displayname "assert"
    };

    assertWithPrimitiveMessage {
        \find(\modality{#allmodal}{.. assert #se1 : #se2; ...}\endmodality (b))
        \sameUpdateLevel
        \varcond(\not \isReference [non_null](\typeof(#se2)))
        "Assertion (#se1) OK":
            \replacewith(\modality{#allmodal}{..  ...}\endmodality (b)) \add(#se1 = TRUE ==>);
        "Assertion (#se1) Failure":
            \replacewith(\modality{#allmodal}{.. throw new java.lang.AssertionError(#se2); ...}\endmodality (b)) \add(#se1 = FALSE ==>)
        \heuristics(simplify_prog)
        \displayname "assert"
    };

}

\rules(programRules:Java, assertions:off) {
    skipAssert {
        \find(\modality{#allmodal}{.. assert #e1 : #e2; ...}\endmodality (b))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (b))
        \heuristics(simplify_prog)
        \displayname "skip assert"
    };

    skipAssert_2 {
        \find(\modality{#allmodal}{.. assert #e1; ...}\endmodality (b))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (b))
        \heuristics(simplify_prog)
        \displayname "skip assert"
    };

}

\rules(programRules:Java, assertions:safe) {

    assertSafe {
        \schemaVar \variable Field f;
        \schemaVar \variable java.lang.Object o;
        \schemaVar \skolemTerm Heap oldHeap;

        \find( ==> \modality{#allmodal}{.#ex.. assert #e1; ...}\endmodality (b))
        \varcond(\newTypeOf(#condition, #e1), \newDependingOn(oldHeap, b), \not \containsAssignment(#e1))
        "Assertion (#e1) Skip":
            \replacewith( ==> \modality{#allmodal}{..  ...}\endmodality (b));
        "Assertion (#e1) Terminates And OK":
            \replacewith( ==> \<{method-frame(#ex){#condition = #e1;}}\> #condition = TRUE);
        "Assertion (#e1) No Effects":
            \replacewith( ==> \[{ method-frame(#ex){
                          #typeof(#e1) #condition = #e1 ;
                        }
                    }\] (\forall f; \forall o; ((o != null & boolean::select(oldHeap, o, java.lang.Object::<created>) = FALSE) | any::select(oldHeap, o, f) = any::select(heap, o, f))))
            \add(oldHeap = heap ==>)
        \heuristics(simplify_prog)
        \displayname "assert"
    };

    assertSafeWithMessage {
        \schemaVar \variable Field f;
        \schemaVar \variable java.lang.Object o;
        \schemaVar \skolemTerm Heap oldHeap;

        \find( ==> \modality{#allmodal}{.#ex.. assert #e1 : #e2; ...}\endmodality (b))
        \varcond(
            \newTypeOf(#condition, #e1),
            \newTypeOf(#message, #e2),
            \newDependingOn(oldHeap, b),
            \not \containsAssignment(#e1),
            \not \containsAssignment(#e2))
        "Assertion (#e1) Skip":
            \replacewith( ==> \modality{#allmodal}{..  ...}\endmodality (b));
        "Assertion (#e1) Terminates And OK":
            \replacewith( ==> \<{method-frame(#ex){#typeof(#e1) #condition = #e1;
                    #typeof(#e2) #message   = #e2;}}\> #condition = TRUE);
        "Assertion (#e1) No Effects":
            \replacewith( ==> \[{ method-frame(#ex){
                                    #typeof(#e1) #condition = #e1;
                    #typeof(#e2) #message   = #e2;
                                  }
                              }\] (\forall f; \forall o; ((o != null & boolean::select(oldHeap, o, java.lang.Object::<created>) = FALSE) | any::select(oldHeap, o, f) = any::select(heap, o, f))))
            \add(oldHeap = heap ==>)
        \heuristics(simplify_prog)
        \displayname "assert"
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules for JML's \bigint type (i.e. mathematical integers).
// The semantics of \bigint are independent of the respectively used Java int semantics,
// i.e. every operation is mapped to the corresponding mathematical operation.
// Bitwise operations do not exist for \bigint.
// Author: Daniel Bruns, last changed 2011-12-05

\schemaVariables {

    \modalOperator {diamond, box} #allmodal;
    \program Variable #loc;
    \program LeftHandSide #lhs;
    \formula post;
    \program JavaBigintExpression #seBigint;
    \program AnyNumberTypeExpression #seAny;
}

\rules(programRules:Java, bigint:on) {

    // identity and widening casts

    widening_identity_cast_bigint {
        \find(\modality{#allmodal}{.. #lhs = (\bigint) #seAny; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seAny;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    // arithmetic operations

    assignmentAdditionBigint1 {
        \find(\modality{#allmodal}{..
                    #loc=#seBigint + #seAny;
                ...}\endmodality (post))
        \replacewith(
            {#loc := add(#seBigint, #seAny)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };

    assignmentAdditionBigint2 {
        \find(\modality{#allmodal}{..
                    #loc=#seAny + #seBigint;
                ...}\endmodality (post))
        \replacewith(
            {#loc := add(#seAny, #seBigint)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };

    assignmentMultiplicationBigint1 {
        \find(\modality{#allmodal}{..
                    #loc = #seBigint * #seAny;
                ...}\endmodality (post))
        \replacewith({#loc := mul(#seBigint, #seAny)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "multiplication"
    };

    assignmentMultiplicationBigint2 {
        \find(\modality{#allmodal}{..
                    #loc = #seAny * #seBigint;
                ...}\endmodality (post))
        \replacewith({#loc := mul(#seAny, #seBigint)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "multiplication"
    };
}

\rules(programRules:Java, bigint:on, runtimeExceptions:ban) {

    assignmentDivisionBigint1 {
        \find( ==> \modality{#allmodal}{..
                    #loc=#seBigint / #seAny;
                ...}\endmodality (post))
        \replacewith
        ( ==> {#loc := div(#seBigint, #seAny)}
            \modality{#allmodal}{.. ...}\endmodality (post));
        \replacewith( ==> #seAny != 0)
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionBigint2 {
        \find( ==> \modality{#allmodal}{..
                    #loc=#seAny / #seBigint;
                ...}\endmodality (post))
        \replacewith
        ( ==> {#loc := div(#seAny, #seBigint)}
            \modality{#allmodal}{.. ...}\endmodality (post));
        \replacewith( ==> #seBigint != 0)
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentModuloBigint1 {
        \find( ==> \modality{#allmodal}{..
                    #loc=#seBigint % #seAny;
                ...}\endmodality (post))
        \replacewith
        ( ==> {#loc := mod(#seBigint, #seAny)}
            \modality{#allmodal}{.. ...}\endmodality (post));
        \replacewith( ==> #seAny != 0)
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };

    assignmentModuloBigint2 {
        \find( ==> \modality{#allmodal}{..
                    #loc=#seAny % #seBigint;
                ...}\endmodality (post))
        \replacewith
        ( ==> {#loc := mod(#seAny, #seBigint)}
            \modality{#allmodal}{.. ...}\endmodality (post));
        \replacewith( ==> #seBigint != 0)
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };

}

\rules(programRules:Java, bigint:on, runtimeExceptions:ignore) {

    assignmentDivisionBigint1 {
        \find(\modality{#allmodal}{..
                    #loc=#seBigint / #seAny;
                ...}\endmodality (post))
        \replacewith
        ({#loc := div(#seBigint, #seAny)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionBigint2 {
        \find(\modality{#allmodal}{..
                    #loc=#seAny / #seBigint;
                ...}\endmodality (post))
        \replacewith
        ({#loc := div(#seAny, #seBigint)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentModuloBigint1 {
        \find(\modality{#allmodal}{..
                    #loc=#seBigint % #seAny;
                ...}\endmodality (post))
        \replacewith
        ({#loc := mod(#seBigint, #seAny)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };

    assignmentModuloBigint2 {
        \find(\modality{#allmodal}{..
                    #loc=#seAny % #seBigint;
                ...}\endmodality (post))
        \replacewith
        ({#loc := mod(#seAny, #seBigint)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };

}

\rules(programRules:Java, bigint:on, runtimeExceptions:allow) {

    assignmentDivisionBigint1 {
        \find(\modality{#allmodal}{..
                    #loc=#seBigint / #seAny;
                ...}\endmodality (post))
        \replacewith(\if(#seAny != 0)
                \then({#loc := div(#seBigint, #seAny)}
                    \modality{#allmodal}{.. ...}\endmodality (post))
                \else(\modality{#allmodal}{..
                            throw new java.lang.ArithmeticException();
                        ...}\endmodality (post)))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionBigint2 {
        \find(\modality{#allmodal}{..
                    #loc=#seAny / #seBigint;
                ...}\endmodality (post))
        \replacewith(\if(#seBigint != 0)
                \then({#loc := div(#seAny, #seBigint)}
                    \modality{#allmodal}{.. ...}\endmodality (post))
                \else(\modality{#allmodal}{..
                            throw new java.lang.ArithmeticException();
                        ...}\endmodality (post)))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentModuloBigint1 {
        \find(\modality{#allmodal}{..
                    #loc=#seBigint % #seAny;
                ...}\endmodality (post))
        \replacewith(\if(#seAny != 0)
                \then({#loc := mod(#seBigint, #seAny)}
                    \modality{#allmodal}{.. ...}\endmodality (post))
                \else(\modality{#allmodal}{..
                           throw new java.lang.ArithmeticException();
                        ...}\endmodality (post)))
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };

    assignmentModuloBigint2 {
        \find(\modality{#allmodal}{..
                    #loc=#seAny % #seBigint;
                ...}\endmodality (post))
        \replacewith(\if(#seBigint != 0)
                \then({#loc := mod(#seAny, #seBigint)}
                    \modality{#allmodal}{.. ...}\endmodality (post))
                \else(\modality{#allmodal}{..
                           throw new java.lang.ArithmeticException();
                        ...}\endmodality (post)))
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };

}

\rules(programRules:Java, bigint:on) {

    assignmentSubtractionBigint1 {
        \find(\modality{#allmodal}{..
                    #loc = #seBigint - #seAny;
                ...}\endmodality (post))
        \replacewith({#loc := sub(#seBigint, #seAny)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    assignmentSubtractionBigint2 {
        \find(\modality{#allmodal}{..
                    #loc = #seAny - #seBigint;
                ...}\endmodality (post))
        \replacewith({#loc := sub(#seAny, #seBigint)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    unaryMinusBigint {
        \find(\modality{#allmodal}{..
                    #loc = - #seBigint;
                ...}\endmodality (post))
        \replacewith({#loc := -#seBigint}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "unaryMinus"
    };

    // there are no bitwise operations since they would make no sense


    // narrowing casts

    narrowingShortCastBigint {
        \find(\modality{#allmodal}{..
                    #loc = (short) #seBigint;
                ...}\endmodality (post))
        \replacewith({#loc := javaCastShort(#seBigint)}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingIntCastBigint {
        \find(\modality{#allmodal}{.. #loc = (int) #seBigint; ...}\endmodality (post))
        \replacewith({#loc := javaCastInt(#seBigint)}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingLongCastBigint {
        \find(\modality{#allmodal}{.. #loc = (long) #seBigint; ...}\endmodality (post))
        \replacewith({#loc := javaCastLong(#seBigint)}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingCharCastBigint {
        \find(\modality{#allmodal}{..
                    #loc = (char) #seBigint;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaCastChar(#seBigint)}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingByteCastBigint {
        \find(\modality{#allmodal}{..
                    #loc = (byte) #seBigint;
                ...}\endmodality (post))
        \replacewith({#loc := javaCastByte(#seBigint)}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules {
    // wrappers for positive numbers to prevent shiftRightDef -> shiftLeftDef mutual recursion
    shiftRightPositiveShiftDef {
        \schemaVar \term int left, right;

        \find(shiftrightPositiveShift(left, right))
        \replacewith(div(left, pow(2, right)))

        \heuristics(simplify)
    };

    shiftLeftPositiveShiftDef {
        \schemaVar \term int left, right;

        \find(shiftleftPositiveShift(left, right))
        \replacewith(mul(left, pow(2, right)))

        \heuristics(simplify)
    };

    // arbitrary fixed length bitvector operations
    shiftRightDef {
        \schemaVar \term int left, right;

        \find(shiftright(left, right))
        \replacewith(\if(right < 0)
                \then(shiftleftPositiveShift(left, -right))
                \else(shiftrightPositiveShift(left, right))
        )

        \heuristics(simplify_enlarging)
    };

    shiftLeftDef {
        \schemaVar \term int left, right;

        \find(shiftleft(left, right))
        \replacewith(\if(right < 0)
                \then(shiftrightPositiveShift(left, -right))
                \else(shiftleftPositiveShift(left, right))
        )

        \heuristics(simplify_enlarging)
    };

    javaShiftRightIntDef {
        \schemaVar \term int left, right;

        \find(shiftrightJint(left, right))
        // usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
        \replacewith(moduloInt(shiftright(left, mod(right, 32))))
        \heuristics(simplify_enlarging)
    };

    javaShiftRightLongDef {
        \schemaVar \term int left, right;

        \find(shiftrightJlong(left, right))
        // usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
        \replacewith(moduloLong(shiftright(left, mod(right, 64))))

        \heuristics(simplify_enlarging)
    };

    javaShiftLeftIntDef {
        \schemaVar \term int left, right;

        \find(shiftleftJint(left, right))
        // usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
        \replacewith(moduloInt(shiftleft(left, mod(right, 32))))
        \heuristics(simplify_enlarging)
    };

    javaShiftLeftLongDef {
        \schemaVar \term int left, right;

        \find(shiftleftJlong(left, right))
        // usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
        \replacewith(moduloLong(shiftleft(left, mod(right, 64))))

        \heuristics(simplify_enlarging)
    };

    unsignedShiftRightJintDef {
        \schemaVar \term int left, right;
        \find(unsignedshiftrightJint(left, right))
        \replacewith(\if(left >= 0) \then(shiftrightJint(left, right))
                \else(addJint(shiftrightJint(left, right), shiftleftJint(2, 31 - mod(right, 32)))))
        \heuristics(simplify_enlarging)
    };

    xorJIntDef {
        \schemaVar \term int left, right;

        \find(xorJint(left, right))
        \replacewith(moduloInt(binaryXOr(left, right)))

        \heuristics(simplify)
    };

    orJIntDef {
        \schemaVar \term int left, right;

        \find(orJint(left, right))
        \replacewith(moduloInt(binaryOr(left, right)))

        \heuristics(simplify)
    };

    andJIntDef {
        \schemaVar \term int left, right;
        \find(andJint(left, right))
        \replacewith(moduloInt(binaryAnd(left, right)))

        \heuristics(simplify)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules {

    binaryOrNeutralRight {
        \schemaVar \term int left;

        \find(binaryOr(left, 0))
        \replacewith(left)

        \heuristics(concrete)
    };

    binaryOrNeutralLeft {
        \schemaVar \term int right;

        \find(binaryOr(0, right))
        \replacewith(right)

        \heuristics(concrete)
    };

    binaryOrSign {
        \schemaVar \term int left, right;

        \find(binaryOr(left, right))
        \sameUpdateLevel
        \add(\if(left >= 0 & right >= 0) \then(1) \else(-1) * binaryOr(left, right) >= 0 ==>)
        \heuristics(userTaclets1)
    };

    binaryOrInInt {
        \schemaVar \term int left, right;

        \find(binaryOr(left, right))
        \sameUpdateLevel
        \add((inRangeInt(left) & inRangeInt(right)) -> inRangeInt(binaryOr(left, right)) ==>)
        \heuristics(userTaclets1)
    };

    binaryOrGte {
        \schemaVar \term int left, right;
        \find(binaryOr(left, right))
        \sameUpdateLevel

        // could be more general, moduloInt(left) >= 0
        \add((left >= 0 & right >= 0) -> (binaryOr(left, right) >= left & binaryOr(left, right) >= right &
                binaryOr(left, right) <= 2 * \if(left > right) \then(left) \else(right))
            ==>)
        \heuristics(userTaclets1)
    };

    // orJint like divJint etc is always inRangeInt as the result is moduloInt(result)
    orJintInInt {
        \schemaVar \term int left, right;

        \find(orJint(left, right))
        \sameUpdateLevel
        \add(inRangeInt(orJint(left, right)) ==>)
        \heuristics(userTaclets1)
    };

    // binaryAnd

    binaryAndZeroRight {
        \schemaVar \term int left;
        \find(binaryAnd(left, 0))
        \replacewith(0)
        \heuristics(concrete)
    };

    binaryAndZeroLeft {
        \schemaVar \term int right;
        \find(binaryAnd(0, right))
        \replacewith(0)
        \heuristics(concrete)
    };

    binaryAndSymm {
        \schemaVar \term int left, right;
        \find(binaryAnd(left, right))
        \replacewith(binaryAnd(right, left))
    };

    binaryAndOne {
        \schemaVar \term int left;
        \find(binaryAnd(left, 1))
        \replacewith(\if(left % 2 = 0) \then(0) \else(1))
        \heuristics(simplify_enlarging)
    };

}

\rules {

    // Literal rules for binary &, |, ^
    binaryAnd_literals {
        \schemaVar \term numbers iz, jz;

        \find(binaryAnd(Z(iz), Z(jz)))
        \replacewith(#BinaryAnd(Z(iz), Z(jz)))

        \heuristics(simplify_literals)
        \displayname "binary_AND"
    };

    binaryOr_literals {
        \schemaVar \term numbers iz, jz;

        \find(binaryOr(Z(iz), Z(jz)))
        \replacewith(#BinaryOr(Z(iz), Z(jz)))

        \heuristics(simplify_literals)
        \displayname "binary_OR"
    };

    binaryXOr_literals {
        \schemaVar \term numbers iz, jz;

        \find(binaryXOr(Z(iz), Z(jz)))
        \replacewith(#BinaryXOr(Z(iz), Z(jz)))

        \heuristics(simplify_literals)
        \displayname "binary_XOR"
    };

    // Shift operations

    shiftright_literals {
        \schemaVar \term numbers iz, jz;

        \find(shiftright(Z(iz), Z(jz)))
        \replacewith(#ShiftRight(Z(iz), Z(jz)))

        \heuristics(simplify_literals)
        \displayname "shift"
    };

    shiftleft_literals {
        \schemaVar \term numbers iz, jz;

        \find(shiftleft(Z(iz), Z(jz)))
        \replacewith(#ShiftLeft(Z(iz), Z(jz)))

        \heuristics(simplify_literals)
        \displayname "shift"
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\sorts {
    boolean;
}

\functions {
    boolean TRUE;
    boolean FALSE;
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term boolean bo, b1, b2;
}

\rules {
    boolean_equal {
        \find(bo = bo)
        \replacewith(true)
        \heuristics(simplify_boolean, concrete)
    };

    boolean_equal_2 {
        \find(b1 = TRUE <-> b2 = TRUE)
        \replacewith(b1 = b2)
        \heuristics(simplify_boolean, concrete)
        \displayname "boolean_equal"
    };

    boolean_not_equal_1 {
        \find(TRUE = FALSE)
        \replacewith(false)
        \heuristics(simplify_boolean, concrete)
        \displayname "boolean_not_equal"
    };
    boolean_not_equal_2 {
        \find(FALSE = TRUE)
        \replacewith(false)
        \heuristics(simplify_boolean, concrete)
        \displayname "boolean_not_equal"
    };

    true_to_not_false {
        \find(bo = TRUE)
        \replacewith(!bo = FALSE)
    };

    // anything to ...=TRUE:

    false_to_not_true {
        \find(bo = FALSE)
        \replacewith(!bo = TRUE)
        \heuristics(simplify_boolean, concrete)
    };

    boolean_true_commute {
        \find(TRUE = bo)
        \replacewith(bo = TRUE)
        \heuristics(simplify_boolean)
        \displayname "boolean commute"
    };

    boolean_false_commute {
        \find(FALSE = bo)
        \replacewith(bo = FALSE)
        \heuristics(simplify_boolean)
        \displayname "boolean commute"
    };

    ex_bool {
        \schemaVar \variables boolean x;
        \schemaVar \formula c;
        \find(\exists x; c)
        \replacewith({\subst x; FALSE}c | {\subst x; TRUE}c)
        \heuristics(boolean_cases)
    };

    all_bool {
        \schemaVar \variables boolean x;
        \schemaVar \formula c;
        \find(\forall x; c)
        \replacewith({\subst x; FALSE}c & {\subst x; TRUE}c)
        \heuristics(boolean_cases)
    };

    ///////////////////////////////////////////////////////////////////////////////

    apply_eq_boolean {
        \assumes( ==> bo = TRUE)
        \find(bo)
        \sameUpdateLevel
        \replacewith(FALSE)
        \heuristics(apply_equations)
    };

    apply_eq_boolean_2 {
        \assumes( ==> bo = FALSE)
        \find(bo)
        \sameUpdateLevel
        \replacewith(TRUE)
        \heuristics(apply_equations)
        \displayname "apply_eq_boolean"
    };

    apply_eq_boolean_rigid {
        \schemaVar \term [rigid] boolean br;
        \assumes( ==> br = TRUE)
        \find(br)
        \replacewith(FALSE)
        \heuristics(apply_equations)
        \displayname "apply_eq_boolean"
    };

    apply_eq_boolean_rigid_2 {
        \schemaVar \term [rigid] boolean br;
        \assumes( ==> br = FALSE)
        \find(br)
        \replacewith(TRUE)
        \heuristics(apply_equations)
        \displayname "apply_eq_boolean"
    };

    \lemma
    ifthenelse_equals {
        \schemaVar \formula b, c;
        \find(\if(b) \then(TRUE) \else(FALSE) = \if(c) \then(TRUE) \else(FALSE))
        \replacewith(b <-> c)
        \heuristics(concrete)
    };

    \lemma
    ifthenelse_equals_1 {
        \schemaVar \formula b;
        \schemaVar \term boolean c;
        \find(\if(b) \then(TRUE) \else(FALSE) = c)
        \replacewith(b <-> c = TRUE)
        // \heuristics(concrete)
    };

    \lemma
    ifthenelse_equals_2 {
        \schemaVar \term boolean b;
        \schemaVar \formula c;
        \find(b = \if(c) \then(TRUE) \else(FALSE))
        \replacewith(b = TRUE <-> c)
        // \heuristics(concrete)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// --------------------------------------------------------------------
// rules for bounded products
// --------------------------------------------------------------------

\schemaVariables {

    \term int i, i0, i1, i2, i3, i4, j, j0, j1, t, t1, t2;
    \skolemTerm int sk, sk2;
    \term numbers iz, jz;
    \formula b, psi, phi, post, inv;
    \variables int uSub, uSub1, uSub2;
}

\rules(integerSimplificationRules:full) {

    // axiom
    bprod_empty {
        \find(bprod{uSub;}(i0, i1, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        "Precondition":
            \add( ==> i1 <= i0);
        "Empty Sum":
            \replacewith(1)
    };

    // axiom
    bprod_induction_upper {
        \find(bprod{uSub;}(i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bprod{uSub;}(i0, i2 - 1, t)
            * \if(i0 < i2) \then({\subst uSub; (i2 - 1)}t) \else(1))
    };

    bprod_find {

        \schemaVar \term int low, high, middle;

        \find(bprod{uSub;}(low, high, t))
        \varcond(\notFreeIn(uSub, low),
            \notFreeIn(uSub, middle),
            \notFreeIn(uSub, high))
        \replacewith(\if(low <= middle & middle <= high)
                \then(bprod{uSub;}(low, middle, t)
                    * bprod{uSub;}(middle, high, t))
                \else(bprod{uSub;}(low, high, t)))

        \heuristics(comprehension_split, triggered)

        \trigger {middle} bprod{uSub;}(low, middle, t) \avoid middle <= low, middle >= high;
    };

    bprod_commutative_associative {
        \find(bprod{uSub;}(i0, i2, t * t2))
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2),
            \notFreeIn(uSub1, t2))
        \replacewith(bprod{uSub;}(i0, i2, t)
            * bprod{uSub1;}(i0, i2, {\subst uSub; uSub1}t2))
    };

    bprod_induction_upper_concrete {
        \find(bprod{uSub;}(i0, 1 + i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bprod{uSub;}(i0, i2, t)
            * \if(i0 <= i2) \then({\subst uSub; (i2)}t) \else(1))
        \heuristics(simplify)
    };

    bprod_induction_lower {
        \find(bprod{uSub;}(i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bprod{uSub;}(i0 + 1, i2, t)
            * \if(i0 < i2) \then({\subst uSub; (i0)}t) \else(1))
    };

    bprod_induction_lower_concrete {
        \find(bprod{uSub;}(-1 + i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bprod{uSub;}(i0, i2, t)
            * \if(-1 + i0 < i2) \then({\subst uSub; (-1 + i0)}t) \else(1))
        \heuristics(simplify)
    };

    // proven in KeY -- DB 25/10/2013
    bprod_shift_index {
        \find(bprod{uSub;}(i0, i1, t))
        \varcond(
            \notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub1, t))
        \replacewith(bprod{uSub1;}(0, i1 - i0, {\subst uSub; uSub1 + i0}t))
    };

    // proven in KeY -- DB 19/10/2012
    bprod_equal_zero_right {
        \find( ==> bprod{uSub;}(i0, i2, t) = 0)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add( ==> \exists uSub; {\subst uSub; uSub}(uSub >= i0 & uSub < i2 & t = 0))
        \heuristics(comprehensions)
    };

    bprod_equal_one_right {
        \find( ==> bprod{uSub;}(i0, i2, t) = 1)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add( ==> \forall uSub; {\subst uSub; uSub}(uSub >= i0 & uSub < i2 -> t = 1))
        \heuristics(comprehensions)
    };

    // proven in KeY -- DB 19/10/2012
    bprod_one_factor {
        \find(bprod{uSub;}(i0, i1, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \replacewith(\if(i0 + 1 = i1) \then({\subst uSub; i0}t)
                \else(bprod{uSub;}(i0, i1, t)))
    };

    // proven in KeY -- DB 19/10/2012
    bprod_one_factor_concrete1 {
        \find(bprod{uSub;}(i0, 1 + i0, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0))
        \replacewith({\subst uSub; i0}t)
        \heuristics(concrete)
    };

    // proven in KeY -- DB 19/10/2012
    bprod_one_factor_concrete2 {
        \find(bprod{uSub;}(-1 + i0, i0, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0))
        \replacewith({\subst uSub; -1 + i0}t)
        \heuristics(concrete)
    };

    // proven in KeY -- DB 27/09/2013
    bprod_zero {
        \find(bprod{uSub;}(i0, i1, 0))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \replacewith(\if(i0 < i1) \then(0) \else(1))
        \heuristics(simplify)
    };

    // proven in KeY -- DB 19/10/2012
    bprod_one {
        \find(bprod{uSub;}(i0, i1, 1))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \replacewith(1)
        \heuristics(concrete)
    };

    // proven in KeY -- DB 19/10/2012
    bprod_lower_equals_upper {
        \find(bprod{uSub;}(i0, i0, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0))
        \replacewith(1)
        \heuristics(concrete)
    };

    equal_bprod1 {
        \find( ==> bprod{uSub1;}(i0, i1, t1) = bprod{uSub2;}(i0, i1, t2))
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub2, i1))
        \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1)
                -> t1 = ({\subst uSub2; uSub1}t2)))
        \heuristics(comprehensions)
        \displayname "equal_bprod_same_index"
    };

    equal_bprod2 {
        \assumes(bprod{uSub1;}(i0, i1, t1) = i ==>)
        \find( ==> bprod{uSub2;}(i0, i1, t2) = i)
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub2, i1))
        \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1)
                -> t1 = ({\subst uSub2; uSub1}t2)))
        \heuristics(comprehensions)
        \displayname "equal_bprod_same_index"
    };

    equal_bprod3 {
        \assumes(bprod{uSub1;}(i0, i1, t1) = i, bprod{uSub2;}(i0, i1, t2) = j ==>)
        \find( ==> j = i)
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub2, i1))
        \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1)
                -> t1 = ({\subst uSub2; uSub1}t2)))
        \heuristics(comprehensions)
        \displayname "equal_bprod_same_index"
    };

    equal_bprod5 {
        \find( ==> bprod{uSub1;}(i0, i1, t1) = bprod{uSub2;}(i2, i3, t2))
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub1, i3),
            \notFreeIn(uSub2, i3))
        "Equal length":
            \add( ==> i1 - i0 = i3 - i2);
        "Equal elements":
            \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1) -> t1 = ({\subst uSub2; uSub1 + i2 - i0}t2)))
        \heuristics(comprehensions_high_costs)
        \displayname "equal_bprod"
    };

    bprod_invert_index {
        \find(bprod{uSub;}(i0, i1, t))
        \varcond(\notFreeIn(uSub, i0, i1),
            \notFreeIn(uSub1, i0, i1, t))
        \replacewith(bprod{uSub1;}(-i1, -i0, {\subst uSub; -uSub1}t))
    };

    bprod_invert_index_concrete {
        \find(bprod{uSub;}(i0 * -1, i1 * -1, t))
        \varcond(\notFreeIn(uSub, i0, i1),
            \notFreeIn(uSub1, i0, i1, t))
        \replacewith(bprod{uSub1;}(i1, i0, {\subst uSub; -uSub1}t))
        \heuristics(simplify)
    };

}

\rules(integerSimplificationRules:full, sequences:on) {
    equal_bprod_perm1 {
        \find( ==> bprod{uSub1;}(i0, i1, t1) = bprod{uSub2;}(i2, i3, t2))
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub1, i3),
            \notFreeIn(uSub2, i3))
        \add( ==> seqPerm(seqDef{uSub1;}(i0, i1, t1), seqDef{uSub2;}(i2, i3, t2)))
        \displayname "equal_bprod_perm"
    };

    equal_bprod_perm2 {
        \assumes(bprod{uSub2;}(i2, i3, t2) = t ==>)
        \find( ==> bprod{uSub1;}(i0, i1, t1) = t)
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub1, i3),
            \notFreeIn(uSub2, i3))
        \add( ==> seqPerm(seqDef{uSub1;}(i0, i1, t1), seqDef{uSub2;}(i2, i3, t2)))
        \displayname "equal_bprod_perm"
    };

    // Proven
    \lemma
    bprod_all_positive {
        \find(bprod{uSub;}(i0, i1, t1))
        \varcond(\notFreeIn(uSub, i0, i1))
        \add(\forall uSub; ((i0 <= uSub & uSub < i1) -> t1 >= 0) -> bprod{uSub;}(i0, i1, t1) >= 0 ==>)
    };

    // Proven
    \lemma
    bprod_split {
        \schemaVar \term int middle;
        \find(bprod{uSub;}(i0, i1, t1))
        \varcond(\notFreeIn(uSub, i0, i1))
        \replacewith(
            \if(i0 <= middle & middle <= i1)
                \then(bprod{uSub;}(i0, middle, t1) * bprod{uSub;}(middle, i1, t1))
                \else(bprod{uSub;}(i0, i1, t1))
        )
    };
}

// --------------------------------------------------------------------
// rules for general products
// --------------------------------------------------------------------
\rules(integerSimplificationRules:full) {

    prod_empty {
        \schemaVar \variables alpha x;
        \find(prod{x;}(FALSE, t))
        \replacewith(1)
        \heuristics(concrete)
    };

    prod_one {
        \schemaVar \variables alpha x;
        \schemaVar \term boolean range;
        \find(prod{x;}(range, 1))
        \replacewith(1)
        \heuristics(concrete)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// --------------------------------------------------------------------
// rules for bounded sums
// --------------------------------------------------------------------

\schemaVariables {

    \term int i, i0, i1, i2, i3, i4, j, j0, j1, t, t1, t2;
    \skolemTerm int sk, sk2;

    \term numbers iz, jz;
    \formula b, psi, phi, post, inv;
    \variables int uSub, uSub1, uSub2;
}

\rules(integerSimplificationRules:full) {

    // axiom
    bsum_def {
        \find(bsum{uSub;}(i0, i1, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \replacewith(\if(i0 < i1)
                \then(bsum{uSub;}(i0, i1 - 1, t) + {\subst uSub; (i1 - 1)}t)
                \else(0))
    };

    \lemma
    bsum_empty {
        \find(bsum{uSub;}(i0, i1, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        "Precondition":
            \add( ==> i1 <= i0);
        "Empty Sum":
            \replacewith(0)
    };

    \lemma
    bsum_induction_upper {
        \find(bsum{uSub;}(i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(i0, i2 - 1, t) + \if(i0 < i2) \then({\subst uSub; (i2 - 1)}t) \else(0))
    };

    \lemma
    bsum_induction_lower {
        \find(bsum{uSub;}(i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(i0 + 1, i2, t) + \if(i0 < i2) \then({\subst uSub; (i0)}t) \else(0))
    };

    \lemma
    bsum_num_of_bounds {
        \find(bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(0 <= bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)),
            i0 <= i2 -> bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)) <= i2 - i0 ==>)
    };

    \lemma
    bsum_num_of_bounds2 {
        \find(bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(0 <= bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)),
            i0 <= i2 -> bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)) <= i2 - i0 ==>)
    };

    bsum_split {
        \schemaVar \term int low, high;
        \schemaVar \term int middle;

        \find(bsum{uSub;}(low, high, t))
        \varcond(\notFreeIn(uSub, low),
            \notFreeIn(uSub, middle),
            \notFreeIn(uSub, high))
        \replacewith(\if(low <= middle & middle <= high)
                \then(bsum{uSub;}(low, middle, t) + bsum{uSub;}(middle, high, t))
                \else(bsum{uSub;}(low, high, t)))

        \heuristics(comprehension_split, triggered)

        \trigger {middle} bsum{uSub;}(low, middle, t) \avoid middle <= low, middle >= high;
    };

    bsum_commutative_associative {
        \find(bsum{uSub;}(i0, i2, t + t2))
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2),
            \notFreeIn(uSub1, t2))
        \replacewith(bsum{uSub;}(i0, i2, t) + bsum{uSub1;}(i0, i2, {\subst uSub; uSub1}t2))

    };

    \lemma
    bsum_induction_upper2 {
        \find(bsum{uSub;}(i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(i0, i2 + 1, t) - \if(i0 < i2 + 1) \then({\subst uSub; (i2)}t) \else(0))

    };

    \lemma
    bsum_induction_upper_concrete {
        \find(bsum{uSub;}(i0, 1 + i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(i0, i2, t) + \if(i0 <= i2) \then({\subst uSub; (i2)}t) \else(0))
        \heuristics(simplify)
    };

    \lemma
    bsum_induction_upper_concrete_2 {
        \find(bsum{uSub;}(Z(iz), Z(jz), t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(Z(iz), Z(jz) - 1, t) + \if(Z(iz) <= Z(jz) - 1) \then({\subst uSub; (Z(jz) - 1)}t) \else(0))
        \heuristics(simplify)
    };

    \lemma
    bsum_induction_upper2_concrete {
        \find(bsum{uSub;}(i0, -1 + i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(i0, i2, t) - \if(i0 < i2) \then({\subst uSub; (i2 - 1)}t) \else(0))
        \heuristics(simplify)
    };

    \lemma
    bsum_induction_lower_concrete {
        \find(bsum{uSub;}(-1 + i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(i0, i2, t) + \if(-1 + i0 < i2) \then({\subst uSub; (-1 + i0)}t) \else(0))
        \heuristics(simplify)
    };

    \lemma
    bsum_induction_lower2 {
        \find(bsum{uSub;}(i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(i0 - 1, i2, t) - \if(i0 - 1 < i2) \then({\subst uSub; (i0 - 1)}t) \else(0))
    };

    \lemma
    bsum_induction_lower2_concrete {
        \find(bsum{uSub;}(1 + i0, i2, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \replacewith(bsum{uSub;}(i0, i2, t) - \if(i0 < i2) \then({\subst uSub; (i0)}t) \else(0))
        \heuristics(simplify)
    };

    bsum_zero_right {
        \find( ==> bsum{uSub;}(i0, i2, t) = 0)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add( ==> \forall uSub; {\subst uSub; uSub}(uSub >= i0 & uSub < i2 -> t = 0))
        \heuristics(comprehensions)
    };

    bsum_distributive {
        \find(bsum{uSub;}(i0, i2, t * t1))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2),
            \notFreeIn(uSub, t1))
        \replacewith(bsum{uSub;}(i0, i2, t) * t1)
        \heuristics(simplify)
    };

    bsum_equal_split1 {
        \find( ==> bsum{uSub1;}(i0, i1, t1) = bsum{uSub2;}(i0, i2, t2))
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub2, i0))
        \add( ==> i0 <= i1 & i0 <= i2 &
            \if(i1 < i2)
                \then(bsum{uSub1;}(i0, i1, t1 - {\subst uSub2; uSub1}t2) = bsum{uSub2;}(i1, i2, t2))
                \else(bsum{uSub1;}(i2, i1, t1) = bsum{uSub2;}(i0, i2, t2 - {\subst uSub1; uSub2}t1)))
        \heuristics(comprehensions)
    };

    bsum_equal_split2 {
        \assumes(bsum{uSub1;}(i0, i1, t1) = i ==>)
        \find( ==> bsum{uSub2;}(i0, i2, t2) = i)
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub2, i0))
        \add( ==> i0 <= i1 & i0 <= i2 &
            \if(i2 < i1)
                \then(bsum{uSub1;}(i2, i1, t1) = bsum{uSub2;}(i0, i2, t2 - {\subst uSub1; uSub2}t1))
                \else(bsum{uSub1;}(i0, i1, t1 - {\subst uSub2; uSub1}t2) = bsum{uSub2;}(i1, i2, t2)))
        \heuristics(comprehensions)
    };

    bsum_equal_split3 {
        \find( ==> bsum{uSub1;}(i1, i0, t1) = bsum{uSub2;}(i2, i0, t2))
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub2, i0))
        \add( ==> i1 <= i0 & i2 <= i0 &
            \if(i1 < i2)
                \then(bsum{uSub1;}(i1, i2, t1) = bsum{uSub2;}(i2, i0, t2 - {\subst uSub1; uSub2}t1))
                \else(bsum{uSub1;}(i1, i0, t1 - {\subst uSub2; uSub1}t2) = bsum{uSub2;}(i2, i1, t2)))
        \heuristics(comprehensions)
    };

    bsum_equal_split4 {
        \assumes(bsum{uSub1;}(i1, i0, t1) = i ==>)
        \find( ==> bsum{uSub2;}(i2, i0, t2) = i)
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub2, i0))
        \add( ==> i1 <= i0 & i2 <= i0 &
            \if(i2 < i1)
                \then(bsum{uSub1;}(i1, i0, t1 - {\subst uSub2; uSub1}t2) = bsum{uSub2;}(i2, i1, t2))
                \else(bsum{uSub1;}(i1, i2, t1) = bsum{uSub2;}(i2, i0, t2 - {\subst uSub1; uSub2}t1)))
        \heuristics(comprehensions)
    };

    bsum_split_in_three {
        \find(bsum{uSub;}(i0, i2, t))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(uSub, i1),
            \notFreeIn(uSub1, t),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub, i0),
            \notFreeIn(uSub1, i2))
        "Precondition":
            \add( ==> (i0 <= i1 & i1 < i2));
        "Splitted Sum":
            \replacewith(bsum{uSub;}(i0, i1, t) +
                {\subst uSub; i1}t +
                bsum{uSub1;}(i1 + 1, i2, {\subst uSub; uSub1}t))
    };

    bsum_one_summand {
        \find(bsum{uSub;}(i0, i1, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \replacewith(\if(i0 + 1 = i1) \then({\subst uSub; i0}t) \else(bsum{uSub;}(i0, i1, t)))
    };

    bsum_one_summand_concrete1 {
        \find(bsum{uSub;}(i0, 1 + i0, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0))
        \replacewith({\subst uSub; i0}t)
        \heuristics(concrete)
    };

    bsum_one_summand_concrete2 {
        \find(bsum{uSub;}(-1 + i0, i0, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0))
        \replacewith({\subst uSub; -1 + i0}t)
        \heuristics(concrete)
    };

    // proven in KeY (DB 25/10/2013)
    bsum_shift_index {
        \find(bsum{uSub;}(i0, i1, t))
        \varcond(
            \notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub1, t))
        \replacewith(bsum{uSub1;}(0, i1 - i0, {\subst uSub; uSub1 + i0}t))
    };

    // proven in KeY (DB 25/10/2013)
    bsum_same_summand {
        \find(bsum{uSub;}(i0, i1, t))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1),
            \notFreeIn(uSub, t))
        \replacewith(\if(i1 >= i0)
                \then(t * (i1 - i0))
                \else(0))
        \heuristics(simplify)
    };

    bsum_zero {
        \find(bsum{uSub;}(i0, i1, 0))
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \replacewith(0)
        \heuristics(concrete)
    };

    bsum_lower_equals_upper {
        \find(bsum{uSub;}(i0, i0, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0))
        \replacewith(0)
        \heuristics(concrete)
    };

    \lemma
    bsum_positive {
        \find( ==> bsum{uSub;}(i0, i1, t) >= 0)
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \add( ==> \forall uSub; ((uSub >= i0 & uSub < i1) -> t >= 0))
    };

    \lemma
    bsum_upper_bound {
        \find(bsum{uSub;}(i0, i1, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1),
            \notFreeIn(uSub, j))
        \add(\forall uSub; ((uSub >= i0 & uSub < i1) -> t <= j) -> bsum{uSub;}(i0, i1, t) <= \if(i1 - i0 > 0) \then((i1 - i0) * j) \else(0) ==>)
    };

    \lemma
    bsum_lower_bound {
        \find(bsum{uSub;}(i0, i1, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1),
            \notFreeIn(uSub, j))
        \add(\forall uSub; ((uSub >= i0 & uSub < i1) -> t >= j) -> bsum{uSub;}(i0, i1, t) >= \if(i1 - i0 > 0) \then((i1 - i0) * j) \else(0) ==>)
    };

    \lemma
    bsum_positive_lower_bound_element {
        \schemaVar \term int index;
        \find(bsum{uSub;}(i0, i1, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1),
            \notFreeIn(uSub, index))
        "Precondition":
            \add( ==> \forall uSub; ((uSub >= i0 & uSub < i1 & uSub != index) -> t >= 0) & i0 <= index & index < i1);
        "Usage":
            \add(({\subst uSub; index}t) <= bsum{uSub;}(i0, i1, t) ==>)
    };

    \lemma
    bsum_sub_same_index {
        \find(bsum{uSub1;}(i0, i1, t1) - bsum{uSub2;}(i0, i1, t2))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1))
        \add(bsum{uSub1;}(i0, i1, t1 - ({\subst uSub2; uSub1}t2)) = bsum{uSub1;}(i0, i1, t1) - bsum{uSub2;}(i0, i1, t2) ==>)
    };

    \lemma
    bsum_less_same_index {
        \find( ==> bsum{uSub1;}(i0, i1, t1) < bsum{uSub2;}(i0, i1, t2))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1))
        \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1) -> t1 <= ({\subst uSub2; uSub1}t2)) & \exists uSub1; ((uSub1 >= i0 & uSub1 < i1) & t1 < ({\subst uSub2; uSub1}t2)))
    };

    // this case occurs when translating \num_of
    bsum_positive1 {
        \find(bsum{uSub;}(i0, i1, \if(b) \then(1) \else(0)))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \add(bsum{uSub;}(i0, i1, \if(b) \then(1) \else(0)) >= 0 ==>)
    };

    // this case occurs when translating \num_of
    bsum_positive2 {
        \find(bsum{uSub;}(i0, i1, \if(b) \then(0) \else(1)))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i1))
        \add(bsum{uSub;}(i0, i1, \if(b) \then(0) \else(1)) >= 0 ==>)
    };

    equal_bsum1 {
        \find( ==> bsum{uSub1;}(i0, i1, t1) = bsum{uSub2;}(i0, i1, t2))
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub2, i1))
        \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1) -> t1 = ({\subst uSub2; uSub1}t2)))
        \heuristics(comprehensions)
        \displayname "equal_bsum_same_index"
    };

    equal_bsum2 {
        \assumes(bsum{uSub1;}(i0, i1, t1) = i ==>)
        \find( ==> bsum{uSub2;}(i0, i1, t2) = i)
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub2, i1))
        \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1) -> t1 = ({\subst uSub2; uSub1}t2)))
        \heuristics(comprehensions)
        \displayname "equal_bsum_same_index"
    };

    equal_bsum3 {
        \assumes(bsum{uSub1;}(i0, i1, t1) = i, bsum{uSub2;}(i0, i1, t2) = j ==>)
        \find( ==> j = i)
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub2, i1))
        \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1) -> t1 = ({\subst uSub2; uSub1}t2)))
        \heuristics(comprehensions)
        \displayname "equal_bsum_same_index"
    };

    \lemma
    bsum_equal_except_one_index {
        \schemaVar \term int index;
        \find( ==> bsum{uSub1;}(i0, i1, t1) = bsum{uSub2;}(i0, i1, t2) + t)
        \sameUpdateLevel
        \varcond(
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t),
            \notFreeIn(uSub2, t),
            \notFreeIn(uSub1, index),
            \notFreeIn(uSub2, index),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1))
        "Precondition":
            \add( ==>
                i0 <= index &
                index < i1 &
                \forall uSub1; ((uSub1 >= i0 & uSub1 < i1 & uSub1 != index) -> t1 = ({\subst uSub2; uSub1}t2))
            );
        "Usage":
            \add( ==>
                t = (({\subst uSub1; index}t1) - ({\subst uSub2; index}t2))
            )
    };

    // proven in KeY (DB 25/10/2013)
    equal_bsum5 {
        \find( ==> bsum{uSub1;}(i0, i1, t1) = bsum{uSub2;}(i2, i3, t2))
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub1, i3),
            \notFreeIn(uSub2, i3))
        "Equal length":
            \add( ==> i1 - i0 = i3 - i2);
        "Equal elements":
            \add( ==> \forall uSub1; ((uSub1 >= i0 & uSub1 < i1) -> t1 = ({\subst uSub2; uSub1 + i2 - i0}t2)))
        \heuristics(comprehensions_high_costs)
        \displayname "equal_bsum"
    };

    \lemma
    bsum_num_of_is_max {
        \find(bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)) = i2 - i0 ==>)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(\forall uSub; ((uSub >= i0 & uSub < i2) -> phi) ==>)
        \heuristics(simplify_enlarging)
    };

    \lemma
    bsum_num_of_is_max2 {
        \assumes(i2 > i0 ==>)
        \find(\forall uSub; ((uSub >= i0 & uSub < i2) -> phi) ==>)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)) = i2 - i0 ==>)
        \heuristics(simplify_enlarging)
    };

    \lemma
    bsum_num_of_is_max3 {
        \find(bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)) = i2 - i0 ==>)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(\forall uSub; ((uSub >= i0 & uSub < i2) -> !phi) ==>)
        \heuristics(simplify_enlarging)
    };

    \lemma
    bsum_num_of_is_max4 {
        \assumes(i2 > i0 ==>)
        \find(\forall uSub; ((uSub >= i0 & uSub < i2) -> !phi) ==>)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)) = i2 - i0 ==>)
        \heuristics(simplify_enlarging)
    };

    \lemma
    bsum_num_of_lt_max {
        \assumes(i2 > i0 & i0 >= 0 ==>)
        \find(bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)) < i2 - i0 ==>)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(\exists uSub; ((uSub >= i0 & uSub < i2) & !phi) ==>)
        \heuristics(simplify_enlarging)
    };

    \lemma
    bsum_num_of_lt_max2 {
        \assumes(i2 > i0 & i0 >= 0 ==>)
        \find(\exists uSub; ((uSub >= i0 & uSub < i2) & !phi) ==>)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)) < i2 - i0 ==>)
        \heuristics(simplify_enlarging)
    };

    \lemma
    bsum_num_of_lt_max3 {
        \assumes(i2 > i0 & i0 >= 0 ==>)
        \find(bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)) < i2 - i0 ==>)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(\exists uSub; ((uSub >= i0 & uSub < i2) & phi) ==>)
        \heuristics(simplify_enlarging)
    };

    \lemma
    bsum_num_of_lt_max4 {
        \assumes(i2 > i0 & i0 >= 0 ==>)
        \find(\exists uSub; ((uSub >= i0 & uSub < i2) & phi) ==>)
        \varcond(\notFreeIn(uSub, i0),
            \notFreeIn(uSub, i2))
        \add(bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)) < i2 - i0 ==>)
        \heuristics(simplify_enlarging)
    };

    \lemma
    bsum_num_of_gt0 {
        \find(bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)))
        \varcond(\notFreeIn(uSub, i0), \notFreeIn(uSub, i2))
        \add(bsum{uSub;}(i0, i2, \if(phi) \then(1) \else(0)) > 0 ->
            \exists uSub; (i0 <= uSub & uSub < i2 & phi) ==>)
    };

    \lemma
    bsum_num_of_gt0_alt {
        \find(bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)))
        \varcond(\notFreeIn(uSub, i0), \notFreeIn(uSub, i2))
        \add(bsum{uSub;}(i0, i2, \if(phi) \then(0) \else(1)) > 0 ->
            \exists uSub; (i0 <= uSub & uSub < i2 & !phi) ==>)
    };

}

\rules(integerSimplificationRules:full, sequences:on) {
    equal_bsum_perm1 {
        \find( ==> bsum{uSub1;}(i0, i1, t1) = bsum{uSub2;}(i2, i3, t2))
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub1, i3),
            \notFreeIn(uSub2, i3))
        \add( ==> seqPerm(seqDef{uSub1;}(i0, i1, t1), seqDef{uSub2;}(i2, i3, t2)))
        \displayname "equal_bsum_perm"
    };

    equal_bsum_perm2 {
        \assumes(bsum{uSub2;}(i2, i3, t2) = t ==>)
        \find( ==> bsum{uSub1;}(i0, i1, t1) = t)
        \varcond(
            \notFreeIn(uSub2, t1),
            \notFreeIn(uSub1, t2),
            \notFreeIn(uSub1, i0),
            \notFreeIn(uSub2, i0),
            \notFreeIn(uSub1, i1),
            \notFreeIn(uSub2, i1),
            \notFreeIn(uSub1, i2),
            \notFreeIn(uSub2, i2),
            \notFreeIn(uSub1, i3),
            \notFreeIn(uSub2, i3))
        \add( ==> seqPerm(seqDef{uSub1;}(i0, i1, t1), seqDef{uSub2;}(i2, i3, t2)))
        \displayname "equal_bsum_perm"
    };
}

\rules(integerSimplificationRules:full) {
    equal_bsum_zero_cut {
        \find( ==> bsum{uSub1;}(i0, i1, t1) = bsum{uSub2;}(i2, i3, t2) * t)
        \add( ==> bsum{uSub1;}(i0, i1, t1) = 0);
        \add(bsum{uSub1;}(i0, i1, t1) = 0 ==>)
    };

    pullOutbsum1 {
        \find(bsum{uSub1;}(i0, i1, t1) >= t ==>)
        \varcond(\newDependingOn(sk, t1),
            \newDependingOn(sk, i0),
            \newDependingOn(sk, i1))
        \replacewith(sk >= t ==>)
        \add(bsum{uSub1;}(i0, i1, t1) = sk ==>)
    };

    pullOutbsum2 {
        \find(bsum{uSub1;}(i0, i1, t1) <= t ==>)
        \varcond(\newDependingOn(sk, t1),
            \newDependingOn(sk, i0),
            \newDependingOn(sk, i1))
        \replacewith(sk <= t ==>)
        \add(bsum{uSub1;}(i0, i1, t1) = sk ==>)
    };

    bsum_invert_index {
        \find(bsum{uSub;}(i0, i1, t))
        \varcond(\notFreeIn(uSub, i0, i1),
            \notFreeIn(uSub1, i0, i1, t))
        \replacewith(bsum{uSub1;}(-i1, -i0, {\subst uSub; -uSub1}t))
    };

    bsum_invert_index_concrete {
        \find(bsum{uSub;}(i0 * -1, i1 * -1, t))
        \varcond(\notFreeIn(uSub, i0, i1),
            \notFreeIn(uSub1, i0, i1, t))
        \replacewith(bsum{uSub1;}(i1, i0, {\subst uSub; -uSub1}t))
        \heuristics(simplify)
    };

    // not proven yet
    bsum_add {
        \find(bsum{uSub1;}(i0, i1, t1) + bsum{uSub2;}(i2, i3, t2))
        \varcond(\notFreeIn(uSub1, i0, i1, i2, i3, t2),
            \notFreeIn(uSub2, i0, i1, i2, i3, t1))
        \replacewith(bsum{uSub1;}(
                \if(i0 < i2) \then(i0) \else(i2),
                \if(i1 > i3) \then(i1) \else(i3),
                {\subst uSub2; uSub1}(
                    \if(i0 <= uSub1 & uSub1 < i1) \then(t1) \else(0) +
                    \if(i2 <= uSub1 & uSub1 < i3) \then(t2) \else(0))
            )
        )
    };

    \lemma // conditionally (see above) -- DB 2012/12/11
    bsum_add_concrete {
        \find(bsum{uSub1;}(i0, i1, t1) + bsum{uSub2;}(i1, i3, t2))
        \varcond(\notFreeIn(uSub1, i0, i1, i3, t2),
            \notFreeIn(uSub2, i0, i1, i3, t1))
        \add( ==> i0 <= i1 & i1 <= i3);
        \replacewith(bsum{uSub1;}(i0, i3,
                {\subst uSub2; uSub1}\if(uSub1 < i1) \then(t1) \else(t2))
        )
    };

    // --------------------------------------------------------------------
    // rules for general sums
    // --------------------------------------------------------------------

    sum_empty {
        \schemaVar \variables alpha x;
        \find(sum{x;}(FALSE, t))
        \replacewith(0)
        \heuristics(concrete)
    };

    sum_zero {
        \schemaVar \variables alpha x;
        \schemaVar \term boolean range;
        \find(sum{x;}(range, 0))
        \replacewith(0)
        \heuristics(concrete)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\functions {
    int clIndexOfChar(Seq, int, int);

    int clIndexOfCl(Seq, int, Seq);
    int clLastIndexOfChar(Seq, int, int);
    int clLastIndexOfCl(Seq, int, Seq);

    Seq clReplace(Seq, int, int);
    Seq clTranslateInt(int);
    Seq clRemoveZeros(Seq);
    int clHashCode(Seq);
}

\predicates {
    clStartsWith(Seq, Seq);
    clEndsWith(Seq, Seq);
    clContains(Seq, Seq);
}

// Changes in KeYHeap:
// -All occurrences of "jchar" have been replaced by "int", which generally replaces the sort "jchar" in KeYHeap.
// -All function names have been prefixed with "cl" to avoid name clashes.
// -The rigid function "strContent" (declared in String.key) replaces the location function "content".
// -The rigid function "strPool" (declared in String.key) replaces the location function "pool".
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules(Strings:on) {
    /***********
     *  AXIOMS *
     ***********/
    /*
     * Seq clTranslateInt (int)
     * - translating an integer into a Seq
     */
    translate0 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(0(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('0')))
        \heuristics(integerToString)
    };

    translate1 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(1(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('1')))
        \heuristics(integerToString)
    };

    translate2 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(2(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('2')))
        \heuristics(integerToString)
    };

    translate3 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(3(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('3')))
        \heuristics(integerToString)
    };

    translate4 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(4(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('4')))
        \heuristics(integerToString)
    };

    translate5 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(5(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('5')))
        \heuristics(integerToString)
    };

    translate6 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(6(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('6')))
        \heuristics(integerToString)
    };

    translate7 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(7(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('7')))
        \heuristics(integerToString)
    };

    translate8 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(8(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('8')))
        \heuristics(integerToString)
    };

    translate9 {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(9(iz))))
        \replacewith(seqConcat(clTranslateInt(Z(iz)), seqSingleton('9')))
        \heuristics(integerToString)
    };

    translate# {
        \find(clTranslateInt(Z(#)))
        \replacewith(seqEmpty)
        \heuristics(integerToString)
    };

    translateNegLit {
        \schemaVar \term numbers iz;
        \find(clTranslateInt(Z(neglit(iz))))
        \replacewith(seqConcat(seqSingleton('-'), clTranslateInt(Z(iz))))
        \heuristics(integerToString)
    };

    /*
     * Seq clRemoveZeros (Seq) - removing '0' from
     * the beginning of a Seq must not lead to the empty list
     */
    removeZeros {
        \schemaVar \term Seq l;
        \find(clRemoveZeros(l))
        \replacewith(\if(l = seqEmpty | int::seqGet(l, 0) = '0') \then(l) \else(clRemoveZeros(seqSub(l, 1, seqLen(l)))))
        \heuristics(integerToString)
    };

    /*
     * = (Seq,Seq)nonNe
     * the equality predicate
     */

    /*
     * clContains (Seq,Seq)
     * predicate indicating whether the second character sequence is contained in the first one
     */
    containsAxiomAntec {
        \schemaVar \term Seq searchString, textString;
        \schemaVar \variables int iv;

        \find(clContains(textString, searchString) ==>)
        \varcond(\notFreeIn(iv, searchString), \notFreeIn(iv, textString))
        \replacewith(\exists iv; (iv >= 0
                & iv + seqLen(searchString) <= seqLen(textString)
                & seqSub(textString, iv, iv + seqLen(searchString)) = searchString) ==>)

        \heuristics(stringsExpandDefNormalOp)
    };

    containsAxiomSucc {
        \schemaVar \term Seq searchString, textString;
        \schemaVar \variables int iv;

        \find( ==> clContains(textString, searchString))
        \varcond(\notFreeIn(iv, searchString), \notFreeIn(iv, textString))
        \replacewith( ==> \exists iv; (iv >= 0
                & iv + seqLen(searchString) <= seqLen(textString)
                & seqSub(textString, iv, iv + seqLen(searchString)) = searchString))

        \heuristics(stringsExpandDefNormalOp)
    };

    contains {
        \schemaVar \term Seq searchString, textStringTail;
        \schemaVar \term int fstTextCharacter;
        \schemaVar \skolemTerm int newSym;

        \find(clContains(seqConcat(seqSingleton(fstTextCharacter), textStringTail), searchString))
        \sameUpdateLevel
        \varcond(\newDependingOn(newSym, searchString))
        \replacewith(newSym < seqLen(textStringTail) &
            (seqSub(seqConcat(seqSingleton(fstTextCharacter), textStringTail), 0, newSym) = searchString |
                clContains(textStringTail, searchString)))
        \add(seqLen(searchString) = newSym ==>)

        \heuristics(stringsContainsDefInline, stringsIntroduceNewSym)

    };

    /*
     * int clIndexOfChar (Sequent, int, int)
     */
    indexOf {
        \schemaVar \term Seq l;
        \schemaVar \term int c;
        \schemaVar \term int i;
        \schemaVar \variables int iv;
        \find(clIndexOfChar(l, c, i))
        \varcond(\notFreeIn(iv, l),
            \notFreeIn(iv, c),
            \notFreeIn(iv, i))
        \replacewith(\ifEx iv; (i >= 0
                & iv >= i
                & iv < seqLen(l)
                & int::seqGet(l, iv) = c)
            \then(iv)
            \else(-1))
        \heuristics(stringsExpandDefNormalOp)
    };

    /*
     * Seq clReplace (Seq, int, int)
     * replace all occurrences of the first character
     * with the second character
     */
    replaceEmpty {
        \schemaVar \term int searchChar, replChar;

        \find(clReplace(seqEmpty, searchChar, replChar))
        \replacewith(seqEmpty)
        \heuristics(stringsSimplify)
    };

    replaceSingleton {
        \schemaVar \term Seq str;
        \schemaVar \term int searchChar, replChar, fstChar;

        \find(clReplace(seqSingleton(fstChar), searchChar, replChar))
        \replacewith(\if(searchChar = fstChar)
                \then(seqSingleton(replChar))
                \else(seqSingleton(fstChar)))
        \heuristics(stringsSimplify)
    };

    replaceCons {
        \schemaVar \term Seq str;
        \schemaVar \term int searchChar, replChar, fstChar;

        \find(clReplace(seqConcat(seqSingleton(fstChar), str), searchChar, replChar))
        \replacewith(\if(searchChar = fstChar)
                \then(seqConcat(seqSingleton(replChar),
                        clReplace(str, searchChar, replChar)))
                \else(seqConcat(seqSingleton(fstChar),
                        clReplace(str, searchChar, replChar))))
        \heuristics(defOpsReplaceInline)
    };

    replaceDef {
        \schemaVar \term Seq str;
        \schemaVar \skolemTerm Seq newSym;
        \schemaVar \term int searchChar, replChar;
        \schemaVar \variables int pos;

        \find(clReplace(str, searchChar, replChar))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(pos, str, searchChar, replChar),
            \newDependingOn(newSym, searchChar),
            \newDependingOn(newSym, replChar),
            \newDependingOn(newSym, str))
        \add(clReplace(str, searchChar, replChar) = newSym &
            seqDef{pos;}(0, seqLen(str), \if(int::seqGet(str, pos) = searchChar) \then(replChar) \else(int::seqGet(str, pos))) = newSym
            ==>)

        \heuristics(defOpsReplace, stringsIntroduceNewSym)
    };

    /*
     * clEndsWith(Seq,Seq)
     * predicate indicating if the second list
     * is a suffix of the first one
     */
    endsWith {
        \schemaVar \term Seq sourceStr, searchStr;

        \find(clEndsWith(sourceStr, searchStr))
        \replacewith(
            \if(seqLen(searchStr) > seqLen(sourceStr))
                \then(false)
                \else(seqSub(sourceStr, seqLen(sourceStr) - seqLen(searchStr), seqLen(sourceStr)) = searchStr))

        \heuristics(defOpsStartsEndsWith)
    };

    /*
     * clStartsWith(Seq,Seq)
     * predicate indicating if the second list
     * is a prefix of the first one
     */
    startsWith {
        \schemaVar \term Seq sourceStr, searchStr;
        \find(clStartsWith(sourceStr, searchStr))
        \replacewith(
            \if(seqLen(searchStr) > seqLen(sourceStr))
                \then(false)
                \else(seqSub(sourceStr, 0, seqLen(searchStr)) = searchStr))
        \heuristics(defOpsStartsEndsWith)
    };

    /*
     * int clIndexOfCl (Seq,int,Seq)
     */
    indexOfStr {
        \schemaVar \term Seq searchStr, sourceStr;
        \schemaVar \term int i;
        \schemaVar \variables int iv;
        \find(clIndexOfCl(sourceStr, i, searchStr))
        \varcond(\notFreeIn(iv, searchStr), \notFreeIn(iv, sourceStr), \notFreeIn(iv, i))
        \replacewith(\ifEx iv; (iv >= i
                & iv >= 0
                & iv + seqLen(searchStr) <= seqLen(sourceStr)
                & (seqSub(sourceStr, iv, iv + seqLen(searchStr)) = searchStr))
            \then(iv)
            \else(-1))
        \heuristics(stringsExpandDefNormalOp)
    };

    /*
     * int clLastIndexOfChar (int,int,Seq)
     */
    lastIndexOf {
        \schemaVar \term Seq sourceStr;
        \schemaVar \term int c;
        \schemaVar \term int i;
        \schemaVar \variables int iv;
        \find(clLastIndexOfChar(sourceStr, c, i))
        \varcond(\notFreeIn(iv, c), \notFreeIn(iv, i), \notFreeIn(iv, sourceStr))
        \replacewith(\ifEx iv; (iv > 0
                & i >= iv
                & i - iv < seqLen(sourceStr)
                & int::seqGet(sourceStr, i - iv) = c)
            \then(i - iv)
            \else(-1))
        \heuristics(stringsExpandDefNormalOp)
    };

    /*
     * int clLastIndexOfCl (Seq,int,Seq)
     */
    lastIndexOfStr {
        \schemaVar \term Seq searchStr, sourceStr;
        \schemaVar \term int i;
        \schemaVar \variables int iv;
        \find(clLastIndexOfCl(sourceStr, i, searchStr))
        \varcond(\notFreeIn(iv, searchStr), \notFreeIn(iv, i), \notFreeIn(iv, sourceStr))
        \replacewith(\ifEx iv; (iv > 0
                & i - iv >= 0
                & seqLen(searchStr) + i - iv <= seqLen(sourceStr)
                & (seqSub(sourceStr, i - iv, seqLen(searchStr) + i - iv) = searchStr))
            \then(i - iv)
            \else(-1))
        \heuristics(stringsExpandDefNormalOp)
    };

    /**
     * we define only the base case
     */
    hashCodeBase {
        \find(clHashCode(seqEmpty))
        \replacewith(0)
        \heuristics(simplify_literals)
    };

    /************
     *  LEMMAS  *
     ************/

    /*
     * A clReplace application will not change
     * the length of the string
     */
    lengthReplace {
        \schemaVar \term Seq str, newStr;
        \schemaVar \term int searchChar, replaceChar;

        \find(seqLen(clReplace(str, searchChar, replaceChar)))
        \replacewith(seqLen(str))
        \heuristics(stringsSimplify)
    };

    lengthReplaceEQ {
        \schemaVar \term Seq str, newStr;
        \schemaVar \term int searchChar, replaceChar;

        \assumes(clReplace(str, searchChar, replaceChar) = newStr ==>)
        \find(seqLen(newStr))
        \sameUpdateLevel
        \replacewith(seqLen(str))
        \heuristics(stringsSimplify)
    };

    /*
     * Two succedent substring calls can be combined to one
     */
    substringSubstring {
        \schemaVar \term Seq str;
        \schemaVar \skolemTerm Seq newSym;
        \schemaVar \term int outerStartIdx, outerEndIdx, innerStartIdx, innerEndIdx;

        \find(seqSub(seqSub(str, innerStartIdx, innerEndIdx), outerStartIdx, outerEndIdx))
        \sameUpdateLevel

        \varcond(
            \newDependingOn(newSym, str),
            \newDependingOn(newSym, outerStartIdx),
            \newDependingOn(newSym, outerEndIdx),
            \newDependingOn(newSym, innerStartIdx))
        \add((innerStartIdx >= 0
                & innerEndIdx >= innerStartIdx
                & innerEndIdx <= seqLen(str)
                & outerStartIdx >= 0
                & outerEndIdx >= outerStartIdx
                & outerEndIdx <= innerEndIdx - innerStartIdx)
            ->
            (
                seqSub(seqSub(str, innerStartIdx, innerEndIdx), outerStartIdx, outerEndIdx) = newSym &
                seqSub(str, outerStartIdx + innerStartIdx, innerStartIdx + outerEndIdx) = newSym) ==>)
        \heuristics(stringsReduceSubstring, stringsIntroduceNewSym)
    };

    substringSubstring2 {
        \schemaVar \term Seq str, innerSub;
        \schemaVar \skolemTerm Seq newSym;
        \schemaVar \term int outerStartIdx, outerEndIdx, innerStartIdx, innerEndIdx;

        \assumes(seqSub(str, innerStartIdx, innerEndIdx) = innerSub ==>)
        \find(seqSub(innerSub, outerStartIdx, outerEndIdx))
        \sameUpdateLevel
        \varcond(
            \newDependingOn(newSym, str),
            \newDependingOn(newSym, outerStartIdx),
            \newDependingOn(newSym, outerEndIdx),
            \newDependingOn(newSym, innerStartIdx))
        \add((innerStartIdx >= 0
                & innerEndIdx >= innerStartIdx
                & innerEndIdx <= seqLen(str)
                & outerStartIdx >= 0
                & outerEndIdx >= outerStartIdx
                & outerEndIdx <= innerEndIdx - innerStartIdx)
            ->
            (seqSub(innerSub, outerStartIdx, outerEndIdx) = newSym &
                seqSub(str, outerStartIdx + innerStartIdx, innerStartIdx + outerEndIdx) = newSym) ==>)
        \heuristics(stringsReduceSubstring, stringsIntroduceNewSym)
    };

    equalCharacters {
        \schemaVar \term numbers iz1, iz2;
        \find(C(iz1) = C(iz2))
        \replacewith(Z(iz1) = Z(iz2))
        \heuristics(stringsSimplify)
    };

    replaceSubstring {
        \schemaVar \term Seq str, subStr;
        \schemaVar \term int searchChar, replaceChar;
        \schemaVar \term int startIdx, endIdx;

        \assumes(seqSub(str, startIdx, endIdx) = subStr ==>)

        \find(clReplace(subStr, searchChar, replaceChar))
        \sameUpdateLevel
        \replacewith(\if(startIdx >= 0 & endIdx >= startIdx & endIdx <= seqLen(str))
                \then(seqSub(clReplace(str, searchChar, replaceChar), startIdx, endIdx))
                \else(clReplace(subStr, searchChar, replaceChar)))
        \heuristics(stringsMoveReplaceInside)

        \displayname "replaceSubstring"
    };

    /*
     * A clReplace inside a seqConcat application
     * does not affect the seqConcat...
     */
    replaceConcat {
        \schemaVar \term Seq leftStr, rightStr;
        \schemaVar \term int searchChar, replaceChar;
        \find(clReplace(seqConcat(leftStr, rightStr), searchChar, replaceChar))
        \replacewith(seqConcat(clReplace(leftStr, searchChar, replaceChar),
                clReplace(rightStr, searchChar, replaceChar)))
        \heuristics(stringsMoveReplaceInside)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules(integerSimplificationRules:full) {

    // The pull out rules are currently commented out
    // because the regular pull out rule can do the job.
    // These here are meant to be assigned a special
    // ruleset in the future for better automation.

    /*
      pullOutMin {
        \schemaVar\variables alpha x;
        \schemaVar\term boolean b;
        \schemaVar\term int t;
        \schemaVar\skolemTerm int sk;
        \find( min{x;}(b,t) )
        \varcond ( \newDependingOn(sk, b),
               \newDependingOn(sk, t))
        \replacewith ( sk )
        \add( min{x;}(b,t) = sk ==> )
      };
    */

    minAxiom {
        \schemaVar \variables alpha x, y, z;
        \schemaVar \term boolean b;
        \schemaVar \term int t, t2;
        \find(min{x;}(b, t) = t2 ==>)
        \varcond(\notFreeIn(x, t2), \notFreeIn(y, b, t, t2))
        "Use Axiom":
            \add(\forall y; {\subst x; y}(b = TRUE -> t >= t2)
                & \exists y; {\subst x; y}(b = TRUE & t = t2) ==>);
        "Show Satisfiability":
            \add( ==> \exists x; (b = TRUE
                    & \forall y; ({\subst x; y}b = TRUE -> {\subst x; y}t >= t)))
    };

    /*
      pullOutMax {
        \schemaVar\variables alpha x;
        \schemaVar\term boolean b;
        \schemaVar\term int t;
        \schemaVar\skolemTerm int sk;
        \find( max{x;}(b,t) )
        \varcond ( \newDependingOn(sk, b),
               \newDependingOn(sk, t))
        \replacewith ( sk )
        \add( max{x;}(b,t) = sk ==> )
      };
    */

    maxAxiom {
        \schemaVar \variables alpha x, y, z;
        \schemaVar \term boolean b;
        \schemaVar \term int t, t2;
        \find(max{x;}(b, t) = t2 ==>)
        \varcond(\notFreeIn(x, t2), \notFreeIn(y, b, t, t2))
        "Use Axiom":
            \add(\forall y; {\subst x; y}(b = TRUE -> t <= t2)
                & \exists y; {\subst x; y}(b = TRUE & t = t2) ==>);
        "Show Satisfiability":
            \add( ==> \exists x; (b = TRUE
                    & \forall y; ({\subst x; y}b = TRUE -> {\subst x; y}t <= t)))
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// --------------- loops ------------------------------------------------------//
\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
    \formula post;
    \program LeftHandSide #lhs, #lhs1;
    \program SimpleExpression #se;
    \program Statement #s;
    \program [list] Statement #slist, #slist1, #slist2, #slist3;
    \program Label #innerLabel, #outerLabel;
    \program Expression #e, #e0, #e1, #e2;
    \program NonSimpleExpression #nse;
    \program ForLoop #forloop;
    \program ProgramMethod #pm;
    \program Type #t, #t2;
    \program Variable #v, #v0, #v1, #a;
    \program NonStringLiteral #lit;
    \program ArrayLength #length;
    \program Label #lb, #lb1;
    \program [list] Ccatch #cs;
}

\rules(programRules:Java) {

    execNoCcatch {
        \find(
            \modality{#allmodal}{..
                    exec { #slist }
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                    { #slist }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    execEmpty {
        \find(
            \modality{#allmodal}{..
                    exec { } ccat #cs
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    ///////////////////////////////////
    // Abrupt completion catching rules
    ///////////////////////////////////

    execReturn {
        \find(
            \modality{#allmodal}{..
                    exec { return; #slist }
                    ccat ( \Return ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                    { #slist1 }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execReturn"
    };

    execReturnVal {
        \find(
            \modality{#allmodal}{..
                    exec { return #se; #slist }
                    ccat ( \Return #t #v ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \varcond(\sub(\typeof(#se), \typeof(#v)))
        \replacewith(\modality{#allmodal}{..
                    {
                        #t #v;
                        #v = (#t) #se;
                        #slist1
                    }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execReturn"
    };

    execBreak {
        \find(
            \modality{#allmodal}{..
                    exec { break; #slist }
                    ccat ( \Break ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                    { #slist1 }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execBreak"
    };

    execBreakLabelMatch {
        \find(
            \modality{#allmodal}{..
                    exec { break #lb; #slist }
                    ccat ( \Break #lb ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                    { #slist1 }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execBreakLabel"
    };

    execBreakLabelWildcard {
        \find(
            \modality{#allmodal}{..
                    exec { break #lb; #slist }
                    ccat ( \Break * ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                    { #slist1 }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execBreakLabel"
    };

    execContinue {
        \find(
            \modality{#allmodal}{..
                    exec { continue; #slist }
                    ccat ( \Continue ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                    { #slist1 }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execContinue"
    };

    execContinueLabelMatch {
        \find(
            \modality{#allmodal}{..
                    exec { continue #lb; #slist }
                    ccat ( \Continue #lb ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                    { #slist1 }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execBreakLabel"
    };

    execContinueLabelWildcard {
        \find(
            \modality{#allmodal}{..
                    exec { continue #lb; #slist }
                    ccat ( \Continue * ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                    { #slist1 }
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execContinueLabel"
    };

    ////////////////////////////////////////////////
    // "Standard" exception rules (cf. try statement)
    ////////////////////////////////////////////////

    execCatchThrow {
        \find(\modality{#allmodal}{.. exec { throw #se; #slist }
                ccat ( #t #v0 ) { #slist1 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. if ( #se == null ) {
                      exec { throw new java.lang.NullPointerException (); }
                      ccat ( #t #v0 ) { #slist1 }
                } else if ( #se instanceof #t ) {
                      #t #v0;
                      #v0 = (#t) #se;
                      #slist1
                } else {
                      throw #se;
                } ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execCatchThrow"
    };

    execMultipleCatchThrow {
        \find(\modality{#allmodal}{.. exec { throw #se; #slist }
                ccat ( #t #v0 ) { #slist1 }
                ccat ( #t2 #v1 ) { #slist3 }
                ccat #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. if ( #se == null ) {
                     exec { throw new java.lang.NullPointerException (); }
                     ccat ( #t #v0 ) { #slist1 }
                     ccat ( #t2 #v1 ) { #slist3 }
                     ccat #cs
                } else if ( #se instanceof #t ) {
                     #t #v0;
                     #v0 = (#t) #se;
                     #slist1
                } else {
                     exec { throw #se; }
                     ccat ( #t2 #v1 ) { #slist3 }
                     ccat #cs
                } ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execCatchThrow"
    };

    //////////////////////////////////////////////////////////////////////
    // Rules for eliminating clauses that don't match the present behavior
    //////////////////////////////////////////////////////////////////////

    // Return

    // return-val clause has to come after return clause,
    // therefore can throw away whole exec statement.
    execReturnEliminateReturnVal {
        \find(\modality{#allmodal}{..
                   exec { return; #slist }
                   ccat ( \Return #t #v ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // break clause has to come after return clause,
    // therefore can throw away whole exec statement.
    execReturnEliminateBreak {
        \find(\modality{#allmodal}{..
                   exec { return; #slist }
                   ccat ( \Break ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // break-label clause has to come after return clause,
    // therefore can throw away whole exec statement.
    execReturnEliminateBreakLabel {
        \find(\modality{#allmodal}{..
                   exec { return; #slist }
                   ccat ( \Break #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // break-label-wildcard clause has to come after return clause,
    // therefore can throw away whole exec statement.
    execReturnEliminateBreakLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { return; #slist }
                   ccat ( \Break * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue clause has to come after return clause,
    // therefore can throw away whole exec statement.
    execReturnEliminateContinue {
        \find(\modality{#allmodal}{..
                   exec { return; #slist }
                   ccat ( \Continue ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue-label clause has to come after return clause,
    // therefore can throw away whole exec statement.
    execReturnEliminateContinueLabel {
        \find(\modality{#allmodal}{..
                   exec { return; #slist }
                   ccat ( \Continue #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue-label-wildcard clause has to come after return clause,
    // therefore can throw away whole exec statement.
    execReturnEliminateContinueLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { return; #slist }
                   ccat ( \Continue * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // exception ccatch clause has to come after return clause,
    // therefore can throw away whole exec statement.
    execReturnEliminateExcCcatch {
        \find(\modality{#allmodal}{..
                   exec { return; #slist }
                   ccat ( #t #v0 ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // Return-val

    execReturnValNonMatchingType {
        \find(
            \modality{#allmodal}{..
                    exec { return #se; #slist }
                    ccat ( \Return #t #v ) { #slist1 }
                    ccat #cs
                ...}\endmodality (post))
        \varcond(\not \sub(\typeof(#se), \typeof(#v)))
        \replacewith(\modality{#allmodal}{..
                    exec { return #se; #slist }
                    ccat #cs
                ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execReturnValEliminateReturn {
        \find(\modality{#allmodal}{..
                   exec { return #se; #slist }
                   ccat ( \Return ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { return #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // break clause has to come after return-val clause,
    // therefore can throw away whole exec statement.
    execReturnValEliminateBreak {
        \find(\modality{#allmodal}{..
                   exec { return #se; #slist }
                   ccat ( \Break ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return #se; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // break-label clause has to come after return-val clause,
    // therefore can throw away whole exec statement.
    execReturnValEliminateBreakLabel {
        \find(\modality{#allmodal}{..
                   exec { return #se; #slist }
                   ccat ( \Break #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return #se; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // break-label-wildcard clause has to come after return-val clause,
    // therefore can throw away whole exec statement.
    execReturnValEliminateBreakLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { return #se; #slist }
                   ccat ( \Break * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return #se; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue clause has to come after return-val clause,
    // therefore can throw away whole exec statement.
    execReturnValEliminateContinue {
        \find(\modality{#allmodal}{..
                   exec { return #se; #slist }
                   ccat ( \Continue ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return #se; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue-label clause has to come after return-val clause,
    // therefore can throw away whole exec statement.
    execReturnValEliminateContinueLabel {
        \find(\modality{#allmodal}{..
                   exec { return #se; #slist }
                   ccat ( \Continue #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return #se; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue-label-wildcard clause has to come after return-val clause,
    // therefore can throw away whole exec statement.
    execReturnValEliminateContinueLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { return #se; #slist }
                   ccat ( \Continue * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return #se; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // exception ccatch clause has to come after return-val clause,
    // therefore can throw away whole exec statement.
    execReturnValEliminateExcCcatch {
        \find(\modality{#allmodal}{..
                   exec { return #se; #slist }
                   ccat ( #t #v0 ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { return #se; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // Break

    execBreakEliminateReturn {
        \find(\modality{#allmodal}{..
                   exec { break; #slist }
                   ccat ( \Return ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { break; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execBreakEliminateReturnVal {
        \find(\modality{#allmodal}{..
                   exec { break; #slist }
                   ccat ( \Return #t #v ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { break; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // break-label clause has to come after break clause,
    // therefore can throw away whole exec statement.
    execBreakEliminateBreakLabel {
        \find(\modality{#allmodal}{..
                   exec { break; #slist }
                   ccat ( \Break #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // break-label-wildcard clause has to come after break clause,
    // therefore can throw away whole exec statement.
    execBreakEliminateBreakLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { break; #slist }
                   ccat ( \Break * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue clause has to come after break clause,
    // therefore can throw away whole exec statement.
    execBreakEliminateContinue {
        \find(\modality{#allmodal}{..
                   exec { break; #slist }
                   ccat ( \Continue ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue-label clause has to come after break clause,
    // therefore can throw away whole exec statement.
    execBreakEliminateContinueLabel {
        \find(\modality{#allmodal}{..
                   exec { break; #slist }
                   ccat ( \Continue #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue-label-wildcard clause has to come after break clause,
    // therefore can throw away whole exec statement.
    execBreakEliminateContinueLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { break; #slist }
                   ccat ( \Continue * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // exception ccatch clause has to come after break clause,
    // therefore can throw away whole exec statement.
    execBreakEliminateExcCcatch {
        \find(\modality{#allmodal}{..
                   exec { break; #slist }
                   ccat ( #t #v0 ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // Break-label

    execBreakLabelEliminateReturn {
        \find(\modality{#allmodal}{..
                   exec { break #lb; #slist }
                   ccat ( \Return ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { break #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execBreakLabelEliminateReturnVal {
        \find(\modality{#allmodal}{..
                   exec { break #lb; #slist }
                   ccat ( \Return #t #v ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { break #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execBreakLabelEliminateBreak {
        \find(\modality{#allmodal}{..
                   exec { break #lb; #slist }
                   ccat ( \Break ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { break #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execBreakLabelEliminateBreakLabelNoMatch {
        \find(\modality{#allmodal}{..
                   exec { break #lb; #slist }
                   ccat ( \Break #lb1 ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \varcond(\different(#lb, #lb1))

        \replacewith(\modality{#allmodal}{..
                    exec { break #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue ccatch clause has to come after break-label clause,
    // therefore can throw away whole exec statement.
    execBreakLabelEliminateContinue {
        \find(\modality{#allmodal}{..
                   exec { break #lb; #slist }
                   ccat ( \Continue ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break #lb; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue-label ccatch clause has to come after break-label clause,
    // therefore can throw away whole exec statement.
    execBreakLabelEliminateContinueLabel {
        \find(\modality{#allmodal}{..
                   exec { break #lb; #slist }
                   ccat ( \Continue #lb1 ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break #lb; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // continue-label-wildcard ccatch clause has to come after break-label clause,
    // therefore can throw away whole exec statement.
    execBreakLabelEliminateContinueLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { break #lb; #slist }
                   ccat ( \Continue * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break #lb; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // exception ccatch clause has to come after break-label clause,
    // therefore can throw away whole exec statement.
    execBreakLabelEliminateExcCcatch {
        \find(\modality{#allmodal}{..
                   exec { break #lb; #slist }
                   ccat ( #t #v ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { break #lb; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // Continue

    execContinueEliminateReturn {
        \find(\modality{#allmodal}{..
                   exec { continue; #slist }
                   ccat ( \Return ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueEliminateReturnVal {
        \find(\modality{#allmodal}{..
                   exec { continue; #slist }
                   ccat ( \Return #t #v ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueEliminateBreak {
        \find(\modality{#allmodal}{..
                   exec { continue; #slist }
                   ccat ( \Break ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueEliminateBreakLabel {
        \find(\modality{#allmodal}{..
                   exec { continue; #slist }
                   ccat ( \Break #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueEliminateBreakLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { continue; #slist }
                   ccat ( \Break * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // exception ccatch clause has to come after continue clause,
    // therefore can throw away whole exec statement.
    execContinueEliminateExcCcatch {
        \find(\modality{#allmodal}{..
                   exec { continue; #slist }
                   ccat ( #t #v0 ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { continue; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // Continue-label

    execContinueLabelEliminateReturn {
        \find(\modality{#allmodal}{..
                   exec { continue #lb; #slist }
                   ccat ( \Return ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueLabelEliminateReturnVal {
        \find(\modality{#allmodal}{..
                   exec { continue #lb; #slist }
                   ccat ( \Return #t #v ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueLabelEliminateBreak {
        \find(\modality{#allmodal}{..
                   exec { continue #lb; #slist }
                   ccat ( \Break ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueLabelEliminateBreakLabel {
        \find(\modality{#allmodal}{..
                   exec { continue #lb; #slist }
                   ccat ( \Break #lb1 ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueLabelEliminateBreakLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { continue #lb; #slist }
                   ccat ( \Break * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueLabelEliminateContinue {
        \find(\modality{#allmodal}{..
                   exec { continue #lb; #slist }
                   ccat ( \Continue ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { continue #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execContinueLabelEliminateContinueLabelNoMatch {
        \find(\modality{#allmodal}{..
                   exec { continue #lb; #slist }
                   ccat ( \Continue #lb1 ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \varcond(\different(#lb, #lb1))

        \replacewith(\modality{#allmodal}{..
                    exec { continue #lb; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // exception ccatch clause has to come after continue-label clause,
    // therefore can throw away whole exec statement.
    execContinueLabelEliminateExcCcatch {
        \find(\modality{#allmodal}{..
                   exec { continue #lb; #slist }
                   ccat ( #t #v ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    { continue #lb; }
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    // Exception

    execThrowEliminateReturn {
        \find(\modality{#allmodal}{..
                   exec { throw #se; #slist }
                   ccat ( \Return ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { throw #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execThrowEliminateReturnVal {
        \find(\modality{#allmodal}{..
                   exec { throw #se; #slist }
                   ccat ( \Return #t #v ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { throw #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execThrowEliminateBreak {
        \find(\modality{#allmodal}{..
                   exec { throw #se; #slist }
                   ccat ( \Break ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { throw #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execThrowEliminateBreakLabel {
        \find(\modality{#allmodal}{..
                   exec { throw #se; #slist }
                   ccat ( \Break #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { throw #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execThrowEliminateBreakLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { throw #se; #slist }
                   ccat ( \Break * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { throw #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execThrowEliminateContinue {
        \find(\modality{#allmodal}{..
                   exec { throw #se; #slist }
                   ccat ( \Continue ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { throw #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execThrowEliminateContinueLabel {
        \find(\modality{#allmodal}{..
                   exec { throw #se; #slist }
                   ccat ( \Continue #lb ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { throw #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

    execThrowEliminateContinueLabelWildcard {
        \find(\modality{#allmodal}{..
                   exec { throw #se; #slist }
                   ccat ( \Continue * ) { #slist1 }
                   ccat #cs
                ...}\endmodality (post))

        \replacewith(\modality{#allmodal}{..
                    exec { throw #se; }
                    ccat #cs
                ...}\endmodality (post))

        \heuristics(simplify_prog)
        \displayname "execEliminateNonMatching"
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains quantifier and equality rules which used to be in genericRules.key

\sorts {
    \generic G, S1, S2, H;
}

\schemaVariables {
    \term G e, s, t, e0;
    \term H t1;
    \term S1 t2;
    \skolemTerm G sk;
    \formula b, c;
    \variables G u, e2;

    \term G commEqLeft;
    \term H commEqRight;

    \term [rigid] G sr;
    \term [rigid] H tr;

    \term S1 ind1, ind2, target;
}

\rules {

    // Gamma rules
    allLeft {
        \find(\forall u; b ==>)
        \add({\subst u; t}(b) ==>)
        \heuristics(gamma)
    };
    exRight {
        \find( ==> \exists u; b)
        \add( ==> {\subst u; t}(b))
        \heuristics(gamma)
    };
    allLeftHide {
        \find(\forall u; b ==>)
        \replacewith({\subst u; t}(b) ==>)
        \addrules(
            insert_hidden {
                \add(\forall u; b ==>)
            })
        \heuristics(gamma_destructive)
    };
    exRightHide {
        \find( ==> \exists u; b)
        \replacewith( ==> {\subst u; t}(b))
        \addrules(
            insert_hidden {
                \add( ==> \exists u; b)
            })
        \heuristics(gamma_destructive)
    };

    instAll {
        \assumes(\forall u; b ==>)
        \find(t)
        \add({\subst u; t}(b) ==>)
    };
    instEx {
        \assumes( ==> \exists u; b)
        \find(t)
        \add( ==> {\subst u; t}(b))
    };

    // delta rules
    allRight {
        \find( ==> \forall u; b)
        \varcond(\newDependingOn(sk, b))
        \replacewith( ==> {\subst u; sk}b) \heuristics(delta)
    };
    exLeft {
        \find(\exists u; b ==>)
        \varcond(\newDependingOn(sk, b))
        \replacewith({\subst u; sk}b ==>) \heuristics(delta)
    };

    // simplification
    all_unused {
        \find(\forall u; b)
        \varcond(\notFreeIn(u, b))
        \replacewith(b)
        \heuristics(elimQuantifier)
    };
    ex_unused {
        \find(\exists u; b)
        \varcond(\notFreeIn(u, b))
        \replacewith(b)
        \heuristics(elimQuantifier)
    };

    // equality
    eqClose {
        \find(s = s)
        \replacewith(true) \heuristics(concrete)
    };

    eqSymm {
        \find(commEqLeft = commEqRight)
        \replacewith(commEqRight = commEqLeft)
        \heuristics(order_terms)
    };

    make_insert_eq {
        \find(sr = tr ==>)
        \addrules(
            insert_eq {
                \find(sr)
                \replacewith(tr)
            })
    };

    make_insert_eq_nonrigid {
        \find(s = t ==>)
        \addrules(
            insert_eq_nonrigid {
                \find(s)
                \sameUpdateLevel
                \replacewith(t)
                \displayname "insert_eq"
            })
    };
    insert_eq_all {
        \find(sr = tr ==>)
        \replacewith( ==>)
        \addrules(
            auto_insert_eq {
                \find(sr)
                \replacewith(tr)
                \heuristics(simplify)
            })
    };

    // wary substitutions
    apply_subst {
        \find({\subst u; t}target)
        // it is enough to rebuild the same term, as substitutions
        // are automatically applied in this situation
        \replacewith({\subst u; t}target)
        \heuristics(try_apply_subst)
    };

    apply_subst_for {
        \schemaVar \formula phi;
        \find({\subst u; t}phi)
        // it is enough to rebuild the same term, as substitutions
        // are automatically applied in this situation
        \replacewith({\subst u; t}phi)
        \heuristics(try_apply_subst)
        \displayname "apply_subst"
    };

    subst_to_eq {
        \find({\subst u; t}target)
        \sameUpdateLevel
        \varcond(\newDependingOn(sk, t))
        \replacewith({\subst u; sk}target)
        \add(sk = t ==>)
        \heuristics(simplify)
    };

    subst_to_eq_for {
        \schemaVar \formula phi;
        \find({\subst u; t}phi)
        \sameUpdateLevel
        \varcond(\newDependingOn(sk, t))
        \replacewith({\subst u; sk}phi)
        \add(sk = t ==>)
        \heuristics(simplify)
        \displayname "subst_to_eq"
    };

    ///////////////////////////////////////////////////////////////////////////////


    applyEq {
        \assumes(s = t1 ==>)
        \find(s)
        \sameUpdateLevel
        \replacewith(t1)
        \heuristics(apply_equations, apply_select_eq)
        \displayname "applyEq"
    };

    applyEqReverse {
        \assumes(s = t1 ==>)
        \find(t1)
        \sameUpdateLevel
        \replacewith(s)
        \heuristics(apply_auxiliary_eq)
        \displayname "applyEqReverse"
    };

    applyEqRigid {
        \schemaVar \term [rigid] H tr1;

        \assumes(sr = tr1 ==>)
        \find(sr)
        \replacewith(tr1)
        \heuristics(apply_equations)
        \displayname "applyEq"
    };

    pullOut {
        \find(t)
        \sameUpdateLevel
        \varcond(\newDependingOn(sk, t))
        \replacewith(sk)
        \add(t = sk ==>)
        \heuristics(semantics_blasting)
    };

    \lemma
    eqTermCut {
        \find(t)
        \sameUpdateLevel
        "Assume #t  = #s":
            \add(t = s ==>);
        "Assume #t != #s":
            \add(t != s ==>)
    };

    \lemma
    equivAllRight {
        \find( ==> \forall u; b <-> \forall e2; c)
        \varcond(\notFreeIn(u, c), \notFreeIn(e2, b))
        \add( ==> \forall u; (b <-> ({\subst e2; u}c)))
    };

    // --------------------------------------------------------------------------
    // rule for unique function symbols
    // --------------------------------------------------------------------------

    equalUnique {
        \schemaVar \term any f, f2;
        \schemaVar \formula result;

        \find(f = f2)
        \varcond(\equalUnique(f, f2, result))

        \replacewith(result)

        \heuristics(concrete)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #normalassign;
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;

    \program JavaFloatExpression #seFloat, #seFloat0, #seFloat1;
    \program JavaDoubleExpression #seDouble, #seDouble0, #seDouble1;
    \program JavaCharByteShortIntExpression #seCharByteShortInt;
    \program JavaLongExpression #seLong;

    \program Variable #loc;
    \program LeftHandSide #lhs;

    \program Variable #v;

    \program NonSimpleExpression #nse;

    \formula post;

    \term float f1, f2;
}

\rules(programRules:Java) {

    // ------------- equality and inequality comparisons, float (similar to those in javaRules)
    // ------------- not covered by the same rules as int because the translation is to different predicates

    equality_comparison_simple_float {
        \find(\modality{#allmodal}{.. #lhs = #seFloat0 == #seFloat1; ...}\endmodality (post))
        \replacewith({#lhs := \if(eqFloat(#seFloat0, #seFloat1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality comparison"
    };

    inequality_comparison_simple_float {
        \find(\modality{#allmodal}{.. #lhs = #seFloat0 != #seFloat1; ...}\endmodality (post))
        \replacewith({#lhs := \if(eqFloat(#seFloat0, #seFloat1)) \then(FALSE) \else(TRUE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality comparison"
    };

    less_than_comparison_simple_float {
        \find(\modality{#allmodal}{.. #lhs = #seFloat0 < #seFloat1; ...}\endmodality (post))
        \replacewith({#lhs := \if(ltFloat(#seFloat0, #seFloat1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "lesser than distinction"
    };

    less_equal_than_comparison_simple_float {
        \find(\modality{#allmodal}{.. #lhs = #seFloat0 <= #seFloat1; ...}\endmodality (post))
        \replacewith({#lhs := \if(leqFloat(#seFloat0, #seFloat1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less-or-equal than distinction"
    };

    greater_than_comparison_simple_float {
        \find(\modality{#allmodal}{.. #lhs = #seFloat0 > #seFloat1; ...}\endmodality (post))
        \replacewith({#lhs := \if(gtFloat(#seFloat0, #seFloat1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater than distinction"
    };

    greater_equal_than_comparison_simple_float {
        \find(\modality{#allmodal}{.. #lhs = #seFloat0 >= #seFloat1; ...}\endmodality (post))
        \replacewith({#lhs := \if(geqFloat(#seFloat0, #seFloat1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater-or-equal than distinction"
    };

    // ------------- equality and inequality comparisons, double (similar to those in javaRules)
    // ------------- not covered by the same rules as int because the translation is to different predicates

    equality_comparison_double {
        \find(\modality{#allmodal}{.. #lhs = #seDouble0 == #seDouble1; ...}\endmodality (post))
        \replacewith({#lhs := \if(eqDouble(#seDouble0, #seDouble1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality comparison"
    };

    inequality_comparison_simple_double {
        \find(\modality{#allmodal}{.. #lhs = #seDouble0 != #seDouble1; ...}\endmodality (post))
        \replacewith({#lhs := \if(eqDouble(#seDouble0, #seDouble1)) \then(FALSE) \else(TRUE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality comparison"
    };

    less_than_comparison_simple_double {
        \find(\modality{#allmodal}{.. #lhs = #seDouble0 < #seDouble1; ...}\endmodality (post))
        \replacewith({#lhs := \if(ltDouble(#seDouble0, #seDouble1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "lesser than distinction"
    };

    less_equal_than_comparison_simple_double {
        \find(\modality{#allmodal}{.. #lhs = #seDouble0 <= #seDouble1; ...}\endmodality (post))
        \replacewith({#lhs := \if(leqDouble(#seDouble0, #seDouble1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less-or-equal than distinction"
    };

    greater_than_comparison_simple_double {
        \find(\modality{#allmodal}{.. #lhs = #seDouble0 > #seDouble1; ...}\endmodality (post))
        \replacewith({#lhs := \if(gtDouble(#seDouble0, #seDouble1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater than distinction"
    };

    greater_equal_than_comparison_simple_double {
        \find(\modality{#allmodal}{.. #lhs = #seDouble0 >= #seDouble1; ...}\endmodality (post))
        \replacewith({#lhs := \if(geqDouble(#seDouble0, #seDouble1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater-or-equal than distinction"
    };

    // ------------- unary minus for float

    unaryMinusFloat {
        \find(\modality{#normalassign}{..
                    #loc = - #seFloat;
                ...}\endmodality (post))
        \replacewith({#loc := javaUnaryMinusFloat(#seFloat)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "unaryMinus"
    };

    unaryMinusDouble {
        \find(\modality{#normalassign}{..
                    #loc = - #seDouble;
                ...}\endmodality (post))
        \replacewith({#loc := javaUnaryMinusDouble(#seDouble)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "unaryMinus"
    };

    // ------------- Arithmetic operations with strictfp
    // float
    assignmentAdditionFloatStrictFP {
        \find(\modality{#normalassign}{..
                    #loc=#seFloat0 + #seFloat1;
                ...}\endmodality (post))
        \varcond(\isInStrictFp)
        \replacewith(
            {#loc := addFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "addition"
    };

    assignmentSubtractionFloatStrictFP {
        \find(\modality{#normalassign}{..
                    #loc = #seFloat0 - #seFloat1;
                ...}\endmodality (post))
        \varcond(\isInStrictFp)
        \replacewith(
            {#loc := subFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "subtraction"
    };

    assignmentMultiplicationFloatStrictFP {
        \find(\modality{#normalassign}{..
                    #loc = #seFloat0 * #seFloat1;
                ...}\endmodality (post))
        \varcond(\isInStrictFp)
        \replacewith(
            {#loc := mulFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "multiplication"
    };

    assignmentDivisionFloatStrictFP {
        \find(\modality{#normalassign}{..
                    #loc = #seFloat0 / #seFloat1;
                ...}\endmodality (post))
        \varcond(\isInStrictFp)
        \replacewith(
            {#loc := divFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "division"
    };

    // double
    assignmentAdditionDoubleStrictFP {
        \find(\modality{#normalassign}{..
                    #loc=#seDouble0 + #seDouble1;
                ...}\endmodality (post))
        \varcond(\isInStrictFp)
        \replacewith(
            {#loc := addDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeDoubleAssignment)
        \displayname "addition"
    };

    assignmentSubtractionDoubleStrictFP {
        \find(\modality{#normalassign}{..
                    #loc = #seDouble0 - #seDouble1;
                ...}\endmodality (post))
        \varcond(\isInStrictFp)
        \replacewith(
            {#loc := subDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeDoubleAssignment)
        \displayname "subtraction"
    };

    assignmentMultiplicationDoubleStrictFP {
        \find(\modality{#normalassign}{..
                    #loc = #seDouble0 * #seDouble1;
                ...}\endmodality (post))
        \varcond(\isInStrictFp)
        \replacewith(
            {#loc := mulDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeDoubleAssignment)
        \displayname "multiplication"
    };

    assignmentDivisionDoubleStrictFP {
        \find(\modality{#normalassign}{..
                    #loc = #seDouble0 / #seDouble1;
                ...}\endmodality (post))
        \varcond(\isInStrictFp)
        \replacewith(
            {#loc := divDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeDoubleAssignment)
        \displayname "division"
    };

    // ------------- Arithmetic operations without strictfp

    assignmentAdditionFloat {
        \find(\modality{#normalassign}{..
                    #loc=#seFloat0 + #seFloat1;
                ...}\endmodality (post))
        \varcond(\not \isInStrictFp)
        \replacewith(
            {#loc := javaAddFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "addition"
    };

    assignmentAdditionDouble {
        \find(\modality{#normalassign}{..
                    #loc=#seDouble0 + #seDouble1;
                ...}\endmodality (post))
        \varcond(\not \isInStrictFp)
        \replacewith(
            {#loc := javaAddDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "addition"
    };

    assignmentSubtractionFloat {
        \find(\modality{#normalassign}{..
                    #loc = #seFloat0 - #seFloat1;
                ...}\endmodality (post))
        \varcond(\not \isInStrictFp)
        \replacewith(
            {#loc := javaSubFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "subtraction"
    };

    assignmentSubtractionDouble {
        \find(\modality{#normalassign}{..
                    #loc = #seDouble0 - #seDouble1;
                ...}\endmodality (post))
        \varcond(\not \isInStrictFp)
        \replacewith(
            {#loc := javaSubDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "subtraction"
    };

    assignmentMultiplicationFloat {
        \find(\modality{#normalassign}{..
                    #loc = #seFloat0 * #seFloat1;
                ...}\endmodality (post))
        \varcond(\not \isInStrictFp)
        \replacewith(
            {#loc := javaMulFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "multiplication"
    };

    assignmentMultiplicationDouble {
        \find(\modality{#normalassign}{..
                    #loc = #seDouble0 * #seDouble1;
                ...}\endmodality (post))
        \varcond(\not \isInStrictFp)
        \replacewith(
            {#loc := javaMulDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "multiplication"
    };

    assignmentDivisionFloat {
        \find(\modality{#normalassign}{..
                    #loc = #seFloat0 / #seFloat1;
                ...}\endmodality (post))
        \varcond(\not \isInStrictFp)
        \replacewith(
            {#loc := javaDivFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "division"
    };

    assignmentDivisionDouble {
        \find(\modality{#normalassign}{..
                    #loc = #seDouble0 / #seDouble1;
                ...}\endmodality (post))
        \varcond(\not \isInStrictFp)
        \replacewith(
            {#loc := javaDivDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "division"
    };

    // modulo operations
    assignmentModFloat {
        \find(\modality{#normalassign}{..
                    #loc = #seFloat0 % #seFloat1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaModFloat(#seFloat0, #seFloat1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "mod"
    };

    assignmentModDouble {
        \find(\modality{#normalassign}{..
                    #loc = #seDouble0 % #seDouble1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaModDouble(#seDouble0, #seDouble1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "mod"
    };

    // Operations on combined float/int

    intLongToFloatAddition1 {
        \find(\modality{#normalassign}{..
                    #loc = #seLong + #seFloat;
                ...}\endmodality (post))
        \replacewith({#loc := javaAddFloat((float)#seLong, #seFloat)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "float addition"
    };

    // For int/short/char/byte, converting to float is the same as
    // converting to long first, then float
    intToFloatAddition {
        \find(\modality{#normalassign}{..
                    #loc = #seCharByteShortInt + #seFloat;
                ...}\endmodality (post))
        \replacewith({#loc := javaAddFloat((float)#seCharByteShortInt, #seFloat)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "float addition"
    };

    castLongToFloatAddition2 {
        \find(\modality{#normalassign}{..
                    #loc = #seFloat + #seLong;
                ...}\endmodality (post))
        \replacewith({#loc := javaAddFloat(#seFloat, (float)#seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "float addition"
    };

    // Typecasts


    // KeY integers are not bounded in size, but ints fit inside long
    wideningCastLongToFloat {
        \find(\modality{#normalassign}{..
                    #loc = (float) #seLong;
                ...}\endmodality (post))
        \replacewith({#loc := (float)#seLong}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "cast"
    };

    wideningCastIntToFloat {
        \find(\modality{#normalassign}{..
                    #loc = (float) #seCharByteShortInt;
                ...}\endmodality (post))
        \replacewith({#loc := (float)(#seCharByteShortInt)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "cast"
    };

    identityCastFloat {
        \find(\modality{#normalassign}{..
                    #loc = (float) #seFloat;
                ...}\endmodality (post))
        \replacewith(\modality{#normalassign}{..
                    #loc = #seFloat;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "identity cast"
    };

    identityCastDouble {
        \find(\modality{#normalassign}{..
                    #loc = (double) #seDouble;
                ...}\endmodality (post))
        \replacewith(\modality{#normalassign}{..
                    #loc = #seDouble;
                ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "identity cast"
    };

    narrowingCastFloatToInt {
        \find(\modality{#normalassign}{..
                    #loc = (int) #seFloat;
                ...}\endmodality (post))
        \replacewith({#loc := (long)(#seFloat)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "cast"
    };

    narrowingCastFloatToLong {
        \find(\modality{#normalassign}{..
                    #loc = (long) #seFloat;
                ...}\endmodality (post))
        \replacewith({#loc := (long)(#seFloat)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeFloatAssignment)
        \displayname "cast"
    };

    // Non-simple expressions

    compound_float_cast_expression {
        \find(\modality{#normalassign}{.. #loc = (float) #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#normalassign}{.. #typeof(#nse) #v = #nse; #loc = (float) #v;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "cast"
    };

    compound_double_cast_expression {
        \find(\modality{#normalassign}{.. #loc = (double) #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#normalassign}{.. #typeof(#nse) #v = #nse; #loc = (double) #v;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "cast"
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\sorts {

    fp;
    float \extends fp;
    double \extends fp;

    java.lang.Math \extends java.lang.Object;
}

\functions {
    // Float literals, represented as the integer with the
    // same binary representation as the fp literal in smt
    float FP(numbers);
    double DFP(numbers);

    // SINGLE PRECISION OPERATIONS

    // Arithmetic operations transformed differently depending on chosen semantics
    float javaUnaryMinusFloat(float);
    float javaAddFloat(float, float);
    float javaSubFloat(float, float);
    float javaMulFloat(float, float);
    float javaDivFloat(float, float);
    float javaModFloat(float, float);
    float javaMinFloat(float, float);
    float javaMaxFloat(float, float);

    // Operations indicating forbidden float values (e.g. NaN or overflow/underflow)
    float javaAddFloatForbiddenResult(float, float);
    float javaSubFloatForbiddenResult(float, float);
    float javaMulFloatForbiddenResult(float, float);
    float javaDivFloatForbiddenResult(float, float);

    // Floating-point arithmetic with IEEE 754 semantics
    float addFloat(float, float);
    float subFloat(float, float);
    float mulFloat(float, float);
    float divFloat(float, float);
    float negFloat(float);

    float absFloat(float);

    // DOUBLE PRECISION OPERATIONS

    // Arithmetic operations transformed differently depending on chosen semantics
    double javaUnaryMinusDouble(double);
    double javaAddDouble(double, double);
    double javaSubDouble(double, double);
    double javaMulDouble(double, double);
    double javaDivDouble(double, double);
    double javaModDouble(double, double);
    double javaMinDouble(double, double);
    double javaMaxDouble(double, double);

    // Operations indicating forbidden double values (e.g. NaN or overflow/underflow)
    double javaAddDoubleForbiddenResult(double, double);
    double javaSubDoubleForbiddenResult(double, double);
    double javaMulDoubleForbiddenResult(double, double);
    double javaDivDoubleForbiddenResult(double, double);

    // Double arithmetic with IEEE 754 semantics
    double addDouble(double, double);
    double subDouble(double, double);
    double mulDouble(double, double);
    double divDouble(double, double);
    double negDouble(double);

    double absDouble(double);

    // Mathematical representations of transcendental functions
    double sinDouble(double);
    double asinDouble(double);
    double cosDouble(double);
    double acosDouble(double);
    double tanDouble(double);
    double atan2Double(double, double);
    double sqrtDouble(double);
    double powDouble(double, double);
    double expDouble(double);
    double atanDouble(double);
}

\predicates
{
    ltFloat(float, float);
    gtFloat(float, float);
    leqFloat(float, float);
    geqFloat(float, float);
    eqFloat(float, float);

    floatIsNaN(float);
    floatIsZero(float);
    floatIsNormal(float);
    floatIsSubnormal(float);
    floatIsInfinite(float);
    floatIsPositive(float);
    floatIsNegative(float);
    floatIsNice(float);

    ltDouble(double, double);
    gtDouble(double, double);
    leqDouble(double, double);
    geqDouble(double, double);
    eqDouble(double, double);

    doubleIsNaN(double);
    doubleIsZero(double);
    doubleIsNormal(double);
    doubleIsSubnormal(double);
    doubleIsInfinite(double);
    doubleIsPositive(double);
    doubleIsNegative(double);
    doubleIsNice(double);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term float f1, f2;
    \term double d1, d2;
}

\rules(programRules:Java, floatRules:assumeStrictfp) {
    translateJavaUnaryMinusFloat {
        \find(javaUnaryMinusFloat(f1))
        \replacewith(negFloat(f1))
        \heuristics(javaFloatSemantics)
    };

    translateJavaAddFloat {
        \find(javaAddFloat(f1, f2))
        \replacewith(addFloat(f1, f2))
        \heuristics(javaFloatSemantics)
    };

    translateJavaSubFloat {
        \find(javaSubFloat(f1, f2))
        \replacewith(subFloat(f1, f2))
        \heuristics(javaFloatSemantics)
    };

    translateJavaMulFloat {
        \find(javaMulFloat(f1, f2))
        \replacewith(mulFloat(f1, f2))
        \heuristics(javaFloatSemantics)
    };

    translateJavaDivFloat {
        \find(javaDivFloat(f1, f2))
        \replacewith(divFloat(f1, f2))
        \heuristics(javaFloatSemantics)
    };

    translateJavaUnaryMinusDouble {
        \find(javaUnaryMinusDouble(d1))
        \replacewith(negDouble(d1))
        \heuristics(javaFloatSemantics)
    };

    translateJavaAddDouble {
        \find(javaAddDouble(d1, d2))
        \replacewith(addDouble(d1, d2))
        \heuristics(javaFloatSemantics)
    };

    translateJavaSubDouble {
        \find(javaSubDouble(d1, d2))
        \replacewith(subDouble(d1, d2))
        \heuristics(javaFloatSemantics)
    };

    translateJavaMulDouble {
        \find(javaMulDouble(d1, d2))
        \replacewith(mulDouble(d1, d2))
        \heuristics(javaFloatSemantics)
    };

    translateJavaDivDouble {
        \find(javaDivDouble(d1, d2))
        \replacewith(divDouble(d1, d2))
        \heuristics(javaFloatSemantics)
    };

    doubleSin {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.sin(#se); ...}\endmodality (post))
        \replacewith({#loc := sinDouble(#se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doubleCos {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.cos(#se); ...}\endmodality (post))
        \replacewith({#loc := cosDouble(#se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doubleAcos {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.acos(#se); ...}\endmodality (post))
        \replacewith({#loc := acosDouble(#se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doubleAsin {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.asin(#se); ...}\endmodality (post))
        \replacewith({#loc := asinDouble(#se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doubleTan {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.tan(#se); ...}\endmodality (post))
        \replacewith({#loc := tanDouble(#se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doubleAtan2 {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se1;
        \schemaVar \program SimpleExpression #se2;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.atan2(#se1, #se2); ...}\endmodality (post))
        \replacewith({#loc := atan2Double(#se1, #se2)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doubleSqrt {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.sqrt(#se); ...}\endmodality (post))
        \replacewith({#loc := sqrtDouble(#se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doublePow {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se1;
        \schemaVar \program SimpleExpression #se2;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.pow(#se1, #se2); ...}\endmodality (post))
        \replacewith({#loc := powDouble(#se1, #se2)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doubleExp {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.exp(#se); ...}\endmodality (post))
        \replacewith({#loc := expDouble(#se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    doubleAtan {
        \schemaVar \program Variable #loc;
        \schemaVar \program SimpleExpression #se;
        \schemaVar \formula post;
        \schemaVar \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
        \find(\modality{#allmodal}{.. #loc = java.lang.Math.atan(#se); ...}\endmodality (post))
        \replacewith({#loc := atanDouble(#se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term float left, right;
}

\rules {

    // primary
    // If the argument is NaN or an infinity, then the result is NaN.
    sinIsNaN {
        \schemaVar \term double arg;
        \find(sinDouble(arg))
        \add(doubleIsNaN(arg) | doubleIsInfinite(arg) -> doubleIsNaN(sinDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is zero, then the result is a zero with the same sign as the argument.
    sineIsZero {
        \schemaVar \term double arg;
        \find(sinDouble(arg))
        \add(arg = 0.0d -> sinDouble(arg) = 0.0d ==>)
        \heuristics(userTaclets1)
    };

    sineRange {
        \schemaVar \term double arg;
        \find(sinDouble(arg))
        \add(sinDouble(arg) >= -1.0d & sinDouble(arg) <= 1.0d | doubleIsNaN(sinDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    sineIsNaNAlt {
        \schemaVar \term double arg;
        \find(doubleIsNaN(sinDouble(arg)))
        \replacewith(doubleIsNaN(arg) | doubleIsInfinite(arg))
        \heuristics(simplify)
    };

    sineRangeAlt {
        \schemaVar \term double arg;
        \find( ==> doubleIsNaN(sinDouble(arg)))
        \add(sinDouble(arg) >= -1.0d & sinDouble(arg) <= 1.0d ==>)
        \heuristics(userTaclets1)
    };

    // lemma
    sinIsNotNaN {
        \schemaVar \term double arg;
        \find(sinDouble(arg))
        \add(!doubleIsNaN(arg) & !doubleIsInfinite(arg) -> !doubleIsNaN(sinDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // lemma
    sinRange2 {
        \schemaVar \term double arg;
        \find(sinDouble(arg))
        \add(!doubleIsNaN(arg) & !doubleIsInfinite(arg) -> sinDouble(arg) >= -1.0d & sinDouble(arg) <= 1.0d ==>)
        \heuristics(userTaclets1)
    };

    // lemma
    sinRange3 {
        \schemaVar \term double arg;
        \find(sinDouble(arg))
        \add(!doubleIsNaN(arg) & !doubleIsInfinite(arg) -> mulDouble(sinDouble(arg), sinDouble(arg)) >= 0.0d &
            mulDouble(sinDouble(arg), sinDouble(arg)) <= 1.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is NaN or an infinity, then the result is NaN.
    cosIsNaN {
        \schemaVar \term double arg;
        \find(cosDouble(arg))
        \add(doubleIsNaN(arg) | doubleIsInfinite(arg) -> doubleIsNaN(cosDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    cosRange {
        \schemaVar \term double arg;
        \find(cosDouble(arg))
        \add(cosDouble(arg) >= 0.0d & cosDouble(arg) <= 1.0d | doubleIsNaN(cosDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    cosIsNaNAlt {
        \schemaVar \term double arg;
        \find(doubleIsNaN(cosDouble(arg)))
        \replacewith(doubleIsNaN(arg) | doubleIsInfinite(arg))
        \heuristics(simplify)
    };

    cosRangeAlt {
        \schemaVar \term double arg;
        \find( ==> doubleIsNaN(cosDouble(arg)))
        \add(cosDouble(arg) >= 0.0d & cosDouble(arg) <= 1.0d ==>)
        \heuristics(userTaclets1)
    };

    // lemma
    cosIsNotNaN {
        \schemaVar \term double arg;
        \find(cosDouble(arg))
        \add(!doubleIsNaN(arg) & !doubleIsInfinite(arg) -> !doubleIsNaN(cosDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // lemma
    cosRange2 {
        \schemaVar \term double arg;
        \find(cosDouble(arg))
        \add(!doubleIsNaN(arg) & !doubleIsInfinite(arg) -> cosDouble(arg) >= 0.0d & cosDouble(arg) <= 1.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is NaN or its absolute value is greater than 1, then the result is NaN.
    asinIsNaN {
        \schemaVar \term double arg;
        \find(asinDouble(arg))
        \add(doubleIsNaN(arg) | arg < -1.0d | arg > 1.0d -> doubleIsNaN(asinDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is zero, then the result is a zero with the same sign as the argument.
    asineIsZero {
        \schemaVar \term double arg;
        \find(asinDouble(arg))
        \add(arg = 0.0d -> asinDouble(arg) = 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is between -1 and 1 then the returned angle is in the range -pi/2 through pi/2
    asineRange {
        \schemaVar \term double arg;
        \find(asinDouble(arg))
        \add(arg >= -1.0d & arg <= 1.0d -> asinDouble(arg) >= -1.5707963267948966d & asinDouble(arg) <= 1.5707963267948966d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is NaN or its absolute value is greater than 1, then the result is NaN
    acosIsNaN {
        \schemaVar \term double arg;
        \find(acosDouble(arg))
        \add(doubleIsNaN(arg) | arg < -1.0d | arg > 1.0d -> doubleIsNaN(acosDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is between -1 and 1 then the returned angle is in the range 0.0 through pi
    acosRange {
        \schemaVar \term double arg;
        \find(acosDouble(arg))
        \add(arg >= -1.0d & arg <= 1.0d -> acosDouble(arg) >= 0.0d & acosDouble(arg) <= 3.14159265358979323846d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is NaN or an infinity, then the result is NaN
    tanIsNaN {
        \schemaVar \term double arg;
        \find(tanDouble(arg))
        \add(doubleIsNaN(arg) | doubleIsInfinite(arg) -> doubleIsNaN(tanDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is zero, then the result is a zero with the same sign as the argument.
    tanIsZero {
        \schemaVar \term double arg;
        \find(tanDouble(arg))
        \add(arg = 0.0d -> tanDouble(arg) = 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If either argument is NaN, then the result is NaN
    atan2IsNaN {
        \schemaVar \term double arg1, arg2;
        \find(atan2Double(arg1, arg2))
        \add(doubleIsNaN(arg1) | doubleIsNaN(arg2) -> doubleIsNaN(atan2Double(arg1, arg2)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If neither argument is NaN, then the returned angle is in the range of -pi through pi
    atan2Range {
        \schemaVar \term double arg1, arg2;
        \find(atan2Double(arg1, arg2))
        \add(!doubleIsNaN(arg1) & !doubleIsNaN(arg2) -> atan2Double(arg1, arg2) >= -3.14159265358979323846d & atan2Double(arg1, arg2) <= 3.14159265358979323846d ==>)
    };

    // primary
    // If the argument is NaN or less than zero, then the result is NaN
    sqrtIsNaN {
        \schemaVar \term double arg;
        \find(sqrtDouble(arg))
        \add(doubleIsNaN(arg) | arg < 0.0d -> doubleIsNaN(sqrtDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is positive infinity, then the result is positive infinity.
    sqrtIsInfinite {
        \schemaVar \term double arg;
        \find(sqrtDouble(arg))
        \add(doubleIsInfinite(arg) & arg > 0.0d -> doubleIsInfinite(sqrtDouble(arg)) & sqrtDouble(arg) > 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is positive zero or negative zero, then the result is the same as the argument.
    sqrtIsZero {
        \schemaVar \term double arg;
        \find(sqrtDouble(arg))
        \add(arg = 0.0d -> sqrtDouble(arg) = 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // proved by SMT solver
    // If the argument is not NaN and greater or equal to zero, then the result is not NaN
    sqrtIsNotNaN {
        \schemaVar \term double arg;
        \find(sqrtDouble(arg))
        \add(!doubleIsNaN(arg) & arg >= 0.0d -> !doubleIsNaN(sqrtDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    sqrtIsSmaller {
        \schemaVar \term double arg;
        \find(sqrtDouble(arg))
        \add(!doubleIsInfinite(arg) & arg > 1.0d -> sqrtDouble(arg) < arg ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the second argument is positive or negative zero, then the result is 1.0.
    powIsOne {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add(arg2 = 0.0d -> powDouble(arg1, arg2) = 1.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the second argument is 1.0 and the first argument is not a NaN, then the result is the same as the first argument.
    powIsNotNaN {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add(!doubleIsNaN(arg1) & arg2 = 1.0d -> powDouble(arg1, arg2) = arg1 ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the second argument is NaN, then the result is NaN.
    powIsNaN1 {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add(doubleIsNaN(arg2) -> doubleIsNaN(powDouble(arg1, arg2)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the first argument is NaN and the second argument is nonzero, then the result is NaN.
    powIsNaN2 {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add(doubleIsNaN(arg1) & arg2 != 0.0d -> doubleIsNaN(powDouble(arg1, arg2)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the absolute value of the first argument is greater than 1 and the second argument is positive infinity, or
    // the absolute value of the first argument is less than 1 and the second argument is negative infinity,
    // then the result is positive infinity.
    powIsInfinite1 {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add(((arg1 >= 1.0d | arg1 <= -1.0d) & doubleIsInfinite(arg2) & arg2 > 0.0d) |
            (arg1 < 1.0d & arg1 > -1.0d & doubleIsInfinite(arg2) & arg2 < 0.0d)
            -> doubleIsInfinite(powDouble(arg1, arg2)) & powDouble(arg1, arg2) > 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the absolute value of the first argument is greater than 1 and the second argument is negative infinity, or
    // the absolute value of the first argument is less than 1 and the second argument is positive infinity,
    // then the result is positive zero.
    powIsZero1 {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add(((arg1 >= 1.0d | arg1 <= -1.0d) & doubleIsInfinite(arg2) & arg2 < 0.0d) |
            (arg1 < 1.0d & arg1 > -1.0d & doubleIsInfinite(arg2) & arg2 > 0.0d)
            -> powDouble(arg1, arg2) = 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN.
    powIsNaN3 {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add((arg1 >= 1.0d | arg1 <= -1.0d) & doubleIsInfinite(arg2) -> doubleIsNaN(powDouble(arg1, arg2)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // the first argument is positive zero and the second argument is greater than zero, or
    // the first argument is positive infinity and the second argument is less than zero,
    // then the result is positive zero.
    powIsZero2 {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add((eqDouble(arg1, 0.0d) & arg2 > 0.0d) | (doubleIsInfinite(arg1) & arg1 > 0.0d & arg2 < 0.0d)
            -> powDouble(arg1, arg2) = 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // the first argument is positive zero and the second argument is less than zero, or
    // the first argument is positive infinity and the second argument is greater than zero,
    // then the result is positive infinity.
    powIsInfinite2 {
        \schemaVar \term double arg1, arg2;
        \find(powDouble(arg1, arg2))
        \add((eqDouble(arg1, 0.0d) & arg2 < 0.0d) | (doubleIsInfinite(arg1) & arg1 > 0.0d & arg2 > 0.0d)
            -> doubleIsInfinite(powDouble(arg1, arg2)) & powDouble(arg1, arg2) > 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is NaN, the result is NaN.
    expIsNaN {
        \schemaVar \term double arg;
        \find(expDouble(arg))
        \add(doubleIsNaN(arg) -> doubleIsNaN(expDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is positive infinity, then the result is positive infinity.
    expIsInfinite {
        \schemaVar \term double arg;
        \find(expDouble(arg))
        \add(doubleIsInfinite(arg) & arg > 0.0d -> doubleIsInfinite(expDouble(arg)) & expDouble(arg) > 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is negative infinity, then the result is positive zero.
    expIsZero {
        \schemaVar \term double arg;
        \find(expDouble(arg))
        \add(doubleIsInfinite(arg) & arg < 0.0d -> expDouble(arg) = 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is NaN, the result is NaN.
    atanIsNaN {
        \schemaVar \term double arg;
        \find(atanDouble(arg))
        \add(doubleIsNaN(arg) -> doubleIsNaN(atanDouble(arg)) ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is zero, then the result is a zero with the same sign as the argument.
    atanIsZero {
        \schemaVar \term double arg;
        \find(atanDouble(arg))
        \add(arg = 0.0d -> atanDouble(arg) = 0.0d ==>)
        \heuristics(userTaclets1)
    };

    // primary
    // If the argument is not NaN,  the returned angle is in the range -pi/2 through pi/2
    atanRange {
        \schemaVar \term double arg;
        \find(atanDouble(arg))
        \add(!doubleIsNaN(arg) -> atanDouble(arg) >= -1.5707963267948966d & atanDouble(arg) <= 1.5707963267948966d ==>)
        \heuristics(userTaclets1)
    };

    // rules for "niceness" syntactic sugar
    niceFloat {
        \schemaVar \term float arg;
        \find(floatIsNice(arg))
        \replacewith(!floatIsNaN(arg) & !floatIsInfinite(arg))
        \heuristics(simplify)
    };

    niceDouble {
        \schemaVar \term double arg;
        \find(doubleIsNice(arg))
        \replacewith(!doubleIsNaN(arg) & !doubleIsInfinite(arg))
        \heuristics(simplify)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term double d1, d2;
    \term float f1, f2;
}

\rules {

    precOfFloat {
        \find(prec(f1, f2))
        \replacewith(f1 < f2)
        \heuristics(simplify)
    };

    precOfDouble {
        \find(prec(d1, d2))
        \replacewith(d1 < d2)
        \heuristics(simplify)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/*

\schemaVariables {
  \term float f1, f2;
}


\rules(programRules:Java, floatRules:verifyResultsAreNormal){

  translateJavaAddFloat {
     \find(javaAddFloat(f1, f2))
     \replacewith(\if (floatIsNormal(addFloat(f1, f2)))
                  \then (addFloat(f1, f2))
                  \else (javaAddFloatForbiddenResult(f1, f2)))
     \heuristics(javaFloatSemantics)
     \displayname "translateJavaAddFP"
  };

  translateJavaSubFloat {
     \find(javaSubFloat(f1, f2))
     \replacewith(\if (floatIsNormal(subFloat(f1, f2)))
                  \then (subFloat(f1, f2))
                  \else (javaSubFloatForbiddenResult(f1, f2)))
     \heuristics(javaFloatSemantics)
     \displayname "translateJavaSubFP"
  };

  translateJavaMulFloat {
     \find(javaMulFloat(f1, f2))
     \replacewith(\if (floatIsNormal(mulFloat(f1, f2)))
                  \then (mulFloat(f1, f2))
                  \else (javaMulFloatForbiddenResult(f1, f2)))
     \heuristics(javaFloatSemantics)
     \displayname "translateJavaMulFP"
  };

  translateJavaDivFloat {
     \find(javaDivFloat(f1, f2))
     \replacewith(\if (floatIsNormal(divFloat(f1, f2)))
                  \then (divFloat(f1, f2))
                  \else (javaDivFloatForbiddenResult(f1, f2)))
     \heuristics(javaFloatSemantics)
     \displayname "translateJavaDivFP"
  };

}
*/
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
    \formula post;
    \program Statement #s;
    \program LoopInit #loopInit;
    \program Guard #guard;
    \program ForUpdates #forupdates;
}

\rules(programRules:Java) {
    forInitUnfold {
        \find(\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality (post))
        \replacewith
        (\modality{#allmodal}{..
                    {
                    #forInitUnfoldTransformer(#loopInit);
                    for(; #guard; #forupdates) #s
                    }
                ...}\endmodality (post))
        \heuristics(loop_expand)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// These schema variables are used to write the following rules.
// They will not be visible in later runs of the parser, so you are
// fairly free in choosing their names.

\sorts {
    \generic G;
    \generic H;
    \generic I;
    \generic subG \extends G;
    \generic NonSingleton \oneof {int, boolean};
}

\schemaVariables {
    \formula phi, psi, eta;
    \formula commLeft, commRight, commResidue;
    \formula assoc0, assoc1, assoc2;
    \formula distLeft, distRight0, distRight1;
    \formula b, c, d;

    \formula varFreeFirstLeft, varFreeFirstRight;
    \formula cnfOrder1, cnfOrder2, cnfOrder3;
    \formula pushDownCNFLeft, pushDownCNFRight;
    \formula pullOutCNFLeft, pullOutCNFRight;

    \variables G u, u2;
    \variables H v;
    \variables G Gvar;
    \term subG subGterm;
    \term H Hterm;

    \term G applyEqLeft;
    \term H applyEqRight;
    \term I applyEqOther;
    \term G else, then;
    \term H t;

    \variables NonSingleton nonSingleVar;
    \term int intTerm, intTermLeft, intTermRight;
    \variables int INTVar;
}

\rules {

    // Propositional simplification

    eq_imp {
        \find(phi -> phi)
        \replacewith(true)
        \heuristics(concrete)
    };

    eq_and {
        \find(phi & phi)
        \replacewith(phi)
        \heuristics(concrete)
    };

    eq_and_2 {
        \find((psi & phi) & phi)
        \replacewith(psi & phi)
        \heuristics(concrete)
    };

    eq_or {
        \find(phi | phi)
        \replacewith(phi)
        \heuristics(concrete)
    };

    eq_or_2 {
        \find((psi | phi) | phi)
        \replacewith(psi | phi)
        \heuristics(concrete)
    };

    eq_eq {
        \find(phi <-> phi)
        \replacewith(true)
        \heuristics(concrete)
    };

    neq_and {
        \find(phi & (!phi))
        \replacewith(false)
        \heuristics(concrete)
    };

    neq_and_2 {
        \find((!phi) & phi)
        \replacewith(false)
        \heuristics(concrete)
    };

    neq_and_3 {
        \find((psi & phi) & (!phi))
        \replacewith(false)
        \heuristics(concrete)
    };

    neq_and_4 {
        \find((psi & (!phi)) & phi)
        \replacewith(false)
        \heuristics(concrete)
    };

    neq_or {
        \find(phi | (!phi))
        \replacewith(true)
        \heuristics(concrete)
    };

    neq_or_2 {
        \find((!phi) | phi)
        \replacewith(true)
        \heuristics(concrete)
    };

    neq_or_3 {
        \find((psi | phi) | (!phi))
        \replacewith(true)
        \heuristics(concrete)
    };

    neq_or_4 {
        \find((psi | (!phi)) | phi)
        \replacewith(true)
        \heuristics(concrete)
    };

    // Negation normal form
    // noninteractive
    nnf_ex2all {
        \find( ==> \exists u; phi)
        \replacewith(\forall u; (!phi) ==>)
        \heuristics(moveQuantToLeft, notHumanReadable)
    };

    nnf_imp2or {
        \find(phi -> psi)
        \replacewith((!phi) | psi)
        \heuristics(negationNormalForm, notHumanReadable)
    };

    nnf_notAll {
        \find(!(\forall u; phi))
        \replacewith(\exists u; (!phi))
        \heuristics(negationNormalForm, notHumanReadable)
    };

    nnf_notEx {
        \find(!(\exists u; phi))
        \replacewith(\forall u; (!phi))
        \heuristics(negationNormalForm, notHumanReadable)
    };

    nnf_notOr {
        \find(!(phi | psi))
        \replacewith((!phi) & (!psi))
        \heuristics(negationNormalForm, notHumanReadable)
    };

    nnf_notAnd {
        \find(!(phi & psi))
        \replacewith((!phi) | (!psi))
        \heuristics(negationNormalForm, notHumanReadable)
    };

    nnf_notEqv {
        \find(!(phi <-> psi))
        \replacewith(phi <-> !psi)
        \heuristics(negationNormalForm, notHumanReadable)
    };

    // Application of equations underneath quantifiers

    applyEq_and_gen0 {
        \find(applyEqLeft = applyEqOther
            & applyEqLeft = applyEqRight)
        \replacewith(applyEqRight = applyEqOther
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_gen1 {
        \find((b & applyEqLeft = applyEqOther)
            & applyEqLeft = applyEqRight)
        \replacewith((b & applyEqRight = applyEqOther)
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_gen2 {
        \find(applyEqLeft != applyEqOther
            & applyEqLeft = applyEqRight)
        \replacewith(applyEqRight != applyEqOther
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_gen3 {
        \find((b & applyEqLeft != applyEqOther)
            & applyEqLeft = applyEqRight)
        \replacewith((b & applyEqRight != applyEqOther)
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_gen0 {
        \find(applyEqLeft = applyEqOther
            | applyEqLeft != applyEqRight)
        \replacewith(applyEqRight = applyEqOther
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_gen1 {
        \find((b | applyEqLeft = applyEqOther)
            | applyEqLeft != applyEqRight)
        \replacewith((b | applyEqRight = applyEqOther)
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_gen2 {
        \find(applyEqLeft != applyEqOther
            | applyEqLeft != applyEqRight)
        \replacewith(applyEqRight != applyEqOther
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_gen3 {
        \find((b | applyEqLeft != applyEqOther)
            | applyEqLeft != applyEqRight)
        \replacewith((b | applyEqRight != applyEqOther)
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    // Putting things in CNF
    // noninteractive
    shift_paren_and {
        \find(assoc0 & (assoc1 & assoc2))
        \replacewith((assoc0 & assoc1) & assoc2)
        \heuristics(conjNormalForm, cnf_andAssoc)

    };

    shift_paren_or {
        \find(assoc0 | (assoc1 | assoc2))
        \replacewith((assoc0 | assoc1) | assoc2)
        \heuristics(conjNormalForm, cnf_orAssoc)

    };

    commute_and {
        \find(commLeft & commRight)
        \replacewith(commRight & commLeft)
        \heuristics(conjNormalForm, cnf_andComm)
    };

    commute_and_2 {
        \find((commResidue & commLeft) & commRight)
        \replacewith((commResidue & commRight) & commLeft)
        \heuristics(conjNormalForm, cnf_andComm)
    };

    commute_or {
        \find(commLeft | commRight)
        \replacewith(commRight | commLeft)
        \heuristics(conjNormalForm, cnf_orComm)
    };

    commute_or_2 {
        \find((commResidue | commLeft) | commRight)
        \replacewith((commResidue | commRight) | commLeft)
        \heuristics(conjNormalForm, cnf_orComm)
    };

    cnf_rightDist {
        \find(distLeft | (distRight0 & distRight1))
        \replacewith((distLeft | distRight0)
            & (distRight1 | distLeft))
        \heuristics(conjNormalForm, cnf_dist)
    };

    local_cut {
        \find(phi)
        \replacewith((!psi | phi) & (psi | phi))
    };

    cnf_eqv {
        \find(phi <-> psi)
        \replacewith((phi | !psi) & (!phi | psi))
        \heuristics(conjNormalForm, cnf_expandIfThenElse, notHumanReadable)

    };

    ifthenelse_to_or_left {
        \find(\if(phi) \then(then) \else(else) = t)
        \replacewith((!phi | then = t) & (phi | else = t))
        \heuristics(conjNormalForm, cnf_expandIfThenElse, notHumanReadable)
    };

    ifthenelse_to_or_left2 {
        \find(\if(phi) \then(then) \else(else) != t)
        \replacewith((!phi | then != t) & (phi | else != t))
        \heuristics(conjNormalForm, cnf_expandIfThenElse, notHumanReadable)
    };

    ifthenelse_to_or_right {
        \find(t = \if(phi) \then(then) \else(else))
        \replacewith((!phi | t = then) & (phi | t = else))
        \heuristics(conjNormalForm, cnf_expandIfThenElse, notHumanReadable)
    };

    ifthenelse_to_or_right2 {
        \find(t != \if(phi) \then(then) \else(else))
        \replacewith((!phi | t != then) & (phi | t != else))
        \heuristics(conjNormalForm, cnf_expandIfThenElse, notHumanReadable)
    };

    ifthenelse_to_or_for {
        \find(\if(phi) \then(b) \else(c))
        \replacewith((!phi | b) & (phi | c))
        \heuristics(conjNormalForm, cnf_expandIfThenElse, notHumanReadable)
    };

    ifthenelse_to_or_for2 {
        \find(!(\if(phi) \then(b) \else(c)))
        \replacewith((!phi | !b) & (phi | !c))
        \heuristics(conjNormalForm, cnf_expandIfThenElse, notHumanReadable)
    };

    // Eliminate quantifiers

    elim_forall0 {
        \find(\forall Gvar; (Gvar != subGterm))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith(false)
        \heuristics(elimQuantifier)
    };

    elim_forall1 {
        \find(\forall Gvar; (subGterm != Gvar))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith(false)
        \heuristics(elimQuantifier)
    };

    elim_forall2 {
        \find(\forall Gvar; (Gvar != Hterm))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_forall3 {
        \find(\forall Gvar; (Hterm != Gvar))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_forall4 {
        \find(\forall Gvar; (phi | Gvar != subGterm))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}phi)
        \heuristics(elimQuantifier)
    };

    elim_forall5 {
        \find(\forall Gvar; (phi | subGterm != Gvar))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}phi)
        \heuristics(elimQuantifier)
    };

    elim_forall6 {
        \find(\forall Gvar; (phi | Gvar != Hterm))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}phi)
            | G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_forall7 {
        \find(\forall Gvar; (phi | Hterm != Gvar))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}phi)
            | G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    // some shortcut rules that are not really necessary,
    // but that can make proofs much shorter
    elim_forall8 {
        \find(\forall Gvar; (Gvar = subGterm -> phi))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}phi)
        \heuristics(elimQuantifier)
    };

    elim_forall9 {
        \find(\forall Gvar; (subGterm = Gvar -> phi))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}phi)
        \heuristics(elimQuantifier)
    };

    elim_forall10 {
        \find(\forall Gvar; (Gvar = Hterm -> phi))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}phi)
            | G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_forall11 {
        \find(\forall Gvar; (Hterm = Gvar -> phi))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}phi)
            | G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_forall12 {
        \find(\forall Gvar; ((psi & Gvar = subGterm) -> phi))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}(psi -> phi))
        \heuristics(elimQuantifier)
    };

    elim_forall13 {
        \find(\forall Gvar; ((psi & subGterm = Gvar) -> phi))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}(psi -> phi))
        \heuristics(elimQuantifier)
    };

    elim_forall14 {
        \find(\forall Gvar; ((psi & Gvar = Hterm) -> phi))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}(psi -> phi))
            | G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_forall15 {
        \find(\forall Gvar; ((psi & Hterm = Gvar) -> phi))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}(psi -> phi))
            | G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_forall16 {
        \find(\forall Gvar; ((Gvar = subGterm & psi) -> phi))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}(psi -> phi))
        \heuristics(elimQuantifier)
    };

    elim_forall17 {
        \find(\forall Gvar; ((subGterm = Gvar & psi) -> phi))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}(psi -> phi))
        \heuristics(elimQuantifier)
    };

    elim_forall18 {
        \find(\forall Gvar; ((Gvar = Hterm & psi) -> phi))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}(psi -> phi))
            | G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_forall19 {
        \find(\forall Gvar; ((Hterm = Gvar & psi) -> phi))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}(psi -> phi))
            | G::instance(Hterm) = FALSE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_exists0 {
        \find(\exists Gvar; (Gvar = subGterm))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith(true)
        \heuristics(elimQuantifier)
    };

    elim_exists1 {
        \find(\exists Gvar; (subGterm = Gvar))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith(true)
        \heuristics(elimQuantifier)
    };

    elim_exists2 {
        \find(\exists Gvar; (Gvar = Hterm))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(G::instance(Hterm) = TRUE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_exists3 {
        \find(\exists Gvar; (Hterm = Gvar))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(G::instance(Hterm) = TRUE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_exists4 {
        \find(\exists Gvar; (phi & Gvar = subGterm))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}phi)
        \heuristics(elimQuantifier)
    };

    elim_exists5 {
        \find(\exists Gvar; (phi & subGterm = Gvar))
        \varcond(\notFreeIn(Gvar, subGterm))
        \replacewith({\subst Gvar; subGterm}phi)
        \heuristics(elimQuantifier)
    };

    elim_exists6 {
        \find(\exists Gvar; (phi & Gvar = Hterm))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}phi)
            & G::instance(Hterm) = TRUE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    elim_exists7 {
        \find(\exists Gvar; (phi & Hterm = Gvar))
        \varcond(\notFreeIn(Gvar, Hterm))
        \replacewith(({\subst Gvar; (G)Hterm}phi)
            & G::instance(Hterm) = TRUE)
        \heuristics(elimQuantifier, elimQuantifierWithCast)
    };

    // ---------------------------------------------------------------------------
    // ----- cases when quantifiers over non-singleton sorts can be removed ------
    // ---------------------------------------------------------------------------

    elim_forall_nonSingleton0 {
        \find(\forall nonSingleVar; (nonSingleVar = Hterm))
        \varcond(\notFreeIn(nonSingleVar, Hterm))
        \replacewith(false)
        \heuristics(elimQuantifier)
    };

    elim_forall_nonSingleton1 {
        \find(\forall nonSingleVar; (Hterm = nonSingleVar))
        \varcond(\notFreeIn(nonSingleVar, Hterm))
        \replacewith(false)
        \heuristics(elimQuantifier)
    };

    elim_forall_nonSingleton2 {
        \find(\forall INTVar; (INTVar >= intTerm))
        \varcond(\notFreeIn(INTVar, intTerm))
        \replacewith(false)
        \heuristics(elimQuantifier)
    };

    elim_forall_nonSingleton3 {
        \find(\forall INTVar; (INTVar <= intTerm))
        \varcond(\notFreeIn(INTVar, intTerm))
        \replacewith(false)
        \heuristics(elimQuantifier)
    };

    elim_forall_nonSingleton4 {
        \find(\forall INTVar; (intTerm >= INTVar))
        \varcond(\notFreeIn(INTVar, intTerm))
        \replacewith(false)
        \heuristics(elimQuantifier)
    };

    elim_forall_nonSingleton5 {
        \find(\forall INTVar; (intTerm <= INTVar))
        \varcond(\notFreeIn(INTVar, intTerm))
        \replacewith(false)
        \heuristics(elimQuantifier)
    };

    elim_exists_nonSingleton0 {
        \find(\exists nonSingleVar; (nonSingleVar != Hterm))
        \varcond(\notFreeIn(nonSingleVar, Hterm))
        \replacewith(true)
        \heuristics(elimQuantifier)
    };

    elim_exists_nonSingleton1 {
        \find(\exists nonSingleVar; (Hterm != nonSingleVar))
        \varcond(\notFreeIn(nonSingleVar, Hterm))
        \replacewith(true)
        \heuristics(elimQuantifier)
    };

    elim_exists_nonSingleton2 {
        \find(\exists INTVar; (INTVar >= intTerm))
        \varcond(\notFreeIn(INTVar, intTerm))
        \replacewith(true)
        \heuristics(elimQuantifier)
    };

    elim_exists_nonSingleton3 {
        \find(\exists INTVar; (INTVar <= intTerm))
        \varcond(\notFreeIn(INTVar, intTerm))
        \replacewith(true)
        \heuristics(elimQuantifier)
    };

    elim_exists_nonSingleton4 {
        \find(\exists INTVar; (intTerm >= INTVar))
        \varcond(\notFreeIn(INTVar, intTerm))
        \replacewith(true)
        \heuristics(elimQuantifier)
    };

    elim_exists_nonSingleton5 {
        \find(\exists INTVar; (intTerm <= INTVar))
        \varcond(\notFreeIn(INTVar, intTerm))
        \replacewith(true)
        \heuristics(elimQuantifier)
    };

    // quantifier elimination rules for sets

    // verified with KeY -- RB 12.10.2013
    elim_exists_sub_1 {
        \schemaVar \variables LocSet locVar;
        \schemaVar \term LocSet locSetTermLeft, locSetTermRight;

        \find(\exists locVar; (subset(locVar, locSetTermRight) & subset(locSetTermLeft, locVar)))
        \varcond(\notFreeIn(locVar, locSetTermLeft, locSetTermRight))
        \replacewith(subset(locSetTermLeft, locSetTermRight))
        \heuristics(elimQuantifier)
    };

    // verified with KeY -- RB 12.10.2013
    elim_exists_sub_1_or_phi {
        \schemaVar \variables LocSet locVar;
        \schemaVar \term LocSet locSetTermLeft, locSetTermRight;

        \find(\exists locVar; ((subset(locVar, locSetTermRight) & subset(locSetTermLeft, locVar)) | phi))
        \varcond(\notFreeIn(locVar, locSetTermLeft, locSetTermRight))
        \replacewith(subset(locSetTermLeft, locSetTermRight) | \exists locVar; phi)
        \heuristics(elimQuantifier)
    };

    // verified with KeY -- RB 12.10.2013
    elim_exists_sub_1_and_phi {
        \schemaVar \variables LocSet locVar;
        \schemaVar \term LocSet locSetTerm;

        \find(\exists locVar; (subset(locVar, locSetTerm) & subset(locSetTerm, locVar) & phi))
        \varcond(\notFreeIn(locVar, locSetTerm))
        \replacewith(\exists locVar; (locVar = locSetTerm & phi))
        \heuristics(elimQuantifier)
    };

    // verified with KeY -- RB 12.10.2013
    elim_forall_superOfAll {
        \schemaVar \variables LocSet locVar;
        \schemaVar \term LocSet locSetTerm;

        \find(\forall locVar; subset(locVar, locSetTerm))
        \varcond(\notFreeIn(locVar, locSetTerm))
        \replacewith(locSetTerm = allLocs)
        \heuristics(elimQuantifier)
    };

    // verified with KeY -- RB 12.10.2013
    elim_forall_subOfAll {
        \schemaVar \variables LocSet locVar;
        \schemaVar \term LocSet locSetTerm;

        \find(\forall locVar; subset(locSetTerm, locVar))
        \varcond(\notFreeIn(locVar, locSetTerm))
        \replacewith(locSetTerm = empty)
        \heuristics(elimQuantifier)
    };

    // verified with KeY -- RB 12.10.2013
    elim_forall_subOfAll_and_phi {
        \schemaVar \variables LocSet locVar;
        \schemaVar \term LocSet locSetTerm;

        \find(\forall locVar; (subset(locSetTerm, locVar) & phi))
        \varcond(\notFreeIn(locVar, locSetTerm))
        \replacewith(locSetTerm = empty & \forall locVar; phi)
        \heuristics(elimQuantifier)
    };

    // verified with KeY -- RB 12.10.2013
    elim_forall_superOfAll_and_phi {
        \schemaVar \variables LocSet locVar;
        \schemaVar \term LocSet locSetTerm;

        \find(\forall locVar; (subset(locVar, locSetTerm) & phi))
        \varcond(\notFreeIn(locVar, locSetTerm))
        \replacewith(locSetTerm = allLocs & \forall locVar; phi)
        \heuristics(elimQuantifier)
    };

    // verified with KeY -- RB 12.10.2013
    elim_forall_eqSet_imp_phi {
        \schemaVar \variables LocSet locVar;
        \schemaVar \term LocSet locSetTerm;

        \find(\forall locVar; ((subset(locVar, locSetTerm) & subset(locSetTerm, locVar)) -> phi))
        \varcond(\notFreeIn(locVar, locSetTerm))
        \replacewith(\forall locVar; (locSetTerm = locVar -> phi))
        \heuristics(elimQuantifier)
    };

    // quantifier elimination rules for orders

    elim_forall_leq {
        \find(\forall INTVar; (INTVar <= intTermLeft | INTVar >= intTermRight))
        \varcond(\notFreeIn(INTVar, intTermLeft, intTermRight))
        \replacewith(intTermRight <= intTermLeft + 1)
        \heuristics(elimQuantifier)
    };

    elim_exists_leq {
        \find(\exists INTVar; (INTVar <= intTermLeft & INTVar >= intTermRight))
        \varcond(\notFreeIn(INTVar, intTermLeft, intTermRight))
        \replacewith(intTermRight <= intTermLeft)
        \heuristics(elimQuantifier)
    };

    // Swap two quantifiers
    swapQuantifiersAll {
        \find(\forall u; \forall v; phi)
        \replacewith(\forall v; \forall u; phi)
        \heuristics(swapQuantifiers)
    };

    swapQuantifiersEx {
        \find(\exists u; \exists v; phi)
        \replacewith(\exists v; \exists u; phi)
        \heuristics(swapQuantifiers)
    };

    // Distribute quantifiers
    // noninteractive
    distr_forallAnd {
        \find(\forall u; (phi & psi))
        \replacewith((\forall u; phi) & (\forall u; psi))
        \heuristics(distrQuantifier, notHumanReadable)
    };

    distr_existsOr {
        \find(\exists u; (phi | psi))
        \replacewith((\exists u; phi) | (\exists u; psi))
        \heuristics(distrQuantifier, notHumanReadable)
    };

    distr_forallOr1 {
        \find(\forall u; (phi | psi))
        \varcond(\notFreeIn(u, psi))
        \replacewith((\forall u; phi) | psi)
        \heuristics(distrQuantifier, notHumanReadable)
    };

    distr_forallOr2 {
        \find(\forall u; (phi | psi))
        \varcond(\notFreeIn(u, phi))
        \replacewith(phi | (\forall u; psi))
        \heuristics(distrQuantifier, notHumanReadable)
    };

    distr_existsAnd1 {
        \find(\exists u; (phi & psi))
        \varcond(\notFreeIn(u, psi))
        \replacewith((\exists u; phi) & psi)
        \heuristics(distrQuantifier, notHumanReadable)
    };

    distr_existsAnd2 {
        \find(\exists u; (phi & psi))
        \varcond(\notFreeIn(u, phi))
        \replacewith(phi & (\exists u; psi))
        \heuristics(distrQuantifier, notHumanReadable)
    };

    // Pull out quantifiers

    all_pull_out0 {
        \find((\forall u; b) & c)
        \varcond(\notFreeIn(u, c))
        \replacewith(\forall u; (b & c))
        \heuristics(pullOutQuantifierAll)
    };

    all_pull_out1 {
        \find(c & (\forall u; b))
        \varcond(\notFreeIn(u, c))
        \replacewith(\forall u; (c & b))
        \heuristics(pullOutQuantifierAll)
    };

    all_pull_out2 {
        \find((\forall u; b) | c)
        \varcond(\notFreeIn(u, c))
        \replacewith(\forall u; (b | c))
        \heuristics(pullOutQuantifierAll)
    };

    all_pull_out3 {
        \find(c | (\forall u; b))
        \varcond(\notFreeIn(u, c))
        \replacewith(\forall u; (c | b))
        \heuristics(pullOutQuantifierAll)
    };

    all_pull_out4 {
        \find((\forall u; b) & (\forall u2; c))
        \varcond(\notFreeIn(u, c))
        \replacewith(\forall u; (b & {\subst u2; u}c))
        \heuristics(pullOutQuantifierAll, pullOutQuantifierUnifying)
    };

    ex_pull_out0 {
        \find((\exists u; b) & c)
        \varcond(\notFreeIn(u, c))
        \replacewith(\exists u; (b & c))
        \heuristics(pullOutQuantifierEx)
    };

    ex_pull_out1 {
        \find(c & (\exists u; b))
        \varcond(\notFreeIn(u, c))
        \replacewith(\exists u; (c & b))
        \heuristics(pullOutQuantifierEx)
    };

    ex_pull_out2 {
        \find((\exists u; b) | c)
        \varcond(\notFreeIn(u, c))
        \replacewith(\exists u; (b | c))
        \heuristics(pullOutQuantifierEx)
    };

    ex_pull_out3 {
        \find(c | (\exists u; b))
        \varcond(\notFreeIn(u, c))
        \replacewith(\exists u; (c | b))
        \heuristics(pullOutQuantifierEx)
    };

    ex_pull_out4 {
        \find((\exists u; b) | (\exists u2; c))
        \varcond(\notFreeIn(u, c))
        \replacewith(\exists u; (b | {\subst u2; u}c))
        \heuristics(pullOutQuantifierEx, pullOutQuantifierUnifying)
    };

    // proven with KeY (CS)
    ifEqualsNull {
        \schemaVar \term any x, y;

        \find(\if(phi) \then(x) \else(y) = null)
        \replacewith((phi & x = null) | (!phi & y = null))
        \heuristics(simplify)
    };

    // proven with KeY (CS)
    ifEqualsTRUE {
        \schemaVar \term any x, y;

        \find(\if(phi) \then(x) \else(y) = TRUE)
        \replacewith((phi & x = TRUE) | (!phi & y = TRUE))
        \heuristics(simplify)
    };

    // proven with KeY (CS)
    ifEqualsInteger {
        \schemaVar \term any x, y;
        \schemaVar \term numbers iz;

        \find(\if(phi) \then(x) \else(y) = Z(iz))
        \replacewith((phi & x = Z(iz)) | (!phi & y = Z(iz)))
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// -----------------------------------------------------------------------------
// This is the bare bone of the Free data type.
// It is used for 'quick and (not completely) dirty' addition of user-defined
// theories which can be given in the taclet language. The data type is built-in
// into KeY and can be accessed in JML as \free. It always contains at least one
// unique function 'atom', the neutral element. Otherwise, you can define your
// theory around it by adding functions, predicates, and rules. To conform with
// KeY's guidelines, please mark your rules as either axiomatic or lemma. In
// order to prove lemma rules in KeY, axiomatic rules need to syntactically
// appear before others in the file. Example theories can be found under
// $key_maindir/examples/theories. Copy one of these files to this location and
// run 'make copy' or 'ant copy' in $key_maindir/system.
//
// @author bruns
// -----------------------------------------------------------------------------

\sorts {Free;}

\functions {
    \unique Free atom;
}

// \rules {
//    Please add rules to another file and add this to standardRules.key using "\include"
// }
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules that are applicable for every sort (as they
// use \generic sorts).
// The format is the same as for problem files.

\sorts {
    \generic G, S1, S2, H;
    \generic GSub \extends G;

    \generic C;
    \generic CSub \extends C;
}

// These schema variables are used to write the following rules.
// They will not be visible in later runs of the parser, so you are
// fairly free in choosing their names.
\schemaVariables {
    \term G e, s, t, e0;
    \term H t1;
    \term S1 t2;
    \skolemTerm G sk;
    \formula b, c;
    \variables G u, e2;

    \term G commEqLeft;
    \term H commEqRight;

    \variables GSub r;

    \term [rigid] G sr;
    \term [rigid] H tr;

    \term G ref1, ref2;
    \term S1 ind1, ind2, target;
    \term S2 else, then;
    \term numbers iz, jz;

    \term int i;

}

\rules {

    firstOfPair {
        \find(first(pair(t, t1)))
        \replacewith(t)
        \heuristics(concrete)
    };

    secondOfPair {
        \find(second(pair(t, t1)))
        \replacewith(t1)
        \heuristics(concrete)
    };

    // --- instanceof rules

    instanceof_static_type {
        \schemaVar \term any a;
        \find(G::instance(a))
        \varcond(\sub(\typeof(a), G))
        \replacewith(TRUE)
        \displayname "instanceof static supertype"
        \heuristics(concrete, evaluate_instanceof)
    };

    instanceof_static_type_2 {
        \schemaVar \term any a, a2;
        \assumes(a2 = a ==>)
        \find(G::instance(a))
        \sameUpdateLevel
        \varcond(\sub(\typeof(a2), G))
        \replacewith(TRUE)
        \displayname "instanceof static supertype"
        \heuristics(concrete, evaluate_instanceof)
    };

    instanceof_not_compatible {
        \schemaVar \term any a;
        \find(G::instance(a) = TRUE)
        \varcond(\sub(Null, G), \disjointModuloNull(G, \typeof(a)))
        \replacewith(a = null)
        \displayname "instanceof disjoint type"
        \heuristics(concrete, evaluate_instanceof)
    };

    instanceof_not_compatible_2 {
        \schemaVar \term any a;
        \find(G::instance(a) = FALSE)
        \varcond(\sub(Null, G), \disjointModuloNull(G, \typeof(a)))
        \replacewith(!(a = null))
        \displayname "instanceof disjoint type"
        \heuristics(concrete, evaluate_instanceof)
    };

    instanceof_not_compatible_3 {
        \schemaVar \term any a;
        \find(G::instance(a) = TRUE)
        \varcond(\not \sub(Null, G), \disjointModuloNull(G, \typeof(a)))
        \replacewith(false)
        \displayname "instanceof disjoint type"
        \heuristics(concrete, evaluate_instanceof)
    };

    instanceof_not_compatible_4 {
        \schemaVar \term any a;
        \find(G::instance(a) = FALSE)
        \varcond(\not \sub(Null, G), \disjointModuloNull(G, \typeof(a)))
        \replacewith(true)
        \displayname "instanceof disjoint type"
        \heuristics(concrete, evaluate_instanceof)
    };

    // This is a typical case with two instanceof operators.
    // Without this rule, automated reasoning about disjoint types is bad.
    // See issue #1501. Rule added by MU 31/10/2014
    instanceof_not_compatible_5 {
        \schemaVar \term any a;
        \assumes(H::instance(a) = TRUE ==>)
        \find(G::instance(a) = TRUE)
        \varcond(\sub(Null, G), \disjointModuloNull(G, H))
        \replacewith(a = null)
        \displayname "instanceof disjoint type"
        \heuristics(concrete, evaluate_instanceof)
    };

    instanceof_known_dynamic_type {
        \schemaVar \term any a;
        \assumes(G::exactInstance(a) = TRUE ==>)
        \find(H::instance(a))
        \sameUpdateLevel
        \varcond(\sub(G, H))
        \replacewith(TRUE)
        \heuristics(simplify, evaluate_instanceof)
    };

    instanceof_known_dynamic_type_2 {
        \schemaVar \term any a;
        \assumes(G::exactInstance(a) = TRUE ==>)
        \find(H::instance(a))
        \sameUpdateLevel
        \varcond(\not \sub(G, H))
        \replacewith(FALSE)
        \heuristics(simplify, evaluate_instanceof)
    };

    exact_instance_known_dynamic_type {
        \schemaVar \term any a;
        \assumes(G::exactInstance(a) = TRUE ==>)
        \find(H::exactInstance(a))
        \sameUpdateLevel
        \varcond(\not \same(G, H))
        \replacewith(FALSE)
        \heuristics(simplify, evaluate_instanceof)
    };

    // --------------- rules for casts in the logic (for programs look e.g. in javaRules.key) ----------

    typeEq {
        \find(s = t1 ==>)
        \add(H::instance(s) = TRUE, G::instance(t1) = TRUE ==>)
        \displayname "typeEq"
    };

    typeEqDerived {
        \assumes(s = t1 ==>)
        \find(H::instance(s))
        \sameUpdateLevel
        \replacewith(TRUE)
        \heuristics(simplify, concrete)
        \displayname "typeEq"
    };

    typeEqDerived2 {
        \assumes(s = t1 ==>)
        \find(G::instance(t1))
        \sameUpdateLevel
        \replacewith(TRUE)
        \heuristics(simplify, concrete)
        \displayname "typeEq"
    };

    typeStatic {
        // is sameUpdateLevel neccessary? Don't think so as static type cannot be changed
        \find(s)
        \sameUpdateLevel
        \add(G::instance(s) = TRUE ==>)
    };

    castAdd {
        \schemaVar \term [strict] C strictCTerm2;

        \assumes(CSub::instance(strictCTerm2) = TRUE ==>)
        \find(strictCTerm2)
        \sameUpdateLevel
        \replacewith((CSub)strictCTerm2)
        // in confluence_restricted as if and find part must be disjoint
        // to be confluent
        \displayname "narrow type"
    };

    castAdd2 {
        \schemaVar \term C cs;
        \schemaVar \term G gt;

        \assumes(cs = gt ==>)
        \find(gt)
        \sameUpdateLevel
        \varcond(\strict \sub(C, G))
        \replacewith((C)gt)
        \displayname "castAdd"
    };

    castDel {
        \schemaVar \term C castedTerm;
        \find((C)castedTerm)
        \replacewith(castedTerm)
        \displayname "castDel"
        \heuristics(simplify, cast_deletion)
    };

    castDel2 {
        \schemaVar \term CSub cs;
        \schemaVar \term G gt;

        \assumes(cs = gt ==>)
        \find((C)gt)
        \sameUpdateLevel
        \replacewith(cs)
        \displayname "castDel"
    };

    castType {
        \assumes(H::instance((C)s) = TRUE ==>)
        \find(CSub::instance(s) = TRUE ==>)
        \replacewith(H::instance(s) = TRUE ==>)
        \heuristics(simplify)
        \displayname "castType"
    };

    castType2 {
        \assumes( ==> H::instance((C)s) = TRUE)
        \find(CSub::instance(s) = TRUE ==>)
        \replacewith( ==> H::instance(s) = TRUE)
        \heuristics(simplify)
        \displayname "castType"
    };

    closeType {
        \assumes( ==> G::instance(t1) = TRUE)
        \find(GSub::instance(t1) = TRUE ==>) \closegoal
        \displayname "closeType"
        \heuristics(closure)

    };

    closeTypeSwitched {
        \assumes(GSub::instance(t1) = TRUE ==>)
        \find( ==> G::instance(t1) = TRUE) \closegoal
        \displayname "closeType"
        \heuristics(closure)
    };

    ineffectiveCast {
        \assumes(H::instance(t) = TRUE ==>)
        \find((H)t)
        \sameUpdateLevel
        \add((H)t = t ==>)
        \heuristics(inReachableStateImplication)
    };

    // correctness has been proved by PHS 19.10.2016
    // needs previous taclet.
    // The usefulness of this taclet remains in doubt.
    // With the heuristics as given it might even
    // be harmful in certain situations.

    // castDel3{
    //    \schemaVar \term any st;
    //
    //    \assumes( H::instance(st) = TRUE ==> )
    //        \find ((H)st) \sameUpdateLevel
    //        \replacewith (st)
    //    \heuristics (simplify)
    //    \displayname "castDel3"
    // };

    // there was a completeness hole w/o this rule
    ineffectiveCast3 {
        \assumes(H::exactInstance(t) = TRUE ==>)
        \find((H)t)
        \sameUpdateLevel
        \add((H)t = t ==>)
        \heuristics(inReachableStateImplication)
    };

    ineffectiveCast2 {
        \schemaVar \term CSub cs;
        \schemaVar \term G gt;

        \assumes(cs = gt ==>)
        \find((C)gt)
        \sameUpdateLevel
        \add((C)gt = gt ==>)
        \heuristics(inReachableStateImplication)
    };

    // --------------------------------------------------------------------------
    // rules for disjointness of sorts
    // --------------------------------------------------------------------------


    sortsDisjointModuloNull {
        \schemaVar \term G x;
        \schemaVar \term H y;

        \find(x = y)
        \varcond(\strict \sub(Null, G), \strict \sub(Null, H), \disjointModuloNull(G, H))

        \replacewith(x = null & y = null)
        \heuristics(simplify)
    };

    sortsDisjoint1 {
        \schemaVar \term G x;
        \schemaVar \term H y;

        \find(x = y)
        \varcond(\not \sub(Null, G), \disjointModuloNull(G, H))

        \replacewith(false)
        \heuristics(concrete)
    };

    sortsDisjoint2 {
        \schemaVar \term G x;
        \schemaVar \term H y;

        \find(x = y)
        \varcond(\not \sub(Null, H), \disjointModuloNull(G, H))

        \replacewith(false)
        \heuristics(concrete)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains the DECLARATIONS for heaps
// To find the RULES for heaps, please visit heapRules.key

\sorts {
    Field;
    Heap;
    \generic alphaObj \extends Object;
}

\functions {
    // select/store
    alpha alpha::select(Heap, Object, Field);
    Heap store(Heap, Object, Field, any);
    Heap create(Heap, Object);
    Heap anon(Heap, LocSet, Heap);
    Heap memset(Heap, LocSet, any);

    // default value for a field
    alpha alpha::defaultValue;

    // reading from final attributes (corresponds to select for non-final fields)
    alpha alpha::final(Object, Field);

    // fields
    \unique Field arr(int);
    \unique Field java.lang.Object::<transient>;
    \unique Field java.lang.Object::<transactionConditionallyUpdated>;
    \unique Field java.lang.Object::<created>;
    \unique Field java.lang.Object::<initialized>;
    \unique Field alpha::<classPrepared>; // static
    \unique Field alpha::<classInitialized>; // static
    \unique Field alpha::<classInitializationInProgress>; // static
    \unique Field alpha::<classErroneous>; // static

    // array length
    int length(Object);

    // null
    Null null;
}

\predicates {
    wellFormed(Heap);
    arrayStoreValid(any, any);
    nonNull(Heap, Object, int);

    // can be used to formulate assignable proof obligations in JML assert statements (via \dl_ escapes)
    assignable(Heap, Heap, LocSet);
}

\programVariables {
    Heap heap, savedHeap, permissions;
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains the RULES for heaps
// To find the DECLARATIONS for heaps, please visit heapRules.key


\rules(programRules:Java) {

    /*! Unrolls the definition of the assignable predicate. */
    assignableDefinition {
        \schemaVar \term Heap heapOld;
        \schemaVar \term Heap heapNew;
        \schemaVar \term LocSet locs;

        \schemaVar \variables Field f;
        \schemaVar \variables java.lang.Object o;

        \find(assignable(heapNew, heapOld, locs))
        \varcond(\notFreeIn(o, locs, heapOld, heapNew),
                 \notFreeIn(f, locs, heapOld, heapNew))

        \replacewith(\forall f;
                       (\forall o;
                         (  elementOf(o, f, locs)
                          | !o = null
                          & !boolean::select(heapOld, o, java.lang.Object::<created>) = TRUE
                          | any::select(heapNew, o, f) = any::select(heapOld, o, f))))
        \heuristics(delayedExpansion)
    };

    // --------------------------------------------------------------------------
    // axioms for select/store (here for manual use only)
    // --------------------------------------------------------------------------

    selectOfStore {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term alpha x;

        \find(beta::select(store(h, o, f, x), o2, f2))

        \replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o2, f2)))
        \heuristics(semantics_blasting)
    };

    selectOfCreate {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;

        \find(beta::select(create(h, o), o2, f))

        (permissions:off) {
            \replacewith(\if(o = o2 & o != null & f = java.lang.Object::<created>)
                    \then((beta)TRUE)
                    \else(beta::select(h, o2, f)))
        };
        (permissions:on) {
            // Permissions are not initialised by Java code when objects are constructed
            // so it is necessary to know the default value for permissions on freshly created objects
            // (applies to all selectOfCreate rules)
            \replacewith(\if(o = o2 & o != null)
                    \then(\if(f = java.lang.Object::<created>) \then((beta)TRUE) \else(beta::defaultValue))
                    \else(beta::select(h, o2, f)))
        }
        \heuristics(semantics_blasting)
    };

    selectOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(beta::select(anon(h, s, h2), o, f))

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>
                | elementOf(o, f, freshLocs(h)))
                \then(beta::select(h2, o, f))
                \else(beta::select(h, o, f)))
        \heuristics(semantics_blasting)
    };

    selectOfMemset {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(beta::select(memset(h, s, x), o, f))

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o, f)))
        \heuristics(semantics_blasting)
    };

    // CS: This is an implicit axiom which follows from the rules
    // selectCreatedOfAnon and selectOfAnon. I made the axiom explicit in this
    // rule. The rule is proven correct within KeY using the rules
    // selectCreatedOfAnon and selectOfAnon on the cut-formula
    // \forall Heap h2;
    // ( boolean::select(anon(v_h_0, empty, h2), null, java.lang.Object::<created>) =
    //   boolean::select(anon(v_h_0, empty, h2), null, java.lang.Object::<created>)   ) .
    // See comment on selectCreatedOfAnon.
    nullCreated {
        \schemaVar \variables Heap h;

        \add((\forall h; boolean::select(h, null, java.lang.Object::<created>) = TRUE) |
            (\forall h; boolean::select(h, null, java.lang.Object::<created>) = FALSE) ==>)
    };

    // --------------------------------------------------------------------------
    // EQ versions of axioms for select/store (here for manual use only)
    // --------------------------------------------------------------------------

    // proven with KeY for beta = Object using selectOfStore (CS)
    selectOfStoreEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term alpha x;
        \schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(beta::select(EQ, o2, f2))
        \sameUpdateLevel

        \replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o2, f2)))
        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY for beta = Object using selectOfCreate (CS)
    selectOfCreateEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term Heap EQ;

        \assumes(create(h, o) = EQ ==>)
        \find(beta::select(EQ, o2, f))
        \sameUpdateLevel

        (permissions:off) {
            \replacewith(\if(o = o2 & o != null & f = java.lang.Object::<created>)
                    \then((beta)TRUE)
                    \else(beta::select(h, o2, f)))
        };
        (permissions:on) {
            \replacewith(\if(o = o2 & o != null)
                    \then(\if(f = java.lang.Object::<created>) \then((beta)TRUE) \else(beta::defaultValue))
                    \else(beta::select(h, o2, f)))
        }
        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY for beta = Object using selectOfAnon (CS)
    selectOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>
                | elementOf(o, f, freshLocs(h)))
                \then(beta::select(h2, o, f))
                \else(beta::select(h, o, f)))
        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY for beta = Object using selectOfMemset (CS)
    selectOfMemsetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap EQ;

        \assumes(memset(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f))
        \sameUpdateLevel

        \replacewith(\if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o, f)))
        \heuristics(simplify_heap_high_costs)
    };

    // --------------------------------------------------------------------------
    // Prevent exponetial term size explosion of select terms by introduction of
    // linear many equations.
    //
    // author: scheben
    //
    // When Daniel and I worked on a case study, we discovered
    // some serious performance issues with older KeY versions. One of the
    // problems was that the at this time current master had serious problems
    // with the simplification of select-terms. For instance, KeY was not able
    // to automatically find a proof for the method foo_2() in the following
    //  example within 20 minutes (using the contract of bar()):
    //
    // class AccessChain4 {
    //   AccessChain4 a;
    //   int x;
    //   int y;
    //
    //   //@ requires a != null && a.a != null && a.a.a != null && a.a.a.a != null;
    //   //@ requires a.a.a.a.x > 0;
    //   //@ ensures a.a.a.a.x > 0;
    //   void foo_2 () {
    //     a.a.a.a.x++; bar();
    //     a.a.a.a.x++; bar();
    //   }
    //
    //   //@ ensures true;
    //   //@ assignable y;
    //   void bar () {};
    // }
    //
    // This was caused by the inplace-simplification of select-terms. Starting
    // with a harmless select-term like  h2[h2[h2[h2[self.a].a].a].x]  we got
    // by the select-axioms in a first step (for instance)
    //
    //   \if ((h2[h2[h2[self.a].a].a], x) \in {(self, y)} & !x=<created> |
    //        (h2[h2[h2[self.a].a].a], x) \in freshLocs(store(h, self.a.a.a.a,
    // x, 1 + self.a.a.a.a.x)))
    //   \then (anon_h2[h2[h2[h2[self.a].a].a].x])
    //   \else (store(h, self.a.a.a.a, x, 1 +
    // self.a.a.a.a.x)[h2[h2[h2[self.a].a].a].x])
    //
    // Because the condition of the \if cannot be simplified easily in any case
    // (like in the case above), we got by recursive application of the
    // select-axioms a term whose size grows exponentially in the number of
    // nested selects. This on the other hand slowed KeY extremely down. The
    // problem appeared also in several other examples, for instance in the
    // following often used dynamic framing pattern:
    //
    // class DynamicGhost {
    //     int x;
    //     C c;
    //
    //     //@ public ghost \locset rep;
    //
    //     //@ public invariant \subset(\locset(rep), rep);
    //     //@ private invariant rep == this.*;
    //
    //     //@ private invariant \disjoint(rep, c.rep);
    //     //@ private invariant \invariant_for(c);
    //
    //     //@ normal_behavior
    //     //@ requires x > 0;
    //     //@ ensures x > 0;
    //
    //     void dynamicGhost_4 () {
    //         x++; c.helper();
    //         x++; c.helper();
    //         x++; c.helper();
    //         x++; c.helper();
    //     }
    //
    //     class C {
    //         int y;
    //
    //         //@ public ghost \locset rep;
    //         //@ public invariant \subset(\locset(rep), rep);
    //         //@ private invariant rep == this.*;
    //
    //         //@ accessible \inv: rep;
    //
    //         //@ normal_behavior
    //         //@ ensures \new_elems_fresh(rep);
    //         //@ assignable rep;
    //         public void helper() {}
    //     }
    // }
    //
    // The above method dynamicGhost_4() could not be proven by the old master
    // within 20 minutes.
    //
    // I addressed the problem by modifying the strategy such that a
    // select term is pulled out before it is simplified. This results in a set
    // of auxiliary-equations which are solved and applied backwards if the
    // result has been computed. After the backwards-application of the
    // auxiliary-equations, no longer needed equations are automatically
    // hidden, such that the sequent is not cluttered by auxiliary-equations.
    // With this strategy, the size of a sequent grows at most linearly with
    // the number of nested selects. Applied to the above examples, the
    // modified strategy can automatically find the proofs within 3 seconds.
    //
    // For testing the performance of KeY, Daniel and I created several test
    // series in the folder examples/performance-test/ which could also be
    // useful in the future.
    //
    // The main drawback of the new strategy that I see is that selects are
    // not simplified under quantifiers automatically any more (because here we
    // cannot do a pullout). However, in some cases it is indeed no good idea
    // to try to do so (because of the possibility of exponentially growing
    // terms).
    //
    // Additionally, the "look-and-feel" changed. I tried to implement
    // every step of the new strategy as transparent as possible for the user
    // (pullout, apply equality, simplify, apply equality reverse, hide
    // equality). However, on simple examples the inplace-simplification might
    // be better readable for humans. On complex examples on the other hand, I
    // think the pullout increases readability. Further one might get puzzled
    // that KeY now sometimes replaces a select term directly by its value.
    // That is because I store the value of each select term which has been
    // simplified once and insert that value directly if the select term occurs
    // again later on in the proof. First of all this increases performance
    // (why should we calculate the same value over and over again?) and
    // secondly I personally prefer to convince my self once that some select
    // term simplifies to a particular value and afterwards I don't want to see
    // the simplification again.
    //
    // --------------------------------------------------------------------------

    // this is a specialisation of the normal pull out rule which
    // matches only select-terms and introduces a skolem constant with a
    // particular label (which is used in the  strategy)
    pullOutSelect {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \skolemTerm beta selectSK;

        \find(beta::select(h, o, f))
        \sameUpdateLevel

        \replacewith(selectSK<<selectSK>>)
        \add(beta::select(h, o, f) = selectSK<<selectSK>> ==>)
        \heuristics(pull_out_select)
    };

    simplifySelectOfStore {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term alpha x;
        \schemaVar \term beta sk;

        \find(beta::select(store(h, o, f, x), o2, f2) = sk ==>)
        \inSequentState

        \replacewith(
            \if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o2, f2))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(store(h, o, f, x), o2, f2))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfStoreEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term alpha x;
        \schemaVar \term beta sk;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(beta::select(EQ, o2, f2) = sk ==>)
        \inSequentState

        \replacewith(
            \if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                \then((beta)x)
                \else(beta::select(h, o2, f2))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(EQ, o2, f2))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfCreate {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \find(beta::select(create(h, o), o2, f) = sk ==>)
        \inSequentState

        (permissions:off) {
            \replacewith(
                \if(o = o2 & o != null & f = java.lang.Object::<created>)
                    \then((beta)TRUE)
                    \else(beta::select(h, o2, f))
                = sk ==>)
            \addrules(
                replaceKnownSelect {
                    \find(beta::select(create(h, o), o2, f))
                    \inSequentState
                    \replacewith(sk)
                    \heuristics(concrete)
                })
        };
        (permissions:on) {
            \replacewith(
                \if(o = o2 & o != null)
                    \then(\if(f = java.lang.Object::<created>) \then((beta)TRUE) \else(beta::defaultValue))
                    \else(beta::select(h, o2, f))
                = sk ==>)
            \addrules(
                replaceKnownSelect {
                    \find(beta::select(create(h, o), o2, f))
                    \inSequentState
                    \replacewith(sk)
                    \heuristics(concrete)
                })
        }

        \heuristics(simplify_select)
    };

    simplifySelectOfCreateEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(create(h, o) = EQ ==>)
        \find(beta::select(EQ, o2, f) = sk ==>)
        \inSequentState

        (permissions:off) {
            \replacewith(
                \if(o = o2 & o != null & f = java.lang.Object::<created>)
                    \then((beta)TRUE)
                    \else(beta::select(h, o2, f))
                = sk ==>)
            \addrules(
                replaceKnownSelect {
                    \find(beta::select(EQ, o2, f))
                    \inSequentState
                    \replacewith(sk)
                    \heuristics(concrete)
                }
            )
        };
        (permissions:on) {
            \replacewith(
                \if(o = o2 & o != null)
                    \then(\if(f = java.lang.Object::<created>) \then((beta)TRUE) \else(beta::defaultValue))
                    \else(beta::select(h, o2, f))
                = sk ==>)
            \addrules(
                replaceKnownSelect {
                    \find(beta::select(EQ, o2, f))
                    \inSequentState
                    \replacewith(sk)
                    \heuristics(concrete)
                })
        }
        \heuristics(simplify_select)
    };

    simplifySelectOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \find(beta::select(anon(h, s, h2), o, f) = sk ==>)
        \inSequentState

        \replacewith(
            \if(elementOf(o, f, s) & f != java.lang.Object::<created>
                | elementOf(o, f, freshLocs(h)))
                \then(beta::select(h2, o, f))
                \else(beta::select(h, o, f))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(anon(h, s, h2), o, f))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfAnonEQ {
        \schemaVar \term Heap h, h2, EQ;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(beta::select(EQ, o, f) = sk ==>)
        \inSequentState

        \replacewith(
            \if(elementOf(o, f, s) & f != java.lang.Object::<created>
                | elementOf(o, f, freshLocs(h)))
                \then(beta::select(h2, o, f))
                \else(beta::select(h, o, f))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(EQ, o, f))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfMemset {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \find(beta::select(memset(h, s, x), o, f) = sk ==>)
        \inSequentState

        \replacewith(
            \if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                \then(x)
                \else(beta::select(h, o, f))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(memset(h, s, x), o, f))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    simplifySelectOfMemsetEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term LocSet s;
        \schemaVar \term any x;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta sk;

        \assumes(memset(h, s, x) = EQ ==>)
        \find(beta::select(EQ, o, f) = sk ==>)
        \inSequentState

        \replacewith(
            \if(elementOf(o, f, s) & f != java.lang.Object::<created>)
                \then(x)
                \else(beta::select(h, o, f))
            = sk ==>)

        \addrules(
            replaceKnownSelect {
                \find(beta::select(EQ, o, f))
                \inSequentState
                \replacewith(sk)
                \heuristics(concrete)
            })

        \heuristics(simplify_select)
    };

    // ---
    // Rules for hiding auxiliary equations
    // ---

    hideAuxiliaryEq {
        \schemaVar \term any result, auxiliarySK;

        \find(result = auxiliarySK ==>)
        \inSequentState
        \replacewith( ==>)
        \addrules(
            replaceKnownAuxiliaryConstant {
                \find(auxiliarySK)
                \inSequentState
                \replacewith(result) \heuristics(concrete)
            })
        \heuristics(hide_auxiliary_eq)
    };

    hideAuxiliaryEqConcrete {
        \schemaVar \term any auxiliarySK;

        \find(auxiliarySK = TRUE ==>)
        \inSequentState
        \replacewith( ==>)
        \addrules(
            replaceKnownAuxiliaryConstant {
                \find(auxiliarySK)
                \inSequentState
                \replacewith(TRUE) \heuristics(concrete)
            })
        \heuristics(hide_auxiliary_eq_const)
    };

    hideAuxiliaryEqConcrete2 {
        \schemaVar \term any auxiliarySK;

        \find( ==> auxiliarySK = TRUE)
        \inSequentState
        \replacewith( ==>)
        \addrules(
            replaceKnownAuxiliaryConstant {
                \find(auxiliarySK)
                \inSequentState
                \replacewith(FALSE) \heuristics(concrete)
            })
        \heuristics(hide_auxiliary_eq_const)
    };

}

\rules(programRules:Java) {

    // --------------------------------------------------------------------------
    // lemmata for some common cases
    // --------------------------------------------------------------------------

    dismissNonSelectedField {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, u;
        \schemaVar \term Field f1, f2;
        \schemaVar \term any x;

        \find(alpha::select(store(h, o, f1, x), u, f2))

        \varcond(\differentFields(f1, f2))

        \replacewith(alpha::select(h, u, f2))

        \heuristics(simplify)
    };

    dismissNonSelectedFieldEQ {
        \schemaVar \term Heap h, EQ;
        \schemaVar \term Object o, u;
        \schemaVar \term Field f1, f2;
        \schemaVar \term any x;

        \assumes(store(h, o, f1, x) = EQ ==>)
        \find(alpha::select(EQ, u, f2))
        \sameUpdateLevel
        \varcond(\differentFields(f1, f2))

        \replacewith(alpha::select(h, u, f2))

        \heuristics(simplify)
    };

    dropEffectlessStores {
        \schemaVar \term Heap h, result;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term any x;

        \find(store(h, o, f, x))
        \varcond(\dropEffectlessStores(h, o, f, x, result))

        \replacewith(result)

        \heuristics(concrete)
    };

    memsetEmpty {
        \schemaVar \term Heap h;
        \schemaVar \term any x;

        \find(memset(h, empty, x))

        \replacewith(h)

        \heuristics(concrete)
    };

    // CS: This taclet is not a lemma. It does not follow from the axiom
    // selectOfAnon. The term
    // boolean::select(anon(h, s, h2), null, java.lang.Object::<created>)
    // equals beta::select(h, null, java.lang.Object::<created>) by the
    // definition selectOfAnon and freshLocs. This taclet replaces
    // boolean::select(anon(h, s, h2), null, java.lang.Object::<created>)
    // by beta::select(h, null, java.lang.Object::<created>) |
    //    beta::select(h2, null, java.lang.Object::<created>)   .
    // As a consequence we have forall heaps h, h2
    // beta::select(h, null, java.lang.Object::<created>) <->
    // ( beta::select(h, null, java.lang.Object::<created>) |
    //   beta::select(h2, null, java.lang.Object::<created>)  )
    // which is equivalent to
    // beta::select(h2, null, java.lang.Object::<created>) ->
    // beta::select(h, null, java.lang.Object::<created>)      forall h, h2.
    // Hence we only consider interpretations where (the underspecified)
    // location (null, java.lang.Object::<created>) equals TRUE on all heaps
    // or where it equals FALSE on all heaps. Since we "only" overspecify the
    // the underspecified here and since an adoption of the rule
    // selectCreatedOfAnon would complicate the rule, I chose to make the above
    // observation explicit in the lemma nullCreated instead of changing the
    // rule selectCreatedOfAnon.
    selectCreatedOfAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;

        \find(boolean::select(anon(h, s, h2), o, java.lang.Object::<created>))

        \replacewith(\if(boolean::select(h, o, java.lang.Object::<created>) = TRUE)
                \then(TRUE)
                \else(boolean::select(h2, o, java.lang.Object::<created>)))

        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonAsFormula {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;

        \find(boolean::select(anon(h, s, h2), o, java.lang.Object::<created>) = TRUE)

        \replacewith(boolean::select(h, o, java.lang.Object::<created>) = TRUE |
            boolean::select(h2, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_ENLARGING)
    };

    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(boolean::select(EQ, o, java.lang.Object::<created>))
        \sameUpdateLevel

        \replacewith(\if(boolean::select(h, o, java.lang.Object::<created>) = TRUE)
                \then(TRUE)
                \else(boolean::select(h2, o, java.lang.Object::<created>)))

        \heuristics(simplify_heap_high_costs)
    };

    // proven with KeY using selectCreatedOfAnon (CS)
    selectCreatedOfAnonAsFormulaEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(boolean::select(EQ, o, java.lang.Object::<created>) = TRUE)
        \sameUpdateLevel

        \replacewith(boolean::select(h, o, java.lang.Object::<created>) = TRUE |
            boolean::select(h2, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_ENLARGING)
    };

    equalityToSelect {
        \schemaVar \term Heap h, h2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(h = h2)
        \varcond(\notFreeIn(ov, h, h2), \notFreeIn(fv, h, h2))

        \replacewith(\forall ov; \forall fv; (any::select(h, ov, fv) = any::select(h2, ov, fv)))

        \heuristics(semantics_blasting)

    };

    // --------------------------------------------------------------------------
    // axioms for using wellFormed
    // --------------------------------------------------------------------------

    onlyCreatedObjectsAreReferenced {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(wellFormed(h) ==>)
        \find(deltaObject::select(h, o, f))
        \sameUpdateLevel

        \add(deltaObject::select(h, o, f) = null
            | boolean::select(h,
                deltaObject::select(h, o, f),
                java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreReferencedFinal {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        // Without that created-check, it is not consistent.
        \assumes(wellFormed(h),
                 boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)
        \find(deltaObject::final(o, f))
        \sameUpdateLevel

        \add(deltaObject::final(o, f) = null
             | boolean::select(h,
                               deltaObject::final(o, f),
                               java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreInLocSets {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;

        \assumes(wellFormed(h) ==>)
        \find(elementOf(o2, f2, LocSet::select(h, o, f)) ==>)

        \add(o2 = null
            | boolean::select(h,
                o2,
                java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreInLocSetsFinal {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;

        \assumes(wellFormed(h) ==>)
        \find(elementOf(o2, f2, LocSet::final(o, f)) ==>)

        \add(o2 = null
             | boolean::select(h,
                               o2,
                               java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };


    onlyCreatedObjectsAreInLocSetsEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term LocSet EQ;

        \assumes(wellFormed(h), LocSet::select(h, o, f) = EQ ==>)
        \find(elementOf(o2, f2, EQ) ==>)

        \add(o2 = null
            | boolean::select(h,
                o2,
                java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreInLocSetsEQFinal {
        \schemaVar \term Heap h;
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;
        \schemaVar \term LocSet EQ;

        \assumes(wellFormed(h), LocSet::final(o, f) = EQ ==>)
        \find(elementOf(o2, f2, EQ) ==>)

        \add(o2 = null
             | boolean::select(h,
                               o2,
                               java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };




    arrayLengthNotNegative {
        \schemaVar \term Object o;

        \find(length(o))
        \sameUpdateLevel

        \add(length(o) >= 0 ==>)

        \heuristics(inReachableStateImplication)
    };

    /*
    enclosing_this_is_created {
        \assumes (obj.<created>@(java.lang.Object) = TRUE, wellFormed(heap) ==>)
        \find ( obj.#et )
        \sameUpdateLevel

        \add ((obj.#et).<created>@(java.lang.Object) = TRUE  ==> obj.#et=null)

        \heuristics(inReachableStateImplication)
    };
    */

    // --------------------------------------------------------------------------
    // axioms for proving wellFormed
    // --------------------------------------------------------------------------

    wellFormedStoreObject {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term deltaObject x;

        \find(wellFormed(store(h, o, f, x)))
        \succedentPolarity

        \varcond(\fieldType(f, alpha))

        \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE & alpha::instance(x) = TRUE))

        \heuristics(simplify_enlarging)
    };

    wellFormedStoreArray {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term int idx;
        \schemaVar \term deltaObject x;

        \find(wellFormed(store(h, o, arr(idx), x)))
        \succedentPolarity

        \varcond(\hasElementarySort(o, alpha))

        \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE & arrayStoreValid(o, x)))

        \heuristics(simplify_enlarging)
    };

    wellFormedStoreLocSet {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet x;

        \find(wellFormed(store(h, o, f, x)))
        \succedentPolarity

        \varcond(\fieldType(f, alpha), \sub(LocSet, alpha))

        \replacewith(wellFormed(h) & createdInHeap(x, h))

        \heuristics(simplify_enlarging)
    };

    wellFormedStorePrimitive {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta x;

        \find(wellFormed(store(h, o, f, x)))
        \succedentPolarity
        \varcond(
            \fieldType(f, alpha),
            \not \sub(beta, java.lang.Object),
            \not \sub(beta, LocSet),
            \sub(beta, alpha))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedStorePrimitiveArray {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term int idx;
        \schemaVar \term beta x;

        \find(wellFormed(store(h, o, arr(idx), x)))
        \succedentPolarity

        \varcond(
            \hasElementarySort(o, alpha),
            \not \sub(beta, java.lang.Object),
            \not \sub(beta, LocSet),
            \sub(beta, alpha))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedCreate {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;

        \find(wellFormed(create(h, o)))
        \succedentPolarity

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;

        \find(wellFormed(anon(h, s, h2)))
        \succedentPolarity

        \replacewith(wellFormed(h) & wellFormed(h2))

        \heuristics(concrete)
    };

    wellFormedMemsetArrayObject {
        \schemaVar \term Heap h;
        \schemaVar \term Object ar;
        \schemaVar \term int lo, up;
        \schemaVar \term deltaObject x;

        \find(wellFormed(memset(h, arrayRange(ar, lo, up), x)))
        \succedentPolarity

        \varcond(\hasElementarySort(ar, alpha))

        \replacewith(wellFormed(h) &
            (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE & arrayStoreValid(ar, x)))

        \heuristics(simplify_enlarging)
    };

    wellFormedMemsetArrayPrimitive {
        \schemaVar \term Heap h;
        \schemaVar \term Object ar;
        \schemaVar \term int lo, up;
        \schemaVar \term beta x;

        \find(wellFormed(memset(h, arrayRange(ar, lo, up), x)))
        \succedentPolarity

        \varcond(
            \hasElementarySort(ar, alpha),
            \not \sub(beta, java.lang.Object),
            \not \sub(beta, LocSet),
            \sub(beta, alpha))

        \replacewith(wellFormed(h))

        \heuristics(simplify_enlarging)
    };

    /*

    In the general case , memset can no longer maintain wellformedness :(

    For a heap h = memset(h2, s, x) to be wellFormed, it is necessary that all locations of h
    are correctly typed, particularly that each location in s is correctly typed.

    In pseudo-notation, the condition is something like this:

        forall (o, f) in s: fieldtype(f)::instance(x) = TRUE

    Since this can not be encoded currently, we uncommented these rules as well as their
    corresponding EQ versions below (see wellFormedMemsetObjectEQ).

    The two taclets wellFormedMemsetArrayObject/Primitive above work around this problem
    by restricting the location set to an arrayRange, in these special cases wellFormedness
    can be proven.

    wellFormedMemsetObject {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term deltaObject x;

        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity

    \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE))

        \heuristics(simplify_enlarging)
    };


    wellFormedMemsetLocSet {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s, x;

        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity

        \replacewith(wellFormed(h) & createdInHeap(x, h))

        \heuristics(simplify_enlarging)
    };


    wellFormedMemsetPrimitive {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term beta x;

        \find(wellFormed(memset(h, s, x)))
        \succedentPolarity
        \varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };
    */

    // --------------------------------------------------------------------------
    // EQ versions of taclets for proving wellFormed (these are lemmata)
    // --------------------------------------------------------------------------

    wellFormedStoreObjectEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term deltaObject x;
        \schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \varcond(\fieldType(f, alpha))

        \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE & alpha::instance(x) = TRUE))

        \heuristics(simplify_enlarging)
    };

    wellFormedStoreLocSetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet x;
        \schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \replacewith(wellFormed(h) & createdInHeap(x, h))

        \heuristics(simplify_enlarging)
    };

    wellFormedStorePrimitiveEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term beta x;
        \schemaVar \term Heap EQ;

        \assumes(store(h, o, f, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity
        \varcond(\not \sub(beta, java.lang.Object), \not \sub(beta, LocSet))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };

    wellFormedAnonEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, s, h2) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \replacewith(wellFormed(h) & wellFormed(h2))

        \heuristics(concrete)
    };

    /*

    In the general case , memset can no longer maintain wellformedness :(
    See comments above (wellFormedMemsetObject) for more details.

    wellFormedMemsetObjectEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term deltaObject x;
    \schemaVar \term Heap EQ;

    \assumes(memset(h, s, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

    \replacewith(wellFormed(h) & (x = null | boolean::select(h, x, java.lang.Object::<created>) = TRUE))

        \heuristics(simplify_enlarging)
    };


    wellFormedMemsetLocSetEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s, x;
    \schemaVar \term Heap EQ;

    \assumes(memset(h, s, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity

        \replacewith(wellFormed(h) & createdInHeap(x, h))

        \heuristics(simplify_enlarging)
    };


    wellFormedMemsetPrimitiveEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term beta x;
    \schemaVar \term Heap EQ;

    \assumes(memset(h, s, x) = EQ ==>)
        \find(wellFormed(EQ))
        \sameUpdateLevel
        \succedentPolarity
        \varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet))

        \replacewith(wellFormed(h))

        \heuristics(concrete)
    };
    */

    // --------------------------------------------------------------------------
    // axioms for observer symbols
    // --------------------------------------------------------------------------

    onlyCreatedObjectsAreObserved {
        \schemaVar \term Heap h;
        \schemaVar \term deltaObject obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(obs)
        \sameUpdateLevel
        \varcond(\isObserver(obs, h))

        \add(obs = null
            | boolean::select(h, obs, java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreObservedInLocSets {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(elementOf(o, f, obs) ==>)
        \varcond(\isObserver(obs, h))

        \add(o = null
            | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    onlyCreatedObjectsAreObservedInLocSetsEQ {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet obs, EQ;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(obs = EQ ==>)
        \find(elementOf(o, f, EQ) ==>)
        \varcond(\isObserver(obs, h))

        \add(o = null
            | boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)

        \heuristics(inReachableStateImplication)
    };

    // --------------------------------------------------------------------------
    // axioms based on definition of semantics for casts
    // --------------------------------------------------------------------------

    narrowSelectType {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(wellFormed(h) ==>)

        \find(beta::select(h, o, f))

        \varcond(\fieldType(f, alpha),
            \strict \sub(alpha, beta))

        \replacewith(alpha::select(h, o, f))

        \heuristics(simplify)
    };

    narrowTypeFinal {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(beta::final(o,f))

        \varcond(\fieldType(f, alpha),
                 \strict\sub(alpha, beta))

        \replacewith(alpha::final(o,f))

	\heuristics(simplify)
    };


    narrowSelectArrayType {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term int idx;

        \assumes(wellFormed(h) ==> o = null)

        \find(beta::select(h, o, arr(idx)))
        \sameUpdateLevel

        \varcond(\hasElementarySort(o, alpha),
            \strict \sub(alpha, beta))

        \replacewith(alpha::select(h, o, arr(idx)))

        \heuristics(simplify)
    };
    narrowFinalArrayType {
        \schemaVar \term Object o;
        \schemaVar \term int idx;

	\assumes( ==> o = null )

        \find(beta::final(o,arr(idx))) \sameUpdateLevel

        \varcond(\hasElementarySort(o, alpha),
                 \strict\sub(alpha, beta))

        \replacewith(alpha::final(o,arr(idx)))

	\heuristics(simplify)
    };


    // NB: This taclet axiomatises the cast of booleans
    // This is (proven to be) equivalent to the axiom
    // "\forall any x; ((boolean)x=TRUE ==> x=TRUE)"

    castTrueImpliesOriginalTrue {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(boolean::select(h, o, f) = TRUE ==>)
        \find( ==> any::select(h, o, f) = TRUE)

        \replacewith( ==> true)

        \heuristics(concrete)
    };
}

\rules(programRules:Java, JavaCard:on) {

    arrayLengthIsAShort {
        \schemaVar \term Object o;

        \find(length(o))
        \sameUpdateLevel

        \add(inShort(length(o)) ==>)

        \heuristics(inReachableStateImplication)
    };
}

\rules(programRules:Java, JavaCard:off) {

    arrayLengthIsAnInt {
        \schemaVar \term Object o;

        \find(length(o))
        \sameUpdateLevel

        \add(inInt(length(o)) ==>)

        \heuristics(inReachableStateImplication)
    };
}

\rules(programRules:Java) {

    observerDependencyEQ {
        \schemaVar \term any t1;
        \schemaVar \term any t2;

        \find(t1 = t2)
        \inSequentState
        \varcond(\sameObserver(t1, t2))

        \replacewith(true);
        \add( ==> #ObserverEquality(t1, t2))
    };

    observerDependencyEquiv {
        \schemaVar \formula t1;
        \schemaVar \formula t2;

        \find(t1 <-> t2)
        \inSequentState
        \varcond(\sameObserver(t1, t2))

        \replacewith(true);
        \add( ==> #ObserverEquality(t1, t2))
        \displayname "observerDependencyEQ"
    };

    observerDependency {
        \schemaVar \term any termWithLargeHeap;
        \schemaVar \term any termWithSmallHeap;

        \find(termWithLargeHeap)
        \inSequentState
        \varcond(\sameObserver(termWithLargeHeap, termWithSmallHeap))

        \replacewith(termWithSmallHeap);
        \add( ==> #ObserverEquality(termWithLargeHeap, termWithSmallHeap))
    };

    observerDependencyFormula {
        \schemaVar \formula termWithLargeHeap;
        \schemaVar \formula termWithSmallHeap;

        \find(termWithLargeHeap)
        \inSequentState
        \varcond(\sameObserver(termWithLargeHeap, termWithSmallHeap))

        \replacewith(termWithSmallHeap);
        \add( ==> #ObserverEquality(termWithLargeHeap, termWithSmallHeap))
        \displayname "observerDependency"
    };

    nonNull {
        \schemaVar \term Object o;
        \schemaVar \term Heap heapSV;
        \schemaVar \term int depth;
        \schemaVar \variables int i;
        \find(nonNull(heapSV, o, depth))
        \varcond(\isReferenceArray(o),
            \notFreeIn(i, o, heapSV, depth))
        \replacewith((
                o != null & (depth > 0 ->
                    \forall i; (0 <= i & i < length(o) ->
                        nonNull(heapSV, Object::select(heapSV, o, arr(i)), depth - 1))
                ))
        )
        \heuristics(simplify_enlarging)
    };

    nullIsNotNonNull {
        \schemaVar \term Object o;
        \schemaVar \term Heap heapSV;
        \schemaVar \term int depth;
        \find(nonNull(heapSV, null, depth))
        \replacewith(false)
        \heuristics(concrete)
    };

    nonNullZero {
        \schemaVar \term Object o;
        \schemaVar \term Heap heapSV;
        \find(nonNull(heapSV, o, 0))
        \replacewith(o != null)
        \heuristics(concrete)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules that are applicable for every sort (as they
// use \generic sorts).
// The format is the same as for problem files.

\sorts {
    \generic G, G2;
}

// These schema variables are used to write the following rules.
// They will not be visible in later runs of the parser, so you are
// fairly free in choosing their names.
\schemaVariables {
    \term G2 else, then;
    \formula phi, b, c;

    \variables int intVar;
    \skolemTerm int intSk;
    \term int t, intT1, intT2, intValue;
}

\predicates {
    // Note: ifEx is DEPRECATED and this predicate may be removed in the future.
    wellOrderLeqInt(int, int);
}

\rules {

    // ------------- handling the if-then-else-operator ----------------------

    ifthenelse_true {
        \find(\if(true) \then(then) \else(else))
        \replacewith(then)
        \heuristics(concrete)
    };

    ifthenelse_true_for {
        \find(\if(true) \then(b) \else(c))
        \replacewith(b)
        \heuristics(concrete)
        \displayname "ifthenelse_true"
    };

    ifthenelse_false {
        \find(\if(false) \then(then) \else(else))
        \replacewith(else)
        \heuristics(concrete)
    };

    ifthenelse_false_for {
        \find(\if(false) \then(b) \else(c))
        \replacewith(c)
        \heuristics(concrete)
        \displayname "ifthenelse_false"
    };

    ifthenelse_negated {
        \find(\if(!phi) \then(then) \else(else))
        \replacewith(\if(phi) \then(else) \else(then))
        \heuristics(simplify)
    };

    ifthenelse_negated_for {
        \find(\if(!phi) \then(b) \else(c))
        \replacewith(\if(phi) \then(c) \else(b))
        \heuristics(simplify)
        \displayname "ifthenelse_negated"
    };

    ifthenelse_same_branches {
        \find(\if(phi) \then(then) \else(then))
        \replacewith(then)
        \heuristics(concrete)
    };

    ifthenelse_same_branches_for {
        \find(\if(phi) \then(b) \else(b))
        \replacewith(b)
        \heuristics(concrete)
        \displayname "ifthenelse_same_branches"
    };

    ifthenelse_concrete {
        \find(\if(phi) \then(true) \else(false))
        \replacewith(phi)
        \heuristics(concrete)
    };

    ifthenelse_concrete2 {
        \find(\if(phi) \then(false) \else(true))
        \replacewith(!phi)
        \heuristics(concrete)
        \displayname "ifthenelse_concrete"
    };

    ifthenelse_concrete3 {
        \find(\if(phi) \then(then) \else(else) = then)
        \replacewith(phi | else = then)
        \heuristics(concrete)
        \displayname "ifthenelse_concrete"
    };

    ifthenelse_concrete4 {
        \find(\if(phi) \then(then) \else(else) = else)
        \replacewith(!phi | then = else)
        \heuristics(concrete)
        \displayname "ifthenelse_concrete"
    };

    ifthenelse_split {
        \find(\if(phi) \then(then) \else(else))
        \sameUpdateLevel
        "#phi TRUE":
            \replacewith(then) \add(phi ==>);
        "#phi FALSE":
            \replacewith(else) \add( ==> phi)
        \heuristics(split_cond)
    };

    ifthenelse_split_for {
        \find(\if(phi) \then(b) \else(c))
        \sameUpdateLevel
        "#phi TRUE":
            \replacewith(b) \add(phi ==>);
        "#phi FALSE":
            \replacewith(c) \add( ==> phi)
        \heuristics(split_cond)
        \displayname "ifthenelse_split"
    };

    // ------------- handling the ifEx-then-else-operator, 1 var ----------------------

    // Note: ifEx is DEPRECATED and may be removed in the future. 01/01/2014

    ifExthenelse1_false {
        \find(\ifEx intVar; (false)\then(then)\else(else))
        \replacewith(else)
        \heuristics(concrete)
    };

    ifExthenelse1_false_for {
        \find(\ifEx intVar; (false)\then(b)\else(c))
        \replacewith(c)
        \heuristics(concrete)
        \displayname "ifExthenelse1_false"
    };

    ifExthenelse1_eq {
        \find(\ifEx intVar; (intVar = t)\then(then)\else(else))
        \varcond(\notFreeIn(intVar, t))
        \replacewith({\subst intVar; t}then)
        \heuristics(concrete)
    };

    ifExthenelse1_eq_for {
        \find(\ifEx intVar; (intVar = t)\then(b)\else(c))
        \varcond(\notFreeIn(intVar, t))
        \replacewith({\subst intVar; t}b)
        \heuristics(concrete)
        \displayname "ifExthenelse1_eq"
    };

    ifExthenelse1_eq2 {
        \find(\ifEx intVar; (t = intVar)\then(then)\else(else))
        \varcond(\notFreeIn(intVar, t))
        \replacewith({\subst intVar; t}then)
        \heuristics(concrete)
        \displayname "ifExthenelse1_eq"
    };

    ifExthenelse1_eq2_for {
        \find(\ifEx intVar; (t = intVar)\then(b)\else(c))
        \varcond(\notFreeIn(intVar, t))
        \replacewith({\subst intVar; t}b)
        \heuristics(concrete)
        \displayname "ifExthenelse1_eq"
    };

    ifExthenelse1_eq_phi {
        \find(\ifEx intVar; (phi & intVar = t)\then(then)\else(else))
        \varcond(\notFreeIn(intVar, t))
        \replacewith(\if({\subst intVar; t}phi)
                \then({\subst intVar; t}then)
                \else(else))
        \heuristics(concrete)
    };

    ifExthenelse1_eq_for_phi {
        \find(\ifEx intVar; (phi & intVar = t)\then(b)\else(c))
        \varcond(\notFreeIn(intVar, t))
        \replacewith(\if({\subst intVar; t}phi)
                \then({\subst intVar; t}b)
                \else(c))
        \heuristics(concrete)
        \displayname "ifExthenelse1_eq"
    };

    ifExthenelse1_eq2_phi {
        \find(\ifEx intVar; (phi & t = intVar)\then(then)\else(else))
        \varcond(\notFreeIn(intVar, t))
        \replacewith(\if({\subst intVar; t}phi)
                \then({\subst intVar; t}then)
                \else(else))
        \heuristics(concrete)
        \displayname "ifExthenelse1_eq"
    };

    ifExthenelse1_eq2_for_phi {
        \find(\ifEx intVar; (phi & t = intVar)\then(b)\else(c))
        \varcond(\notFreeIn(intVar, t))
        \replacewith(\if({\subst intVar; t}phi)
                \then({\subst intVar; t}b)
                \else(c))
        \heuristics(concrete)
        \displayname "ifExthenelse1_eq"
    };

    ifExthenelse1_unused_var {
        \find(\ifEx intVar; (phi)\then(then)\else(else))
        \varcond(\notFreeIn(intVar, then))
        \replacewith(\if(\exists intVar; phi) \then(then) \else(else))
        \heuristics(simplify)
    };

    ifExthenelse1_unused_var_for {
        \find(\ifEx intVar; (phi)\then(b)\else(c))
        \varcond(\notFreeIn(intVar, b))
        \replacewith(\if(\exists intVar; phi) \then(b) \else(c))
        \heuristics(simplify)
        \displayname "ifExthenelse1_unused_var"
    };

    ifExthenelse1_split {
        \find(\ifEx intVar; (phi)\then(then)\else(else))
        \sameUpdateLevel
        \varcond(\newDependingOn(intSk, phi),
            \notFreeIn(intVar, intSk))
        \replacewith({\subst intVar; intSk}then)
        \add({\subst intVar; intSk}phi,
            \forall intVar; (phi -> wellOrderLeqInt(intSk, intVar)) ==>);
        \replacewith(else) \add( ==> \exists intVar; phi)
        \heuristics(split_cond)
    };

    ifExthenelse1_solve {
        \find(\ifEx intVar; (phi)\then(then)\else(else))
        \sameUpdateLevel
        \varcond(\notFreeIn(intVar, intValue))
        \replacewith({\subst intVar; intValue}then);
        \replacewith(\ifEx intVar; (phi)\then(then)\else(else))
        \add( ==> {\subst intVar; intValue}phi &
            \forall intVar; (phi -> wellOrderLeqInt(intValue, intVar)))
    };

    ifExthenelse1_min {
        \find(\ifEx intVar; (phi)\then(then)\else(else))
        \sameUpdateLevel
        \varcond(\notFreeIn(intVar, phi))
        \replacewith(\if(phi) \then({\subst intVar; 0}then) \else(else))
        \heuristics(concrete)
    };

    ifExthenelse1_split_for {
        \find(\ifEx intVar; (phi)\then(b)\else(c))
        \sameUpdateLevel
        \varcond(\newDependingOn(intSk, phi),
            \notFreeIn(intVar, intSk))
        \replacewith({\subst intVar; intSk}b)
        \add({\subst intVar; intSk}phi,
            \forall intVar; (phi -> wellOrderLeqInt(intSk, intVar)) ==>);
        \replacewith(c) \add( ==> \exists intVar; phi)
        \heuristics(split_cond)
        \displayname "ifExthenelse1_split"
    };

    ifExthenelse1_solve_for {
        \find(\ifEx intVar; (phi)\then(b)\else(c))
        \sameUpdateLevel
        \varcond(\notFreeIn(intVar, intValue))
        \replacewith({\subst intVar; intValue}b);
        \replacewith(\ifEx intVar; (phi)\then(b)\else(c))
        \add( ==> {\subst intVar; intValue}phi &
            \forall intVar; (phi -> wellOrderLeqInt(intValue, intVar)))
        \displayname "ifExthenelse1_solve"
    };

    ifExthenelse1_min_for {
        \find(\ifEx intVar; (phi)\then(b)\else(c))
        \sameUpdateLevel
        \varcond(\notFreeIn(intVar, phi))
        \replacewith(\if(phi) \then({\subst intVar; 0}b) \else(c))
        \heuristics(concrete)
        \displayname "ifExthenelse1_min"
    };

    // ------------- well-orderings used ----------------------

    def_wellOrderLeqInt {
        \find(wellOrderLeqInt(intT1, intT2))
        \replacewith((geq(intT1, intT2) & lt(intT2, 0)) |
            (leq(0, intT1) & leq(intT1, intT2)))
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains a rule set for handling of object isomorphisms in
// information flow proof.
//
// Author: Christoph Scheben

\predicates {
    newObjectsIsomorphic(Seq, Heap, Seq, Heap);
    newOnHeap(Heap, Seq);
    sameTypes(Seq, Seq);
    sameType(any, any);
    objectsIsomorphic(Seq, Seq, Seq, Seq);
    objectIsomorphic(Seq, Object, Seq, Object);
}

\functions {
}

\rules {

    definitionOfNewObjectsIsomorphic {
        \schemaVar \term Seq s1, s2;
        \schemaVar \term Heap h1, h2;

        \find( ==> newObjectsIsomorphic(s1, h1, s2, h2))

        "New on Heap 1":
            \replacewith( ==> newOnHeap(h1, s1));
        "New on Heap 2":
            \replacewith( ==> newOnHeap(h2, s2));
        "Same Types":
            \replacewith( ==> sameTypes(s1, s2));
        "Objects Isomorphic":
            \replacewith( ==> objectsIsomorphic(s1, s1, s2, s2))

        \heuristics(simplify_enlarging)
    };

    definitionOfNewOnHeap {
        \schemaVar \term Seq s;
        \schemaVar \term Heap h;
        \schemaVar \variables int i;

        \find( ==> newOnHeap(h, s))
        \varcond(\notFreeIn(i, s), \notFreeIn(i, h))

        \replacewith( ==>
            \forall i;
            ((0 <= i & i < seqLen(s))
                -> ((java.lang.Object::instance(any::seqGet(s, i)) = TRUE
                        -> boolean::select(h, java.lang.Object::seqGet(s, i), java.lang.Object::<created>) = FALSE)
                    & (Seq::instance(any::seqGet(s, i)) = TRUE
                        -> newOnHeap(h, Seq::seqGet(s, i))))))

        \heuristics(comprehensions)
    };

    definitionOfSameTypes {
        \schemaVar \term Seq s1, s2;
        \schemaVar \variables int i;

        \find( ==> sameTypes(s1, s2))
        \varcond(\notFreeIn(i, s1), \notFreeIn(i, s2))

        \replacewith( ==>
            seqLen(s1) = seqLen(s2)
            & \forall i;
            ((0 <= i & i < seqLen(s1))
                -> ((sameType(any::seqGet(s1, i), any::seqGet(s2, i)))
                    & (Seq::instance(any::seqGet(s1, i)) = TRUE
                        -> sameTypes(Seq::seqGet(s1, i), Seq::seqGet(s2, i))))))

        \heuristics(comprehensions)
    };

    definitionOfObjectsIsomorphic {
        \schemaVar \term Seq s1, t1, s2, t2;
        \schemaVar \variables int i;

        \find( ==> objectsIsomorphic(s1, t1, s2, t2))
        \varcond(
            \notFreeIn(i, s1),
            \notFreeIn(i, s2),
            \notFreeIn(i, t1),
            \notFreeIn(i, t2))

        \replacewith( ==>
            \forall i;
            ((0 <= i & i < seqLen(t1))
                -> ((java.lang.Object::instance(any::seqGet(t1, i)) = TRUE
                        -> objectIsomorphic(s1,
                            java.lang.Object::seqGet(t1, i),
                            s2,
                            java.lang.Object::seqGet(t2, i)))
                    & (Seq::instance(any::seqGet(t1, i)) = TRUE
                        -> objectsIsomorphic(s1,
                            Seq::seqGet(t1, i),
                            s2,
                            Seq::seqGet(t2, i))))))

        \heuristics(comprehensions)
    };

    definitionOfObjectIsomorphic {
        \schemaVar \term Seq s1, s2;
        \schemaVar \term Object o1, o2;
        \schemaVar \variables int i;

        \find( ==> objectIsomorphic(s1, o1, s2, o2))
        \varcond(
            \notFreeIn(i, s1),
            \notFreeIn(i, s2),
            \notFreeIn(i, o1),
            \notFreeIn(i, o2))

        \replacewith( ==>
            \forall i;
            ((0 <= i & i < seqLen(s1))
                -> ((java.lang.Object::instance(any::seqGet(s1, i)) = TRUE
                        -> (java.lang.Object::seqGet(s1, i) = o1
                            <-> java.lang.Object::seqGet(s2, i) = o2))
                    & (Seq::instance(any::seqGet(s1, i)) = TRUE
                        -> objectIsomorphic(Seq::seqGet(s1, i),
                            o1,
                            Seq::seqGet(s2, i),
                            o2)))))

        \heuristics(comprehensions)
    };

    sameTypeTrue {
        \schemaVar \term any x1, x2;

        \assumes(G::exactInstance(x1) = TRUE, G::exactInstance(x2) = TRUE ==>)
        \find(sameType(x1, x2))

        \replacewith(true)

        \heuristics(concrete)
    };

    sameTypeFalse {
        \schemaVar \term any x1, x2;

        \assumes(G::exactInstance(x1) = TRUE, H::exactInstance(x2) = TRUE ==>)
        \find(sameType(x1, x2))

        \varcond(\not \same(G, H))

        \replacewith(false)

        \heuristics(concrete)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\sorts {
    \generic G;
    \generic H \extends Object;
    \generic J \extends Object;
    \generic K;
    \generic alphaObj \extends Object;
    \generic betaObj \extends Object;
}

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;

    \program MethodName [name = <allocate>] #allocate;

    \program SpecialConstructorReference #scr;

    \program SimpleInstanceCreation #n;
    \program NonSimpleInstanceCreation #nsn;
    \program ArrayCreation #na;
    \program ArrayInitializer #arrayinitializer;

    \program SimpleExpression #len;

    \program StaticVariable #staticField;
    \program Variable #v0;
    \program LeftHandSide #lhs;
    \program Type #t, #t2;

    \program ExecutionContext #ex;
    \program ProgramMethod #pm;

    \term int idx0, idx1, allocNr;

    \variables int iv;
    \variables boolean bv;
    \variables G ov;
    \term G ot;
    \term H const;
    \term J obj;
    \formula post, b;

    \term boolean bool;
    \skolemTerm G sk;

    \term J array;
    // attention some strategies rely on the name of the SV if you change it, please adapt
    // the strategies as well
    \term int negLit;
    \term int nonNegLit;
}

\rules(programRules:Java) {

    // ----------------------------------------------------------------------------
    // -----------                 object creation                      -----------
    // ----------------------------------------------------------------------------

    instanceCreationUnfoldArguments {
        \find(\modality{#allmodal}{.. #nsn ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #evaluate-arguments(#nsn); ...}\endmodality (post))
        \heuristics(simplify_autoname)
    };

    instanceCreationAssignmentUnfoldArguments {
        \find(\modality{#allmodal}{.. #lhs = #nsn;  ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #evaluate-arguments(#lhs = #nsn); ...}\endmodality (post))
        \heuristics(simplify_autoname)
    };

    instanceCreation {
        \find(\modality{#allmodal}{.. #n ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #n))
        \replacewith(\modality{#allmodal}{.. #typeof(#v0) #v0 = #create-object(#n);
                #constructor-call(#v0, #n);
                        #post-work(#v0); ...}\endmodality (post))
        \heuristics(method_expand)
    };

    instanceCreationAssignment {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find(\modality{#normal}{.. #lhs = #n;  ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs))
        \replacewith(\modality{#normal}{.. #typeof(#v0) #v0 = #create-object(#n);
                    #constructor-call(#v0, #n);
                            #post-work(#v0);
                #lhs = #v0;
                ...}\endmodality (post))
        \heuristics(method_expand)
    };
}

\rules(programRules:Java, permissions:on) {

    allocateInstance {
        \find( ==> \modality{#allmodal}{.#pm@#t2().. #lhs = #t.#allocate()@#t; ...}\endmodality (post))
        \varcond(\hasSort(#t2, alphaObj))
        \replacewith( ==> {
                heap := create(heap, #lhs)
                ||
                permissions := create(permissions, #lhs)
            }
            \modality{#allmodal}{..  ...}\endmodality (post))
        \add(#lhs != null
            & (wellFormed(heap) -> boolean::select(heap, #lhs, java.lang.Object::<created>) = FALSE)
            & (wellFormed(permissions) -> boolean::select(permissions, #lhs, java.lang.Object::<created>) = FALSE)
            & alphaObj::exactInstance(#lhs) = TRUE ==>)

        \heuristics(method_expand)
    };

    allocateInstanceWithLength {
        \find( ==> \modality{#allmodal}{.#pm@#t2().. #lhs = #t.#allocate(#len)@#t; ...}\endmodality (post))
        \varcond(\hasSort(#t2, alphaObj))
        \replacewith( ==>
            {heap := store(
                    store(
                        create(heap, #lhs),
                        #lhs, java.lang.Object::<transient>, 0),
                    #lhs, java.lang.Object::<transactionConditionallyUpdated>, FALSE)
                || permissions := create(permissions, #lhs)}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \add(#lhs != null
            & (wellFormed(heap) -> (boolean::select(heap, #lhs, java.lang.Object::<created>) = FALSE
                    & length(#lhs) = #len))
            & (wellFormed(permissions) -> boolean::select(permissions, #lhs, java.lang.Object::<created>) = FALSE)
            & alphaObj::exactInstance(#lhs) = TRUE ==>)

        \heuristics(method_expand)
    };
}

\rules(programRules:Java, permissions:off) {

    allocateInstance {
        \find( ==> \modality{#allmodal}{.#pm@#t2().. #lhs = #t.#allocate()@#t; ...}\endmodality (post))
        \varcond(\hasSort(#t2, alphaObj))
        \replacewith( ==> {heap := create(heap, #lhs)}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \add(#lhs != null
            & (wellFormed(heap) -> boolean::select(heap, #lhs, java.lang.Object::<created>) = FALSE)
            & alphaObj::exactInstance(#lhs) = TRUE ==>)

        \heuristics(method_expand)
    };

    allocateInstanceWithLength {
        \find( ==> \modality{#allmodal}{.#pm@#t2().. #lhs = #t.#allocate(#len)@#t; ...}\endmodality (post))
        \varcond(\hasSort(#t2, alphaObj))
        \replacewith( ==>
            {heap := store(
                    store(
                        create(heap, #lhs),
                        #lhs, java.lang.Object::<transient>, 0),
                    #lhs, java.lang.Object::<transactionConditionallyUpdated>, FALSE)}
            \modality{#allmodal}{..  ...}\endmodality (post))
        \add(#lhs != null
            & (wellFormed(heap) -> (boolean::select(heap, #lhs, java.lang.Object::<created>) = FALSE
                    & length(#lhs) = #len))
            & alphaObj::exactInstance(#lhs) = TRUE ==>)

        \heuristics(method_expand)
    };
}

\rules(programRules:Java) {

    special_constructor_call {
        \find(\modality{#allmodal}{.. #scr ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #special-constructor-call(#scr); ...}\endmodality (post))
        \heuristics(method_expand)
    };

    // ----------------------------------------------------------------------------
    // -----------                 array creation                      -----------
    // ----------------------------------------------------------------------------


    arrayCreation {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find(\modality{#normal}{.. #lhs = #na; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #na))
        \replacewith(\modality{#normal}{..
                #typeof(#na) #v0;
                #init-array-creation(#v0, #na);
                        #lhs = #v0; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    arrayCreationWithInitializers {
        \find(\modality{#allmodal}{.. #lhs = #arrayinitializer; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs))
        \replacewith(\modality{#allmodal}{..
                #typeof(#lhs) #v0;
                #init-array-creation(#v0, #arrayinitializer);
                        #lhs = #v0; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    // ----------------------------------------------------------------------------
    // -----------                 exactInstance                      ------------
    // ----------------------------------------------------------------------------
    /*
       exact_instance_implies_instance_reference {
             \find (alphaObj::exactInstance(obj) = TRUE ==>)
             \add (alphaObj::instance(obj) = TRUE ==>)
             \heuristics (type_hierarchy_def)
       };
    */
    exact_instance_definition_int {
        \find(int::exactInstance(idx0) = TRUE)
        \varcond(\notFreeIn(iv, idx0))
        \replacewith(\exists iv; (idx0 = iv))
        \heuristics(simplify)
    };

    exact_instance_definition_boolean {
        \find(boolean::exactInstance(bool) = TRUE)
        \varcond(\notFreeIn(bv, bool))
        \replacewith(\exists bv; (bool = bv))
        \heuristics(simplify)
    };

    exact_instance_definition_null {
        \find(Null::exactInstance(obj) = TRUE)
        \varcond(\notFreeIn(bv, bool))
        \replacewith(obj = null)
        \heuristics(simplify)
    };

    exact_instance_for_interfaces_or_abstract_classes {
        \find(G::exactInstance(obj))
        \varcond(\isAbstractOrInterface(G))
        \replacewith(FALSE)
        \heuristics(simplify)
        \displayname "interfaces or abstract classes have no exact instances"
    };

    instance_for_final_types {
        \schemaVar \term any a;
        \assumes(==> J::exactInstance(a) = TRUE)
        \find(J::instance(a) = TRUE ==>)
        \varcond(\isFinal(J))
        \replacewith(a = null ==>)
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

//
//  This file contains rule for integer division
//   both div and jdiv and the related operators
//   mod and jmod
//   In the beginning these rules were part o
//   integerSimplification.key
//   As they grew more and more they habe been put
//   in this separate file.
//

\schemaVariables {
    \term int divNum, divDenom, polyDivCoeff;
    \skolemTerm int l, quotient;
}

\rules {

    jdiv_axiom_inline {
        \find(jdiv(divNum, divDenom))
        \replacewith(\if(divNum >= 0)
                \then(div(divNum, divDenom))
                \else(div(divNum * (-1), divDenom) * (-1)))
        \heuristics(defOps_jdiv_inline, notHumanReadable)
    };

    jdiv_axiom {
        \find(jdiv(divNum, divDenom))
        \sameUpdateLevel
        \add(jdiv(divNum, divDenom) =
            \if(divNum >= 0)
                \then(div(divNum, divDenom))
                \else(div(divNum * (-1), divDenom) * (-1)) ==>)
        \heuristics(defOps_jdiv, notHumanReadable)
    };

    div_axiom {
        \find(div(divNum, divDenom))
        \sameUpdateLevel
        \varcond(\newDependingOn(quotient, divNum),
            \newDependingOn(quotient, divDenom))
        \add(divDenom = 0 |
            (div(divNum, divDenom) = quotient &
                mul(quotient, divDenom) <= divNum &
                \if(divDenom >= 0)
                    \then(mul(quotient, divDenom) >= 1 + divNum + (-1) * divDenom)
                    \else(mul(quotient, divDenom) >= 1 + divNum + divDenom)) ==>)
        \heuristics(defOps_div, polySimp_newSmallSym, notHumanReadable)
    };

    \lemma
    div_unique1 {
        \schemaVar \variables int a, cnom, x, y;
        \find(div(divNum, divDenom))
        \add(\forall a; \forall cnom; \forall x; \forall y;
            ((cnom > 0 & x * cnom <= a & y * cnom <= a &
                    x * cnom >= 1 + a - cnom & y * cnom >= 1 + a - cnom) -> x = y) ==>)
    };

    \lemma
    div_unique2 {
        \schemaVar \variables int a, cnom, x, y;
        \find(div(divNum, divDenom))
        \add(\forall a; \forall cnom; \forall x; \forall y;
            ((cnom < 0 & x * cnom <= a & y * cnom <= a &
                    x * cnom >= 1 + a + cnom & y * cnom >= 1 + a + cnom) -> x = y) ==>)
    };

    \lemma
    div_exists {
        \schemaVar \variables int a, cnom, qu, rm;
        \find(div(divNum, divDenom))
        \add(\forall cnom; (cnom != 0 -> \forall a; \exists qu; \exists rm;
                (a = qu * cnom + rm & 0 <= rm &
                    \if(cnom >= 0)
                        \then(mul(qu, cnom) >= 1 + a + (-1) * cnom & rm < cnom)
                        \else(mul(qu, cnom) >= 1 + a + cnom & rm < -cnom))) ==>
        )
    };
    \lemma
    div_one {
        \find(div(divNum, 1))
        \replacewith(divNum)
        \heuristics(concrete)
    };
    \lemma
    jdiv_one {
        \find(jdiv(divNum, 1))
        \replacewith(divNum)
        \heuristics(concrete)
    };

    \lemma
    div_zero {
        \find(div(0, divDenom))
        \replacewith(0);
        \add( ==> divDenom != 0)
        \heuristics(simplify_enlarging)
    };
    \lemma
    divResZero1 {
        \find(div(divNum, divDenom))
        \add((divDenom > 0 &
                0 <= divNum &
                divNum < divDenom) ->
            div(divNum, divDenom) = 0 ==>)
    };

    \lemma
    divResZero2 {
        \find(div(divNum, divDenom))
        \add((divDenom < 0 &
                0 <= divNum &
                divNum < -divDenom) ->
            div(divNum, divDenom) = 0 ==>)
    };

    \lemma
    divResOne1 {
        \find(div(divNum, divDenom))
        \add((divDenom > 0 &
                divNum < 0 &
                -divDenom < divNum) ->
            div(divNum, divDenom) = -1 ==>)
    };

    \lemma
    divResOne2 {
        \find(div(divNum, divDenom))
        \add((divDenom < 0 &
                divNum < 0 &
                divDenom < divNum) ->
            div(divNum, divDenom) = 1 ==>)
    };

    \lemma
    div_cancel1 {
        \find(div(divNum * divDenom, divDenom))
        \replacewith(divNum);
        \add( ==> divDenom != 0)
        \heuristics(simplify_enlarging)
    };

    \lemma
    div_cancel2 {
        \find(div(divDenom * divNum, divDenom))
        \replacewith(divNum);
        \add( ==> divDenom != 0)
        \heuristics(simplify_enlarging)
    };

    \lemma
    divAddMultDenom {
        \schemaVar \term int coef;
        \find(div(divNum + coef * divDenom, divDenom))
        \replacewith(div(divNum, divDenom) + coef);
        \add( ==> divDenom != 0)
        \heuristics(simplify_enlarging)
    };

    \lemma
    divMinus {
        \find(div(-divNum, divDenom))
        \replacewith(\if(div(divNum, divDenom) * divDenom = divNum)
                \then(-div(divNum, divDenom))
                \else(\if(divDenom > 0)
                        \then(-div(divNum, divDenom) - 1)
                        \else(-div(divNum, divDenom) + 1)));
        \add( ==> divDenom != 0)
    };

    \lemma
    divMinusDenom {
        \find(div(divNum, -divDenom))
        \replacewith(-div(divNum, divDenom));
        \add( ==> divDenom != 0)
        \heuristics(simplify_enlarging)
    };

    \lemma
    divLeastDPos {
        \schemaVar \term int coef;
        \find(divNum < divDenom * coef ==>)
        \add(divDenom > 0 -> div(divNum, divDenom) < coef ==>)
    };

    \lemma
    divLeastDNeg {
        \schemaVar \term int coef;
        \find(divDenom * coef <= divNum ==>)
        \add(divDenom < 0 -> div(divNum, divDenom) <= coef ==>)
    };

    \lemma
    divGreatestDPos {
        \schemaVar \term int coef;
        \find(divDenom * coef <= divNum ==>)
        \add(divDenom > 0 -> coef <= div(divNum, divDenom) ==>)
    };

    \lemma
    divGreatestDNeg {
        \schemaVar \term int coef;
        \find(divNum < divDenom * coef ==>)
        \add(divDenom < 0 -> coef < div(divNum, divDenom) ==>)
    };

    \lemma
    divIncreasingPos {
        \schemaVar \variables int divNum1, divNum2, divDenom1;
        \add(\forall divDenom1; (\forall divNum1; (\forall divNum2; (
                        divDenom1 > 0 & divNum1 <= divNum2
                        ->
                        div(divNum1, divDenom1) <= div(divNum2, divDenom1)))) ==>)
    };

    \lemma
    divIncreasingNeg {
        \schemaVar \variables int divNum1, divNum2, divDenom1;
        \add(\forall divDenom1; (\forall divNum1; (\forall divNum2; (
                        divDenom1 < 0 & divNum1 <= divNum2
                        ->
                        div(divNum1, divDenom1) >= div(divNum2, divDenom1)))) ==>)
    };

    \lemma
    jdiv_zero {
        \find(jdiv(0, divDenom))
        \replacewith(0);
        \add( ==> divDenom != 0)
        \heuristics(simplify_enlarging)
    };

    \lemma
    jdivPulloutMinusNum {
        \find(jdiv(-divNum, divDenom))
        \replacewith(-jdiv(divNum, divDenom));
        \add( ==> divDenom != 0)
    };

    \lemma
    jdivPulloutMinusDenom {
        \find(jdiv(divNum, -divDenom))
        \replacewith(-jdiv(divNum, divDenom));
        \add( ==> divDenom != 0)
        \heuristics(simplify_enlarging)
    };

    \lemma
    jdiv_uniquePosPos {
        \schemaVar \variables int a, cnom, x, y;
        \find(jdiv(divNum, divDenom))
        \add(\forall a; \forall cnom; \forall x; \forall y;
            ((a >= 0 & cnom > 0 & x * cnom <= a & y * cnom <= a &
                    (x + 1) * cnom > a & (y + 1) * cnom > a) -> x = y) ==>)
    };

    \lemma
    jdiv_uniquePosNeg {
        \schemaVar \variables int a, cnom, x, y;
        \find(jdiv(divNum, divDenom))
        \add(\forall a; \forall cnom; \forall x; \forall y;
            ((a >= 0 & cnom < 0 & x * cnom <= a & y * cnom <= a &
                    (x - 1) * cnom > a & (y - 1) * cnom > a) -> x = y) ==>)
    };

    \lemma
    jdiv_uniqueNegPos {
        \schemaVar \variables int a, cnom, x, y;
        \find(jdiv(divNum, divDenom))
        \add(\forall a; \forall cnom; \forall x; \forall y;
            ((a < 0 & cnom > 0 & x * cnom >= a & y * cnom >= a &
                    (x - 1) * cnom < a & (y - 1) * cnom < a) -> x = y) ==>)
    };

    \lemma
    jdiv_uniqueNegNeg {
        \schemaVar \variables int a, cnom, x, y;
        \find(jdiv(divNum, divDenom))
        \add(\forall a; \forall cnom; \forall x; \forall y;
            ((a < 0 & cnom < 0 & x * cnom >= a & y * cnom >= a &
                    (x + 1) * cnom < a & (y + 1) * cnom < a) -> x = y) ==>)
    };

    \lemma
    jdivMultDenom1 {
        \schemaVar \term int cfac;
        \find(jdiv(divDenom * cfac, divDenom))
        \replacewith(cfac);
        \add( ==> divDenom != 0)
        \heuristics(simplify_enlarging)
    };

    \lemma
    jdivMultDenom2 {
        \schemaVar \term int cfac;
        \find(jdiv(cfac * divDenom, divDenom))
        \replacewith(cfac);
        \add( ==> divDenom != 0)
    };

    jmod_axiom {
        \find(jmod(divNum, divDenom))
        \replacewith(divNum + jdiv(divNum, divDenom) * (-1) * divDenom)
        \heuristics(defOps_mod, notHumanReadable)
    };

    mod_axiom {
        \find(mod(divNum, divDenom))
        \replacewith(divNum + (divNum/divDenom) * (-1) * divDenom)
        \heuristics(defOps_mod, notHumanReadable)
    };

    \lemma
    mod_geZero {
        \find(mod(divNum, divDenom))
        \add(divDenom != 0 -> 0 <= mod(divNum, divDenom) ==>)
    };

    \lemma
    mod_lessDenom {
        \find(mod(divNum, divDenom))
        \add(divDenom != 0 -> mod(divNum, divDenom) < \if(divDenom >= 0)
                \then(divDenom)
                \else(-divDenom) ==>)
    };

    \lemma
    jmod_NumPos {
        \find(jmod(divNum, divDenom))
        \add((divDenom != 0 & divNum >= 0) -> jmod(divNum, divDenom) < \if(divDenom >= 0)
                \then(divDenom)
                \else(-divDenom) ==>)
    };

    \lemma
    jmod_NumNeg {
        \find(jmod(divNum, divDenom))
        \add((divDenom != 0 & divNum <= 0) -> jmod(divNum, divDenom) > \if(divDenom >= 0)
                \then(-divDenom)
                \else(divDenom) ==>)
    };

    \lemma
    jmod_geZero {
        \find(jmod(divNum, divDenom))
        \add((divDenom != 0 -> 0 <= \if(divNum >= 0)
                    \then(jmod(divNum, divDenom))
                    \else(-jmod(divNum, divDenom))) ==>)
    };

    \lemma
    jmodNumZero {
        \find(jmod(0, divDenom))
        \replacewith(0)
        \heuristics(concrete)
    };

    \lemma
    jmod_pulloutminusNum {
        \find(jmod(-divNum, divDenom))
        \replacewith(-jmod(divNum, divDenom));
        \add( ==> divDenom != 0)
    };

    \lemma
    jmod_pulloutminusDenom {
        \find(jmod(divNum, -divDenom))
        \replacewith(jmod(divNum, divDenom));
        \add( ==> divDenom != 0)
    };

    \lemma
    jmodUnique1 {
        \schemaVar \variables int a, deb, cmod, x;
        \add(\forall a; (\forall deb; (\forall cmod; (
                        (a >= 0 & deb != 0 & 0 <= cmod &
                            (cmod < \if(deb > 0)
                                    \then(deb)
                                    \else(-deb))
                            &
                            \exists x; (a = deb * x + cmod)) ->
                        cmod = jmod(a, deb))))
            ==>)
    };

    \lemma
    jmodUnique2 {
        \schemaVar \variables int a, deb, cmod, x;
        \add(\forall a; (\forall deb; (\forall cmod; (
                        (a <= 0 & deb != 0 &
                            (-cmod < \if(deb > 0)
                                    \then(deb)
                                    \else(-deb))
                            & cmod <= 0 &
                            \exists x; (a = deb * x + cmod)) ->
                        cmod = jmod(a, deb))))
            ==>)
    };

    \lemma
    intDivRem {
        \find(jmod(divNum, divDenom))
        \add(divDenom != 0 ->
            divNum = jdiv(divNum, divDenom) * divDenom + jmod(divNum, divDenom)
            ==>)
    };

    \lemma
    jmodjmod {
        \schemaVar \variables int N, D1, D2;
        \add(\forall N; (\forall D1; (\forall D2; (
                        (D1 != 0 & D2 != 0 & jmod(D1, D2) = 0 &
                            (D1 >= 0 <-> D2 >= 0))
                        ->
                        jmod(N, D2) = jmod(jmod(N, D1), D2))))
            ==>)
    };

    \lemma
    jmodDivisible {
        \schemaVar \variables int D, A;
        \add(\forall D; (\forall A; (
                    D != 0 -> jmod(D * A, D) = 0))
            ==>)
    };

    \lemma
    jmodDivisibleRep {
        \schemaVar \term int D, A;
        \find(jmod(D * A, D))
        \replacewith(0);
        \add( ==> D != 0)
        \heuristics(simplify_enlarging)
    };

    \lemma
    jdivAddMultDenom {
        \schemaVar \variables int N, D, A;
        \add(\forall N; (\forall D; (\forall A;
                    (D != 0 ->
                        (jdiv(N + A * D, D) =
                            (\if(N = jdiv(N, D) * D)
                                    \then(jdiv(N, D) + A)
                                    \else(\if(N != jdiv(N, D) * D & (N >= 0 <-> N + D * A >= 0))
                                            \then(jdiv(N, D) + A)
                                            \else(\if(N != jdiv(N, D) * D & (N >= 0 <-> N + D * A < 0) & (D > 0 <-> N + D * A < 0))
                                                    \then(jdiv(N, D) + A + 1)
                                                    \else(jdiv(N, D) + A - 1))))
                        ))))
            ==>)
    };

    \lemma
    jmodAltZero {
        \schemaVar \variables int N, D, A;
        \add(\forall N; (\forall D; (
                    D != 0 ->
                    (jmod(N, D) = 0 <-> \exists A; (N = A * D))))
            ==>)
    };

    \lemma
    jmodAddMultDenomZero {
        \schemaVar \term int N, D, A;
        \find(jmod(N + A * D, D) = 0)
        \sameUpdateLevel
        \replacewith(jmod(N, D) = 0);
        \add( ==> D != 0)
        \heuristics(simplify_enlarging)
    };

    polyDiv_pullOut {
        \find(divNum/divDenom)
        \replacewith(\if(divDenom = 0)
                \then(divNum/0)
                \else((divNum + polyDivCoeff * (-1) * divDenom)
                    /divDenom + polyDivCoeff))
        \heuristics(polyDivision, defOps_divModPullOut, notHumanReadable)
    };

    \lemma
    polyDiv_zero {
        \find(0/divDenom)
        \replacewith(\if(divDenom = 0)
                \then(0/0)
                \else(0))
        \heuristics(polyDivision)
    };

    polyMod_pullOut {
        \find(divNum % divDenom)
        \replacewith((divNum + polyDivCoeff * (-1) * divDenom)
            % divDenom)
        \heuristics(polyDivision, defOps_divModPullOut, notHumanReadable)
    };

    polyMod_zero {
        \find(0 % divDenom)
        \replacewith(0)
        \heuristics(polyDivision, concrete)
    };

    \lemma
    polyMod_ltdivDenom {
        \find(divNum % divDenom)
        \add((divDenom > 0 -> divNum % divDenom < divDenom)
            &
            (divDenom < 0 -> divNum % divDenom < -divDenom)
            ==>)
    };

    mod_homoEq {
        \schemaVar \term int modNumLeft, modNumRight, modDenom;
        \find(modNumLeft % modDenom = modNumRight % modDenom)
        \replacewith((modNumLeft - modNumRight) % modDenom = 0)
        \heuristics(defOps_modHomoEq, notHumanReadable)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    This file contains all rules moving an integer related assignment
    from the inside of a normalAssignment (diamond, box, etc.)
    modality to the logic (as an update). The Java operators are
    therefore mapped to their generic logic function. These generic
    functions (java...) are later interpreted as mathematical function
    dependent on the chosen Java semantics.

    See intRules.key for an overview of the integer files.
*/

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #normalassign;

    \program SimpleExpression #se, #se0, #se1;
    \program JavaByteExpression #seByte, #seByte0, #seByte1;
    \program JavaShortExpression #seShort, #seShort0, #seShort1;
    \program JavaIntExpression #seInt, #seInt0, #seInt1;
    \program JavaLongExpression #seLong, #seLong0, #seLong1;
    \program JavaCharByteShortIntExpression #seCharByteShortInt,
    #seCharByteShortInt0, #seCharByteShortInt1;
    \program JavaByteShortExpression #seByteShort;

    \program Variable #loc;

    \formula post;
}

\rules(programRules:Java) {

    // ------------------------------------------------------------------------
    // ----------- Rules for binary arithmetic operators
    // ------------------------------------------------------------------------

    // ------------- multiplication

    assignmentMultiplicationInt {
        \find(\modality{#normalassign}{..
                    #loc = #seCharByteShortInt0 * #seCharByteShortInt1;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                \add(==> inInt(mul(#seCharByteShortInt0, #seCharByteShortInt1)))
        };
        \replacewith({#loc := javaMulInt(#seCharByteShortInt0, #seCharByteShortInt1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "multiplication"
    };

    assignmentMultiplicationLong {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt * #seLong;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                \add(==> inLong(mul(#seCharByteShortInt, #seLong)))
        };
        \replacewith({#loc := javaMulLong(#seCharByteShortInt, #seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "multiplication"
    };

    assignmentMultiplicationLong2 {
        \find(\modality{#normalassign}{..
                       #loc=#seLong * #seCharByteShortInt;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                \add(==> inLong(mul(#seLong, #seCharByteShortInt)))
        };
        \replacewith({#loc := javaMulLong(#seLong, #seCharByteShortInt)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "multiplication"
    };

    assignmentMultiplicationLong3 {
        \find(\modality{#normalassign}{..
                    #loc=#seLong0 * #seLong1;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(mul(#seLong0, #seLong1)))
        };
        \replacewith({#loc := javaMulLong(#seLong0, #seLong1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "multiplication"
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {

    // ------------- division
    // Integer division does not need an overflow check

    assignmentDivisionInt {
        \find( ==> \modality{#normalassign}{..
                    #loc=#seCharByteShortInt0 / #seCharByteShortInt1;
                ...}\endmodality (post))
        \replacewith(
            ==> {#loc := javaDivInt(#seCharByteShortInt0, #seCharByteShortInt1)}
            \modality{#normalassign}{.. ...}\endmodality (post));
        \replacewith( ==> #seCharByteShortInt1 != 0)
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionLong {
        \find( ==> \modality{#normalassign}{..
                    #loc=#se / #seLong;
                ...}\endmodality (post))
        \replacewith(
            ==> {#loc := javaDivLong(#se, #seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post));
        \replacewith( ==> #seLong != 0)
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionLong2 {
        \find( ==> \modality{#normalassign}{..
                    #loc=#seLong / #seCharByteShortInt;
                ...}\endmodality (post))
        \replacewith(
            ==> {#loc := javaDivLong(#seLong, #seCharByteShortInt)}
            \modality{#normalassign}{.. ...}\endmodality (post));
        \replacewith( ==> #seCharByteShortInt != 0)
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    // ------------- modulo
    // a modulo operation cannot cause overflow since the magnitude of the result is always
    // less than the magnitude of the divisor (according to Java Lang Spec)

    assignmentModulo {
        \find( ==> \modality{#normalassign}{..
                    #loc=#se0 % #se1;
                ...}\endmodality (post))
        \replacewith(
            ==> {#loc := javaMod(#se0, #se1)}
            \modality{#normalassign}{.. ...}\endmodality (post));
        \replacewith( ==> #se1 != 0)
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {

    // ------------- division

    assignmentDivisionInt {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt0 / #seCharByteShortInt1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaDivInt(#seCharByteShortInt0, #seCharByteShortInt1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionLong {
        \find(\modality{#normalassign}{..
                    #loc=#se / #seLong;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaDivLong(#se, #seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionLong2 {
        \find(\modality{#normalassign}{..
                    #loc=#seLong / #seCharByteShortInt;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaDivLong(#seLong, #seCharByteShortInt)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    // ------------- modulo
    // a modulo operation cannot cause overflow since the magnitude of the result is always
    // less than the magnitude of the divisor (according to Java Lang Spec)

    assignmentModulo {
        \find(\modality{#normalassign}{..
                    #loc=#se0 % #se1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaMod(#se0, #se1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };
}

\rules(programRules:Java, runtimeExceptions:allow) {

    // ------------- division

    assignmentDivisionInt {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt0 / #seCharByteShortInt1;
                ...}\endmodality (post))
        \replacewith(\if(#seCharByteShortInt1 != 0)
                \then({#loc := javaDivInt(#seCharByteShortInt0, #seCharByteShortInt1)}
                    \modality{#normalassign}{.. ...}\endmodality (post))
                \else(\modality{#normalassign}{..
                            throw new java.lang.ArithmeticException();
                        ...}\endmodality (post)))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionLong {
        \find(\modality{#normalassign}{..
                    #loc=#se / #seLong;
                ...}\endmodality (post))
        \replacewith(\if(#seLong != 0)
                \then({#loc := javaDivLong(#se, #seLong)}
                    \modality{#normalassign}{.. ...}\endmodality (post))
                \else(\modality{#normalassign}{..
                            throw new java.lang.ArithmeticException();
                        ...}\endmodality (post)))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    assignmentDivisionLong2 {
        \find(\modality{#normalassign}{..
                    #loc=#seLong / #seCharByteShortInt;
                ...}\endmodality (post))
        \replacewith(\if(#seCharByteShortInt != 0)
                \then({#loc := javaDivLong(#seLong, #seCharByteShortInt)}
                    \modality{#normalassign}{.. ...}\endmodality (post))
                \else(\modality{#normalassign}{..
                        throw new java.lang.ArithmeticException();
                        ...}\endmodality (post)))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };

    // ------------- modulo
    // a modulo operation cannot cause overflow since the magnitude of the result is always
    // less than the magnitude of the divisor (according to Java Lang Spec)

    assignmentModulo {
        \find(\modality{#normalassign}{..
                    #loc=#se0 % #se1;
                ...}\endmodality (post))
        \replacewith(\if(#se1 != 0)
                \then({#loc := javaMod(#se0, #se1)}
                    \modality{#normalassign}{.. ...}\endmodality (post))
                \else(\modality{#normalassign}{..
                           throw new java.lang.ArithmeticException();
                        ...}\endmodality (post)))
        \heuristics(executeIntegerAssignment)
        \displayname "modulo"
    };

}

\rules(programRules:Java) {

    // ------------- subtraction

    assignmentSubtractionInt {
        \find(\modality{#normalassign}{..
                    #loc = #seCharByteShortInt0 - #seCharByteShortInt1;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inInt(sub(#seCharByteShortInt0, #seCharByteShortInt1)))
        };
        \replacewith({#loc := javaSubInt(#seCharByteShortInt0, #seCharByteShortInt1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    assignmentSubtractionLong {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt - #seLong;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(sub(#seCharByteShortInt, #seLong)))
        };
        \replacewith({#loc := javaSubLong(#seCharByteShortInt, #seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    assignmentSubtractionLong2 {
        \find(\modality{#normalassign}{..
                    #loc=#seLong - #seCharByteShortInt;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(sub(#seLong, #seCharByteShortInt)))
        };
        \replacewith(
            {#loc := javaSubLong(#seLong, #seCharByteShortInt)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    assignmentSubtractionLong3 {
        \find(\modality{#normalassign}{..
                     #loc=#seLong0 - #seLong1;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(sub(#seLong0, #seLong1)))
        };
        \replacewith({#loc := javaSubLong(#seLong0, #seLong1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    // ------------- addition

    assignmentAdditionInt {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt0 + #seCharByteShortInt1;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inInt(add(#seCharByteShortInt0, #seCharByteShortInt1)))
        };
        \replacewith(
            {#loc := javaAddInt(#seCharByteShortInt0, #seCharByteShortInt1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };

    assignmentAdditionLong {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt + #seLong;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(add(#seCharByteShortInt, #seLong)))
        };
        \replacewith(
            {#loc := javaAddLong(#seCharByteShortInt, #seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };

    assignmentAdditionLong2 {
        \find(\modality{#normalassign}{..
                    #loc=#seLong + #seCharByteShortInt;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(add(#seLong, #seCharByteShortInt)))
        };
        \replacewith({#loc := javaAddLong(#seLong, #seCharByteShortInt)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };

    // reviewed 04/20/2004, St.S.
    assignmentAdditionLong3 {
        \find(\modality{#normalassign}{..
                    #loc=#seLong0 + #seLong1;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(add(#seLong0, #seLong1)))
        };
        \replacewith({#loc := javaAddLong(#seLong0, #seLong1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };

    // ------------- binary "and"
    // "and" and "or" can't overflow, no overflow branch needed

    assignmentBitwiseAndInt {
        \find(\modality{#normalassign}{..
                     #loc=#seCharByteShortInt0 & #seCharByteShortInt1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseAndInt(#seCharByteShortInt0, #seCharByteShortInt1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseAnd"
    };

    assignmentBitwiseAndLong {
        \find(\modality{#normalassign}{..
                     #loc=#seCharByteShortInt & #seLong;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseAndLong(#seCharByteShortInt, #seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseAnd"
    };

    assignmentBitwiseAndLong2 {
        \find(\modality{#normalassign}{..
                     #loc=#seLong & #seCharByteShortInt;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseAndLong(#seLong, #seCharByteShortInt)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseAnd"
    };

    assignmentBitwiseAndLong3 {
        \find(\modality{#normalassign}{..
                     #loc=#seLong0 & #seLong1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseAndLong(#seLong0, #seLong1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseAnd"
    };

    // ------------- binary "or"

    assignmentBitwiseOrInt {
        \find(\modality{#normalassign}{..
                     #loc=#seCharByteShortInt0 | #seCharByteShortInt1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseOrInt(#seCharByteShortInt0, #seCharByteShortInt1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseOr"
    };

    assignmentBitwiseOrLong {
        \find(\modality{#normalassign}{..
                     #loc=#seCharByteShortInt | #seLong;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseOrLong(#seCharByteShortInt, #seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseOr"
    };

    // reviewed 04/20/2004, St.S.
    assignmentBitwiseOrLong2 {
        \find(\modality{#normalassign}{..
                     #loc=#seLong | #seCharByteShortInt;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseOrLong(#seLong, #seCharByteShortInt)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseOr"
    };

    // reviewed 04/20/2004, St.S.
    assignmentBitwiseOrLong3 {
        \find(\modality{#normalassign}{..
                     #loc=#seLong0 | #seLong1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseOrLong(#seLong0, #seLong1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseOr"
    };

    // ------------- binary "xor"

    assignmentBitwiseXOrInt {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt0 ^ #seCharByteShortInt1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseXOrInt(#seCharByteShortInt0, #seCharByteShortInt1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseXOr"
    };

    assignmentBitwiseXOrLong {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt ^ #seLong;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseXOrLong(#seCharByteShortInt, #seLong)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseXOr"
    };

    assignmentBitwiseXOrLong2 {
        \find(\modality{#normalassign}{..
                    #loc=#seLong ^ #seCharByteShortInt;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseXOrLong(#seLong, #seCharByteShortInt)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseXOr"
    };

    assignmentBitwiseXOrLong3 {
        \find(\modality{#normalassign}{..
                    #loc=#seLong0 ^ #seLong1;
                ...}\endmodality (post))
        \replacewith(
            {#loc := javaBitwiseXOrLong(#seLong0, #seLong1)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "bitwiseXOr"
    };

    // ------------- binary shift-right

    assignmentShiftRightInt {
        \find(\modality{#normalassign}{..
                   #loc=#seCharByteShortInt0 >> #se;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inInt(shiftright(#seLong0, #se)))
        };
        \replacewith(
            {#loc := javaShiftRightInt(#seCharByteShortInt0, #se)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "shift"
    };

    assignmentShiftRightLong {
        \find(\modality{#normalassign}{..
                    #loc=#seLong0 >> #se;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inInt(shiftright(#seLong0, #se)))
        };
        \replacewith(
            {#loc := javaShiftRightLong(#seLong0, #se)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "shift"
    };

    // ------------- binary shift-left

    assignmentShiftLeftInt {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt0 << #se; ...}
                \endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inInt(shiftleft(#seCharByteShortInt0, #se)))
        };
        \replacewith(
            {#loc := javaShiftLeftInt(#seCharByteShortInt0, #se)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "shift"
    };

    assignmentShiftLeftLong {
        \find(\modality{#normalassign}{..
                    #loc=#seLong0 << #se;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(shiftleft(#seLong0, #se)))
        };
        \replacewith(
            {#loc := javaShiftLeftLong(#seLong0, #se)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "shift"
    };

    // ------------- binary unsigned-shift-right

    assignmentUnsignedShiftRightInt {
        \find(\modality{#normalassign}{..
                    #loc=#seCharByteShortInt0 >>> #se; ...}
                \endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(unsignedshiftrightJint(#seCharByteShortInt0, #se)))
        };
        \replacewith(
            {#loc := javaUnsignedShiftRightInt(#seCharByteShortInt0, #se)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "shift"
    };

    assignmentUnsignedShiftRightLong {
        \find(\modality{#normalassign}{..
                    #loc=#seLong0 >>> #se;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(unsignedshiftrightJlong(#seLong0, #se)))
        };
        \replacewith({#loc := javaUnsignedShiftRightLong(#seLong0, #se)}
            \modality{#normalassign}{.. ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "shift"
    };

    // ------------------------------------------------------------------------
    // ----------- Rules for unary plus, minus, and negation
    // ------------------------------------------------------------------------

    unaryMinusInt {
        \find(\modality{#normalassign}{..
                    #loc = - #seCharByteShortInt;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inInt(neg(#seCharByteShortInt)))
        };
        \replacewith({#loc := javaUnaryMinusInt(#seCharByteShortInt)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "unaryMinus"
    };

    unaryMinusLong {
        \find(\modality{#normalassign}{..
                    #loc = - #seLong;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inLong(neg(#seLong)))
        };
        \replacewith({#loc := javaUnaryMinusLong(#seLong)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "unary_minus"
    };

    bitwiseNegationInt {
        \find(\modality{#normalassign}{.. #loc = ~ #seCharByteShortInt; ...}\endmodality (post))
        \replacewith({#loc := javaBitwiseNegateInt(#se)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "invertBits"
    };

    bitwiseNegationLong {
        \find(\modality{#normalassign}{.. #loc = ~ #se; ...}\endmodality (post))
        \replacewith({#loc := javaBitwiseNegateLong(#seLong)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "invertBits"
    };

    // ------------------------------------------------------------------------
    // ------------- Rules for Java types narrowing casts
    // ------------------------------------------------------------------------

    narrowingByteCastShort {
        \find(\modality{#normalassign}{..
                    #loc = (byte) #seShort;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inByte(#seShort))
        };
        \replacewith({#loc := javaCastByte(#seShort)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingByteCastInt {
        \find(\modality{#normalassign}{..
                    #loc = (byte) #seInt;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inByte(#seInt))
        };
        \replacewith({#loc := javaCastByte(#seInt)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingByteCastLong {
        \find(\modality{#normalassign}{..
                    #loc = (byte) #seLong;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inByte(#seLong))
        };
        \replacewith({#loc := javaCastByte(#seLong)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingShortCastInt {
        \find(\modality{#normalassign}{..
                   #loc = (short) #seInt;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inShort(#seInt))
        };
        \replacewith({#loc := javaCastShort(#seInt)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingShortCastLong {
        \find(\modality{#normalassign}{..
                    #loc = (short) #seLong;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inShort(#seLong))
        };
        \replacewith({#loc := javaCastShort(#seLong)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingIntCastLong {
        \find(\modality{#normalassign}{.. #loc = (int) #seLong; ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inInt(#seLong))
        };
        \replacewith({#loc := javaCastInt(#seLong)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingCharCastByte {
        \find(\modality{#normalassign}{..
                    #loc = (char) #seByte;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inChar(#seByte))
        };
        \replacewith(
            {#loc := javaCastChar(#seByte)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingCharCastShort {
        \find(\modality{#normalassign}{..
                    #loc = (char) #seShort;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inChar(#seShort))
        };
        \replacewith(
            {#loc := javaCastChar(#seShort)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingCharCastInt {
        \find(\modality{#normalassign}{..
                    #loc = (char) #seInt;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inChar(#seInt))
        };
        \replacewith({#loc := javaCastChar(#seInt)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };

    narrowingCharCastLong {
        \find(\modality{#normalassign}{..
                    #loc = (char) #seLong;
                ...}\endmodality (post))
        \sameUpdateLevel
        (intRules:arithmeticSemanticsCheckingOF) {
            "Overflow check":
                 \add(==> inChar(#seLong))
        };
        \replacewith({#loc := javaCastChar(#seLong)}
            \modality{#normalassign}{..  ...}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "cast"
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\sorts {
    numbers;
    int;

    // these sort are not axiomatised yet; to come in CHARTER
    // they are here included to allow us to load Java program that
    // contain some methods or fields of type float or double

    real; 
}

\functions {

    // ----------------------------------------------------------------------------
    // The functions declared below preserve their semantics independently
    // from the current integer semantics.
    // ----------------------------------------------------------------------------

    numbers #;
    numbers 0(numbers);
    numbers 1(numbers);
    numbers 2(numbers);
    numbers 3(numbers);
    numbers 4(numbers);
    numbers 5(numbers);
    numbers 6(numbers);
    numbers 7(numbers);
    numbers 8(numbers);
    numbers 9(numbers);
    numbers neglit(numbers);

    int Z(numbers);
    int C(numbers);

    // arithmetic operators on mathematical integers
    int add(int, int);
    int neg(int);
    int sub(int, int);
    int mul(int, int);
    int div(int, int);
    int mod(int, int);
    int pow(int, int);
    int log(int, int);

    // comprehensions
    int bsum {false, false, true}(int, int, int);
    int bprod {false, false, true}(int, int, int);
    int sum {true, true}(boolean, int);
    int prod {true, true}(boolean, int);
    int min {true, true}(boolean, int);
    int max {true, true}(boolean, int);

    // max and min constants
    int byte_MAX;
    int byte_MIN;
    int char_MAX;
    int char_MIN;
    int int_MAX;
    int int_MIN;
    int long_MAX;
    int long_MIN;
    int short_MAX;
    int short_MIN;

    // range constants
    int byte_HALFRANGE;
    int byte_RANGE;
    int char_RANGE;
    int int_HALFRANGE;
    int int_RANGE;
    int long_HALFRANGE;
    int long_RANGE;
    int short_HALFRANGE;
    int short_RANGE;

    // functions to indicate undefinedness
    int undefinedPow(int, int);
    int undefinedLog(int, int);

    // functions to indicate overflows
    int javaUnaryMinusIntOverFlow(int);
    int javaUnaryMinusLongOverFlow(int);
    int javaAddIntOverFlow(int, int);
    int javaAddLongOverFlow(int, int);
    int javaSubIntOverFlow(int, int);
    int javaSubLongOverFlow(int, int);
    int javaMulIntOverFlow(int, int);
    int javaMulLongOverFlow(int, int);
    int javaModOverFlow(int, int);
    int javaDivIntOverFlow(int, int);
    int javaDivLongOverFlow(int, int);
    int javaUnsignedShiftRightOverFlow(int, int);
    int javaBitwiseOrIntOverFlow(int, int);
    int javaCastByteOverFlow(int);
    int javaCastShortOverFlow(int);
    int javaCastIntOverFlow(int);
    int javaCastLongOverFlow(int);
    int javaCastCharOverFlow(int);

    // arithmetic operators with modulo semantics
    int jmod(int, int);
    int jdiv(int, int);
    int unaryMinusJint(int);
    int unaryMinusJlong(int);
    int addJint(int, int);
    int addJlong(int, int);
    int subJint(int, int);
    int subJlong(int, int);
    int mulJint(int, int);
    int mulJlong(int, int);
    int modJint(int, int);
    int modJlong(int, int);
    int divJint(int, int);
    int divJlong(int, int);
    int moduloByte(int);
    int moduloShort(int);
    int moduloInt(int);
    int moduloLong(int);
    int moduloChar(int);

    // bitvector operations
    int bitwiseNegateJint(int);
    int bitwiseNegateJlong(int);

    // shift operations

    // left '>>' right
    int shiftright(/* left */ int, /* right */ int);
    // left '<<' right
    int shiftleft(/* left */ int, /* right */ int);

    // left '>>' right with right >= 0
    int shiftrightPositiveShift(/* left */ int, /* right */ int);
    // left '<<' right with right >= 0
    int shiftleftPositiveShift(/* left */ int, /* right */ int);

    // unsignedshift for arbitrary length bitvectors does not make much sense
    // therefore only a version with an explicit bitvector size is supported
    int unsignedshift(/* left */ int, /* right */ int, /* bitsize */ int);

    // bitvector operations as in Java with bitvector sizes 32 (int) and 64 (long)
    // right op only the lower 5 bits/6 bits (i.e., range is always 0..31 inclusive for int and 0..63 incl. for long
    int shiftrightJint(int, int);
    int shiftleftJint(int, int);

    int shiftleftJlong(int, int);
    int shiftrightJlong(int, int);

    int unsignedshiftrightJint(int, int);
    int unsignedshiftrightJlong(int, int);

    // bitmask operations &, |, ^
    int binaryAnd(/* left */ int, /* right */ int);
    int binaryOr(/* left */ int, /* right */ int);
    int binaryXOr(/* left */ int, /* right */ int);

    // bitmask operations for Java
    int orJint(int, int);
    int orJlong(int, int);
    int andJint(int, int);
    int andJlong(int, int);
    int xorJint(int, int);
    int xorJlong(int, int);

    // placeholder for loop index variable
    int index;

    // ----------------------------------------------------------------------------
    // The functions declared below change their semantics when switching the
    // used integer semantics.
    // ----------------------------------------------------------------------------

    int javaUnaryMinusInt(int);
    int javaUnaryMinusLong(int);
    int javaBitwiseNegateInt(int);
    int javaBitwiseNegateLong(int);
    int javaAddInt(int, int);
    int javaAddLong(int, int);
    int javaSubInt(int, int);
    int javaSubLong(int, int);
    int javaMulInt(int, int);
    int javaMulLong(int, int);
    int javaMod(int, int);
    int javaDivInt(int, int);
    int javaDivLong(int, int);
    int javaShiftRightInt(int, int);
    int javaShiftRightLong(int, int);
    int javaShiftLeftInt(int, int);
    int javaShiftLeftLong(int, int);
    int javaUnsignedShiftRightInt(int, int);
    int javaUnsignedShiftRightLong(int, int);
    int javaBitwiseOrInt(int, int);
    int javaBitwiseOrLong(int, int);
    int javaBitwiseAndInt(int, int);
    int javaBitwiseAndLong(int, int);
    int javaBitwiseXOrInt(int, int);
    int javaBitwiseXOrLong(int, int);
    int javaCastByte(int);
    int javaCastShort(int);
    int javaCastInt(int);
    int javaCastLong(int);
    int javaCastChar(int);

    // ----------------------------------------------------------------------------
    // The functions declared below are have checked overflow in wd-checks
    // and otherwise behave like the bigint mode.
    // ----------------------------------------------------------------------------
    int checkedUnaryMinusInt(int);
    int checkedUnaryMinusLong(int);
    int checkedBitwiseNegateInt(int);
    int checkedBitwiseNegateLong(int);
    int checkedAddInt(int, int);
    int checkedAddLong(int, int);
    int checkedSubInt(int, int);
    int checkedSubLong(int, int);
    int checkedMulInt(int, int);
    int checkedMulLong(int, int);
    int checkedDivInt(int, int);
    int checkedDivLong(int, int);
    int checkedShiftRightInt(int, int);
    int checkedShiftRightLong(int, int);
    int checkedShiftLeftInt(int, int);
    int checkedShiftLeftLong(int, int);
    int checkedUnsignedShiftRightInt(int, int);
    int checkedUnsignedShiftRightLong(int, int);
    int checkedBitwiseOrInt(int, int);
    int checkedBitwiseOrLong(int, int);
    int checkedBitwiseAndInt(int, int);
    int checkedBitwiseAndLong(int, int);
    int checkedBitwiseXOrInt(int, int);
    int checkedBitwiseXOrLong(int, int);
}

\predicates {

    // ----------------------------------------------------------------------------
    // The predicates declared below preserve their semantics independently
    // from the current integer semantics.
    // ----------------------------------------------------------------------------

    leq(int, int);
    lt(int, int);
    geq(int, int);
    gt(int, int);

    // ----------------------------------------------------------------------------
    // The functions declared below change their semantics when switching the
    // used integer semantics.
    // ----------------------------------------------------------------------------

    inByte(int);
    inChar(int);
    inInt(int);
    inLong(int);
    inShort(int);

    // ----------------------------------------------------------------------------
    // The predicates declared below preserve their semantics independently
    // from the current integer semantics.
    // ----------------------------------------------------------------------------

    inRangeByte(int);
    inRangeChar(int);
    inRangeInt(int);
    inRangeLong(int);
    inRangeShort(int);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    Integer semantics independent rules which transform programs.

    See intRules.key for an overview of the integer files.
*/

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;

    \program JavaCharExpression #seChar;
    \program JavaByteExpression #seByte, #seByte0, #seByte1;
    \program JavaShortExpression #seShort, #seShort0, #seShort1;
    \program JavaIntExpression #seInt, #seInt0, #seInt1;
    \program JavaLongExpression #seLong, #seLong0, #seLong1;
    \program JavaByteShortIntExpression #seByteShortInt,
    seByteShortInt0, #seByteShortInt1;
    \program JavaByteShortExpression #seByteShort;

    \program NonSimpleExpression #nse;
    \program Expression #e;
    \program Variable #v0;

    \program LeftHandSide #lhs;
    \formula post;

    \term int left, right, i;
}

\rules(programRules:Java) {

    // ------------------------------------------------------------------------
    // Rules for unary arithmetic operators  applied to a non-simple expression
    // ------------------------------------------------------------------------

    // reviewed 04/15/2004, St.S.
    compound_unary_plus_assignment {
        \find(\modality{#allmodal}{..#lhs=+#e;...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..#lhs=#e;...}\endmodality (post)) \heuristics(executeIntegerAssignment)
    };

    // reviewed 04/15/2004, St.S.
    compound_unary_minus_eval {
        \find(\modality{#allmodal}{..#lhs=-#nse;...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0 = #nse;
                #lhs = -#v0;
                           ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/19/2004, St.S.
    compound_binary_neg {
        \find(\modality{#allmodal}{..#lhs=~#nse;...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{..#typeof(#nse) #v0=#nse; #lhs=~#v0;...}
                \endmodality (post))
        \heuristics(simplify_expression)
    };

    // ------------------------------------------------------------------------
    //  Rules for widening or identity cast from Java types to Java types
    // ------------------------------------------------------------------------

    // reviewed 04/20/2004, St.S.
    widening_identity_cast_1 {
        \find(\modality{#allmodal}{.. #lhs = (byte) #seByte; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seByte;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    // reviewed 04/20/2004, St.S.
    widening_identity_cast_2 {
        \find(\modality{#allmodal}{.. #lhs = (short) #seByte; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seByte;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    // reviewed 04/20/2004, St.S.
    widening_identity_cast_3 {
        \find(\modality{#allmodal}{.. #lhs = (char) #seChar; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seChar;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    // reviewed 04/20/2004, St.S.
    widening_identity_cast_4 {
        \find(\modality{#allmodal}{.. #lhs = (short) #seShort; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seShort;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    // reviewed 04/20/2004, St.S.
    widening_identity_cast_5 {
        \find(\modality{#allmodal}{.. #lhs = (int) #seByteShortInt; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seByteShortInt;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    // reviewed 04/20/2004, St.S.
    widening_identity_cast_10 {
        \find(\modality{#allmodal}{.. #lhs = (long) #seByteShortInt; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seByteShortInt;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    // reviewed 04/20/2004, St.S.
    widening_identity_cast_11 {
        \find(\modality{#allmodal}{.. #lhs = (long) #seLong; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seLong;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    widening_identity_cast_12 {
        \find(\modality{#allmodal}{.. #lhs = (int) #seChar; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seChar;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };

    widening_identity_cast_13 {
        \find(\modality{#allmodal}{.. #lhs = (long) #seChar; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #seChar;  ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "cast"
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    Integer simplification rules.

    See intRules.key for an overview of the integer files.
*/

\schemaVariables {

    \term int i, i0, i1, i2, i3, i4, j, j0, j1, t, t1, t2;
    \term [rigid] int ir, i0r;
    \variables int k, j2, c, nv;
    \skolemTerm int sk, sk2;

    \term numbers iz, jz;
    \formula b, psi, phi, post, inv;

    \term int commLeft, commRight;
    \term int distSummand0, distSummand1, distCoeff;
    \term int invertLeft, invertRight;
    \term int pullOutCommon, pullOutLeft, pullOutRight;
    \term int homoLeft, homoRight;
    \term int addAssocMono, addAssocPoly0, addAssocPoly1;
    \term int mulAssocAtom, mulAssocMono0, mulAssocMono1;
    \term int applyEqDividend, applyEqDivisor;
    \term [rigid] int applyEqDivisorr;
    \term int cpLeft1, cpLeft2, cpRight1, cpRight2;
    \term int esLeft, esRight1, esRight2, esCoeff1, esCoeff2;
    \term int sepPosMono, sepNegMono, sepResidue;
    \term int multLeft, multRight, multFac;
    \term int multFacLeft, multFacRight;
    \term int divX, divXBoundPos, divXBoundNonPos, divXBoundNeg, divXBoundNonNeg;
    \term int divY;
    \term int divProd, divProdBoundPos, divProdBoundNonPos;
    \term int divProdBoundNeg, divProdBoundNonNeg;
    \term int squareFac;
    \term int subsumLeft, subsumRightBigger, subsumRightSmaller,
    subsumCoeffBigger, subsumCoeffSmaller;
    \term int contradLeft, contradRightBigger, contradRightSmaller,
    contradCoeffBigger, contradCoeffSmaller;
    \term int strengthenLeft, strengthenRight;
    \term int splitEqLeft, splitEqRight;
    \term int signCasesLeft;
    \term int elimGcdLeft, elimGcdRight, elimGcd;

    \term int elimGcdLeftDiv, elimGcdRightDiv;
    \term int divNum, divDenom, polyDivCoeff;
    \term int modNumLeft, modNumRight, modDenom;
    \term int newSymLeft, newSymLeftCoeff, newSymRight, newSymDef;
    \skolemTerm int l, quotient;
    \term int applyEqLeft, applyEqRight, applyEqOther;
    \term int tautLeft, tautRightBigger, tautRightSmaller;
    \term int weakenLeft, weakenRightSmaller, weakenRightBigger;
    \term int antiSymmLeft, antiSymmRightSmaller, antiSymmRightBigger;
    \term int aePseudoLeft, aePseudoLeftCoeff, aePseudoRight;
    \term int aePseudoTargetLeft, aePseudoTargetRight, aePseudoTargetFactor;

    // attention strategy depends on this var.name
    \term int castedTerm;

    \variables int uSub, uSub1, uSub2;
    \term int tInt;
}

\rules {

    // --------------------------------------------------------------------
    // some of these taclets are from Isabelle theory IntArith
    // --------------------------------------------------------------------

    // reviewed 04/16/2004, St.S.
    less_iff_diff_less_0 {
        \find(lt(i0, i1))
        \replacewith(lt(sub(i0, i1), 0))
    };

    // reviewed 04/16/2004, St.S.
    leq_iff_diff_leq_0 {
        \find(leq(i0, i1))
        \replacewith(leq(sub(i0, i1), 0))
    };

    // reviewed 04/16/2004, St.S.
    minus_distribute_1 {
        \find(neg(add(i, i1)))
        \replacewith(add(neg(i), neg(i1)))
        \heuristics(simplify_int)
        \displayname "minus_distribute"
    };
    // reviewed 04/16/2004, St.S.
    minus_distribute_2 {
        \find(neg(sub(i, i1)))
        \replacewith(add(neg(i), i1))
        \heuristics(simplify_int)
        \displayname "minus_distribute"
    };

    // reviewed 04/16/2004, St.S.
    left_add_mult_distrib {
        \find(add(mul(i0, i1), add(mul(i2, i1), i3)))
        \replacewith(add(mul(add(i0, i2), i1), i3))
    };

    // reviewed 04/16/2004, St.S.
    eq_add_iff1 {
        \find(add(mul(i0, i1), i2) = add(mul(i3, i1), i4))
        \replacewith(add(mul(sub(i0, i3), i1), i2) = i4)
    };

    // reviewed 04/16/2004, St.S.
    eq_add_iff2 {
        \find(add(mul(i0, i1), i2) = add(mul(i3, i1), i4))
        \replacewith(i2 = add(mul(sub(i3, i0), i1), i4))
    };

    // reviewed 04/16/2004, St.S.
    less_add_iff1 {
        \find(lt(add(mul(i0, i1), i2), add(mul(i3, i1), i4)))
        \replacewith(lt(add(mul(sub(i0, i3), i1), i2), i4))
    };

    // reviewed 04/16/2004, St.S.
    less_add_iff2 {
        \find(lt(add(mul(i0, i1), i2), add(mul(i3, i1), i4)))
        \replacewith(lt(i2, add(mul(sub(i3, i0), i1), i4)))
    };

    // reviewed 04/16/2004, St.S.
    leq_add_iff1 {
        \find(leq(add(mul(i0, i1), i2), add(mul(i3, i1), i4)))
        \replacewith(leq(add(mul(sub(i0, i3), i1), i2), i4))
    };

    // reviewed 04/16/2004, St.S.
    leq_add_iff2 {
        \find(leq(add(mul(i0, i1), i2), add(mul(i3, i1), i4)))
        \replacewith(leq(i2, add(mul(sub(i3, i0), i1), i4)))
    };

    // reviewed 04/16/2004, St.S.
    leq_diff1_eq {
        \find(leq(i0, sub(i1, 1)))
        \replacewith(lt(i0, i1))
        \heuristics(simplify_int)
    };

    // reviewed 04/16/2004, St.S.
    le1_add1_eq_le {
        \find(lt(i0, add(i1, 1)))
        \replacewith(leq(i0, i1))
        \heuristics(simplify_int)
    };

    // reviewed 04/16/2004, St.S.
    zadd_left_cancel0 {
        \find(i0 = add(i0, i1))
        \replacewith(i1 = 0)
    };

    // reviewed 04/16/2004, St.S.
    int_diff_minus_eq {
        \find(sub(i0, neg(i1)))
        \replacewith(add(i0, i1))
    };

    // reviewed 04/16/2004, St.S.
    mult_pos {
        \find(lt(0, i0) & lt(0, i1))
        \replacewith(lt(0, mul(i0, i1)))
    };

    // reviewed 04/16/2004, St.S.
    mult_neg {
        \find(lt(i0, 0) & lt(i1, 0))
        \replacewith(lt(0, mul(i0, i1)))
    };

    // reviewed 04/16/2004, St.S.
    mult_pos_neg {
        \find(lt(i0, 0) & lt(0, i1))
        \replacewith(lt(mul(i0, i1), 0))
    };

    // reviewed 04/16/2004, St.S.
    zero_less_mult_iff {
        \find(lt(0, mul(i0, i1)))
        \replacewith(lt(0, i0) & lt(0, i1) | lt(i0, 0) & lt(i1, 0))
    };

    // reviewed 04/16/2004, St.S.
    zero_leq_mult_iff {
        \find(leq(0, mul(i0, i1)))
        \replacewith(leq(0, i0) & leq(0, i1) | leq(i0, 0) & leq(i1, 0))
    };

    // reviewed 04/16/2004, St.S.
    mult_less_0_iff {
        \find(lt(mul(i0, i1), 0))
        \replacewith(lt(i0, 0) & lt(0, i1) | lt(0, i0) & lt(i1, 0))
    };

    // reviewed 04/16/2004, St.S.
    mult_leq_0_iff {
        \find(leq(mul(i0, i1), 0))
        \replacewith(leq(i0, 0) & leq(0, i1) | leq(0, i0) & leq(i1, 0))
    };

    // reviewed 04/16/2004, St.S.
    square_nonneg {
        \find(leq(0, mul(i0, i0)))
        \replacewith(true) \heuristics(simplify_int)
    };

    // reviewed 04/16/2004, St.S.
    mult_eq_self_iff {
        \find(i0 = mul(i0, i1))
        \replacewith(i0 = 0 | i1 = 1)
    };

    // reviewed 04/16/2004, St.S.
    less_1_mult {
        \find(lt(1, i0) & lt(1, i1))
        \replacewith(lt(1, mul(i0, i1)))
    };

    // reviewed 04/16/2004, St.S.
    pos_mult_eq_1_iff {
        \find(lt(0, i0) -> mul(i0, i1) = 1)
        \replacewith(i0 = 1 & i1 = 1)
    };

    // reviewed 04/16/2004, St.S.
    mult_eq_1_iff {
        \find(mul(i0, i1) = 1)
        \replacewith(i0 = 1 & i1 = 1 | i0 = Z(neglit(1(#))) & i1 = Z(neglit(1(#))))
    };

    // reviewed 04/16/2004, St.S.
    multiply_distribute_1 {
        \find(mul(add(i0, i1), add(j0, j1)))
        \replacewith
        (add(add(mul(i0, j0), mul(i0, j1)), add(mul(i1, j0), mul(i1, j1))))
        \displayname "multiply_distribute"
    };

    // reviewed 04/16/2004, St.S.
    multiply_distribute_2 {
        \find(mul(add(i0, i1), sub(j0, j1)))
        \replacewith
        (add(sub(mul(i0, j0), mul(i0, j1)), sub(mul(i1, j0), mul(i1, j1))))
        \displayname "multiply_distribute"
    };

    // reviewed 04/16/2004, St.S.
    multiply_distribute_3 {
        \find(mul(sub(i0, i1), sub(j0, j1)))
        \replacewith
        (add(sub(mul(i0, j0), mul(i0, j1)), sub(mul(i1, j1), mul(i1, j0))))
        \displayname "multiply_distribute"
    };

    // reviewed 12/21/2004, St.S.
    mul_distribute_4 {
        \find(mul(i0, add(i1, i2)))
        \replacewith(add(mul(i0, i1), mul(i0, i2)))
        \displayname "multiply_distribute"
    };

    // reviewed 12/21/2004, St.S.
    mul_distribute_5 {
        \find(mul(add(i1, i2), i0))
        \replacewith(add(mul(i0, i1), mul(i0, i2)))
        \displayname "multiply_distribute"
    };

    // reviewed 12/21/2004, St.S.
    theorem_of_archimedes {
        \assumes(gt(i0, sub(i1, 1)) ==>)
        \find(lt(i0, i1) ==>)
        \replacewith(false ==>)
    };

    // reviewed 04/16/2004, St.S.
    collect_same_terms_1 {
        \find(add(mul(i, j), mul(i, j)))
        \replacewith(mul(2, mul(i, j)))
        \displayname "collect_same_terms"
    };

    // reviewed 04/16/2004, St.S.
    collect_same_terms_2 {
        \find(add(add(mul(i, j), mul(i0, i1)), add(mul(i, j), mul(j0, j1))))
        \replacewith(add(mul(2, mul(i, j)), add(mul(i0, i1), mul(j0, j1))))
        \displayname "collect_same_terms"
    };

    // reviewed 04/16/2004, St.S.
    collect_same_terms_3 {
        \find(add(add(neg(mul(i, j)), mul(i0, i1)), add(neg(mul(i, j)), mul(j0, j1))))
        \replacewith(add(neg(mul(2, mul(i, j))), add(mul(i0, i1), mul(j0, j1))))
        \displayname "collect_same_terms"
    };

    // reviewed 04/16/2004, St.S.
    addition_associative {
        \find(add(add(i0, i1), add(j0, j1)))
        \replacewith(add(add(j0, i1), add(i0, j1)))
    };

    // reviewed 04/16/2004, St.S.
    leq_add_one {
        \find(leq(i0, i1))
        \replacewith(leq(add(i0, 1), add(i1, 1)))
    };

    // reviewed 04/16/2004, St.S.
    less_add_one {
        \find(lt(i0, i1))
        \replacewith(lt(add(i0, 1), add(i1, 1)))
    };

    // reviewed 04/16/2004, St.S.
    geq_add_one {
        \find(geq(i0, i1))
        \replacewith(geq(add(i0, 1), add(i1, 1)))
    };

    // reviewed 04/16/2004, St.S.
    greater_add_one {
        \find(gt(i0, i1))
        \replacewith(gt(add(i0, 1), add(i1, 1)))
    };
    // reviewed 04/16/2004, St.S.
    equal_add_one {
        \find(i0 = i1)
        \replacewith(add(i0, 1) = add(i1, 1))
    };

    // reviewed 04/16/2004, St.S.
    leq_add {
        \find( ==> leq(i0, i1))
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; leq(add(i0, j2), add(i1, j2)))
    };

    // reviewed 04/16/2004, St.S.
    less_add {
        \find( ==> lt(i0, i1))
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; lt(add(i0, j2), add(i1, j2)))
    };

    // reviewed 04/16/2004, St.S.
    geq_add {
        \find( ==> geq(i0, i1))
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; geq(add(i0, j2), add(i1, j2)))
    };

    // reviewed 04/16/2004, St.S.
    greater_add {
        \find( ==> gt(i0, i1))
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; gt(add(i0, j2), add(i1, j2)))
    };

    // reviewed 04/16/2004, St.S.
    equal_add {
        \find( ==> i0 = i1)
        \varcond(\notFreeIn(j2, i0, i1))
        \replacewith( ==> \exists j2; add(i0, j2) = add(i1, j2))
    };

    // reviewed 04/16/2004, St.S.
    leq_diff_1 {
        \find(leq(i0, add(i0, 1)))
        \replacewith(true)
        \heuristics(int_arithmetic)
    };

    // reviewed 04/16/2004, St.S.
    lt_diff_1 {
        \find(lt(i0, add(i0, 1)))
        \replacewith(true)
        \heuristics(int_arithmetic)
    };

    // reviewed 04/16/2004, St.S.
    geq_diff_1 {
        \find(geq(add(i0, 1), i0))
        \replacewith(true)
        \heuristics(int_arithmetic)
    };

    // reviewed 04/16/2004, St.S.
    gt_diff_1 {
        \find(gt(add(i0, 1), i0))
        \replacewith(true)
        \heuristics(int_arithmetic)
    };

    // reviewed 04/16/2004, St.S.
    i_minus_i_is_zero {
        \find(sub(i, i))
        \replacewith(0) \heuristics(simplify_int)
    };

    // reviewed 04/16/2004, St.S.
    add_two_inequations_1 {
        \assumes(lt(i, i0) ==>)
        \find(lt(j, j0) ==>)
        \add(lt(add(i, j), add(i0, j0)) ==>)
    };
    // reviewed 04/16/2004, St.S.
    add_two_inequations_2 {
        \assumes(leq(i, i0) ==>)
        \find(leq(j, j0) ==>)
        \add(leq(add(i, j), add(i0, j0)) ==>)
    };

    // reviewed 04/16/2004, St.S.
    partition_inequation {
        \assumes( ==> lt(i, i0))
        \find(lt(i, i1) ==>)
        \add( ==> lt(i1, i0))
    };

    // reviewed 04/16/2004, St.S.
    eq_sides {
        \find(i = j)
        \replacewith(sub(i, j) = 0)
    };

    // reviewed 04/15/2004, St.S.
    times_one_1 {
        \find(mul(i, 1))
        \replacewith(i)
        \heuristics(simplify_int)
        \displayname "times_one"
    };
    // reviewed 04/15/2004, St.S.
    times_one_2 {
        \find(mul(1, i))
        \replacewith(i)
        \heuristics(simplify_int)
        \displayname "times_one"
    };
    // reviewed 04/15/2004, St.S.
    times_minus_one_1 {
        \find(mul(i, -1))
        \replacewith(neg(i))
        \heuristics(simplify_int)
        \displayname "times_minus_one"
    };
    // reviewed 04/15/2004, St.S.
    times_minus_one_2 {
        \find(mul(-1, i))
        \replacewith(neg(i))
        \heuristics(simplify_int)
        \displayname "times_minus_one"
    };
    // reviewed 04/15/2004, St.S.
    times_zero_1 {
        \find(mul(i, 0))
        \replacewith(0)
        \heuristics(simplify_literals)
        \displayname "times_zero"
    };
    // reviewed 04/15/2004, St.S.
    times_zero_2 {
        \find(mul(0, i))
        \replacewith(0) \heuristics(simplify_literals)
        \displayname "times_zero"
    };

    // reviewed 04/15/2004, St.S.
    leq_to_gt {
        \find(leq(i, j))
        \replacewith(!gt(i, j))
    };

    // reviewed 04/15/2004, St.S.
    geq_to_lt {
        \find(geq(i, j))
        \replacewith(!lt(i, j))
    };

    // reviewed 04/15/2004, St.S.
    leq_to_gt_alt {
        \find(leq(i, j))
        \replacewith(lt(i, j) | i = j)
    };

    // reviewed 04/15/2004, St.S.
    geq_to_lt_alt {
        \find(geq(i, j))
        \replacewith(gt(i, j) | i = j)
    };

    // reviewed 04/15/2004, St.S.
    greater {
        \find(gt(i, i0))
        \replacewith(lt(i0, i))
    };

    // reviewed 04/15/2004, St.S.
    less_is_total_heu {
        \assumes( ==> lt(i, i0), (i = i0), lt(i0, i)) \closegoal
    };
    // reviewed 04/15/2004, St.S.
    less_is_total {
        \find(i)
        \sameUpdateLevel
        \add(lt(i, i0) ==>);
        \add((i = i0) ==>);
        \add(lt(i0, i) ==>)
    };
    // reviewed 04/15/2004, St.S.
    less_zero_is_total {
        \find(i)
        \sameUpdateLevel
        \add(lt(i, 0) ==>);
        \add(i = 0 ==>);
        \add(lt(0, i) ==>)
    };

    // reviewed 04/15/2004, St.S.
    less_is_alternative_1 {
        \assumes(lt(i, i0), lt(i0, i) ==>) \closegoal
    };
    // reviewed 04/15/2004, St.S.
    less_is_alternative_2 {
        \assumes( ==> lt(i, i0))
        \find( ==> lt(i0, i))
        \add((i = i0) ==>)
    };

    // reviewed 04/15/2004, St.S.
    less_trans {
        \assumes(lt(i, i0) ==>)
        \find(lt(i0, i1) ==>)
        \add(lt(i, i1) ==>)
    };
    // reviewed 04/15/2004, St.S.
    leq_trans {
        \assumes(leq(i, i0) ==>)
        \find(leq(i0, i1) ==>)
        \add(leq(i, i1) ==>)
    };

    // reviewed 04/15/2004, St.S.
    less_neg {
        \find(lt(i, i0))
        \replacewith(!(lt(i0, i + 1)))
    };

    // reviewed 04/15/2004, St.S.
    less_base {
        \find(lt(i, i))
        \replacewith(false) \heuristics(simplify_int)
    };

    // reviewed 04/15/2004, St.S.
    add_zero_left {
        \find(add(0, i))
        \replacewith(i) \heuristics(simplify_literals)
    };
    // reviewed 04/15/2004, St.S.
    add_zero_right {
        \find(add(i, 0))
        \replacewith(i) \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    switch_brackets {
        \find(add(add(i, i0), i1))
        \replacewith(add(i, add(i0, i1)))
    };
    // reviewed 04/15/2004, St.S.
    switch_params {
        \find(add(i0, i1))
        \replacewith(add(i1, i0))
    };

    // reviewed 04/15/2004, St.S.
    mul_assoc {
        \find(mul(mul(i, i0), i1))
        \replacewith(mul(i, mul(i0, i1)))
    };
    // reviewed 04/15/2004, St.S.
    mul_comm {
        \find(mul(i0, i1))
        \replacewith(mul(i1, i0))
    };

    // reviewed 04/15/2004, St.S.
    pull_out_neg_1 {
        \find(mul(neg(i0), i1))
        \replacewith(neg(mul(i0, i1)))
        \displayname "pull_out_minus"
    };
    // reviewed 04/15/2004, St.S.
    pull_out_neg_2 {
        \find(mul(i0, neg(i1)))
        \replacewith(neg(mul(i0, i1)))
        \displayname "pull_out_minus"
    };

    // reviewed 04/15/2004, St.S.
    rotate_params {
        \find(add(i, add(i0, i1)))
        \replacewith(add(i0, add(i, i1)))
    };

    // ____: review;  added 04/19/05 RB
    add_equations {
        \assumes(i = i0 ==>)
        \find(j = j0 ==>)
        \add(add(i, j) = add(i0, j0) ==>)
    };
    add_equations_right {
        \assumes(i = i0 ==>)
        \find( ==> j = j0)
        \add( ==> add(i, j) = add(i0, j0))
    };

    sub_equations_left {
        \assumes(i = i0 ==>)
        \find(j = j0 ==>)
        \add(sub(j, i) = sub(j0, i0) ==>)
    };
    sub_equations_right {
        \assumes(i = i0 ==>)
        \find( ==> j = j0)
        \add( ==> sub(j, i) = sub(j0, i0))
    };

    // reviewed 04/15/2004, St.S.
    add_eq {
        \find(i0 = i1)
        \replacewith(add(i, i0) = add(i, i1))
    };

    // reviewed 04/15/2004, St.S.
    add_eq_back {
        \find(add(i1, i) = add(i1, i0))
        \replacewith(i = i0)
        \heuristics(simplify_int)
    };

    // new, not reviewed but proven: see ../proof/rules/proven_rules/add_eq_back_2.proof
    add_eq_back_2 {
        \find(add(i, i1) = add(i0, i1))
        \replacewith(i = i0)
        \heuristics(simplify_int)
        \displayname "add_eq_back"
    };

    // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_eq_back_2_fst_comm.proof
    add_eq_back_2_fst_comm {
        \find(add(i1, i) = add(i0, i1))
        \replacewith(i = i0)
        \heuristics(simplify_int)
        \displayname "add_eq_back"
    };

    // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_eq_back_3.proof
    add_eq_back_3 {
        \find(i1 = add(i1, i0))
        \replacewith(0 = i0)
        \heuristics(simplify_int)
        \displayname "add_eq_back"
    };

    // reviewed 04/15/2004, St.S.
    add_less {
        \find(lt(i, i0))
        \replacewith(lt(add(i1, i), add(i1, i0)))
    };

    // added 08/02/2019 PHS
    add_greater {
        \find(gt(i, i0))
        \replacewith(gt(add(i1, i), add(i1, i0)))
    };

    // added 08/02/2019 PHS
    add_lesseq {
        \find(leq(i, i0))
        \replacewith(leq(add(i1, i), add(i1, i0)))
    };

    // added 08/02/2019 PHS
    add_greatereq {
        \find(geq(i, i0))
        \replacewith(geq(add(i1, i), add(i1, i0)))
    };

    // reviewed 04/15/2004, St.S.
    add_less_back {
        \find(lt(add(i1, i), add(i1, i0)))
        \replacewith(lt(i, i0))
        \heuristics(simplify_int)
    };

    // reviewed 04/15/2004, St.S.
    add_less_back_zero_1 {
        \find(lt(i, add(i, i1)))
        \replacewith(lt(0, i1))
        \heuristics(simplify_int)
        \displayname "add_less_back"
    };

    // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_less_back_zero_1_comm.proof
    add_less_back_zero_1_comm {
        \find(lt(i, add(i1, i)))
        \replacewith(lt(0, i1))
        \heuristics(simplify_int)
        \displayname "add_less_back"
    };

    // reviewed 04/15/2004, St.S.
    add_less_back_zero_2 {
        \find(lt(add(i, i1), i))
        \replacewith(lt(i1, 0))
        \heuristics(simplify_int)
        \displayname "add_less_back"
    };

    // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_less_back_zero_2_comm.proof
    add_less_back_zero_2_comm {
        \find(lt(add(i1, i), i))
        \replacewith(lt(i1, 0))
        \heuristics(simplify_int)
        \displayname "add_less_back"
    };

    // reviewed 04/15/2004, St.S.
    sub {
        \find(sub(i, i0))
        \replacewith(add(i, neg(i0))) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    sub_zero_1 {
        \find(Z(neglit(0(#))))
        \replacewith(Z(0(#)))
        \heuristics(simplify_literals)
    };
    // reviewed 04/15/2004, St.S.
    sub_zero_2 {
        \find(sub(i, 0))
        \replacewith(i) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    add_sub_elim_left {
        \find(add(neg(i), i))
        \replacewith(0) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    add_sub_elim_right {
        \find(add(i, neg(i)))
        \replacewith(0) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    add_sub_step {
        \find(add(neg(i), neg(i0)))
        \replacewith(neg(add(i, i0)))
    };
    // reviewed 04/15/2004, St.S.
    sub_sub_elim {
        \find(neg(neg(i)))
        \replacewith(i) \heuristics(simplify_int)
    };
    // reviewed 04/15/2004, St.S.
    less_sub {
        \find(lt(i, i0))
        \replacewith(lt(neg(i0), neg(i)))
    };

    // reviewed 04/15/2004, St.S.
    less_plus {
        \find(lt(0, add(i0, i1)))
        \replacewith(lt(neg(i0), i1))
    };

    // reviewed 04/15/2004, St.S.
    close_by_lt_leq {
        \assumes(lt(i, j) ==>)
        \find( ==> leq(add(i, 1), j))
        \replacewith( ==> true)
    };

    // reviewed 04/15/2004, St.S.
    lt_to_leq_1 {
        \find(lt(i, j) | i = j)
        \replacewith(leq(i, j)) \heuristics(simplify_int)
    };

    // reviewed 04/15/2004, St.S.
    lt_to_leq_2 {
        \assumes( ==> lt(i, j))
        \find( ==> i = j)
        \replacewith( ==> leq(i, j))
        \heuristics(simplify_int)
    };

    // reviewed 04/15/2004, St.S.
    lt_to_gt {
        \find(lt(i, i0))
        \replacewith(gt(i0, i))
    };
    // reviewed 04/15/2004, St.S.
    gt_to_lt {
        \find(gt(i, i0))
        \replacewith(lt(i0, i))
    };
    // reviewed 04/15/2004, St.S.
    leq_to_geq {
        \find(leq(i, i0))
        \replacewith(geq(i0, i))
    };
    // reviewed 04/15/2004, St.S.
    geq_to_leq {
        \find(geq(i, i0))
        \replacewith(leq(i0, i))
    };

    // -------------------------------------------------------
    // ------------- Rules for integer literals --------------
    // -------------------------------------------------------

    // reviewed 04/20/2004, St.S.
    double_unary_minus_literal {
        \find(Z(neglit(neglit(iz))))
        \replacewith(Z(iz))
        \heuristics(simplify_literals)
        \displayname "double_unary_minus"
    };

    // reviewed 04/16/2004, St.S.
    charLiteral_to_int {
        \find(C(iz))
        \replacewith(Z(iz)) \heuristics(charLiteral_to_intLiteral)
    };

    // reviewed 04/15/2004, St.S.
    add_literals {
        \find(add(Z(iz), Z(jz)))
        \replacewith(#add(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    sub_literals {
        \find(sub(Z(iz), Z(jz)))
        \replacewith(#sub(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    mul_literals {
        \find(mul(Z(iz), Z(jz)))
        \replacewith(#mul(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    div_literals {
        \find(div(Z(iz), Z(jz)))
        \replacewith(#div(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    less_literals {
        \find(lt(Z(iz), Z(jz)))
        \replacewith(#less(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    greater_literals {
        \find(gt(Z(iz), Z(jz)))
        \replacewith(#greater(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    leq_literals {
        \find(leq(Z(iz), Z(jz)))
        \replacewith(#leq(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    qeq_literals {
        \find(geq(Z(iz), Z(jz)))
        \replacewith(#geq(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    equal_literals {
        \find(Z(iz) = Z(jz))
        \replacewith(#eq(Z(iz), Z(jz)))
        \heuristics(simplify_literals)
    };

    // reviewed 04/15/2004, St.S.
    neg_literal {
        \find(neg(Z(iz)))
        \replacewith(Z(neglit(iz)))
        \heuristics(simplify_literals)
    };

    pow_literals {
        \find(pow(Z(iz), Z(jz)))
        \replacewith(#pow(Z(iz), Z(jz)))
        \heuristics(simplify_literals, nonDuplicateAppCheckEq)
    };

}

// ---------------------------------------------------------
// - multiply both sides of an (in)equation with some term -
// ---------------------------------------------------------

\rules(integerSimplificationRules:full) {
    multiply_inEq0 {
        \find(multLeft <= multRight ==>)
        \add(\if(multFac >= 0)
                \then(multLeft * multFac <= multRight * multFac)
                \else(multLeft * multFac >= multRight * multFac) ==>)
    };

    multiply_inEq1 {
        \find(multLeft >= multRight ==>)
        \add(\if(multFac >= 0)
                \then(multLeft * multFac >= multRight * multFac)
                \else(multLeft * multFac <= multRight * multFac) ==>)
    };

    multiply_eq {
        \find(multLeft = multRight ==>)
        \add(multLeft * multFac = multRight * multFac ==>)
    };

    multiply_2_inEq0 {
        \assumes(multFacLeft <= multFacRight ==>)
        \find(multLeft <= multRight ==>)
        \add(multLeft * multFacLeft >=
            -multRight * multFacRight
            + multRight * multFacLeft
            + multLeft * multFacRight ==>)
        \heuristics(inEqSimp_nonLin,
            inEqSimp_nonLin_multiply)
    };

    multiply_2_inEq1 {
        \assumes(multFacLeft >= multFacRight ==>)
        \find(multLeft <= multRight ==>)
        \add(multLeft * multFacLeft <=
            -multRight * multFacRight
            + multRight * multFacLeft
            + multLeft * multFacRight ==>)
        \heuristics(inEqSimp_nonLin,
            inEqSimp_nonLin_multiply)
    };

    multiply_2_inEq2 {
        \assumes(multFacLeft <= multFacRight ==>)
        \find(multLeft >= multRight ==>)
        \add(multLeft * multFacLeft <=
            -multRight * multFacRight
            + multRight * multFacLeft
            + multLeft * multFacRight ==>)
        \heuristics(inEqSimp_nonLin,
            inEqSimp_nonLin_multiply)
    };

    multiply_2_inEq3 {
        \assumes(multFacLeft >= multFacRight ==>)
        \find(multLeft >= multRight ==>)
        \add(multLeft * multFacLeft >=
            -multRight * multFacRight
            + multRight * multFacLeft
            + multLeft * multFacRight ==>)
        \heuristics(inEqSimp_nonLin,
            inEqSimp_nonLin_multiply)
    };

    divide_inEq0 {
        \assumes(divX >= divXBoundPos ==>)
        \find(divProd <= divProdBoundNonNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundPos >= 1 ->
            divProdBoundNonNeg >= 0 ->
            divY <= divProdBoundNonNeg/divXBoundPos ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_inEq1 {
        \assumes(divX >= divXBoundNonNeg ==>)
        \find(divProd <= divProdBoundNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNonNeg >= 0 ->
            divProdBoundNeg <= -1 ->
            divY <= -1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_neg)
    };

    divide_inEq2 {
        \assumes(divX >= divXBoundPos ==>)
        \find(divProd >= divProdBoundNonPos ==>)
        \add(divProd = divX * divY ->
            divXBoundPos >= 1 ->
            divProdBoundNonPos <= 0 ->
            divY >= (divProdBoundNonPos + divXBoundPos - 1)
            /divXBoundPos ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_inEq3 {
        \assumes(divX >= divXBoundNonNeg ==>)
        \find(divProd >= divProdBoundPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNonNeg >= 0 ->
            divProdBoundPos >= 1 ->
            divY >= 1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_pos)
    };

    divide_inEq4 {
        \assumes(divX <= divXBoundNeg ==>)
        \find(divProd >= divProdBoundNonPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNeg <= -1 ->
            divProdBoundNonPos <= 0 ->
            divY <= divProdBoundNonPos/divXBoundNeg ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_inEq5 {
        \assumes(divX <= divXBoundNonPos ==>)
        \find(divProd >= divProdBoundPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNonPos <= 0 ->
            divProdBoundPos >= 1 ->
            divY <= -1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_neg)
    };

    divide_inEq6 {
        \assumes(divX <= divXBoundNeg ==>)
        \find(divProd <= divProdBoundNonNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNeg <= -1 ->
            divProdBoundNonNeg >= 0 ->
            divY >= divProdBoundNonNeg/divXBoundNeg ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_inEq7 {
        \assumes(divX <= divXBoundNonPos ==>)
        \find(divProd <= divProdBoundNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNonPos <= 0 ->
            divProdBoundNeg <= -1 ->
            divY >= 1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_pos)
    };

    divide_eq0 {
        \assumes(divX >= divXBoundPos ==>)
        \find(divProd = divProdBoundNonNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundPos >= 1 ->
            divProdBoundNonNeg >= 0 ->
            divY <= divProdBoundNonNeg/divXBoundPos ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_eq1 {
        \assumes(divX >= divXBoundNonNeg ==>)
        \find(divProd = divProdBoundNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNonNeg >= 0 ->
            divProdBoundNeg <= -1 ->
            divY <= -1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_neg)
    };

    divide_eq2 {
        \assumes(divX >= divXBoundPos ==>)
        \find(divProd = divProdBoundNonPos ==>)
        \add(divProd = divX * divY ->
            divXBoundPos >= 1 ->
            divProdBoundNonPos <= 0 ->
            divY >= (divProdBoundNonPos + divXBoundPos - 1)
            /divXBoundPos ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_eq3 {
        \assumes(divX >= divXBoundNonNeg ==>)
        \find(divProd = divProdBoundPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNonNeg >= 0 ->
            divProdBoundPos >= 1 ->
            divY >= 1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_pos)
    };

    divide_eq4 {
        \assumes(divX <= divXBoundNeg ==>)
        \find(divProd = divProdBoundNonPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNeg <= -1 ->
            divProdBoundNonPos <= 0 ->
            divY <= divProdBoundNonPos/divXBoundNeg ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_eq5 {
        \assumes(divX <= divXBoundNonPos ==>)
        \find(divProd = divProdBoundPos ==>)
        \add(divProd = divX * divY ->
            divXBoundNonPos <= 0 ->
            divProdBoundPos >= 1 ->
            divY <= -1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_neg)
    };

    divide_eq6 {
        \assumes(divX <= divXBoundNeg ==>)
        \find(divProd = divProdBoundNonNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNeg <= -1 ->
            divProdBoundNonNeg >= 0 ->
            divY >= divProdBoundNonNeg/divXBoundNeg ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_divide)
    };

    divide_eq7 {
        \assumes(divX <= divXBoundNonPos ==>)
        \find(divProd = divProdBoundNeg ==>)
        \add(divProd = divX * divY ->
            divXBoundNonPos <= 0 ->
            divProdBoundNeg <= -1 ->
            divY >= 1 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonLin_pos)
    };
}

// ##########################################################################################################
// ------------- integer induction rules    --------------
// ##########################################################################################################

\rules {
    // reviewed 04/15/2004, St.S.
    int_induction {
        "Base Case":
            \add( ==> {\subst nv; 0}(b));
        "Step Case":
            \add( ==> \forall nv; ((geq(nv, 0) & b) -> {\subst nv; (nv + 1)}b));
        "Use Case":
            \add(\forall nv; (geq(nv, 0) -> b) ==>)
    };
}

// -------------------------------------------------------------------------------------
// Automatic induction rules. Ch.G.
// Universal quantification in the succedent
// -------------------------------------------------------------------------------------

\rules(integerSimplificationRules:full) {

    // basic pattern,
    auto_int_induction_geqZero {
        \find( ==> \forall uSub; b)
        \varcond(\newDependingOn(sk, b))
        "Base Case":
            \replacewith( ==> {\subst uSub; 0}b);
        "Step Case (positive)":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; sk}b) ->
                    {\subst uSub; sk + 1}b));
        "Step Case (negative)":
            \replacewith( ==> ((leq(sk, 0) & {\subst uSub; sk}b) ->
                    {\subst uSub; sk - 1}b))
        \displayname "auto_induction"
    };

    // -------------------------------------------------------------------------------------
    // auto induction for: variable greater or equal to some term
    auto_int_induction_geq_1 {
        \find( ==> \forall uSub; (t <= uSub -> b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_geq_2 {
        \find( ==> \forall uSub; (t > uSub | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_geq_3 {
        \find( ==> \forall uSub; (uSub < t | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // auto induction for: variable greater or equal to some term and a second bound psi

    auto_int_induction_geq_5 {
        \find( ==> \forall uSub; ((t > uSub | psi) | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}(psi | b), true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_geq_6 {
        \find( ==> \forall uSub; ((uSub < t | psi) | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}(psi | b), true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // -------------------------------------------------------------------------------------
    // auto induction for: variable greater than some term
    auto_int_induction_gt_1 {
        \find( ==> \forall uSub; (t < uSub -> b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_gt_2 {
        \find( ==> \forall uSub; (t >= uSub | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_gt_3 {
        \find( ==> \forall uSub; (uSub <= t | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // auto induction for: variable greater than some term and a second bound psi

    auto_int_induction_gt_5 {
        \find( ==> \forall uSub; ((t >= uSub | psi) | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}(psi | b), true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_gt_6 {
        \find( ==> \forall uSub; ((uSub <= t | psi) | b))
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}(psi | b), true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // -------------------------------------------------------------------------------------
    // Automatic induction rules and lemma generation rule. The inductively proved formula is
    //  used as a lemma for consecutive formulas in a conjunction. Ch.G.
    // -------------------------------------------------------------------------------------

    // basic pattern
    autoInduct_Lemma {
        \find( ==> (\forall uSub; b) & phi)
        \varcond(\newDependingOn(sk, b))
        "Base Case":
            \replacewith( ==> {\subst uSub; 0}b);
        "Step Case (positive)":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; sk}b) ->
                    {\subst uSub; sk + 1}b));
        "Step Case (negative)":
            \replacewith( ==> ((leq(sk, 0) & {\subst uSub; sk}b) ->
                    {\subst uSub; sk - 1}b));
        "Use Case":
            \replacewith(\forall uSub; b ==> phi)
    };

    // ---------------------------------------------------------------------------------------------------------------------------------
    // auto induction for: variable greater or equal to some term
    autoInductGEQ_Lemma_1 {
        \find( ==> (\forall uSub; (t <= uSub -> b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGEQ_Lemma_2 {
        \find( ==> (\forall uSub; (t > uSub | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGEQ_Lemma_3 {
        \find( ==> (\forall uSub; (uSub < t | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    // auto induction for: variable greater or equal to some term and a second bound psi.

    autoInductGEQ_Lemma_5 {
        \find( ==> (\forall uSub; ((t > uSub | psi) | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi | b), true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> (psi | b)) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGEQ_Lemma_6 {
        \find( ==> (\forall uSub; ((uSub < t | psi) | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi | b), true)));
        "Use Case":
            \replacewith(\forall uSub; (t <= uSub -> (psi | b)) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    // ---------------------------------------------------------------------------------------------------------------------------------
    // auto induction for: variable greater than some term

    autoInductGT_Lemma_1 {
        \find( ==> (\forall uSub; (t < uSub -> b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGT_Lemma_2 {
        \find( ==> (\forall uSub; (t >= uSub | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    autoInductGT_Lemma_3 {
        \find( ==> (\forall uSub; (uSub <= t | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> b) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    // auto induction for: variable greater than some term and a second bound psi.

    autoInductGT_Lemma_5 {
        \find( ==> (\forall uSub; ((t >= uSub | psi) | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi | b), true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> (psi | b)) ==> phi)
        \heuristics(auto_induction_lemma)
        \displayname "auto_induction_lemma"
    };

    autoInductGT_Lemma_6 {
        \find( ==> (\forall uSub; ((uSub <= t | psi) | b)) & phi)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}(psi | b), true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}(psi | b)) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi | b), true)));
        "Use Case":
            \replacewith(\forall uSub; (t < uSub -> (psi | b)) ==> phi)
        \heuristics(auto_induction_lemma, induction_var)
        \displayname "auto_induction_lemma"
    };

    // -------------------------------------------------------------------------------------
    // Automatic induction rules. Ch.G.
    // Existential quantification in the antecedent
    // -------------------------------------------------------------------------------------

    // basic pattern,
    auto_int_induction_geqZeroLeft {
        \find(\exists uSub; b ==>)
        \varcond(\newDependingOn(sk, b))
        "Base Case":
            \replacewith( ==> {\subst uSub; 0}!b);
        "Step Case (positive)":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; sk}!b) ->
                    {\subst uSub; (sk + 1)}!b));
        "Step Case (negative)":
            \replacewith( ==> ((leq(sk, 0) & {\subst uSub; sk}!b) ->
                    {\subst uSub; (sk - 1)}!b))
        \displayname "auto_induction"
    };

    // auto induction for: variable greater or equal to some term
    auto_int_induction_geq_Left1 {
        \find(\exists uSub; (t <= uSub & b) ==>)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}!b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}!b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_geq_Left2 {
        \find(\exists uSub; (uSub >= t & b) ==>)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t}!b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 0) & {\subst uSub; t + sk}!b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // auto induction for: variable greater than some term
    auto_int_induction_gt_Left1 {
        \find(\exists uSub; (t < uSub & b) ==>)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}!b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}!b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    auto_int_induction_gt_Left2 {
        \find(\exists uSub; (uSub > t & b) ==>)
        \varcond(\newDependingOn(sk, b), \notFreeIn(uSub, t))
        "Base Case":
            \replacewith( ==> #ExpandQueries({\subst uSub; t + 1}!b, true));
        "Step Case":
            \replacewith( ==> ((geq(sk, 1) & {\subst uSub; t + sk}!b) ->
                    #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)))
        \heuristics(auto_induction, induction_var)
        \displayname "auto_induction"
    };

    // ##########################################################################################################


    // ##########################################################################################################

}

// ---------------------------------------------------------
// ------------- split an equation into inequations --------
// ---------------------------------------------------------

\rules {

    splitEquation {
        \find(splitEqLeft = splitEqRight)
        \replacewith(splitEqLeft >= splitEqRight & splitEqLeft <= splitEqRight)
    };

    splitEquationSucc {
        \find( ==> splitEqLeft = splitEqRight)
        \replacewith( ==> splitEqLeft >= splitEqRight);
        \replacewith( ==> splitEqLeft <= splitEqRight)
        \heuristics(inEqSimp_nonLin, inEqSimp_split_eq, notHumanReadable)
    };
}

// ---------------------------------------------------------
// ------------- normalisation of polynomials --------------
// ---------------------------------------------------------

\rules {

    polySimp_elimSub {
        \find(sub(i, i0))
        \replacewith(add(i, mul(i0, -1)))
        \heuristics(polySimp_expand, polySimp_elimSubNeg)
    };

    polySimp_elimNeg {
        \find(neg(i))
        \replacewith(mul(i, -1))
        \heuristics(polySimp_expand, polySimp_elimSubNeg)
    };

    polySimp_elimOne {
        \find(mul(i, 1))
        \replacewith(i)
        \heuristics(polySimp_expand, polySimp_elimOneRight)
    };

    polySimp_elimOneLeft0 {
        \find(mul(1, i))
        \replacewith(i)
        \heuristics(polySimp_expand, polySimp_elimOneLeft)
    };

    polySimp_elimOneLeft1 {
        \find(mul(mul(i0, 1), i))
        \replacewith(mul(i0, i))
        \heuristics(polySimp_expand, polySimp_elimOneLeft)
    };

    polySimp_homoEq {
        \find(homoLeft = homoRight)
        \replacewith(add(homoRight, mul(homoLeft, -1)) = 0)
        \heuristics(polySimp_expand, polySimp_homo, notHumanReadable)
    };

    polySimp_rightDist {
        \find(mul(distCoeff, add(distSummand0, distSummand1)))
        \replacewith(add(mul(distCoeff, distSummand0),
                mul(distSummand1, distCoeff)))
        \heuristics(polySimp_expand, polySimp_dist)
    };

    polySimp_addAssoc {
        \find(add(addAssocPoly0, add(addAssocPoly1, addAssocMono)))
        \replacewith(add(add(addAssocPoly0, addAssocPoly1), addAssocMono))
        \heuristics(polySimp_expand, polySimp_addAssoc)
    };

    polySimp_mulAssoc {
        \find(mul(mulAssocMono0, mul(mulAssocMono1, mulAssocAtom)))
        \replacewith(mul(mul(mulAssocMono0, mulAssocMono1), mulAssocAtom))
        \heuristics(polySimp_expand, polySimp_mulAssoc)
    };

    polySimp_addComm0 {
        \find(add(commLeft, commRight))
        \replacewith(add(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    polySimp_addComm1 {
        \find(add(add(i0, commLeft), commRight))
        \replacewith(add(add(i0, commRight), commLeft))
        \heuristics(polySimp_expand, polySimp_addOrder)
    };

    polySimp_mulComm0 {
        \find(mul(commLeft, commRight))
        \replacewith(mul(commRight, commLeft))
        \heuristics(polySimp_expand, polySimp_mulOrder)
    };

    polySimp_mulComm1 {
        \find(mul(mul(i0, commLeft), commRight))
        \replacewith(mul(mul(i0, commRight), commLeft))
        \heuristics(polySimp_expand, polySimp_mulOrder)
    };

    polySimp_addLiterals {
        \find(add(add(i, Z(iz)), Z(jz)))
        \replacewith(add(i, #add(Z(iz), Z(jz))))
        \heuristics(simplify_literals)
    };

    polySimp_mulLiterals {
        \find(mul(mul(i, Z(iz)), Z(jz)))
        \replacewith(mul(i, #mul(Z(iz), Z(jz))))
        \heuristics(simplify_literals)
    };

    polySimp_pullOutFactor0 {
        \find(add(mul(pullOutCommon, pullOutLeft),
                mul(pullOutCommon, pullOutRight)))
        \replacewith(mul(pullOutCommon,
                add(pullOutLeft, pullOutRight)))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor1 {
        \find(add(pullOutCommon,
                mul(pullOutCommon, pullOutRight)))
        \replacewith(mul(pullOutCommon,
                add(1, pullOutRight)))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor2 {
        \find(add(mul(pullOutCommon, pullOutLeft),
                pullOutCommon))
        \replacewith(mul(pullOutCommon,
                add(pullOutLeft, 1)))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor3 {
        \find(add(pullOutCommon, pullOutCommon))
        \replacewith(mul(pullOutCommon, 2))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor0b {
        \find(add(add(i0, mul(pullOutCommon, pullOutLeft)),
                mul(pullOutCommon, pullOutRight)))
        \replacewith(add(i0, mul(pullOutCommon,
                    add(pullOutLeft, pullOutRight))))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor1b {
        \find(add(add(i0, pullOutCommon),
                mul(pullOutCommon, pullOutRight)))
        \replacewith(add(i0, mul(pullOutCommon,
                    add(1, pullOutRight))))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor2b {
        \find(add(add(i0, mul(pullOutCommon, pullOutLeft)),
                pullOutCommon))
        \replacewith(add(i0, mul(pullOutCommon,
                    add(pullOutLeft, 1))))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_pullOutFactor3b {
        \find(add(add(i0, pullOutCommon), pullOutCommon))
        \replacewith(add(i0, mul(pullOutCommon, 2)))
        \heuristics(polySimp_expand, polySimp_pullOutFactor)
    };

    polySimp_invertEq {
        \find(invertLeft = invertRight)
        \replacewith(invertLeft * (-1) = invertRight * (-1))
        \heuristics(polySimp_directEquations, polySimp_normalise)
    };

    polySimp_sepPosMonomial {
        \find(add(sepResidue, sepPosMono) = 0)
        \replacewith(sepPosMono = mul(sepResidue, -1))
        \heuristics(polySimp_directEquations, polySimp_balance, notHumanReadable)
    };

    polySimp_sepNegMonomial {
        \find(add(sepResidue, sepNegMono) = 0)
        \replacewith(mul(sepNegMono, -1) = sepResidue)
        \heuristics(polySimp_directEquations, polySimp_balance)
    };

    apply_eq_monomials {
        \assumes(applyEqDivisor = i0 ==>)
        \find(applyEqDividend)
        \sameUpdateLevel
        \replacewith(#divideMonomials(applyEqDividend, applyEqDivisor) *
            (i0 + applyEqDivisor * -1)
            + applyEqDividend)
        \heuristics(polySimp_applyEq, apply_equations, notHumanReadable)
    };

    apply_eq_monomials_rigid {
        \assumes(applyEqDivisorr = i0r ==>)
        \find(applyEqDividend)
        \replacewith(#divideMonomials(applyEqDividend, applyEqDivisorr) *
            (i0r + applyEqDivisorr * -1)
            + applyEqDividend)
        \heuristics(polySimp_applyEqRigid, apply_equations, notHumanReadable)
    };

    apply_eq_pseudo_eq {
        \assumes(aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==>)
        \find(aePseudoTargetLeft = aePseudoTargetRight)
        \sameUpdateLevel
        \replacewith(\if(aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                & aePseudoLeftCoeff != 0)
                \then(aePseudoRight * aePseudoTargetFactor
                    = aePseudoTargetRight * aePseudoLeftCoeff)
                \else(aePseudoTargetLeft = aePseudoTargetRight))
        \heuristics(polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable, notHumanReadable)
    };

    apply_eq_pseudo_leq {
        \assumes(aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==>)
        \find(aePseudoTargetLeft <= aePseudoTargetRight)
        \sameUpdateLevel
        \replacewith(\if(aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                & aePseudoLeftCoeff > 0)
                \then(aePseudoRight * aePseudoTargetFactor
                    <= aePseudoTargetRight * aePseudoLeftCoeff)
                \else(aePseudoTargetLeft <= aePseudoTargetRight))
        \heuristics(polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable)
    };

    apply_eq_pseudo_geq {
        \assumes(aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==>)
        \find(aePseudoTargetLeft >= aePseudoTargetRight)
        \sameUpdateLevel
        \replacewith(\if(aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                & aePseudoLeftCoeff > 0)
                \then(aePseudoRight * aePseudoTargetFactor
                    >= aePseudoTargetRight * aePseudoLeftCoeff)
                \else(aePseudoTargetLeft >= aePseudoTargetRight))
        \heuristics(polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable)
    };

    polySimp_critPair {
        \assumes(cpLeft1 = cpRight1 ==>)
        \find(cpLeft2 = cpRight2 ==>)
        \add(#divideLCRMonomials(cpLeft2, cpLeft1)
            * (-1 * cpRight1 + cpLeft1)
            +
            #divideLCRMonomials(cpLeft1, cpLeft2)
            * (cpRight2 + -1 * cpLeft2)
            = 0 ==>)
        \heuristics(polySimp_saturate, polySimp_critPair, notHumanReadable)
    };

}

// ---------------------------------------------------------
// ------------- normalisation of inequations --------------
// ---------------------------------------------------------

\rules {

    inEqSimp_ltRight {
        \find( ==> i < i0)
        \replacewith((-1) * i0 + i >= 0 ==>)
        \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
    };

    inEqSimp_gtRight {
        \find( ==> i > i0)
        \replacewith((-1) * i0 + i <= 0 ==>)
        \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
    };

    inEqSimp_leqRight {
        \find( ==> i <= i0)
        \replacewith((-1) + (-1) * i0 + i >= 0 ==>)
        \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
    };

    inEqSimp_geqRight {
        \find( ==> i >= i0)
        \replacewith(1 + (-1) * i0 + i <= 0 ==>)
        \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
    };

    inEqSimp_ltToLeq {
        \find(i < i0)
        \replacewith(1 + (-1) * i0 + i <= 0)
        \heuristics(inEqSimp_expand, inEqSimp_makeNonStrict, notHumanReadable)
    };

    inEqSimp_gtToGeq {
        \find(i > i0)
        \replacewith((-1) + (-1) * i0 + i >= 0)
        \heuristics(inEqSimp_expand, inEqSimp_makeNonStrict, notHumanReadable)
    };

    inEqSimp_commuteLeq {
        \find(commLeft <= commRight)
        \replacewith(commRight >= commLeft)
        \heuristics(inEqSimp_expand, inEqSimp_commute)
    };

    inEqSimp_commuteGeq {
        \find(commLeft >= commRight)
        \replacewith(commRight <= commLeft)
        \heuristics(inEqSimp_expand, inEqSimp_commute)
    };

    inEqSimp_homoInEq0 {
        \find(homoLeft <= homoRight)
        \replacewith(add(homoRight, mul(homoLeft, -1)) >= 0)
        \heuristics(inEqSimp_expand, inEqSimp_homo, notHumanReadable)
    };

    inEqSimp_homoInEq1 {
        \find(homoLeft >= homoRight)
        \replacewith(add(homoRight, mul(homoLeft, -1)) <= 0)
        \heuristics(inEqSimp_expand, inEqSimp_homo, notHumanReadable)
    };

    inEqSimp_invertInEq0 {
        \find(invertLeft <= invertRight)
        \replacewith(invertLeft * (-1) >= invertRight * (-1))
        \heuristics(inEqSimp_directInEquations, inEqSimp_normalise, notHumanReadable)
    };

    inEqSimp_invertInEq1 {
        \find(invertLeft >= invertRight)
        \replacewith(invertLeft * (-1) <= invertRight * (-1))
        \heuristics(inEqSimp_directInEquations, inEqSimp_normalise, notHumanReadable)
    };

    inEqSimp_sepPosMonomial0 {
        \find(add(sepResidue, sepPosMono) <= 0)
        \replacewith(sepPosMono <= mul(sepResidue, -1))
        \heuristics(inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
    };

    inEqSimp_sepNegMonomial0 {
        \find(add(sepResidue, sepNegMono) <= 0)
        \replacewith(mul(sepNegMono, -1) >= sepResidue)
        \heuristics(inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
    };

    inEqSimp_sepPosMonomial1 {
        \find(add(sepResidue, sepPosMono) >= 0)
        \replacewith(sepPosMono >= mul(sepResidue, -1))
        \heuristics(inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
    };

    inEqSimp_sepNegMonomial1 {
        \find(add(sepResidue, sepNegMono) >= 0)
        \replacewith(mul(sepNegMono, -1) <= sepResidue)
        \heuristics(inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
    };

    inEqSimp_antiSymm {
        \assumes(i <= i0 ==>)
        \find(i >= i0 ==>)
        \add(i = i0 ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_antiSymm)
    };

    inEqSimp_exactShadow0 {
        \assumes(mul(esLeft, esCoeff1) <= esRight1 ==>)
        \find(mul(esLeft, esCoeff2) >= esRight2 ==>)
        \add((esCoeff1 > 0 & esCoeff2 > 0)
            ->
            (-1) * mul(esCoeff1, esRight2)
            + mul(esCoeff2, esRight1) >= 0
            ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable)
    };

    inEqSimp_exactShadow1 {
        \assumes(esLeft <= esRight1 ==>)
        \find(mul(esLeft, esCoeff2) >= esRight2 ==>)
        \add((esCoeff2 > 0)
            ->
            (-1) * esRight2 + mul(esCoeff2, esRight1) >= 0
            ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable)
    };

    inEqSimp_exactShadow2 {
        \assumes(mul(esLeft, esCoeff1) <= esRight1 ==>)
        \find(esLeft >= esRight2 ==>)
        \add((esCoeff1 > 0)
            ->
            (-1) * mul(esCoeff1, esRight2) + esRight1 >= 0
            ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable)
    };

    inEqSimp_exactShadow3 {
        \assumes(esLeft <= esRight1 ==>)
        \find(esLeft >= esRight2 ==>)
        \add((-1) * esRight2 + esRight1 >= 0 ==>)
        \heuristics(inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable)
    };

    inEqSimp_subsumption0 {
        \assumes(subsumLeft <= subsumRightSmaller ==>)
        \find(subsumLeft <= subsumRightBigger)
        \sameUpdateLevel
        \replacewith(subsumRightSmaller <= subsumRightBigger |
            subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption1 {
        \assumes(subsumLeft >= subsumRightBigger ==>)
        \find(subsumLeft >= subsumRightSmaller)
        \sameUpdateLevel
        \replacewith(subsumRightSmaller <= subsumRightBigger |
            subsumLeft >= subsumRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption2 {
        \assumes(subsumLeft * subsumCoeffSmaller <= subsumRightSmaller ==>)
        \find(subsumLeft * subsumCoeffBigger <= subsumRightBigger)
        \sameUpdateLevel
        \replacewith((subsumCoeffSmaller > 0
                & subsumCoeffBigger > 0
                & subsumCoeffBigger * subsumRightSmaller <=
                subsumCoeffSmaller * subsumRightBigger) |
            subsumLeft * subsumCoeffBigger <= subsumRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption4 {
        \assumes(subsumLeft <= subsumRightSmaller ==>)
        \find(subsumLeft * subsumCoeffBigger <= subsumRightBigger)
        \sameUpdateLevel
        \replacewith((subsumCoeffBigger > 0
                & subsumCoeffBigger * subsumRightSmaller <=
                subsumRightBigger) |
            subsumLeft * subsumCoeffBigger <= subsumRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption5 {
        \assumes(subsumLeft * subsumCoeffBigger >= subsumRightBigger ==>)
        \find(subsumLeft * subsumCoeffSmaller >= subsumRightSmaller)
        \sameUpdateLevel
        \replacewith((subsumCoeffSmaller > 0
                & subsumCoeffBigger > 0
                & subsumCoeffBigger * subsumRightSmaller <=
                subsumCoeffSmaller * subsumRightBigger) |
            subsumLeft * subsumCoeffSmaller >= subsumRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_subsumption6 {
        \assumes(subsumLeft >= subsumRightBigger ==>)
        \find(subsumLeft * subsumCoeffSmaller >= subsumRightSmaller)
        \sameUpdateLevel
        \replacewith((subsumCoeffSmaller > 0
                & subsumRightSmaller <=
                subsumCoeffSmaller * subsumRightBigger) |
            subsumLeft * subsumCoeffSmaller >= subsumRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable)
    };

    inEqSimp_contradInEq0 {
        \assumes(contradLeft <= contradRightSmaller ==>)
        \find(contradLeft >= contradRightBigger)
        \sameUpdateLevel
        \replacewith(contradRightSmaller >= contradRightBigger &
            contradLeft >= contradRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq1 {
        \assumes(contradLeft >= contradRightBigger ==>)
        \find(contradLeft <= contradRightSmaller)
        \sameUpdateLevel
        \replacewith(contradRightSmaller >= contradRightBigger &
            contradLeft <= contradRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq2 {
        \assumes(contradLeft * contradCoeffSmaller <= contradRightSmaller ==>)
        \find(contradLeft * contradCoeffBigger >= contradRightBigger)
        \sameUpdateLevel
        \replacewith((contradCoeffSmaller > 0 ->
                contradCoeffBigger > 0 ->
                contradCoeffBigger * contradRightSmaller >=
                contradCoeffSmaller * contradRightBigger) &
            contradLeft * contradCoeffBigger >= contradRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq3 {
        \assumes(contradLeft <= contradRightSmaller ==>)
        \find(contradLeft * contradCoeffBigger >= contradRightBigger)
        \sameUpdateLevel
        \replacewith((contradCoeffBigger > 0 ->
                contradCoeffBigger * contradRightSmaller >=
                contradRightBigger) &
            contradLeft * contradCoeffBigger >= contradRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq4 {
        \assumes(contradLeft * contradCoeffBigger >= contradRightBigger ==>)
        \find(contradLeft * contradCoeffSmaller <= contradRightSmaller)
        \sameUpdateLevel
        \replacewith((contradCoeffSmaller > 0 ->
                contradCoeffBigger > 0 ->
                contradCoeffBigger * contradRightSmaller >=
                contradCoeffSmaller * contradRightBigger) &
            contradLeft * contradCoeffSmaller <= contradRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_contradInEq5 {
        \assumes(contradLeft >= contradRightBigger ==>)
        \find(contradLeft * contradCoeffSmaller <= contradRightSmaller)
        \sameUpdateLevel
        \replacewith((contradCoeffSmaller > 0 ->
                contradRightSmaller >=
                contradCoeffSmaller * contradRightBigger) &
            contradLeft * contradCoeffSmaller <= contradRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_contradInEqs, notHumanReadable)
    };

    inEqSimp_strengthen0 {
        \assumes( ==> strengthenLeft = strengthenRight)
        \find(strengthenLeft <= strengthenRight ==>)
        \replacewith(strengthenLeft <= -1 + strengthenRight ==>)
        \heuristics(inEqSimp_propagation, inEqSimp_strengthen, notHumanReadable)
    };

    inEqSimp_strengthen1 {
        \assumes( ==> strengthenLeft = strengthenRight)
        \find(strengthenLeft >= strengthenRight ==>)
        \replacewith(strengthenLeft >= 1 + strengthenRight ==>)
        \heuristics(inEqSimp_propagation, inEqSimp_strengthen, notHumanReadable)
    };

    inEqSimp_contradEq3 {
        \assumes(contradLeft <= contradRightSmaller ==>)
        \find(contradLeft = contradRightBigger)
        \sameUpdateLevel
        \replacewith(contradRightSmaller + (-1) * contradRightBigger >= 0 &
            contradLeft = contradRightBigger)
        \heuristics(inEqSimp_propagation, inEqSimp_contradEqs, notHumanReadable)
    };

    inEqSimp_contradEq7 {
        \assumes(contradLeft >= contradRightBigger ==>)
        \find(contradLeft = contradRightSmaller)
        \sameUpdateLevel
        \replacewith(contradRightBigger + (-1) * contradRightSmaller <= 0 &
            contradLeft = contradRightSmaller)
        \heuristics(inEqSimp_propagation, inEqSimp_contradEqs, notHumanReadable)
    };

    \lemma
    irrflConcrete1 {
        \find(i < i ==>)
        \replacewith(false ==>)
        \heuristics(concrete)
    };
    \lemma
    irrflConcrete2 {
        \find(i > i ==>)
        \replacewith(false ==>)
        \heuristics(concrete)
    };

    // PHS 13.03.2019
    // This taclet appears here because its proof uses  induction
    \lemma
    cancel_gtPos {
        \schemaVar \term int Less, More, Fac;
        \assumes(Fac > 0 ==>)
        \find(Less < More ==>)
        \add(Less * Fac < More * Fac ==>)
    };

    // PHS 14.03.2019
    // This taclet appears here because its proof uses  induction
    \lemma
    cancel_gtNeg {
        \schemaVar \term int Less, More, Fac;
        \assumes(Fac < 0 ==>)
        \find(Less < More ==>)
        \add(Less * Fac > More * Fac ==>)
    };

}

// ---------------------------------------------------------------------------
// ------------- formula normalisation ---------------------------------------
// ---------------------------------------------------------------------------

// conjunctions and disjunctions are normalised so that they are left-associative,
// <= is left of >= is left of = (provided that the left sides are equal)

\rules {

    inEqSimp_notLeq {
        \find(!(i <= i0))
        \replacewith((-1) + (-1) * i0 + i >= 0)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)
    };

    inEqSimp_notGeq {
        \find(!(i >= i0))
        \replacewith(1 + (-1) * i0 + i <= 0)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)
    };

    inEqSimp_and_antiSymm0 {
        \find(i <= i0 & i >= i0)
        \replacewith(i = i0)
        \heuristics(inEqSimp_forNormalisation)
    };

    inEqSimp_and_antiSymm1 {
        \find((b & i <= i0) & i >= i0)
        \replacewith(b & i = i0)
        \heuristics(inEqSimp_forNormalisation)
    };

    inEqSimp_and_contradInEq0 {
        \find(contradLeft <= contradRightSmaller
            & contradLeft >= contradRightBigger)
        \replacewith((contradLeft <= contradRightSmaller
                & contradLeft >= contradRightBigger)
            & contradRightSmaller >= contradRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_contradInEqs,
            notHumanReadable)
    };

    inEqSimp_and_contradInEq1 {
        \find((b & contradLeft <= contradRightSmaller)
            & contradLeft >= contradRightBigger)
        \replacewith(((b & contradLeft <= contradRightSmaller)
                & contradLeft >= contradRightBigger)
            & contradRightSmaller >= contradRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_contradInEqs,
            notHumanReadable)
    };

    inEqSimp_and_strengthen0 {
        \find(strengthenLeft <= strengthenRight
            & strengthenLeft != strengthenRight)
        \replacewith(strengthenLeft <= -1 + strengthenRight)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)

    };

    inEqSimp_and_strengthen1 {
        \find(strengthenLeft >= strengthenRight
            & strengthenLeft != strengthenRight)
        \replacewith(strengthenLeft >= 1 + strengthenRight)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)
    };

    inEqSimp_and_strengthen2 {
        \find((b & strengthenLeft <= strengthenRight)
            & strengthenLeft != strengthenRight)
        \replacewith(b & strengthenLeft <= -1 + strengthenRight)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)

    };

    inEqSimp_and_strengthen3 {
        \find((b & strengthenLeft >= strengthenRight)
            & strengthenLeft != strengthenRight)
        \replacewith(b & strengthenLeft >= 1 + strengthenRight)
        \heuristics(inEqSimp_forNormalisation, notHumanReadable)
    };

    inEqSimp_and_subsumption0 {
        \find(subsumLeft <= subsumRightSmaller
            & subsumLeft <= subsumRightBigger)
        \replacewith(subsumLeft <= subsumRightSmaller
            & (subsumRightSmaller <= subsumRightBigger
                | subsumLeft <= subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption, notHumanReadable)
    };

    inEqSimp_and_subsumption1 {
        \find((b & subsumLeft <= subsumRightSmaller)
            & subsumLeft <= subsumRightBigger)
        \replacewith((b & subsumLeft <= subsumRightSmaller)
            & (subsumRightSmaller <= subsumRightBigger
                | subsumLeft <= subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption, notHumanReadable)
    };

    inEqSimp_and_subsumption2 {
        \find(subsumLeft >= subsumRightSmaller
            & subsumLeft >= subsumRightBigger)
        \replacewith((subsumRightSmaller <= subsumRightBigger
                | subsumLeft >= subsumRightSmaller)
            & subsumLeft >= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption, notHumanReadable)
    };

    inEqSimp_and_subsumption3 {
        \find((b & subsumLeft >= subsumRightSmaller)
            & subsumLeft >= subsumRightBigger)
        \replacewith((b & (subsumRightSmaller <= subsumRightBigger
                    | subsumLeft >= subsumRightSmaller))
            & subsumLeft >= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption, notHumanReadable)
    };

    inEqSimp_and_subsumption4 {
        \find(subsumLeft <= subsumRightSmaller
            & subsumLeft != subsumRightBigger)
        \replacewith(subsumLeft <= subsumRightSmaller
            & (subsumRightSmaller < subsumRightBigger
                | subsumLeft != subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_subsumptionEq, notHumanReadable)
    };

    inEqSimp_and_subsumption5 {
        \find((b & subsumLeft <= subsumRightSmaller)
            & subsumLeft != subsumRightBigger)
        \replacewith((b & subsumLeft <= subsumRightSmaller)
            & (subsumRightSmaller < subsumRightBigger
                | subsumLeft != subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_subsumptionEq, notHumanReadable)
    };

    inEqSimp_and_subsumption6 {
        \find(subsumLeft >= subsumRightBigger
            & subsumLeft != subsumRightSmaller)
        \replacewith(subsumLeft >= subsumRightBigger
            & (subsumRightSmaller < subsumRightBigger
                | subsumLeft != subsumRightSmaller))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_subsumptionEq, notHumanReadable)
    };

    inEqSimp_and_subsumption7 {
        \find((b & subsumLeft >= subsumRightBigger)
            & subsumLeft != subsumRightSmaller)
        \replacewith((b & subsumLeft >= subsumRightBigger)
            & (subsumRightSmaller < subsumRightBigger
                | subsumLeft != subsumRightSmaller))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_and_subsumptionEq, notHumanReadable)
    };

    inEqSimp_or_antiSymm0 {
        \find(antiSymmLeft <= antiSymmRightSmaller
            | antiSymmLeft >= antiSymmRightBigger)
        \replacewith(\if(2 + antiSymmRightSmaller
                = antiSymmRightBigger)
                \then(antiSymmLeft != 1 + antiSymmRightSmaller)
                \else(antiSymmLeft <= antiSymmRightSmaller
                    | antiSymmLeft >= antiSymmRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_antiSymm, notHumanReadable)
    };

    inEqSimp_or_antiSymm1 {
        \find((b | antiSymmLeft <= antiSymmRightSmaller)
            | antiSymmLeft >= antiSymmRightBigger)
        \replacewith(b |
            \if(2 + antiSymmRightSmaller
                = antiSymmRightBigger)
                \then(antiSymmLeft != 1 + antiSymmRightSmaller)
                \else(antiSymmLeft <= antiSymmRightSmaller
                    | antiSymmLeft >= antiSymmRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_antiSymm, notHumanReadable)
    };

    inEqSimp_or_tautInEq0 {
        \find(tautLeft <= tautRightBigger
            | tautLeft >= tautRightSmaller)
        \replacewith((tautLeft <= tautRightBigger
                | tautLeft >= tautRightSmaller)
            | tautRightBigger >= (-1) + tautRightSmaller)
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable)
    };

    inEqSimp_or_tautInEq1 {
        \find((b | tautLeft <= tautRightBigger)
            | tautLeft >= tautRightSmaller)
        \replacewith(((b | tautLeft <= tautRightBigger)
                | tautLeft >= tautRightSmaller)
            | tautRightBigger >= (-1) + tautRightSmaller)
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable)
    };

    inEqSimp_or_tautInEq2 {
        \find(tautLeft >= tautRightSmaller
            | tautLeft <= tautRightBigger)
        \replacewith((tautLeft >= tautRightSmaller
                | tautLeft <= tautRightBigger)
            | tautRightBigger >= (-1) + tautRightSmaller)
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable)
    };

    inEqSimp_or_tautInEq3 {
        \find((b | tautLeft >= tautRightSmaller)
            | tautLeft <= tautRightBigger)
        \replacewith(((b | tautLeft >= tautRightSmaller)
                | tautLeft <= tautRightBigger)
            | tautRightBigger >= (-1) + tautRightSmaller)
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable)
    };

    inEqSimp_or_weaken0 {
        \find(weakenLeft <= weakenRightSmaller
            | weakenLeft = weakenRightBigger)
        \replacewith(\if(weakenRightBigger = 1 + weakenRightSmaller)
                \then(weakenLeft <= weakenRightBigger)
                \else(weakenLeft <= weakenRightSmaller
                    | weakenLeft = weakenRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable)
    };

    inEqSimp_or_weaken1 {
        \find(weakenLeft = weakenRightSmaller
            | weakenLeft >= weakenRightBigger)
        \replacewith(\if(weakenRightBigger = 1 + weakenRightSmaller)
                \then(weakenLeft >= weakenRightSmaller)
                \else(weakenLeft = weakenRightSmaller
                    | weakenLeft >= weakenRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable)
    };

    inEqSimp_or_weaken2 {
        \find((b | weakenLeft <= weakenRightSmaller)
            | weakenLeft = weakenRightBigger)
        \replacewith(b |
            \if(weakenRightBigger = 1 + weakenRightSmaller)
                \then(weakenLeft <= weakenRightBigger)
                \else(weakenLeft <= weakenRightSmaller
                    | weakenLeft = weakenRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable)
    };

    inEqSimp_or_weaken3 {
        \find((b | weakenLeft = weakenRightSmaller)
            | weakenLeft >= weakenRightBigger)
        \replacewith(b |
            \if(weakenRightBigger = 1 + weakenRightSmaller)
                \then(weakenLeft >= weakenRightSmaller)
                \else(weakenLeft = weakenRightSmaller
                    | weakenLeft >= weakenRightBigger))
        \heuristics(inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable)
    };

    inEqSimp_or_subsumption0 {
        \find(subsumLeft <= subsumRightSmaller
            | subsumLeft <= subsumRightBigger)
        \replacewith((subsumRightSmaller >= subsumRightBigger
                & subsumLeft <= subsumRightSmaller)
            | subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption1 {
        \find((b | subsumLeft <= subsumRightSmaller)
            | subsumLeft <= subsumRightBigger)
        \replacewith((b | (subsumRightSmaller >= subsumRightBigger
                    & subsumLeft <= subsumRightSmaller))
            | subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption2 {
        \find(subsumLeft >= subsumRightSmaller
            | subsumLeft >= subsumRightBigger)
        \replacewith(subsumLeft >= subsumRightSmaller
            | (subsumRightSmaller >= subsumRightBigger
                & subsumLeft >= subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption3 {
        \find((b | subsumLeft >= subsumRightSmaller)
            | subsumLeft >= subsumRightBigger)
        \replacewith((b | subsumLeft >= subsumRightSmaller)
            | (subsumRightSmaller >= subsumRightBigger
                & subsumLeft >= subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption4 {
        \find(subsumLeft = subsumRightSmaller
            | subsumLeft <= subsumRightBigger)
        \replacewith((subsumRightSmaller > subsumRightBigger
                & subsumLeft = subsumRightSmaller)
            | subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption5 {
        \find((b | subsumLeft = subsumRightSmaller)
            | subsumLeft <= subsumRightBigger)
        \replacewith((b | (subsumRightSmaller > subsumRightBigger
                    & subsumLeft = subsumRightSmaller))
            | subsumLeft <= subsumRightBigger)
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption6 {
        \find(subsumLeft >= subsumRightSmaller
            | subsumLeft = subsumRightBigger)
        \replacewith(subsumLeft >= subsumRightSmaller
            | (subsumRightSmaller > subsumRightBigger
                & subsumLeft = subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    inEqSimp_or_subsumption7 {
        \find((b | subsumLeft >= subsumRightSmaller)
            | subsumLeft = subsumRightBigger)
        \replacewith((b | subsumLeft >= subsumRightSmaller)
            | (subsumRightSmaller > subsumRightBigger
                & subsumLeft = subsumRightBigger))
        \heuristics(inEqSimp_forNormalisation,
            inEqSimp_andOr_subsumption,
            notHumanReadable)
    };

    applyEq_and_int0 {
        \find(applyEqLeft >= applyEqOther
            & applyEqLeft = applyEqRight)
        \replacewith(applyEqRight >= applyEqOther
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int1 {
        \find((b & applyEqLeft >= applyEqOther)
            & applyEqLeft = applyEqRight)
        \replacewith((b & applyEqRight >= applyEqOther)
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int2 {
        \find(applyEqLeft <= applyEqOther
            & applyEqLeft = applyEqRight)
        \replacewith(applyEqRight <= applyEqOther
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int3 {
        \find((b & applyEqLeft <= applyEqOther)
            & applyEqLeft = applyEqRight)
        \replacewith((b & applyEqRight <= applyEqOther)
            & applyEqLeft = applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int4 {
        \find(applyEqLeft = applyEqRight
            & applyEqLeft >= applyEqOther)
        \replacewith(applyEqLeft = applyEqRight
            & applyEqRight >= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int5 {
        \find((b & applyEqLeft = applyEqRight)
            & applyEqLeft >= applyEqOther)
        \replacewith((b & applyEqLeft = applyEqRight)
            & applyEqRight >= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int6 {
        \find(applyEqLeft = applyEqRight
            & applyEqLeft <= applyEqOther)
        \replacewith(applyEqLeft = applyEqRight
            & applyEqRight <= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_and_int7 {
        \find((b & applyEqLeft = applyEqRight)
            & applyEqLeft <= applyEqOther)
        \replacewith((b & applyEqLeft = applyEqRight)
            & applyEqRight <= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int0 {
        \find(applyEqLeft >= applyEqOther
            | applyEqLeft != applyEqRight)
        \replacewith(applyEqRight >= applyEqOther
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int1 {
        \find((b | applyEqLeft >= applyEqOther)
            | applyEqLeft != applyEqRight)
        \replacewith((b | applyEqRight >= applyEqOther)
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int2 {
        \find(applyEqLeft <= applyEqOther
            | applyEqLeft != applyEqRight)
        \replacewith(applyEqRight <= applyEqOther
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int3 {
        \find((b | applyEqLeft <= applyEqOther)
            | applyEqLeft != applyEqRight)
        \replacewith((b | applyEqRight <= applyEqOther)
            | applyEqLeft != applyEqRight)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int4 {
        \find(applyEqLeft != applyEqRight
            | applyEqLeft >= applyEqOther)
        \replacewith(applyEqLeft != applyEqRight
            | applyEqRight >= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int5 {
        \find((b | applyEqLeft != applyEqRight)
            | applyEqLeft >= applyEqOther)
        \replacewith((b | applyEqLeft != applyEqRight)
            | applyEqRight >= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int6 {
        \find(applyEqLeft != applyEqRight
            | applyEqLeft <= applyEqOther)
        \replacewith(applyEqLeft != applyEqRight
            | applyEqRight <= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

    applyEq_or_int7 {
        \find((b | applyEqLeft != applyEqRight)
            | applyEqLeft <= applyEqOther)
        \replacewith((b | applyEqLeft != applyEqRight)
            | applyEqRight <= applyEqOther)
        \heuristics(apply_equations_andOr)
    };

}

// ---------------------------------------------------------------------------
// ------------- dividing equations and inequations by literals --------------
// ---------------------------------------------------------------------------

\rules(integerSimplificationRules:full) {

    cancel_equation {
        \schemaVar \term int eqLeft, eqRight, Fac;
        \find(eqLeft * Fac = eqRight * Fac)
        \replacewith(eqLeft = eqRight);
        \add( ==> Fac != 0)
        \heuristics(simplify_enlarging)
    };

    divide_equation {
        \find(elimGcdLeft = elimGcdRight)
        \replacewith(\if(elimGcd >= 1
                & elimGcdLeft % elimGcd = 0
                & elimGcdRight % elimGcd <= (-1) + elimGcd)
                \then(elimGcdRight % elimGcd = 0
                    & div(elimGcdLeft, elimGcd) = div(elimGcdRight, elimGcd))
                \else(elimGcdLeft = elimGcdRight))
    };

    divide_leq {
        \find(elimGcdLeft <= elimGcdRight)
        \replacewith(\if(elimGcd >= 1
                & elimGcdLeft % elimGcd = 0
                & elimGcdRight % elimGcd <= (-1) + elimGcd)
                \then(div(elimGcdLeft, elimGcd) <= div(elimGcdRight, elimGcd))
                \else(elimGcdLeft <= elimGcdRight))
    };

    divide_geq {
        \find(elimGcdLeft >= elimGcdRight)
        \replacewith(\if(elimGcd >= 1
                & elimGcdLeft % elimGcd = 0
                & elimGcdRight % elimGcd <= (-1) + elimGcd)
                \then(div(elimGcdLeft, elimGcd) >=
                    1 + div((-1) + elimGcdRight, elimGcd))
                \else(elimGcdLeft >= elimGcdRight))
    };

    elimGcdEq {
        \find(elimGcdLeft = elimGcdRight)
        \replacewith(\if(elimGcdLeftDiv * elimGcd = elimGcdLeft
                & elimGcdRight + (elimGcd * (-1)) * elimGcdRightDiv
                <= (-1) + elimGcd
                & elimGcdRight + (elimGcd * (-1)) * elimGcdRightDiv
                >= 0)
                \then(elimGcdRight + (elimGcd * (-1)) * elimGcdRightDiv = 0
                    & elimGcdLeftDiv = elimGcdRightDiv)
                \else(elimGcdLeft = elimGcdRight))
        \heuristics(polySimp_pullOutGcd, notHumanReadable)
    };

    elimGcdLeq {
        \find(elimGcdLeft <= elimGcdRight)
        \replacewith(\if(1 - elimGcd
                + (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
                + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                <= 0
                & (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
                + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                >= 0)
                \then(elimGcdLeftDiv <= elimGcdRightDiv)
                \else(elimGcdLeft <= elimGcdRight))
        \heuristics(inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_leq, notHumanReadable)
    };

    elimGcdGeq {
        \find(elimGcdLeft >= elimGcdRight)
        \replacewith(\if(elimGcd - 1
                + (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
                + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                >= 0
                & (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
                + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                <= 0)
                \then(elimGcdLeftDiv >= elimGcdRightDiv)
                \else(elimGcdLeft >= elimGcdRight))
        \heuristics(inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_geq, notHumanReadable)
    };

    elimGcdLeq_antec {
        \find(elimGcdLeft <= elimGcdRight ==>)
        \replacewith(elimGcd <= 0
            | -elimGcd
            + (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
            + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
            >= 0
            | elimGcdLeftDiv <= elimGcdRightDiv ==>)
        \heuristics(inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_leq, inEqSimp_pullOutGcd_antec, notHumanReadable)
    };

    elimGcdGeq_antec {
        \find(elimGcdLeft >= elimGcdRight ==>)
        \replacewith(elimGcd <= 0
            | elimGcd
            + (elimGcd * (-1)) * elimGcdRightDiv + elimGcdRight
            + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
            <= 0
            | elimGcdLeftDiv >= elimGcdRightDiv ==>)
        \heuristics(inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_geq, inEqSimp_pullOutGcd_antec, notHumanReadable)
    };

}

// ---------------------------------------------------------------------------
// ------------- case distinctions on the sign of a term ---------------------
// ---------------------------------------------------------------------------

\rules {
    sign_case_distinction {
        "#signCasesLeft is negative":
            \add(signCasesLeft <= -1 ==>);
        "#signCasesLeft is zero":
            \add(signCasesLeft = 0 ==>);
        "#signCasesLeft is positive":
            \add(signCasesLeft >= 1 ==>)
        \heuristics(inEqSimp_signCases)
    };

    // ---------------------------------------------------------------------------
    // ------------- squares are always non-negative -----------------------------
    // ---------------------------------------------------------------------------

    add_non_neg_square {
        \add(squareFac * squareFac >= 0 ==>)
        \heuristics(inEqSimp_special_nonLin,
            inEqSimp_nonNegSquares)
    };

    // ---------------------------------------------------------------------------
    // -------- operations defined using polynomials (division, modulo) ----------
    // ---------------------------------------------------------------------------


    //
    // Useful lemmas for elimination of inInt moduloInt chains
    //

    \lemma
    moduloIntIsInInt {
        \find(inInt(moduloInt(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    moduloLongIsInLong {
        \find(inLong(moduloLong(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    moduloShortIsInShort {
        \find(inShort(moduloShort(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    moduloByteIsInByte {
        \find(inByte(moduloByte(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    moduloCharIsInChar {
        \find(inChar(moduloChar(t)))
        \replacewith(true)

        \heuristics(concrete)
    };

}

// ---------------------------------------------------------------------------
// ------------- introduce new symbols for basis transformations -------------
// ---------------------------------------------------------------------------

\rules(integerSimplificationRules:full) {
    newSym_eq {
        \find(newSymLeft * newSymLeftCoeff = newSymRight ==>)
        \varcond(\newDependingOn(l, newSymDef),
            \newDependingOn(l, newSymLeft))
        \add(newSymLeft = l + newSymDef ==>)
        \heuristics(polySimp_leftNonUnit,
            polySimp_newSym, polySimp_newSmallSym)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

//
//  This file contains rule for integer powers and logs.
//

\schemaVariables {
    \term int base, exp, exp_2, x, x_2;
    \term numbers iz;
}

\rules {
    powDef {
        \schemaVar \variables int i;

        \find(pow(base, exp))
        \varcond(\notFreeIn(i, exp, base))
        \replacewith(
            \if(exp >= 0)
                \then(bprod{i;}(0, exp, base))
                \else(undefinedPow(base, exp))
        )
    };

    \lemma
    powConcrete0 {
        \find(pow(base, 0))
        \replacewith(
            1
        )
        \heuristics(simplify)
    };

    \lemma
    powConcrete1 {
        \find(pow(base, 1))
        \replacewith(
            base
        )
        \heuristics(simplify)
    };

    \lemma
    powSplitFactor {
        \find(pow(base, exp))
        \replacewith(
            \if(exp >= 0)
                \then(
                    \if(exp >= 1)
                        \then(base * pow(base, exp - 1))
                        \else(1)
                )
                \else(undefinedPow(base, exp))
        )
    };

    \lemma
    powAdd {
        \find(pow(base, exp + exp_2))
        \replacewith(
            \if(exp >= 0 & exp_2 >= 0)
                \then(pow(base, exp) * pow(base, exp_2))
                \else(pow(base, exp + exp_2))
        )
    };

    \lemma
    powMono {
        \find(pow(base, exp) <= pow(base, exp_2))
        \add(
            exp >= 0 & exp_2 >= exp & base >= 1 ->
            pow(base, exp) <= pow(base, exp_2) ==>
        )
    };

    \lemma
    powMonoConcrete {
        \find(pow(base, exp_2) <= -1 + pow(base, exp) ==>)
        \add(
            ==> exp >= 0 & exp_2 >= exp & base >= 1
        )
        \heuristics(simplify)
    };

    \lemma
    powMonoConcreteRight {
        \find( ==> pow(base, exp) <= pow(base, exp_2))
        \add(
            ==> exp >= 0 & exp_2 >= exp & base >= 1
        )
        \heuristics(concrete)
    };

    \lemma
    powPositive {
        \find(pow(base, exp))
        \add(
            exp >= 0 & base >= 1 ->
            pow(base, exp) >= 1 ==>
        )
    };

    \lemma
    powPositiveConcrete {
        \find(pow(base, exp) <= -1 ==>)
        \add(
            ==> exp >= 0 & base >= 1
        )
        \heuristics(simplify)
    };

    \lemma
    powGeq1Concrete {
        \find(pow(base, exp) <= 0 ==>)
        \add(
            ==> exp >= 0 & base >= 1
        )
        \heuristics(simplify)
    };

    \lemma
    pow2InIntLower {
        \find(pow(2, exp) <= -2147483649 ==>)
        \add(
            ==> exp >= 0
        )
        \heuristics(simplify)
    };

    \lemma
    pow2InIntUpper {
        \find(pow(2, exp) >= 2147483648 ==>)
        \add(
            ==> exp >= 0 & exp <= 30
        )
        \heuristics(simplify)
    };

    logDefinition {
        \find(log(base, x))
        \replacewith(
            \if(x >= 1 & base > 1)
                \then(
                    \if(x < base)
                        \then(0)
                        \else(1 + log(base, x/base))
                )
                \else(undefinedLog(base, x))
        )
    };

    \lemma
    logSelfConcrete {
        \find(log(base, base))
        \replacewith(\if(base > 1) \then(1) \else(undefinedLog(base, base)))
        \heuristics(simplify)
    };

    \lemma
    log1Concrete {
        \find(log(base, 1))
        \replacewith(\if(base > 1) \then(0) \else(undefinedLog(base, 1)))
        \heuristics(simplify)
    };

    \lemma
    logProduct {
        \find(log(base, x * base))
        \add(
            x >= 1 & base > 1 -> log(base, x * base) = log(base, x) + 1 ==>
        )
    };

    \lemma
    logTimesBaseConcrete {
        \find(log(base, x * base))
        \replacewith(
            \if(x >= 1 & base > 1)
                \then(log(base, x) + 1)
                \else(undefinedLog(base, x * base))
        )
        \heuristics(simplify)
    };

    // Works only when (x / 2) * (x_2 / 2) == (x * x_2) / 4
    // maybe if x, x_2 % 2 != 0 ??
    /*
    \lemma log2Mul {
        \find(log(2, x * x_2))
        \add(
            x >= 1 & x_2 >= 1 -> log(2, x * x_2) = log(2, x) + log(2, x_2) ==>
        )
    };
    */

    \lemma
    logProdIdentity {
        \schemaVar \variables int i;
        \find(log(base, bprod{i;}(0, exp, base)))
        \varcond(\notFreeIn(i, exp, base))
        \add(
            exp >= 0 & base > 1 -> log(base, bprod{i;}(0, exp, base)) = exp ==>
        )
    };

    \lemma
    logProdIdentityConcrete {
        \schemaVar \variables int i;
        \find(log(base, bprod{i;}(0, exp, base)))
        \varcond(\notFreeIn(i, exp, base))
        \replacewith(
            \if(base > 1)
                \then(
                    \if(exp < 0)
                        \then(0)
                        \else(exp)
                )
                \else(undefinedLog(base, bprod{i;}(0, exp, base)))
        )
        \heuristics(simplify)
    };

    \lemma
    logPowIdentity {
        \schemaVar \variables int i;
        \find(log(base, x))
        \varcond(\notFreeIn(i, x, base))
        \add(
            base > 1 -> \forall i; (i >= 0 -> log(base, pow(base, i)) = i) ==>
        )
    };

    \lemma
    logPowIdentityConcrete {
        \find(log(base, pow(base, exp)))
        \replacewith(
            \if(base > 1)
                \then(
                    \if(exp >= 0)
                        \then(exp)
                        \else(log(base, undefinedPow(base, exp)))
                )
                \else(undefinedLog(base, pow(base, exp)))
        )
        \heuristics(simplify)
    };

    \lemma
    logPositive {
        \find(log(base, x))
        \add(
            base > 1 & x >= 1 -> log(base, x) >= 0 ==>
        )
    };

    \lemma
    logPositiveConcrete {
        \find(log(base, x) <= -1 ==>)
        \add(
            ==> base > 1 & x >= 1
        )
        \heuristics(simplify)
    };

    \lemma
    logMono {
        \find(log(base, x) <= log(base, x_2))
        \add(
            x >= 1 & x_2 >= x & base > 1 ->
            log(base, x) <= log(base, x_2) ==>
        )
    };

    \lemma
    logMonoConcrete {
        \find(log(base, x_2) <= -1 + log(base, x) ==>)
        \add(
            ==> x >= 1 & x_2 >= x & base > 1
        )
        \heuristics(simplify)
    };

    \lemma
    powLogLess {
        \find(pow(base, log(base, exp)))
        \add(
            exp >= 1 & base > 1 ->
            pow(base, log(base, exp)) <= exp ==>
        )
    };

    // This could be extended to all bases, but e.g. base = 3 and x = 2 doesn't work
    \lemma
    powLogMore2 {
        \find(pow(base, log(base, x)))
        \add(
            base = 2 & x >= 1 -> x - pow(base, log(base, x)) < pow(base, log(base, x)) ==>
        )
    };

    \lemma
    logLessThanPow {
        \find(log(base, x) < exp)
        \add(
            base > 1 & x >= 1 & x < pow(base, exp) & exp >= 1 -> log(base, x) < exp ==>
        )
    };

    \lemma
    logLessThanPowConcrete {
        \find( ==> log(base, x) < exp)
        \add(
            ==> base > 1 & x >= 1 & x < pow(base, exp) & exp >= 1
        )
        \heuristics(simplify)
    };

    \lemma
    logSqueeze {
        \find(log(base, x) = exp)
        \add(
            base > 1 & x >= 1 & x >= pow(base, exp) & x < pow(base, exp + 1) & exp >= 0 -> log(base, x) = exp ==>
        )
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    Rules for checked integer semantics.

    See intRules.key for an overview of the integer files.
*/

\schemaVariables {
    \term int left, right, i, i0, i1;
    \term numbers iz, jz;
}

\rules {
    translateCheckedUnaryMinusInt {
        \find(checkedUnaryMinusInt(left))
        \replacewith(neg(left))
        \heuristics(simplify)
    };

    translateCheckedUnaryMinusLong {
        \find(checkedUnaryMinusLong(left))
        \replacewith(neg(left))
        \heuristics(simplify)
    };

    translateCheckedBitwiseNegateInt {
        \find(checkedBitwiseNegateInt(left))
        \replacewith(sub(neg(left), 1))
        \heuristics(simplify)
    };

    translateCheckedBitwiseNegateLong {
        \find(checkedBitwiseNegateLong(left))
        \replacewith(sub(neg(left), 1))
        \heuristics(simplify)
    };

    translateCheckedAddInt {
        \find(checkedAddInt(left, right))
        \replacewith(add(left, right))
        \heuristics(simplify)
    };

    translateCheckedAddLong {
        \find(checkedAddLong(left, right))
        \replacewith(add(left, right))
        \heuristics(simplify)
    };

    translateCheckedSubInt {
        \find(checkedSubInt(left, right))
        \replacewith(sub(left, right))
        \heuristics(simplify)
    };
    translateCheckedSubLong {
        \find(checkedSubLong(left, right))
        \replacewith(sub(left, right))
        \heuristics(simplify)
    };

    translateCheckedMulInt {
        \find(checkedMulInt(left, right))
        \replacewith(mul(left, right))
        \heuristics(simplify)
    };

    translateCheckedMulLong {
        \find(checkedMulLong(left, right))
        \replacewith(mul(left, right))
        \heuristics(simplify)
    };

    translateCheckedDivInt {
        \find(checkedDivInt(left, right))
        \replacewith(jdiv(left, right))
        \heuristics(simplify)
    };

    translateCheckedDivLong {
        \find(checkedDivLong(left, right))
        \replacewith(jdiv(left, right))
        \heuristics(simplify)
    };

    translateCheckedShiftRightInt {
        \find(checkedShiftRightInt(left, right))
        \replacewith(shiftright(left, right))
        \heuristics(simplify)
    };

    translateCheckedShiftRightLong {
        \find(checkedShiftRightLong(left, right))
        \replacewith(shiftright(left, right))
        \heuristics(simplify)
    };

    translateCheckedShiftLeftInt {
        \find(checkedShiftLeftInt(left, right))
        \replacewith(shiftleft(left, right))
        \heuristics(simplify)
    };

    translateCheckedShiftLeftLong {
        \find(checkedShiftLeftLong(left, right))
        \replacewith(shiftleft(left, right))
        \heuristics(simplify)
    };

    /*
    translateCheckedUnsignedShiftRightInt {
      \find(checkedUnsignedShiftRightInt(left, right))
      \replacewith(x(left, right))
      \heuristics(simplify)
    };

    translateCheckedUnsignedShiftRightLong {
      \find(checkedUnsignedShiftRightLong(left, right))
      \replacewith(x(left, right))
      \heuristics(simplify)
    };
    */

    translateCheckedBitwiseOrInt {
        \find(checkedBitwiseOrInt(left, right))
        \replacewith(binaryOr(left, right))
        \heuristics(simplify)
    };

    translateCheckedBitwiseOrLong {
        \find(checkedBitwiseOrLong(left, right))
        \replacewith(binaryOr(left, right))
        \heuristics(simplify)
    };

    translateCheckedBitwiseAndInt {
        \find(checkedBitwiseAndInt(left, right))
        \replacewith(binaryAnd(left, right))
        \heuristics(simplify)
    };

    translateCheckedBitwiseAndLong {
        \find(checkedBitwiseAndLong(left, right))
        \replacewith(binaryAnd(left, right))
        \heuristics(simplify)
    };

    translateCheckedBitwiseXOrInt {
        \find(checkedBitwiseXOrInt(left, right))
        \replacewith(binaryXOr(left, right))
        \heuristics(simplify)
    };

    translateCheckedBitwiseXOrLong {
        \find(checkedBitwiseXOrLong(left, right))
        \replacewith(binaryXOr(left, right))
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    Rules for java integer semantics and all functions which simulate Java overflow.

    See intRules.key for an overview of the integer files.
*/

\schemaVariables {
    \term int left, right, i, i0, i1;
    \term numbers iz, jz;
}

// ------------------------------------------------------------------------
// rules handling modulo functions which simulate Java overflow
// ------------------------------------------------------------------------
\rules {
    // reviewed 04/20/2004, St.S.
    expand_addJint {
        \find(addJint(i, i1))
        \replacewith(moduloInt(add(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 04/20/2004, St.S.
    expand_unaryMinusJint {
        \find(unaryMinusJint(i))
        \replacewith(moduloInt(neg(i)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 04/20/2004, St.S.
    expand_subJint {
        \find(subJint(i, i1))
        \replacewith(moduloInt(sub(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 04/20/2004, St.S.
    expand_mulJint {
        \find(mulJint(i, i1))
        \replacewith(moduloInt(mul(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 04/20/2004, St.S.
    expand_divJint {
        \find(divJint(i, i1))
        \replacewith(moduloInt(jdiv(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 04/20/2004, St.S.
    expand_modJint {
        \find(modJint(i, i1))
        \replacewith(moduloInt(jmod(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 11/30/2004, St.S.
    expand_addJlong {
        \find(addJlong(i, i1))
        \replacewith(moduloLong(add(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 11/30/2004, St.S.
    expand_unaryMinusJlong {
        \find(unaryMinusJlong(i))
        \replacewith(moduloLong(neg(i)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 11/30/2004, St.S.
    expand_subJlong {
        \find(subJlong(i, i1))
        \replacewith(moduloLong(sub(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 11/30/2004, St.S.
    expand_mulJlong {
        \find(mulJlong(i, i1))
        \replacewith(moduloLong(mul(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 11/30/2004, St.S.
    expand_divJlong {
        \find(divJlong(i, i1))
        \replacewith(moduloLong(jdiv(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    // reviewed 11/30/2004, St.S.
    expand_modJlong {
        \find(modJlong(i, i1))
        \replacewith(moduloLong(jmod(i, i1)))
        \heuristics(defOps_expandJNumericOp)
    };

    bitwiseNegateJIntDefinition {
        \find(bitwiseNegateJint(i))
        \replacewith(sub(neg(i), 1))
        \heuristics(javaIntegerSemantics)
        \displayname "bitwiseNegateDefinition"
    };

    bitwiseNegateJlongDefinition {
        \find(bitwiseNegateJlong(i))
        \replacewith(sub(neg(i), 1))
        \heuristics(javaIntegerSemantics)
        \displayname "bitwiseNegateDefinition"
    };
}

// --------------------------------------------------------------------------
// Axioms defining the integer translation functions
// --------------------------------------------------------------------------
\rules(programRules:Java & (intRules:javaSemantics | intRules:arithmeticSemanticsCheckingOF)) {
    expandInByte {
        \find(inByte(i))
        \replacewith(inRangeByte(i))
        \heuristics(concrete)
    };

    expandInChar {
        \find(inChar(i))
        \replacewith(inRangeChar(i))
        \heuristics(concrete)
    };

    expandInShort {
        \find(inShort(i))
        \replacewith(inRangeShort(i))
        \heuristics(concrete)
    };

    expandInInt {
        \find(inInt(i))
        \replacewith(inRangeInt(i))
        \heuristics(concrete)
    };

    expandInLong {
        \find(inLong(i))
        \replacewith(inRangeLong(i))
        \heuristics(concrete)
    };
}

\rules(programRules:Java, intRules:javaSemantics) {
    translateJavaUnaryMinusInt {
        \find(javaUnaryMinusInt(left))
        \replacewith(unaryMinusJint(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaUnaryMinus"
    };

    translateJavaUnaryMinusLong {
        \find(javaUnaryMinusLong(left))
        \replacewith(unaryMinusJlong(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaUnaryMinus"
    };

    translatejavaBitwiseNegateInt {
        \find(javaBitwiseNegateInt(left))
        \replacewith(bitwiseNegateJint(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseNegation"
    };

    translatejavaBitwiseNegateLong {
        \find(javaBitwiseNegateLong(left))
        \replacewith(bitwiseNegateJlong(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseNegation"
    };

    translateJavaAddInt {
        \find(javaAddInt(left, right))
        \replacewith(addJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaAdd"
    };

    translateJavaAddLong {
        \find(javaAddLong(left, right))
        \replacewith(addJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaAdd"
    };

    translateJavaSubInt {
        \find(javaSubInt(left, right))
        \replacewith(subJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaSub"
    };

    translateJavaSubLong {
        \find(javaSubLong(left, right))
        \replacewith(subJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaSub"
    };

    translateJavaMulInt {
        \find(javaMulInt(left, right))
        \replacewith(mulJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaMul"
    };

    translateJavaMulLong {
        \find(javaMulLong(left, right))
        \replacewith(mulJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaMul"
    };

    translateJavaMod {
        \find(javaMod(left, right))
        \replacewith(jmod(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaMod"
    };

    translateJavaDivInt {
        \find(javaDivInt(left, right))
        \replacewith(divJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaDiv"
    };

    translateJavaDivLong {
        \find(javaDivLong(left, right))
        \replacewith(divJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaDiv"
    };

    translateJavaCastByte {
        \find(javaCastByte(left))
        \replacewith(moduloByte(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaCast"
    };

    translateJavaCastShort {
        \find(javaCastShort(left))
        \replacewith(moduloShort(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaCast"
    };

    translateJavaCastInt {
        \find(javaCastInt(left))
        \replacewith(moduloInt(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaCast"
    };

    translateJavaCastLong {
        \find(javaCastLong(left))
        \replacewith(moduloLong(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaCast"
    };

    translateJavaCastChar {
        \find(javaCastChar(left))
        \replacewith(moduloChar(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaCast"
    };

    translateJavaShiftRightInt {
        \find(javaShiftRightInt(left, right))
        \replacewith(shiftrightJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaShiftRight"
    };

    translateJavaShiftRightLong {
        \find(javaShiftRightLong(left, right))
        \replacewith(shiftrightJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaShiftRight"
    };

    translateJavaShiftLeftInt {
        \find(javaShiftLeftInt(left, right))
        \replacewith(shiftleftJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaShiftLeft"
    };

    translateJavaShiftLeftLong {
        \find(javaShiftLeftLong(left, right))
        \replacewith(shiftleftJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaShiftLeft"
    };

    translateJavaUnsignedShiftRightInt {
        \find(javaUnsignedShiftRightInt(left, right))
        \replacewith(unsignedshiftrightJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaUnsignedShiftRight"
    };

    translateJavaUnsignedShiftRightLong {
        \find(javaUnsignedShiftRightLong(left, right))
        \replacewith(unsignedshiftrightJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaUnsignedShiftRight"
    };

    translateJavaBitwiseOrInt {
        \find(javaBitwiseOrInt(left, right))
        \replacewith(orJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseOr"
    };

    translateJavaBitwiseOrLong {
        \find(javaBitwiseOrLong(left, right))
        \replacewith(orJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseOr"
    };

    translateJavaBitwiseAndInt {
        \find(javaBitwiseAndInt(left, right))
        \replacewith(andJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseAnd"
    };

    translateJavaBitwiseAndLong {
        \find(javaBitwiseAndLong(left, right))
        \replacewith(andJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseAnd"
    };

    translateJavaBitwiseXOrInt {
        \find(javaBitwiseXOrInt(left, right))
        \replacewith(xorJint(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseXOr"
    };

    translateJavaBitwiseXOrLong {
        \find(javaBitwiseXOrLong(left, right))
        \replacewith(xorJlong(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseXOr"
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    Rules for integer constants, inRangeInt and moduloInt

    READ FIRST BEFORE EDITING:
    In case of changes PLEASE preserve the files intended meaning. If
    you want to test some rules before implementing them completely,
    please create a new file and include it into the standardRules.key

    Files:
        // rules treating Java programs

        integerAssignment2UpdateRules.key: all integer related assignment
                                           rules for normal assignments

        integerCommonRules.key: integer semantics independent rules which
            transform programs

        // rules treating integer semantics insensitive functions

        integerSimplificationRules.key: rules for arithmetic functions
            that do not depend on the chose integer semantics

        // rules treating integer semantics sensitive functions

        intRules.key: Rules for integer constants, inRangeInt and moduloInt

        intRulesCheckedSemantics.key: Rules for checked overflows

        intRulesUncheckedSemantics.key: Rules for unchecked overflows

        intRulesJavaSemantics.key: Rules for java integer semantics and all functions which simulate Java overflow.
*/

\schemaVariables {
    \term int left, right, i, i0, i1;
    \term numbers iz, jz;
}

// --------------------------------------------------------------------
// -- Rules to replace the min/max constants by concrete values
// --------------------------------------------------------------------
\rules {
    // reviewed 04/16/2004, St.S.
    replace_byte_MAX {
        \find(byte_MAX)
        \replacewith(127)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_byte_MIN {
        \find(byte_MIN)
        \replacewith(-128)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_char_MAX {
        \find(char_MAX)
        \replacewith(65535)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_char_MIN {
        \find(char_MIN)
        \replacewith(0)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_short_MAX {
        \find(short_MAX)
        \replacewith(32767)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_short_MIN {
        \find(short_MIN)
        \replacewith(-32768)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_int_MAX {
        \find(int_MAX)
        \replacewith(2147483647)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_int_MIN {
        \find(int_MIN)
        \replacewith(-2147483648)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_long_MAX {
        \find(long_MAX)
        \replacewith(9223372036854775807)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/16/2004, St.S.
    replace_long_MIN {
        \find(long_MIN)
        \replacewith(-9223372036854775808)
        \heuristics(defOps_expandRanges)
    };

    // --------------------------------------------------------------------
    // -- Rules to replace the min/max constants by concrete values
    // --------------------------------------------------------------------

    // reviewed 04/19/2004, St.S.
    replace_byte_RANGE {
        \find(byte_RANGE)
        \replacewith(256)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/19/2004, St.S.
    replace_byte_HALFRANGE {
        \find(byte_HALFRANGE)
        \replacewith(128)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/19/2004, St.S.
    replace_short_RANGE {
        \find(short_RANGE)
        \replacewith(65536)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/19/2004, St.S.
    replace_short_HALFRANGE {
        \find(short_HALFRANGE)
        \replacewith(32768)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/19/2004, St.S.
    replace_char_RANGE {
        \find(char_RANGE)
        \replacewith(65536)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/19/2004, St.S.
    replace_int_RANGE {
        \find(int_RANGE)
        \replacewith(4294967296)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/19/2004, St.S.
    replace_int_HALFRANGE {
        \find(int_HALFRANGE)
        \replacewith(2147483648)
        \heuristics(defOps_expandRanges)
    };

    // reviewed 04/19/2004, St.S.
    replace_long_RANGE {
        \find(long_RANGE)
        \replacewith(18446744073709551616)
        \heuristics(defOps_expandRanges)
    };
    // reviewed 04/19/2004, St.S.
    replace_long_HALFRANGE {
        \find(long_HALFRANGE)
        \replacewith(9223372036854775808)
        \heuristics(defOps_expandRanges)
    };
}

//
// Expanding inRangeInt
//
\rules {
    expandInRangeByte {
        \find(inRangeByte(i))
        \replacewith(leq(i, byte_MAX) & leq(byte_MIN, i))
        \heuristics(defOps_expandRanges, delayedExpansion)
    };

    expandInRangeChar {
        \find(inRangeChar(i))
        \replacewith(leq(i, char_MAX) & leq(char_MIN, i))
        \heuristics(defOps_expandRanges, delayedExpansion)
    };

    expandInRangeShort {
        \find(inRangeShort(i))
        \replacewith(leq(i, short_MAX) & leq(short_MIN, i))
        \heuristics(defOps_expandRanges, delayedExpansion)
    };

    expandInRangeInt {
        \find(inRangeInt(i))
        \replacewith(leq(i, int_MAX) & leq(int_MIN, i))
        \heuristics(defOps_expandRanges, delayedExpansion)
    };

    expandInRangeLong {
        \find(inRangeLong(i))
        \replacewith(leq(i, long_MAX) & leq(long_MIN, i))
        \heuristics(defOps_expandRanges, delayedExpansion)
    };
}

\rules {
    // ------------------------------------------------------------------------
    // rules for expansion of moduloInt
    // ------------------------------------------------------------------------

    // reviewed 04/20/2004, St.S.
    expand_moduloByte {
        \find(moduloByte(i))
        \replacewith(add(byte_MIN, mod(add(byte_HALFRANGE, i), byte_RANGE)))
        \heuristics(defOps_expandJNumericOp, delayedExpansion)
    };

    // reviewed 04/20/2004, St.S.
    expand_moduloShort {
        \find(moduloShort(i))
        \replacewith(add(short_MIN, mod(add(short_HALFRANGE, i), short_RANGE)))
        \heuristics(defOps_expandJNumericOp, delayedExpansion)
    };

    // reviewed 04/20/2004, St.S.
    expand_moduloInteger {
        \find(moduloInt(i))
        \replacewith(add(int_MIN, mod(add(int_HALFRANGE, i), int_RANGE)))
        \heuristics(defOps_expandJNumericOp, delayedExpansion)
    };

    // reviewed 04/20/2004, St.S.
    expand_moduloLong {
        \find(moduloLong(i))
        \replacewith(add(long_MIN, mod(add(long_HALFRANGE, i), long_RANGE)))
        \heuristics(defOps_expandJNumericOp, delayedExpansion)
    };

    expand_moduloChar {
        \find(moduloChar(i))
        \replacewith(mod(i, char_MAX + 1))
        \heuristics(defOps_expandJNumericOp, delayedExpansion)
    };

    //
    // Lemmas for easy elimination of moduloInt
    //

    moduloIntFixpoint {
        \assumes(inRangeInt(i) ==>)
        \find(moduloInt(i))
        \sameUpdateLevel
        \replacewith(i)

        \heuristics(simplify)
    };

    moduloLongFixpoint {
        \assumes(inRangeLong(i) ==>)
        \find(moduloLong(i))
        \sameUpdateLevel
        \replacewith(i)

        \heuristics(simplify)
    };

    moduloShortFixpoint {
        \assumes(inRangeShort(i) ==>)
        \find(moduloShort(i))
        \sameUpdateLevel
        \replacewith(i)

        \heuristics(simplify)
    };

    moduloByteFixpoint {
        \assumes(inRangeByte(i) ==>)
        \find(moduloByte(i))
        \sameUpdateLevel
        \replacewith(i)

        \heuristics(simplify)
    };

    moduloCharFixpoint {
        \assumes(inRangeChar(i) ==>)
        \find(moduloChar(i))
        \sameUpdateLevel
        \replacewith(i)

        \heuristics(simplify)
    };

    moduloIntFixpointInline {
        \schemaVar \skolemTerm int moduloT;

        \find(moduloInt(i))
        \sameUpdateLevel
        \varcond(\newDependingOn(moduloT, i))
        \replacewith(moduloT)
        \add(\if(inRangeInt(i)) \then(i) \else(moduloT) = moduloT, moduloInt(i) = moduloT ==>)
    };

    moduloLongFixpointInline {
        \schemaVar \skolemTerm int moduloT;

        \find(moduloLong(i))
        \sameUpdateLevel
        \varcond(\newDependingOn(moduloT, i))
        \replacewith(moduloT)
        \add(\if(inRangeLong(i)) \then(i) \else(moduloT) = moduloT, moduloLong(i) = moduloT ==>)
    };

    moduloShortFixpointInline {
        \schemaVar \skolemTerm int moduloT;

        \find(moduloShort(i))
        \sameUpdateLevel
        \varcond(\newDependingOn(moduloT, i))
        \replacewith(moduloT)
        \add(\if(inRangeShort(i)) \then(i) \else(moduloT) = moduloT, moduloShort(i) = moduloT ==>)
    };

    moduloByteFixpointInline {
        \schemaVar \skolemTerm int moduloT;

        \find(moduloByte(i))
        \sameUpdateLevel
        \varcond(\newDependingOn(moduloT, i))
        \replacewith(moduloT)
        \add(\if(inRangeByte(i)) \then(i) \else(moduloT) = moduloT, moduloByte(i) = moduloT ==>)
    };

    moduloCharFixpointInline {
        \schemaVar \skolemTerm int moduloT;

        \find(moduloChar(i))
        \sameUpdateLevel
        \varcond(\newDependingOn(moduloT, i))
        \replacewith(moduloT)
        \add(\if(inRangeChar(i)) \then(i) \else(moduloT) = moduloT, moduloChar(i) = moduloT ==>)
    };

    //
    // Useful rules for elimination of inRangeInt moduloInt chains
    //

    moduloIntIsInRangeInt {
        \find(inRangeInt(moduloInt(i)))
        \replacewith(true)
        \heuristics(concrete)
    };

    moduloLongIsInRangeLong {
        \find(inRangeLong(moduloLong(i)))
        \replacewith(true)
        \heuristics(concrete)
    };

    moduloShortIsInRangeShort {
        \find(inRangeShort(moduloShort(i)))
        \replacewith(true)
        \heuristics(concrete)
    };

    moduloByteIsInRangeByte {
        \find(inRangeByte(moduloByte(i)))
        \replacewith(true)
        \heuristics(concrete)
    };

    moduloCharIsInRangeChar {
        \find(inRangeChar(moduloChar(i)))
        \replacewith(true)
        \heuristics(concrete)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    Rules for unchecked overflows.
    Most rules here are shared with check overflows semantics since the check is generated by the wd checker,
    the rest is analogous to unchecked overflows.

    See intRules.key for an overview of the integer files.
*/

\schemaVariables {
    \term int left, right, i, i0, i1;
    \term numbers iz, jz;
}

\rules(programRules:Java & intRules:arithmeticSemanticsIgnoringOF) {

    // ------------------------------------------------------------------------
    // Rules to expand the predicates inByte, inShort, inInt, and inLong
    // ------------------------------------------------------------------------

    expandInByte {
        \find(inByte(i))
        \replacewith(true)
        \heuristics(concrete)
    };

    expandInChar {
        \find(inChar(i))
        \replacewith(true)
        \heuristics(concrete)
    };

    expandInShort {
        \find(inShort(i))
        \replacewith(true)
        \heuristics(concrete)
    };

    expandInInt {
        \find(inInt(i))
        \replacewith(true)
        \heuristics(concrete)
    };

    expandInLong {
        \find(inLong(i))
        \replacewith(true)
        \heuristics(concrete)
    };
}

\rules(programRules:Java & (intRules:arithmeticSemanticsIgnoringOF | intRules:arithmeticSemanticsCheckingOF)) {

    // --------------------------------------------------------------------------
    // Axioms defining the integer translation functions
    // --------------------------------------------------------------------------

    translateJavaUnaryMinusInt {
        \find(javaUnaryMinusInt(left))
        \replacewith(neg(left))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaUnaryMinus"
    };

    translateJavaUnaryMinusLong {
        \find(javaUnaryMinusLong(left))
        \replacewith(neg(left))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaUnaryMinus"
    };

    translatejavaBitwiseNegateInt {
        \find(javaBitwiseNegateInt(left))
        \replacewith(bitwiseNegateJint(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseNegation"
    };

    translatejavaBitwiseNegateLong {
        \find(javaBitwiseNegateLong(left))
        \replacewith(bitwiseNegateJlong(left))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseNegation"
    };

    translateJavaAddInt {
        \find(javaAddInt(left, right))
        \replacewith(add(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaAdd"
    };

    translateJavaAddLong {
        \find(javaAddLong(left, right))
        \replacewith(add(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaAdd"
    };

    translateJavaSubInt {
        \find(javaSubInt(left, right))
        \replacewith(sub(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaSub"
    };

    translateJavaSubLong {
        \find(javaSubLong(left, right))
        \replacewith(sub(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaSub"
    };

    translateJavaMulInt {
        \find(javaMulInt(left, right))
        \replacewith(mul(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaMul"
    };

    translateJavaMulLong {
        \find(javaMulLong(left, right))
        \replacewith(mul(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaMul"
    };

    translateJavaMod {
        \find(javaMod(left, right))
        \replacewith(jmod(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaMod"
    };

    translateJavaDivInt {
        \find(javaDivInt(left, right))
        \replacewith(jdiv(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaDiv"
    };

    translateJavaDivLong {
        \find(javaDivLong(left, right))
        \replacewith(jdiv(left, right))
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaDiv"
    };

    translateJavaCastByte {
        \find(javaCastByte(left))
        \replacewith(left)
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaCast"
    };

    translateJavaCastShort {
        \find(javaCastShort(left))
        \replacewith(left)
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaCast"
    };

    translateJavaCastInt {
        \find(javaCastInt(left))
        \replacewith(left)
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaCast"
    };

    translateJavaCastLong {
        \find(javaCastLong(left))
        \replacewith(left)
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaCast"
    };

    translateJavaCastChar {
        \find(javaCastChar(left))
        \replacewith(left)
        \heuristics(javaIntegerSemantics, simplify)
        \displayname "translateJavaCast"
    };

    translateJavaShiftRightInt {
        \find(javaShiftRightInt(left, right))
        \replacewith(shiftright(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaShiftRight"
    };

    translateJavaShiftRightLong {
        \find(javaShiftRightLong(left, right))
        \replacewith(shiftright(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaShiftRight"
    };

    translateJavaShiftLeftInt {
        \find(javaShiftLeftInt(left, right))
        \replacewith(shiftleft(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaShiftLeft"
    };

    translateJavaShiftLeftLong {
        \find(javaShiftLeftLong(left, right))
        \replacewith(shiftleft(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaShiftLeft"
    };

    /*
    translateJavaUnsignedShiftRightInt{
        \find(javaUnsignedShiftRightInt(left,right))
        \replacewith(unsignedshiftrightJint(left,right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaUnsignedShiftRight"
    };

    translateJavaUnsignedShiftRightLong{
        \find(javaUnsignedShiftRightLong(left,right))
        \replacewith(unsignedshiftrightJlong(left,right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaUnsignedShiftRight"
    };
    */

    translateJavaBitwiseOrInt {
        \find(javaBitwiseOrInt(left, right))
        \replacewith(binaryOr(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseOr"
    };

    translateJavaBitwiseOrLong {
        \find(javaBitwiseOrLong(left, right))
        \replacewith(binaryOr(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseOr"
    };

    translateJavaBitwiseAndInt {
        \find(javaBitwiseAndInt(left, right))
        \replacewith(binaryAnd(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseAnd"
    };

    translateJavaBitwiseAndLong {
        \find(javaBitwiseAndLong(left, right))
        \replacewith(binaryAnd(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseAnd"
    };

    translateJavaBitwiseXOrInt {
        \find(javaBitwiseXOrInt(left, right))
        \replacewith(binaryXOr(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseXOr"
    };

    translateJavaBitwiseXOrLong {
        \find(javaBitwiseXOrLong(left, right))
        \replacewith(binaryXOr(left, right))
        \heuristics(javaIntegerSemantics)
        \displayname "translateJavaBitwiseXOr"
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\sorts {
    \generic E;
    \generic G;
}

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
    \program Type #ty;
    \program SimpleExpression #se;
    \program NonSimpleExpression #nse;
    \program Expression #e;
    \program Variable #v0;
    \program Variable #id;
    \program Variable #a;
    \program Statement #stm;

    \variables int I;
    \skolemTerm G ar;

    \formula anon1, anon2;

    \formula post, inv;

    \term E e;
}

/***
 *** Enhanced for
 ***/
\rules(programRules:Java) {

    /* enhancedfor_array {
         \find( \modality{#allmodal}{ .. for (#ty #id : #e) #stm ... }\endmodality(post) )
         \varcond(\newTypeOf(#v0, int), \new(#a, #e), \isArray(#e))
         \replacewith( \modality{#allmodal}{ ..
             {
                #typeof(#a) #a = #e;
                for(int #v0 = 0; #v0 < #length-reference(#a); #v0 ++)
                {
                   #ty #id = #a[#v0];
                   #stm
                }
             } ... }\endmodality(post) )
         \displayname "enhancedfor_array"
         \heuristics(loop_expand,obsolete)
    };*/

    enhancedfor_iterable {
        \find(\modality{#allmodal}{ .. for (#ty #id : #e) #stm ... }\endmodality (post))
        \replacewith(\modality{#allmodal}{ .. #enhancedfor-elim(for (#ty #id : #e) #stm); ... }\endmodality (post))
        \displayname "enhancedfor"
        \heuristics(simplify_prog)
    };

    /*
     * Make the iterated expression in an enhanced for loop simple.
     */
    /*
    enhancedfor_not_simple {
      \find( \modality{#allmodal}{ .. for (#ty #id: #nse) #stm ... }\endmodality(post) )
      \varcond(\newTypeOf(#v0, #nse))
      \replacewith( \modality{#allmodal}{ .. #typeof(#nse) #v0 = #nse; for (#ty #id: #v0) #stm ... }\endmodality(post) )
         \heuristics(simplify_prog)
    };*/
}

/***
 *** Enumerations
 ***/
\rules(programRules:Java) {
    /* XXX
      enumConstantByIndex {
           \assumes(wellFormed(heap) ==>)
           \find( e )
           \sameUpdateLevel
           \varcond(\enumConstant(e))
           \replacewith( E::<get>(#enumconstantvalue(e)) )
           \heuristics(simplify)
      };


      enumOrdinalToIndex {
           \find( #fieldref(e, "ordinal") )
           \varcond(\isEnumType(E))
           \add(e = E::<get>(#fieldref(e, "ordinal")) ==> )
      };

    }

    \rules(programRules:Java,initialisation:disableStaticInitialisation) {

      enumNextToCreateConstant {
           \assumes( wellFormed(heap) ==> )
           \find( #nc )
           \sameUpdateLevel
           \varcond(\isEnumType(\containerType(#nc)))
           \replacewith( #enumconstantvalue( #nc ) )
           \heuristics(simplify)
      };

    }

    \rules(programRules:Java,initialisation:enableStaticInitialisation) {

      enumNextToCreateConstant {
           \assumes ( wellFormed(heap), #classInitialized = TRUE ==> )
           \find( #nc )
           \sameUpdateLevel
           \varcond(\isEnumType(\containerType(#nc)), \same(\containerType(#classInitialized), \containerType(#nc)))
           \replacewith( #enumconstantvalue(#nc) )
           \heuristics(simplify)
      };
    */
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/*
 * This file contains the declarations for Java. To find the rules, look at javaRules.key.
 */

\sorts {
    any;
    java.lang.Object;
    \abstract java.lang.Cloneable \extends java.lang.Object;
    \abstract java.io.Serializable \extends java.lang.Object;

    \generic alpha, beta, gamma;
    \generic deltaObject \extends java.lang.Object;

    \generic G;
    \generic H;
    \generic J \extends G;
    \generic GOS \extends Object;
    \generic alphaObj \extends Object;
    \generic betaObj \extends Object;
}


\functions {
    alpha alpha::cast(any);
    boolean alpha::exactInstance(any);
    boolean alpha::instance(any);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules for handling java programs


\include assertions;

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
    \modalOperator {diamond, diamond_transaction} #diamond;
    \modalOperator {box, box_transaction} #box;

    \formula post, inv, post1;
    \program Type #t, #t2;
    \program NonPrimitiveType #npit;
    \program PrimitiveType #pit;

    \term G q;
    \skolemTerm G sk;

    \program ArrayLength #length;

    \program MultipleVariableDeclaration #multvardecl;
    \program ArrayPostDeclaration #arraypost;
    \program SimpleExpression #se, #se0, #se1, #se2;
    \program SimpleExpression #src, #dest, #srcOff, #destOff, #arlength;
    \program SimpleExpressionNonFloatDouble #senf, #senf0, #senf1;

    \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2;
    \program LeftHandSide #attribute;
    \program Variable #loc;
    \program StaticVariable #sv, #sv0, #sv1;

    \program Variable #v, #v0, #v1, #v2, #boolv, #a, #a0, #a1;

    \program ConstantPrimitiveTypeVariable #cv; // variables that are compile-time constants
    \program Variable #b0, #ar1;
    \program VariableInitializer #vi;
    \program SimpleJavaBooleanExpression #seBool, #seBool0, #seBool1, #seBool2;
    \program JavaBooleanExpression #exBool, #exBool0, #exBool1, #exBool2;

    \program NonSimpleExpression #nseBool, #nseBool0, #nseBool1, #nseBool2;
    \program Statement #s, #s0, #s1;
    \program LoopInit #loopInit;
    \program Guard #guard;
    \program ForUpdates #forupdates;
    \program ForLoop #forloop;
    \program Expression #e, #e0, #e1, #e2;
    \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv;
    \program NonSimpleExpressionNoClassReference #nsencr;

    \program ClassReference #cr;

    \program [list] Statement #slist, #slist1, #slist2, #slist3;
    \program [list] Expression #elist;
    \program [list] SimpleExpression #selist;
    \program [list] Catch #cs;

    \program Switch #sw;
    \program Label #lb, #lb0, #lb1, #innerLabel, #outerLabel;
    \program NonSimpleMethodReference #nsmr;
    \program NonModelMethodBody #mb;
    \program MethodName #mn;

    \program NonPrimitiveType [name = javacard.framework.JCSystem] #jcsystemType;
    \program MethodName [name = nativeKeYBeginTransaction] #beginTransaction;
    \program MethodName [name = nativeKeYCommitTransaction] #commitTransaction;
    \program MethodName [name = nativeKeYAbortTransaction] #abortTransaction;

    \program ExecutionContext #ex, #ex1;
    \program ProgramMethod #pm;

    \formula anon1, anon2, anon3;

    \formula for1, for2;

    \program NonStringLiteral #lit;
    \program StringLiteral #slit;

    \variables int iv, iv2, iv3;
    \term int idx;

    // generic sorts
    \term G variant;
    \term GOS array;
    \term H obj;

    \variables G x;
    \term H then, else;

    \term G updatedTerm1, updatedTerm2;
}

\rules(programRules:Java, JavaCard:on) {

    getJavaCardTransient {
        \schemaVar \program MethodName [name = nativeKeYGetTransient] #getTransient;
        \find( ==>
            \modality{#allmodal}{..
                   #lhs = #jcsystemType.#getTransient(#se)@#jcsystemType;
                ...}\endmodality post)
        "Normal Execution":
            \replacewith( ==>
                {#lhs := int::select(heap, #se, java.lang.Object::<transient>)}
                \modality{#allmodal}{.. ...}\endmodality post);
        "#se is not null":
            \replacewith( ==> #se != null)
        \heuristics(simplify_prog)
    };

    setJavaCardTransient {
        \schemaVar \program MethodName [name = nativeKeYSetTransient] #setTransient;
        \find( ==>
            \modality{#allmodal}{..
                   #jcsystemType.#setTransient(#se, #se1)@#jcsystemType;
                ...}\endmodality post)
        "Normal Execution":
            \replacewith( ==>
                {heap := store(heap, #se, java.lang.Object::<transient>, #se1)}
                \modality{#allmodal}{.. ...}\endmodality post);
        "#se is not null":
            \replacewith( ==> #se != null)
        \heuristics(simplify_prog)
    };

    beginJavaCardTransactionAPI {
        \find( ==>
            \modality{#allmodal}{..
                   #jcsystemType.#beginTransaction()@#jcsystemType;
                ...}\endmodality post)
        \replacewith( ==>
            \modality{#allmodal}{.. #beginJavaCardTransaction; ...}\endmodality post)
        \heuristics(simplify_prog)
    };

    commitJavaCardTransactionAPI {
        \find( ==>
            \modality{#allmodal}{..
                   #jcsystemType.#commitTransaction()@#jcsystemType;
                ...}\endmodality post)
        \replacewith( ==>
            \modality{#allmodal}{.. #commitJavaCardTransaction; ...}\endmodality post)
        \heuristics(simplify_prog)
    };

    abortJavaCardTransactionAPI {
        \find( ==>
            \modality{#allmodal}{..
                   #jcsystemType.#abortTransaction()@#jcsystemType;
                ...}\endmodality post)
        \replacewith( ==>
            \modality{#allmodal}{.. #abortJavaCardTransaction; ...}\endmodality post)
        \heuristics(simplify_prog)
    };

    beginJavaCardTransactionDiamond {
        \find( ==>
            \<{..
                   #beginJavaCardTransaction;
                ...}\> post)
        \replacewith( ==>
            {savedHeap := heap}\diamond_transaction{.. ...}\endmodality post)
        \heuristics(simplify_prog)
        \displayname "beginJavaCardTransaction"
    };

    beginJavaCardTransactionBox {
        \find( ==>
            \[{..
                   #beginJavaCardTransaction;
                ...}\] post)
        \replacewith( ==>
            {savedHeap := heap}\box_transaction{.. ...}\endmodality post)
        \heuristics(simplify_prog)
        \displayname "beginJavaCardTransaction"
    };

    commitJavaCardTransactionDiamond {
        \find( ==>
            \diamond_transaction{..
                   #commitJavaCardTransaction;
                ...}\endmodality post)
        \replacewith( ==>
            \<{.. ...}\> post)
        \heuristics(simplify_prog)
        \displayname "commitJavaCardTransaction"
    };

    commitJavaCardTransactionBox {
        \find( ==>
            \box_transaction{..
                   #commitJavaCardTransaction;
                ...}\endmodality post)
        \replacewith( ==>
            \[{.. ...}\] post)
        \heuristics(simplify_prog)
        \displayname "commitJavaCardTransaction"
    };

    finishJavaCardTransactionDiamond {
        \find( ==>
            \diamond_transaction{..
                   #finishJavaCardTransaction;
                ...}\endmodality post)
        \replacewith( ==>
            \<{.. ...}\> post)
        \heuristics(simplify_prog)
        \displayname "finishJavaCardTransaction"
    };

    finishJavaCardTransactionBox {
        \find( ==>
            \box_transaction{..
                   #finishJavaCardTransaction;
                ...}\endmodality post)
        \replacewith( ==>
            \[{.. ...}\] post)
        \heuristics(simplify_prog)
        \displayname "finishJavaCardTransaction"
    };

    abortJavaCardTransactionDiamond {
        \find( ==>
            \diamond_transaction{..
                   #abortJavaCardTransaction;
                ...}\endmodality post)
        \replacewith( ==>
            {heap := anon(savedHeap, allObjects(java.lang.Object::<transactionConditionallyUpdated>), heap)}\<{.. ...}\> post)
        \heuristics(simplify_prog)
        \displayname "abortJavaCardTransaction"
    };

    abortJavaCardTransactionBox {
        \find( ==>
            \box_transaction{..
                   #abortJavaCardTransaction;
                ...}\endmodality post)
        \replacewith( ==>
            {heap := anon(savedHeap, allObjects(java.lang.Object::<transactionConditionallyUpdated>), heap)}\[{.. ...}\] post)
        \heuristics(simplify_prog)
        \displayname "abortJavaCardTransaction"
    };

}

\rules(programRules:Java) {

    emptyModality {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find(\modality{#normal}{}\endmodality (post))
        \replacewith(post)
        \heuristics(simplify_prog)
    };

    emptyModalityBoxTransaction {
        \find(\box_transaction{  }\endmodality (post))
        "Unbalanced Transaction":
            \replacewith(true)
        \displayname "emptyModality"
        \heuristics(simplify_prog)
    };

    emptyModalityDiamondTransaction {
        \find(\diamond_transaction{  }\endmodality (post))
        "Unbalanced Transaction":
            \replacewith(false)
        \displayname "emptyModality"
        \heuristics(simplify_prog)
    };

    returnUnfold {
        \find(\modality{#allmodal}{.. return #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; return #v0; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "returnUnfold"
    };

    deleteMergePoint {
        \find(\modality{#allmodal}{.. merge_point(#lhs); ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(simplify_prog, merge_point)
    };

    // -----------------------------------------------------------------------------------------
    //                        some common assignment rules
    // -----------------------------------------------------------------------------------------

    assignment {
        \find(\modality{#allmodal}{.. #loc = #se; ...}\endmodality (post))
        \replacewith({#loc := #se}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java, permissions:off) {
    // skip index check as the case below can only happen in an implicit method
    assignment_write_array_this_access_normalassign {
        \find(\modality{#allmodal}{.#pm@#t(#v).. this[#se]=#se0; ...}\endmodality (post))
        \replacewith((lt(#se, length(#v)) & lt(-1, #se)) ->
            {heap := store(heap, #v, arr(#se), #se0)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
    };
}

\rules(programRules:Java, permissions:on) {
    assignment_write_array_this_access_normalassign {
        \find(\modality{#allmodal}{.#pm@#t(#v).. this[#se]=#se0; ...}\endmodality (post))
        \replacewith((lt(#se, length(#v)) & lt(-1, #se) &
                writePermission(Permission::select(permissions, #v, arr(#se)))) ->
            {heap := store(heap, #v, arr(#se), #se0)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
    };
}

\rules(programRules:Java) {
    // skip index check as the case below can only happen in an implicit method
    eval_array_this_access {
        \find(\modality{#allmodal}{.. this[#nse]=#se0; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; this[#v0]=#se0; ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "eval_array_access"
    };

    // ---------- rules for array store ---------------//


    array_self_reference {
        \schemaVar \term Heap heapSV;
        \assumes(wellFormed(heapSV) ==> array = null)
        \find(arrayStoreValid(array, G::select(heapSV, array, arr(idx))))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };

    // author: scheben; correctness proven in KeY for G = Object
    array_self_reference_eq {
        \schemaVar \term Heap heapSV;
        \schemaVar \term G EQ;
        \assumes(wellFormed(heapSV), G::select(heapSV, array, arr(idx)) = EQ ==> array = null)
        \find(arrayStoreValid(array, EQ))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };

    null_can_always_be_stored_in_a_reference_type_array {
        \assumes( ==> array = null)
        \find(arrayStoreValid(array, null))
        \sameUpdateLevel
        \varcond(\isReferenceArray(array))
        \replacewith(true)
        \heuristics(simplify)
    };

    /* array_store_known_dynamic_array_type_prim {
      \find (arrayStoreValid(G::<get>(idx), vint_val))
          \varcond(\isReference(G))
      \replacewith(#arrayBaseInstanceOf(G::<get>(idx), vint_val) = TRUE)
      \heuristics(simplify)
      \displayname "known dynamic array type"
     };
    */

    array_store_known_dynamic_array_type {
        \assumes(J::exactInstance(array) = TRUE ==>)
        \find(arrayStoreValid(array, obj))
        \sameUpdateLevel
        \varcond(\isReference [non_null](J))
        \replacewith(obj = null |
            #arrayBaseInstanceOf(J::exactInstance(array), obj) = TRUE)
        \heuristics(simplify)
        \displayname "known dynamic array type"
    };

    // ------------ dynamic types ------------------ //

    /* // will be uncommented soon
        dynamic_type_for_null {
       \find (G::exactInstance(null) = TRUE ==>)
       \varcond(G not Null) // Woj: parser doesn't allow this at the moment
       \replacewith(false)
     };
    };*/

    // --------------- variable declarations --------------------------------------//


    // reviewed 04/19/2004, St.S.
    variableDeclaration {
        \find(\modality{#allmodal}{.. #t #v0; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \addprogvars(#v0)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "variableDeclaration"
    };

    variableDeclarationFinal {
        \find(\modality{#allmodal}{.. final #t #v0; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \addprogvars(#v0)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "variableDeclaration"
    };

    variableDeclarationGhost {
        \find(\modality{#allmodal}{.. ghost #t #v0; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \addprogvars(#v0)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "ghostDeclaration"
    };

    variableDeclarationAssign {
        \find(\modality{#allmodal}{.. #t #v0 = #vi; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #t #v0; #v0 = #vi; ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "variableDeclaration"
    };

    variableDeclarationFinalAssign {
        \find(\modality{#allmodal}{.. final #t #v0 = #vi; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. final #t #v0; #v0 = #vi; ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "variableDeclaration"
    };

    variableDeclarationGhostAssign {
        \find(\modality{#allmodal}{.. ghost #t #v0 = #vi; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. ghost #t #v0; #v0 = #vi; ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "ghostDeclaration"
    };

    variableDeclarationMult {
        \find(\modality{#allmodal}{.. #multvardecl ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #resolve-multiple-var-decl(#multvardecl); ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "variableDeclaration"
    };

    array_post_declaration {
        \find(\modality{#allmodal}{.. #arraypost ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..
                #array-post-declaration(#arraypost);
                              ...}\endmodality (post))
        \heuristics(simplify_prog,
            simplify_prog_subset)
    };

    // --------------- try-statement ----------------------------------------------//

    throwNull {
        \find(\modality{#allmodal}{.. throw null; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. throw new java.lang.NullPointerException(); ...}\endmodality (post))
        \displayname "throwNull"
    };

    throwUnfold {
        \find(\modality{#allmodal}{.. throw #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0 = #nse; throw #v0; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "throwUnfold"
    };

    // VERIFY this rule:

    throwLabel {
        \find(\modality{#allmodal}{.. #lb: throw #se; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    throwLabelBlock {
        \find(\modality{#allmodal}{.. #lb: { throw #se; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    throwBox {
        \find(\modality{#box}{ throw #se; #slist }\endmodality (post))
        \replacewith(true)
        \heuristics(simplify_prog)
    };

    throwDiamond {
        \find(\modality{#diamond}{ throw #se; #slist }\endmodality (post))
        \replacewith(false)
        \heuristics(simplify_prog)
    };

    tryCatchThrow {
        \find(\modality{#allmodal}{.. try { throw #se; #slist }
                catch ( #t #v0 ) { #slist1 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. if ( #se == null ) {
                      try { throw new java.lang.NullPointerException (); }
                      catch ( #t #v0 ) { #slist1 }
                } else if ( #se instanceof #t ) {
                      #t #v0;
                      #v0 = (#t) #se;
                      #slist1
                } else {
                      throw #se;
                } ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryCatchThrow"
    };

    tryMultipleCatchThrow {
        \find(\modality{#allmodal}{.. try { throw #se; #slist }
                catch ( #t #v0 ) { #slist1 }
                catch ( #t2 #v1 ) { #slist3 }
                catch #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. if ( #se == null ) {
                     try { throw new java.lang.NullPointerException (); }
                     catch ( #t #v0 ) { #slist1 }
                     catch ( #t2 #v1 ) { #slist3 }
                     catch #cs
                } else if ( #se instanceof #t ) {
                     #t #v0;
                     #v0 = (#t) #se;
                     #slist1
                } else {
                     try { throw #se; }
                     catch ( #t2 #v1 ) { #slist3 }
                     catch #cs
                } ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryCatchThrow"
    };

    tryCatchFinallyThrow {
        \find(\modality{#allmodal}{.. try { throw #se; #slist}
                catch ( #t #v0 ) { #slist1 }
                catch #cs
                finally { #slist2 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. if ( #se == null ) {
                     try { throw new java.lang.NullPointerException (); }
                     catch ( #t #v0 ) { #slist1 }
                     catch #cs
                     finally { #slist2 }
                } else if ( #se instanceof #t ) {
                     try {
                        #t #v0;
                        #v0 = (#t) #se;
                        #slist1
                     } finally { #slist2 }
                } else {
                     try { throw #se; }
                     catch #cs
                     finally { #slist2 }
                } ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryCatchFinallyThrow"
    };

    // Note: If an exception is not caught, the finally block is executed first,
    // then the exception is propagated. Especially, if null is thrown,
    // a new NPE is thrown after the finally block. JLS 3rd ed., Sect. 11.3.
    tryFinallyThrow {
        \find(\modality{#allmodal}{.. try { throw #se; #slist }
                finally { #slist2 } ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #se))
        \replacewith(\modality{#allmodal}{.. if ( #se == null ) {
                     { #slist2 }
                     throw new java.lang.NullPointerException ();
                } else {
                     #typeof(#se) #v0 = #se;
                     { #slist2 }
                     throw #v0;
                } ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryFinallyThrow"
    };

    tryEmpty {
        \find(\modality{#allmodal}{.. try {} #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    tryFinallyEmpty {
        \find(\modality{#allmodal}{.. try {}
                catch #cs
                finally { #slist2 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #slist2 }  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryEmpty"
    };

    tryBreakLabel {
        \find(\modality{#allmodal}{.. try { break #lb; #slist }
                catch #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. break #lb; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryBreak"
    };

    tryFinallyBreakLabel {
        \find(\modality{#allmodal}{.. try { break #lb; #slist }
                catch #cs
                finally { #slist2 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #slist2 } break #lb; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryBreak"
    };

    tryBreak {
        \find(\modality{#allmodal}{.. try { break; #slist }
                catch #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. break; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryBreak"
    };

    tryFinallyBreak {
        \find(\modality{#allmodal}{.. try { break; #slist }
                catch #cs
                finally { #slist2 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #slist2 } break; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryBreak"
    };

    try_continue_1 {
        \find(\modality{#allmodal}{.. try { continue #lb; #slist }
                catch #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. continue #lb; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "try_continue"
    };

    try_finally_continue_1 {
        \find(\modality{#allmodal}{.. try { continue #lb; #slist }
                catch #cs
                finally { #slist2 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #slist2 } continue #lb; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "try_continue"
    };

    try_continue_2 {
        \find(\modality{#allmodal}{.. try { continue; #slist }
                catch #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. continue; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "try_continue"
    };

    try_finally_continue_2 {
        \find(\modality{#allmodal}{.. try { continue; #slist }
                catch #cs
                finally { #slist2 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #slist2 } continue; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "try_continue"
    };

    tryReturn {
        \find(\modality{#allmodal}{.. try { return #se; #slist }
                catch #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. return #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryReturn"
    };

    tryFinallyReturn {
        \find(\modality{#allmodal}{.. try { return #se; #slist }
                catch #cs
                finally { #slist2 } ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #se))
        \replacewith(\modality{#allmodal}{.. #typeof(#se) #v0 = #se;
                { #slist2 }
                return #v0; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryReturn"
    };

    tryReturnNoValue {
        \find(\modality{#allmodal}{.. try { return; #slist }
                catch #cs ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. return; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryReturn"
    };

    tryFinallyReturnNoValue {
        \find(\modality{#allmodal}{.. try { return; #slist }
                catch #cs
                finally { #slist2 } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #slist2 } return; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "tryReturn"
    };

    // ------------------------------------------------------------------------
    // ----------- Rules for prefix and postfix increment and decrement operators
    // ------------------------------------------------------------------------

    // reviewed 04/16/2004, St.S.
    preincrement_assignment {
        \find(\modality{#allmodal}{.. #lhs0 = ++#lhs1; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1); #lhs0 = #lhs1;
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    preincrement_assignment_attribute {
        \find(\modality{#allmodal}{.. #lhs0 = ++#e.#attribute; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1); #lhs0=#v.#attribute;
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // new 06/12/2008, BW
    preincrement_assignment_array {
        \find(\modality{#allmodal}{.. #lhs0 = ++#e[#e0]; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0;
                #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]+1); #lhs0=#v[#v0];
                 ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    preincrement {
        \find(\modality{#allmodal}{.. ++#lhs1; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    preincrement_attribute {
        \find(\modality{#allmodal}{.. ++#e.#attribute; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // new 06/12/2008, BW
    preincrement_array {
        \find(\modality{#allmodal}{.. ++#e[#e0]; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0;
                   #v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    predecrement {
        \find(\modality{#allmodal}{.. --#lhs1; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1-1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    predecrement_attribute {
        \find(\modality{#allmodal}{.. --#e.#attribute; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // new 06/12/2008, BW
    predecrement_array {
        \find(\modality{#allmodal}{.. --#e[#e0]; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0;
                #v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);
                     ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    predecrement_assignment {
        \find(\modality{#allmodal}{.. #lhs0 = --#lhs1; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1-1); #lhs0 = #lhs1; ...}\endmodality (post))
        \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    predecrement_assignment_attribute {
        \find(\modality{#allmodal}{.. #lhs = --#e.#attribute; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1); #lhs = #v.#attribute;
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // new 06/12/2008, BW
    predecrement_assignment_array {
        \find(\modality{#allmodal}{.. #lhs0 = --#e[#e0]; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0;
                #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]-1); #lhs0 = #v[#v0];
                 ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 06/23/2005, St.S.
    postincrement_assignment {
        \find(\modality{#allmodal}{.. #lhs0 = #lhs1++; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #lhs0))
        \replacewith(\modality{#allmodal}{.. #typeof(#lhs0) #v = #lhs1; #lhs1 = (#typeof(#lhs1))(#lhs1+1); #lhs0 = #v;
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 06/23/2005, St.S.
    postincrement_assignment_attribute {
        \find(\modality{#allmodal}{.. #lhs0 = #e.#attribute++; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v1, #lhs0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#lhs0) #v1=#v.#attribute; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1); #lhs0 = #v1;
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 06/23/2005, St.S.
    postincrement_assignment_array {
        \find(\modality{#allmodal}{.. #lhs0 = #e[#e0]++; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v0, #e0), \newTypeOf(#v1, #lhs0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0;
                #typeof(#lhs0) #v1=#v[#v0]; #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]+1); #lhs0=#v1;
                 ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    postincrement {
        \find(\modality{#allmodal}{.. #lhs1++; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    postincrement_attribute {
        \find(\modality{#allmodal}{.. #e.#attribute++; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    postincrement_array {
        \find(\modality{#allmodal}{.. #e[#e0]++; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0;
                   #v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    postdecrement {
        \find(\modality{#allmodal}{.. #lhs1--; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))#lhs1-1;
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    postdecrement_attribute {
        \find(\modality{#allmodal}{.. #e.#attribute--; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1);
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 04/16/2004, St.S.
    postdecrement_array {
        \find(\modality{#allmodal}{.. #e[#e0]--; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0;
                #v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);
                     ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 06/23/2005, St.S.
    postdecrement_assignment {
        \find(\modality{#allmodal}{.. #lhs0 = #lhs1--; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #lhs0))
        \replacewith(\modality{#allmodal}{.. #typeof(#lhs0) #v = #lhs1; #lhs1 = (#typeof(#lhs1))(#lhs1-1); #lhs0 = #v; ...}\endmodality (post))
        \heuristics(simplify_expression)
    };

    // reviewed 06/23/2005, St.S.
    postdecrement_assignment_attribute {
        \find(\modality{#allmodal}{.. #lhs0 = #e.#attribute--; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v1, #lhs0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#lhs0) #v1=#v.#attribute; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1); #lhs0 = #v1;
                ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // reviewed 06/23/2005, St.S.
    postdecrement_assignment_array {
        \find(\modality{#allmodal}{.. #lhs0 = #e[#e0]--; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e), \newTypeOf(#v0, #e0), \newTypeOf(#v1, #lhs0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0;
                #typeof(#lhs0) #v1=#v[#v0]; #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]-1); #lhs0 = #v1;
                 ...}\endmodality (post)) \heuristics(simplify_expression)
    };

    // boolean cast
    castToBoolean {
        \find(\modality{#allmodal}{.. #lhs = (boolean) #exBool; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #exBool; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    // -----------------------------------------------------------------------------------------//
    // --------------- reference type casts  ---------------------------------------------------//
    // -----------------------------------------------------------------------------------------//


    // implementation of the rules for type casts defined in the Java language
    // specification, chapter 5.5. We assume that no compile-time error occurred.

    // null can be cast to any type

    compound_reference_cast_expression {
        \find(\modality{#allmodal}{.. #lhs = (#npit) #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v = #nse;
                #lhs = (#npit) #v;
                     ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "cast"
    };

    compound_reference_cast_expression_primitive {
        \find(\modality{#allmodal}{.. #lhs = (#pit) #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v = #nse;
                #lhs = (#pit) #v;
                     ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "cast"
    };

    delete_unnecessary_cast {
        \find(\modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(#npit, G), \sub(\typeof(#se), G))
        "Normal Execution (#se instanceof #npit)":
            \replacewith({#lhs := #addCast(#se, #lhs)}\modality{#allmodal}{.. ...}\endmodality (post))
            \add(#se = null | G::instance(#se) = TRUE ==>)
        \heuristics(simplify_prog)
    };

}

\rules(programRules:Java, runtimeExceptions:allow) {

    reference_type_cast {
        \find(\modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(#npit, G), \not \sub(\typeof(#se), G))
        "Normal Execution (#se instanceof #npit)":
            \replacewith({#lhs := #addCast(#se, #lhs)}\modality{#allmodal}{.. ...}\endmodality (post))
            \add(#se = null | G::instance(#se) = TRUE ==>);
        "ClassCastException (!(#se instanceof #npit))":
            \replacewith(\modality{#allmodal}{.. throw new java.lang.ClassCastException();
                    ...}\endmodality (post))
            \add( ==> #se = null | G::instance(#se) = TRUE)
        \heuristics(simplify_prog)
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {
    reference_type_cast {
        \find( ==> \modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality (post))
        \varcond(\hasSort(#npit, G), \not \sub(\typeof(#se), G))
        "Normal Execution (#se instanceof #npit)":
            \replacewith( ==> {#lhs := #addCast(#se, #lhs)}\modality{#allmodal}{.. ...}\endmodality (post))
            // \add(#se = null | G::instance(#se) = TRUE ==>)
        ;
        "ClassCastException (!(#se instanceof #npit))":
            \replacewith( ==> false)
            \add( ==> #se = null | G::instance(#se) = TRUE)
        \heuristics(simplify_prog)
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
    reference_type_cast {
        \find(\modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality (post))
        \varcond(\hasSort(#npit, G))
        \replacewith({#lhs := #addCast(#se, #lhs)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };
}

// --------------- methods ----------------------------------------------------//

\rules(programRules:Java, runtimeExceptions:allow) {
    methodCall {
        \find(\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\not \staticMethodReference(#se, #mn, #selist),
            \mayExpandMethod(#se, #mn, #selist))
        "Normal Execution (#se != null )":
            \replacewith(\modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality (post))
            \add( ==> #se = null);
        "Null Reference (#se = null)":
            \replacewith(\modality{#allmodal}{.. throw new java.lang.NullPointerException();
                    ...}\endmodality (post))
            \add(#se = null ==>)
        \heuristics(method_expand)
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {
    methodCall {
        \find( ==> \modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality (post))
        \varcond(\not \staticMethodReference(#se, #mn, #selist),
            \mayExpandMethod(#se, #mn, #selist))
        "Normal Execution (#se != null )":
            \replacewith( ==> \modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality (post))
            // \add (==> #se = null)
        ;
        "Null Reference (#se = null)":
            \replacewith( ==> false)
            \add(#se = null ==>)
        \heuristics(method_expand)
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
    methodCall {
        \find(\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality (post))
        \varcond(\not \staticMethodReference(#se, #mn, #selist),
            \mayExpandMethod(#se, #mn, #selist))
        \replacewith(\modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality (post))
        \heuristics(method_expand)
    };
}

\rules(programRules:Java, runtimeExceptions:allow) {
    methodCallWithAssignment {
        \find(\modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality ((post)))
        \sameUpdateLevel
        \varcond(\newTypeOf(#v0, #lhs), \not \staticMethodReference(#se, #mn, #selist), \mayExpandMethod(#se, #mn, #selist))
        "Normal Execution (#se != null)":
            \replacewith(\modality{#allmodal}{.. #typeof(#lhs) #v0;
                      #method-call(#v0, #se.#mn(#selist));
                    #lhs = #v0;
                            ...}\endmodality (post))
            \add( ==> #se = null);
        "Null Reference (#se = null)":
            \replacewith(\modality{#allmodal}{.. throw new java.lang.NullPointerException();
                    ...}\endmodality (post))
            \add(#se = null ==>)
        \heuristics(method_expand)
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {
    methodCallWithAssignment {
        \find( ==> \modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality ((post)))
        \varcond(\newTypeOf(#v0, #lhs), \not \staticMethodReference(#se, #mn, #selist), \mayExpandMethod(#se, #mn, #selist))
        "Normal Execution (#se != null)":
            \replacewith( ==> \modality{#allmodal}{.. #typeof(#lhs) #v0;
                      #method-call(#v0, #se.#mn(#selist));
                    #lhs = #v0;
                            ...}\endmodality (post))
            // \add (==>#se = null)
        ;
        "Null Reference (#se = null)":
            \replacewith( ==> false)
            \add(#se = null ==>)
        \heuristics(method_expand)
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
    methodCallWithAssignment {
        \find(\modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality ((post)))
        \varcond(\newTypeOf(#v0, #lhs), \not \staticMethodReference(#se, #mn, #selist), \mayExpandMethod(#se, #mn, #selist))
        \replacewith(\modality{#allmodal}{.. #typeof(#lhs) #v0;
                  #method-call(#v0, #se.#mn(#selist));
                #lhs = #v0;
                        ...}\endmodality (post))
        \heuristics(method_expand)
    };
}

\rules(programRules:Java) {

    methodCallUnfoldArguments {
        \find(\modality{#allmodal}{.. #nsmr ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #evaluate-arguments(#nsmr); ...}\endmodality (post))
        \heuristics(simplify_autoname)
    };

    methodCallUnfoldTarget {
        \find(\modality{#allmodal}{.. #nse.#mn(#elist); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0;
                #v0 = #nse; #v0.#mn(#elist); ...}\endmodality (post))
        \heuristics(simplify_autoname)
    };
}

\rules(programRules:Java) {

    // may trigger static initialisation, but the super class has either
    // initialized or during initialisation, but not erroneous. So nothing
    // happens and we do not need to treat static initialisation here
    methodCallSuper {
        \find(\modality{#allmodal}{.#ex.. super.#mn(#elist); ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #method-call(#ex, super.#mn(#elist));
                ...}\endmodality (post))
        \heuristics(simplify_autoname, method_expand)
    };

    // may trigger static initialisation, but the super class has either
    // initialized or during initialisation, but not erroneous. So nothing
    // happens and we do not need to treat static initialisation here
    methodCallWithAssignmentSuper {
        \find(\modality{#allmodal}{.#ex.. #lhs=super.#mn(#elist); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs))
        \replacewith(\modality{#allmodal}{.. #typeof(#lhs) #v0;
                   #method-call(#ex, #v0, super.#mn(#elist));
                   #lhs = #v0;
                ...}\endmodality (post))
        \displayname "methodCallSuper"
        \heuristics(simplify_autoname, method_expand)
    };

    methodCallWithAssignmentUnfoldArguments {
        \find(\modality{#allmodal}{.. #lhs = #nsmr; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #evaluate-arguments(#lhs = #nsmr); ...}\endmodality (post))
        \heuristics(simplify_autoname)
        \displayname "methodCallUnfoldArguments"
    };

    methodCallWithAssignmentUnfoldTarget {
        \find(\modality{#allmodal}{.. #lhs = #nse.#mn(#elist); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0;
                #v0 = #nse; #lhs = #v0.#mn(#elist); ...}\endmodality (post))
        \heuristics(simplify_autoname)
        \displayname "methodCallUnfoldTarget"
    };

    methodCallEmpty {
        \find(\modality{#allmodal}{.. method-frame(#ex){} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    methodCallEmptyReturn {
        \find(\modality{#allmodal}{.. method-frame(#ex){return; #slist} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "methodCallReturn"
    };

    methodCallReturn {
        \find(\modality{#allmodal}{.. method-frame(#v0, #ex){return #se; #slist} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. method-frame(#ex){ #v0 = #se; } ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "methodCallReturn"
    };

    methodCallReturnIgnoreResult {
        \find(\modality{#allmodal}{.. method-frame(#ex){return #se; #slist} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \displayname "methodCallReturn"
        \heuristics(simplify_prog)
    };

    methodBodyExpand {
        \find(\modality{#allmodal}{.. #mb ...}\endmodality (post))
        \replacewith(#introAtPreDefs(\modality{#allmodal}{.. #expand-method-body(#mb); ...}\endmodality (post)))
        \heuristics(simplify_prog)
    };

    blockReturnNoValue {
        \find(\modality{#allmodal}{.. {return; #slist} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. return;  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockReturn"
    };

    blockReturn {
        \find(\modality{#allmodal}{.. {return #se; #slist} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. return #se;  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockReturn"
    };

    blockReturnLabel1 {
        \find(\modality{#allmodal}{.. #lb: return #se; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. return #se;  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockReturn (remove label)"
    };

    blockReturnLabel2 {
        \find(\modality{#allmodal}{.. #lb: { return #se; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. return #se;  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockReturn (remove label)"
    };

    methodCallThrow {
        \find(\modality{#allmodal}{.. method-frame(#ex){throw #se; #slist} ...}\endmodality (post))
        \varcond(\isLocalVariable(#se))
        \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "methodCallThrow"
    };

    methodCallParamThrow {
        \find(\modality{#allmodal}{.. method-frame(#v0, #ex){throw #se; #slist}
                ...}\endmodality (post))
        \varcond(\isLocalVariable(#se))
        \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "methodCallThrow"
    };

    // throwEvaluate in the book, ignored for consistency reasons
    throwUnfoldMore {
        \find(\modality{#allmodal}{.. throw #se; ...}\endmodality (post))
        \varcond(\not \isLocalVariable(#se), \newTypeOf(#v0, #se))
        \replacewith(\modality{#allmodal}{.. #typeof(#se) #v0 = #se; throw #v0; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "throwUnfold"
    };

    blockThrow {
        \find(\modality{#allmodal}{.. {throw #e; #slist} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. throw #e;  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockThrow"
    };

    methodCallEmptyNoreturnBox {
        \find(\[{.. method-frame(#v0, #ex){} ...}\] (post))
        \replacewith(\[{..  ...}\] (post))
        \displayname "methodCallEmpty"
        \heuristics(simplify_prog)
    };

    // --------------- if-statements ----------------------------------------------//

    ifUnfold {
        \find(\modality{#allmodal}{.. if(#nse) #s0 ...}\endmodality (post))
        \varcond(\new(#boolv, boolean))
        \replacewith(\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 ...}\endmodality (post))
        \heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    ifElseUnfold {
        \find(\modality{#allmodal}{.. if(#nse) #s0 else #s1 ...}\endmodality (post))
        \varcond(\new(#boolv, boolean))
        \replacewith(\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 else{#s1}
                ...}\endmodality (post))
        \heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    if {
        \find(\modality{#allmodal}{.. if(#se) #s0  ...}\endmodality (post))
        \replacewith(\if(#se = TRUE) \then(\modality{#allmodal}{.. #s0 ...}\endmodality (post))
                \else(\modality{#allmodal}{.. ...}\endmodality (post)))
        // \heuristics(split_if)
        \displayname "ifElse"
    };

    ifElse {
        \find(\modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality (post))
        \replacewith(\if(#se = TRUE) \then(\modality{#allmodal}{.. #s0 ...}\endmodality (post))
                \else(\modality{#allmodal}{.. #s1 ...}\endmodality (post)))
        // \heuristics(split_if)
        \displayname "ifElse"
    };

    ifElseSplit {
        \find( ==> \modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality (post))
        "if #se true":
            \replacewith( ==> \modality{#allmodal}{.. #s0 ...}\endmodality (post)) \add(#se = TRUE ==>);
        "if #se false":
            \replacewith( ==> \modality{#allmodal}{.. #s1 ...}\endmodality (post)) \add(#se = FALSE ==>)
        \heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifSplit {
        \find( ==> \modality{#allmodal}{.. if(#se) #s0  ...}\endmodality (post))
        "if #se true":
            \replacewith( ==> \modality{#allmodal}{.. #s0 ...}\endmodality (post)) \add(#se = TRUE ==>);
        "if #se false":
            \replacewith( ==> \modality{#allmodal}{..  ...}\endmodality (post)) \add(#se = FALSE ==>)
        \heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifElseSplitLeft {
        \find(\modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality (post) ==>)
        \replacewith(\modality{#allmodal}{.. #s0 ...}\endmodality (post) ==>) \add(#se = TRUE ==>);
        \replacewith(\modality{#allmodal}{.. #s1 ...}\endmodality (post) ==>) \add(#se = FALSE ==>) \heuristics(split_if)
    };

    ifSplitLeft {
        \find(\modality{#allmodal}{.. if(#se) #s0  ...}\endmodality (post) ==>)
        \replacewith(\modality{#allmodal}{.. #s0 ...}\endmodality (post) ==>) \add(#se = TRUE ==>);
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post) ==>) \add(#se = FALSE ==>) \heuristics(split_if)
    };

    ifTrue {
        \assumes(#se = TRUE ==>)
        \find( ==> \modality{#allmodal}{.. if (#se) #s0 ...}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{.. #s0 ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    ifElseTrue {
        \assumes(#se = TRUE ==>)
        \find( ==> \modality{#allmodal}{.. if (#se) #s0 else #s1 ...}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{.. #s0 ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    ifFalse {
        \assumes(#se = FALSE ==>)
        \find( ==> \modality{#allmodal}{.. if (#se) #s0 ...}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    ifElseFalse {
        \assumes(#se = FALSE ==>)
        \find( ==> \modality{#allmodal}{.. if (#se) #s0 else #s1 ...}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{.. #s1 ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    ifEnterThen {
        \find(\modality{#allmodal}{.. #loc=true; if (#loc) #s0 ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #loc=true; #s0 ...}\endmodality (post))
        \heuristics(simplify)
    };

    ifSkipThen {
        \find(\modality{#allmodal}{.. #loc=false; if (#loc) #s0 ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #loc=false; ...}\endmodality (post))
        \heuristics(simplify)
    };

    ifElseSkipElse {
        \find(\modality{#allmodal}{.. #loc=true; if (#loc) #s0 else #s1 ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #loc=true; #s0 ...}\endmodality (post))
        \heuristics(simplify)
    };

    ifElseSkipThen {
        \find(\modality{#allmodal}{.. #loc=false; if (#loc) #s0 else #s1 ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #loc=false; #s1 ...}\endmodality (post))
        \heuristics(simplify)
    };

    ifEnterThenConditionInBlock {
        \find(\modality{#allmodal}{.. { #loc=true; } if (#loc) #s0 ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #loc=true; } #s0 ...}\endmodality (post))
        \heuristics(simplify)
        \displayname "ifEnterThen"
    };

    ifSkipThenConditionInBlock {
        \find(\modality{#allmodal}{.. { #loc=false; } if (#loc) #s0 ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #loc=false; } ...}\endmodality (post))
        \heuristics(simplify)
        \displayname "ifSkipThen"
    };

    ifElseSkipElseConditionInBlock {
        \find(\modality{#allmodal}{.. { #loc=true;} if (#loc) #s0 else #s1 ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #loc=true;} #s0 ...}\endmodality (post))
        \heuristics(simplify)
        \displayname "ifElseSkipElse"
    };

    ifElseSkipThenConditionInBlock {
        \find(\modality{#allmodal}{.. { #loc=false; } if (#loc) #s0 else #s1 ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #loc=false; } #s1 ...}\endmodality (post))
        \heuristics(simplify)
        \displayname "ifElseSkipThen"
    };

    // --------------- switch-statements ------------------------------------------//


    switch {
        \find(\modality{#allmodal}{.. #sw ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #switch-to-if(#sw) ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    // --------------- labels and blocks ------------------------------------------//


    break {
        \find(\modality{#allmodal}{.. #lb0: break #lb1;  ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #do-break(#lb0: break #lb1;); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    blockBreakNoLabel {
        \find(\modality{#allmodal}{.. { break #lb1; #slist} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. break #lb1; ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockBreakNoLabel"
    };

    blockBreakLabel {
        \find(\modality{#allmodal}{.. #lb0: {break #lb1; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #do-break(#lb0: break #lb1;); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    blockEmptyLabel {
        \find(\modality{#allmodal}{.. #lb:{} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. {}  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockEmpty"
    };

    blockEmpty {
        \find(\modality{#allmodal}{.. {} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    unusedLabel {
        \find(\modality{#allmodal}{.. #lb: #s ...}\endmodality (post))
        \varcond(\not \freeLabelIn(#lb, #s))
        \replacewith(\modality{#allmodal}{.. #s ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    emptyStatement {
        \find(\modality{#allmodal}{.. ; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    synchronizedBlockEvalSync {
        \find(\modality{#allmodal}{.. synchronized(#nsencr){ #slist } ...}\endmodality (post))
        \varcond(\not \isLocalVariable(#nsencr), \newTypeOf(#loc, #nsencr))
        \replacewith(\modality{#allmodal}{.. #typeof(#nsencr) #loc=#nsencr; synchronized(#loc){ #slist } ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java, runtimeExceptions:ban) {

    synchronizedBlockEmpty {
        \find( ==> \modality{#allmodal}{.. synchronized(#se){} ...}\endmodality (post))
        \varcond(\isLocalVariable(#se))
        "Normal Execution":
            \replacewith( ==> \modality{#allmodal}{..  ...}\endmodality (post));
        "#se is not null":
            \replacewith( ==> #se != null)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java, runtimeExceptions:ignore) {

    synchronizedBlockEmpty {
        \find( ==> \modality{#allmodal}{.. synchronized(#se){} ...}\endmodality (post))
        \varcond(\isLocalVariable(#se))
        "Normal Execution":
            \replacewith( ==> \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java, runtimeExceptions:allow) {

    synchronizedBlockEmpty {
        \find( ==> \modality{#allmodal}{.. synchronized(#se){} ...}\endmodality (post))
        \varcond(\isLocalVariable(#se))
        \replacewith( ==> \modality{#allmodal}
                {.. if(#se==null){throw new java.lang.NullPointerException();}  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java) {

    synchronizedBlockEmpty2 {
        \find(\modality{#allmodal}{.. synchronized(#cr){} ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "synchronizedBlockEmpty"
    };

    // ----------------------------------------------------------------------------
    // -----------                  instanceof                -----------
    // ----------------------------------------------------------------------------

    instanceof_eval {
        \find(\modality{#allmodal}{.. #v = #nse instanceof #t; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{..#typeof(#nse) #v0=#nse;
                #v=#v0 instanceof #t;...}\endmodality (post))
        \heuristics(simplify_autoname)
    };

    // ----------------------------------------------------------------------------
    // -----------            Compile-time constant variables           -----------
    // ----------------------------------------------------------------------------

    insert_constant_value {
        \find(#cv)
        \replacewith(#constantvalue(#cv))
        \heuristics(concrete)
    };

    // ------------------------------------------------------------------------
    // ------------ Rules for conditional expression
    // ------------------------------------------------------------------------


    condition {
        \find(\modality{#allmodal}{.. #lhs = #e0 ? #e1 : #e2; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. if(#e0) {#lhs = #e1;}
                else {#lhs = #e2;} ...}\endmodality (post))
        \heuristics(simplify_prog, split_if)
    };

    condition_not_simple {
        \find(\modality{#allmodal}{.. #lhs = #nse ? #se1 : #se2; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0 = #nse; #lhs = #v0 ? #se1 : #se2; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "condition"
    };

    condition_simple {
        \find(\modality{#allmodal}{.. #lhs = #se0 ? #se1 : #se2; ...}\endmodality (post))
        \replacewith({#lhs := \if(#se0 = TRUE) \then(#se1) \else(#se2)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "condition"
    };

    // ------------------------------------------------------------------------
    // ------------ Rules for comparison operators
    // ------------------------------------------------------------------------

    equality_comparison_new {
        \find(\modality{#allmodal}{.. #lhs = #senf0 == #senf1; ...}\endmodality (post))
        \replacewith(\if(!#senf0 = #senf1)
                \then(\modality{#allmodal}{.. #lhs = false; ...}\endmodality (post))
                \else(\modality{#allmodal}{.. #lhs = true;  ...}\endmodality (post)))
        \heuristics(obsolete, simplify_prog, split_if)
        \displayname "equality comparison"
    };

    equality_comparison_simple {
        \find(\modality{#allmodal}{.. #lhs = #senf0 == #senf1; ...}\endmodality (post))
        \replacewith({#lhs := \if(#senf0 = #senf1) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality comparison"
    };

    inequality_comparison_new {
        \find(\modality{#allmodal}{.. #lhs = #senf0 != #senf1; ...}\endmodality (post))
        \replacewith(\if(!#senf0 = #senf1) \then(\modality{#allmodal}{.. #lhs = true; ...}\endmodality (post))
                \else(\modality{#allmodal}{.. #lhs = false; ...}\endmodality (post)))
        \heuristics(obsolete, simplify_prog, split_if)
        \displayname "inequality comparison"
    };

    inequality_comparison_simple {
        \find(\modality{#allmodal}{.. #lhs = #senf0 != #senf1; ...}\endmodality (post))
        \replacewith({#lhs := \if(#senf0 = #senf1) \then(FALSE) \else(TRUE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality comparison"
    };

    less_than_comparison_new {
        \find(\modality{#allmodal}{.. #lhs = #senf0 < #senf1; ...}\endmodality (post))
        \replacewith(\if(lt(#senf0, #senf1)) \then(\modality{#allmodal}{.. #lhs = true;  ...}\endmodality (post))
                \else(\modality{#allmodal}{.. #lhs = false; ...}\endmodality (post)))
        \heuristics(obsolete, simplify_prog, split_if)
        \displayname "lesser than distinction"
    };

    less_than_comparison_simple {
        \find(\modality{#allmodal}{.. #lhs = #senf0 < #senf1; ...}\endmodality (post))
        \replacewith({#lhs := \if(lt(#senf0, #senf1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "lesser than distinction"
    };

    less_equal_than_comparison_new {
        \find(\modality{#allmodal}{.. #lhs = #senf0 <= #senf1; ...}\endmodality (post))
        \replacewith(\if(leq(#senf0, #senf1)) \then(\modality{#allmodal}{.. #lhs = true; ...}\endmodality (post))
                \else(\modality{#allmodal}{.. #lhs = false; ...}\endmodality (post)))
        \heuristics(obsolete, simplify_prog, split_if)
        \displayname "less-or-equal than distinction"
    };

    less_equal_than_comparison_simple {
        \find(\modality{#allmodal}{.. #lhs = #senf0 <= #senf1; ...}\endmodality (post))
        \replacewith({#lhs := \if(leq(#senf0, #senf1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less-or-equal than distinction"
    };

    greater_than_comparison_new {
        \find(\modality{#allmodal}{.. #lhs = #senf0 > #senf1; ...}\endmodality (post))
        \replacewith(\if(gt(#senf0, #senf1)) \then(\modality{#allmodal}{.. #lhs = true;  ...}\endmodality (post))
                \else(\modality{#allmodal}{.. #lhs = false; ...}\endmodality (post)))
        \heuristics(obsolete, simplify_prog, split_if)
        \displayname "greater than distinction"
    };

    greater_than_comparison_simple {
        \find(\modality{#allmodal}{.. #lhs = #senf0 > #senf1; ...}\endmodality (post))
        \replacewith({#lhs := \if(gt(#senf0, #senf1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater than distinction"
    };

    greater_equal_than_comparison_new {
        \find(\modality{#allmodal}{.. #lhs = #senf0 >= #senf1; ...}\endmodality (post))
        \replacewith(\if(geq(#senf0, #senf1)) \then(\modality{#allmodal}{.. #lhs = true; ...}\endmodality (post))
                \else(\modality{#allmodal}{.. #lhs = false; ...}\endmodality (post)))
        \heuristics(obsolete, simplify_prog, split_if)
        \displayname "greater-or-equal than distinction"
    };

    greater_equal_than_comparison_simple {
        \find(\modality{#allmodal}{.. #lhs = #senf0 >= #senf1; ...}\endmodality (post))
        \replacewith({#lhs := \if(geq(#senf0, #senf1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater-or-equal than distinction"
    };

    // ------------------------------------------------------------------------
    // ----------- Rules for handling a cast applied to a compound expression
    // ------------------------------------------------------------------------

    compound_byte_cast_expression {
        \find(\modality{#allmodal}{.. #lhs = (byte) #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (byte) #v;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "cast"
    };

    compound_short_cast_expression {
        \find(\modality{#allmodal}{.. #lhs = (short) #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (short) #v;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "cast"
    };

    compound_int_cast_expression {
        \find(\modality{#allmodal}{.. #lhs = (int) #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (int) #v;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "cast"
    };

    compound_long_cast_expression {
        \find(\modality{#allmodal}{.. #lhs = (long) #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (long) #v;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "cast"
    };

    // ------------------------------------------------------------------------
    // ----------- Rules for expanding compound assignment operators
    // ------------------------------------------------------------------------

    compound_assignment_op_mul_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute *= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute * #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_mul_array {
        \find(\modality{#allmodal}{.. #e0[#e] *= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] * #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_mul {
        \find(\modality{#allmodal}{.. #lhs *= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs * (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_div_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute /= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute / #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_div_array {
        \find(\modality{#allmodal}{.. #e0[#e] /= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] / #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_div {
        \find(\modality{#allmodal}{.. #lhs /= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs / (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_mod_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute %= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute % #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_mod_array {
        \find(\modality{#allmodal}{.. #e0[#e] %= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] % #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_mod {
        \find(\modality{#allmodal}{.. #lhs %= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs % (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_plus_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute += #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute + #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_plus_array {
        \find(\modality{#allmodal}{.. #e0[#e] += #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] + #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_plus {
        \find(\modality{#allmodal}{.. #lhs += #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs + (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_minus_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute -= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute - #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_minus_array {
        \find(\modality{#allmodal}{.. #e0[#e] -= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] - #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_minus {
        \find(\modality{#allmodal}{.. #lhs -= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs - (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_shiftleft_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute <<= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute << #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_shiftleft_array {
        \find(\modality{#allmodal}{.. #e0[#e] <<= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] << #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_shiftleft {
        \find(\modality{#allmodal}{.. #lhs <<= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs << (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_shiftright_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute >>= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute >> #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_shiftright_array {
        \find(\modality{#allmodal}{.. #e0[#e] >>= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] >> #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_shiftright {
        \find(\modality{#allmodal}{.. #lhs >>= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs >> (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_unsigned_shiftright_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute >>>= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute >>> #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_unsigned_shiftright_array {
        \find(\modality{#allmodal}{.. #e0[#e] >>>= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] >>> #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_unsigned_shiftright {
        \find(\modality{#allmodal}{.. #lhs >>>= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs >>> (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_and_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute &= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute & #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_and_array {
        \find(\modality{#allmodal}{.. #e0[#e] &= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] & #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_and {
        \find(\modality{#allmodal}{.. #lhs &= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs & (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_or_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute |= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute | #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_or_array {
        \find(\modality{#allmodal}{.. #e0[#e] |= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] | #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_or {
        \find(\modality{#allmodal}{.. #lhs |= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs | (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_xor_attr {
        \find(\modality{#allmodal}{.. #e0.#attribute ^= #e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute ^ #e); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_xor_array {
        \find(\modality{#allmodal}{.. #e0[#e] ^= #e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0), \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e;
                #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] ^ #e1); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    compound_assignment_op_xor {
        \find(\modality{#allmodal}{.. #lhs ^= #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = (#typeof(#lhs))(#lhs ^ (#e)); ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    // ------------------------------------------------------------------------
    // ----------- Rule for expanding iterated assignments -------------------
    // ------------------------------------------------------------------------

    eval_order_iterated_assignments_0_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]=#e1;
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_0_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute=#e;
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_0 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1=#e; #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_1_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]*=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] * #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_1_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute*=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute * #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_1 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1*=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 * #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_2_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]/=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] / #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_2_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute/=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute / #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_2 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1/=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 / #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_3_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]%=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] % #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_3_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute%=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute % #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_3 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1%=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 % #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_4_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]+=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] + #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_4_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute+=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute + #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_4 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1+=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 + #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_5_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]-=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] - #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_5_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute-=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute - #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_5 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1-=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 - #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_6_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]<<=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] << #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_6_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute<<=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute << #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_6 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1<<=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 << #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_7_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]>>=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] >> #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_7_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute>>=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute >> #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_7 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1>>=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 >> #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_8_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]>>>=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] >>> #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_8_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute>>>=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute >>> #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_8 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1>>>=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 >>> #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_9_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]&=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] & #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_9_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute&=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute & #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_9 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1&=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 & #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_10_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]|=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] | #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_10_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute|=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute | #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_10 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1|=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 | #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_11_0 {
        \find(\modality{#allmodal}{.. #lhs0=#e0[#e]^=#e1; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0),
            \newTypeOf(#v1, #e))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #typeof(#e) #v1=#e;
                #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] ^ #e1);
                #lhs0=#v0[#v1];  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    eval_order_iterated_assignments_11_1 {
        \find(\modality{#allmodal}{.. #lhs0=#e0.#attribute^=#e; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e0) #v0=#e0;
                #v0.#attribute = (#typeof(#attribute))(#v0.#attribute ^ #e);
                #lhs0=#v0.#attribute;  ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    iterated_assignments_11 {
        \find(\modality{#allmodal}{.. #lhs0=#lhs1^=#e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 ^ #e); #lhs0=#lhs1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "eval_order_iterated_assignments"
    };

    // ------------------------------------------------------------------------
    // ----------- Rule for removing redundant braces
    // ------------------------------------------------------------------------

    elim_double_block {
        \find(\modality{#allmodal}{{ #slist }}\endmodality (post))
        \replacewith(\modality{#allmodal}{ #slist }\endmodality (post))
        \heuristics(simplify_prog)
    };

    elim_double_block_2 {
        \find(\modality{#allmodal}{.. { { #slist } } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #slist } ...}\endmodality (post))
        \displayname "elim_double_block"
        \heuristics(simplify_prog)
    };

    elim_double_block_3 {
        \find(\modality{#allmodal}{.. { while ( #e ) #s } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. while ( #e ) #s ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "elim_double_block"
    };

    elim_double_block_4 {
        \find(\modality{#allmodal}{.. { for(#loopInit; #guard; #forupdates) #s } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "elim_double_block"
    };

    elim_double_block_5 {
        \find(\modality{#allmodal}{.. { for(; #guard; #forupdates) #s } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. for(; #guard; #forupdates) #s ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "elim_double_block"
    };

    elim_double_block_6 {
        \find(\modality{#allmodal}{.. { for(#loopInit; #guard;) #s } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. for(#loopInit; #guard;) #s ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "elim_double_block"
    };

    elim_double_block_7 {
        \find(\modality{#allmodal}{.. { for(; #guard;) #s } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. for(; #guard;) #s ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "elim_double_block"
    };

    elim_double_block_8 {
        \find(\modality{#allmodal}{.. { do #s while (#e); } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. do #s while (#e); ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "elim_double_block"
    };

    elim_double_block_9 {
        \find(\modality{#allmodal}{.. { { #slist } { #slist1 } } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. { #slist } { #slist1 } ...}\endmodality (post))
        \displayname "elim_double_block"
        \heuristics(simplify_prog)
    };

    // ------------------------------------------------------------------------
    // ----------- Rule for removing redundant parentheses
    // ------------------------------------------------------------------------

    remove_parentheses_right {
        \find(\modality{#allmodal}{.. #lhs = (#e); ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #e; ...}\endmodality (post)) \heuristics(simplify_prog)
    };

    remove_parentheses_attribute_left {
        \find(\modality{#allmodal}{.. (#e.#attribute) = #e0; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #e.#attribute = #e0; ...}\endmodality (post)) \heuristics(simplify_prog)
        \displayname "remove_parentheses"
    };

    remove_parentheses_lhs_left {
        \find(\modality{#allmodal}{.. (#lhs) = #e; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #lhs = #e; ...}\endmodality (post)) \heuristics(simplify_prog)
        \displayname "remove_parentheses"
    };

    // ------------------------------------------------------------------------
    // ----------- Rules for binary arithmetic operators applied to at least one compound expression
    // ------------------------------------------------------------------------

    compound_multiplication_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse * #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v * #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "multiplication"
    };

    compound_multiplication_2 {
        \find(\modality{#allmodal}{.. #lhs=#e * #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 * #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "multiplication"
    };

    compound_division_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse / #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v / #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "division"
    };

    compound_division_2 {
        \find(\modality{#allmodal}{.. #lhs=#e / #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 / #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "division"
    };

    compound_modulo_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse % #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v % #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "modulo"
    };

    compound_modulo_2 {
        \find(\modality{#allmodal}{.. #lhs=#e % #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 % #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "modulo"
    };

    compound_addition_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse + #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v + #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "addition"
    };

    compound_addition_2 {
        \find(\modality{#allmodal}{.. #lhs=#e + #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 + #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "addition"
    };

    compound_binary_AND_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse & #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v & #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "binary_AND"
    };

    compound_binary_AND_2 {
        \find(\modality{#allmodal}{.. #lhs=#e & #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 & #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "binary_AND"
    };

    compound_binary_OR_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse | #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v | #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "binary_OR"
    };

    compound_binary_OR_2 {
        \find(\modality{#allmodal}{.. #lhs=#e | #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 | #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "binary_OR"
    };

    compound_binary_XOR_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse ^ #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v ^ #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "binary_XOR"
    };

    compound_binary_XOR_2 {
        \find(\modality{#allmodal}{.. #lhs=#e ^ #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 ^ #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "binary_XOR"
    };

    compound_invert_bits {
        \find(\modality{#allmodal}{.. #lhs=~#nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{..  #typeof(#nse) #v1=#nse; #lhs=~#v1 ; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "invert_bits"
    };

    compound_subtraction_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse - #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v - #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "subtraction"
    };

    compound_subtraction_2 {
        \find(\modality{#allmodal}{.. #lhs=#e - #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 - #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "subtraction"
    };

    compound_shiftright_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse >> #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >> #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift"
    };

    compound_shiftright_2 {
        \find(\modality{#allmodal}{.. #lhs=#e >> #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >> #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift"
    };

    compound_unsigned_shiftright_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse >>> #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >>> #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift"
    };

    compound_unsigned_shiftright_2 {
        \find(\modality{#allmodal}{.. #lhs=#e >>> #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >>> #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift"
    };

    compound_shiftleft_1 {
        \find(\modality{#allmodal}{.. #lhs=#nse << #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v << #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift"
    };

    compound_shiftleft_2 {
        \find(\modality{#allmodal}{.. #lhs=#e << #nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 << #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift"
    };

    compound_equality_comparison_1 {
        \find(\modality{#allmodal}{.. #lhs = #nse0 == #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 == #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality"
    };

    compound_equality_comparison_2 {
        \find(\modality{#allmodal}{.. #lhs = #e == #nse0; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 == #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality"
    };

    compound_inequality_comparison_1 {
        \find(\modality{#allmodal}{.. #lhs = #nse0 != #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 != #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality"
    };

    compound_inequality_comparison_2 {
        \find(\modality{#allmodal}{.. #lhs = #e != #nse0; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 != #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality"
    };

    compound_less_than_comparison_1 {
        \find(\modality{#allmodal}{.. #lhs = #nse0 < #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 < #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less_than"
    };

    compound_less_than_comparison_2 {
        \find(\modality{#allmodal}{.. #lhs = #e < #nse0; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 < #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less_than"
    };

    compound_less_equal_than_comparison_1 {
        \find(\modality{#allmodal}{.. #lhs = #nse0 <= #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 <= #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less_or_equal"
    };

    compound_less_equal_than_comparison_2 {
        \find(\modality{#allmodal}{.. #lhs = #e <= #nse0; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 <= #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less_or_equal"
    };

    compound_greater_than_comparison_1 {
        \find(\modality{#allmodal}{.. #lhs = #nse0 > #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 > #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater_than"
    };

    compound_greater_than_comparison_2 {
        \find(\modality{#allmodal}{.. #lhs = #e > #nse0; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 > #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater_than"
    };

    compound_greater_equal_than_comparison_1 {
        \find(\modality{#allmodal}{.. #lhs = #nse0 >= #se; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 >= #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater_or_equal"
    };

    compound_greater_equal_than_comparison_2 {
        \find(\modality{#allmodal}{.. #lhs = #e >= #nse0; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #e), \newTypeOf(#v1, #nse0))
        \replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 >= #v1; ...}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater_or_equal"
    };

    // ------------------------------------------------------------------------
    // ---------------------- Rules boolean expressions -----------------------
    // ------------------------------------------------------------------------


    // new rules which do not necessarily lead to proof splits -- DB 09/08/12

    compound_assignment_1_new {
        \find(\modality{#allmodal}{.. #lhs=!#seBool; ...}\endmodality (post))
        \replacewith({#lhs := \if(#seBool = TRUE) \then(FALSE) \else(TRUE)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "assignment_negation"
    };

    compound_assignment_2 {
        \find(\modality{#allmodal}{.. #lhs=!#nseBool; ...}\endmodality (post))
        \varcond(\new(#v, boolean))
        \replacewith(\modality{#allmodal}{.. boolean #v=#nseBool; #lhs=!#v; ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "compound_assignment"
    };

    compound_assignment_3_nonsimple {
        \find(\modality{#allmodal}{.. #lhs=#exBool0 && #nseBool1; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. if (!#exBool0) #lhs=false; else #lhs=#nseBool1; ...}\endmodality (post))
        \heuristics(simplify_expression, split_if)
        \displayname "compound_assignment"
    };

    compound_assignment_3_mixed {
        \find(\modality{#allmodal}{.. #lhs=#nseBool0 && #seBool1; ...}\endmodality (post))
        \varcond(\new(#v0, boolean))
        \replacewith(\modality{#allmodal}{.. boolean #v0 = #nseBool0; #lhs = #v0 && #seBool1; ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "compound_assignment"
    };

    compound_assignment_3_simple {
        \find(\modality{#allmodal}{.. #lhs=#seBool0 && #seBool1; ...}\endmodality (post))
        \replacewith({#lhs := \if(#seBool0 = TRUE) \then(\if(#seBool1 = TRUE) \then(TRUE) \else(FALSE)) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "assignment_and"
    };

    compound_assignment_4_nonsimple {
        \find(\modality{#allmodal}{.. #lhs=#nseBool0 & #exBool1; ...}\endmodality (post))
        \varcond(\new(#v0, boolean), \new(#v1, boolean))
        \replacewith(\modality{#allmodal}{.. boolean #v0 = #nseBool0;
                boolean #v1 = #exBool1; #lhs= #v0 & #v1; ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "compound_assignment"
    };

    compound_assignment_4_simple {
        \find(\modality{#allmodal}{.. #lhs=#seBool0 & #seBool1; ...}\endmodality (post))
        \replacewith({#lhs := \if(#seBool0 = TRUE) \then(\if(#seBool1 = TRUE) \then(TRUE) \else(FALSE)) \else(FALSE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "assignment_and"
    };

    compound_assignment_5_nonsimple {
        \find(\modality{#allmodal}{.. #lhs=#exBool0 || #nseBool1; ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. if (#exBool0) #lhs=true; else #lhs=#nseBool1; ...}\endmodality (post))
        \heuristics(simplify_expression, split_if)
        \displayname "compound_assignment"
    };

    compound_assignment_5_mixed {
        \find(\modality{#allmodal}{.. #lhs=#nseBool0 || #seBool1; ...}\endmodality (post))
        \varcond(\new(#v0, boolean))
        \replacewith(\modality{#allmodal}{.. boolean #v0 = #nseBool0; #lhs = #v0 || #seBool1; ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "compound_assignment"
    };

    compound_assignment_5_simple {
        \find(\modality{#allmodal}{.. #lhs=#seBool0 || #seBool1; ...}\endmodality (post))
        \replacewith({#lhs := \if(#seBool0 = TRUE) \then(TRUE) \else(\if(#seBool1 = TRUE) \then(TRUE) \else(FALSE))}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "assignment_or"
    };

    compound_assignment_6_nonsimple {
        \find(\modality{#allmodal}{.. #lhs=#nseBool0 | #exBool1; ...}\endmodality (post))
        \varcond(\new(#v0, boolean), \new(#v1, boolean))
        \replacewith(\modality{#allmodal}{.. boolean #v0 = #nseBool0;
                boolean #v1 = #exBool1; #lhs = #v0 | #v1; ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "compound_assignment"
    };

    compound_assignment_6_simple {
        \find(\modality{#allmodal}{.. #lhs=#seBool0 | #seBool1; ...}\endmodality (post))
        \replacewith({#lhs := \if(#seBool0 = TRUE) \then(TRUE) \else(\if(#seBool1 = TRUE) \then(TRUE) \else(FALSE))}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "assignment_or"
    };

    compound_assignment_xor_nonsimple {
        \find(\modality{#allmodal}{.. #lhs=#nseBool0 ^ #exBool1; ...}\endmodality (post))
        \varcond(\new(#v0, boolean), \new(#v1, boolean))
        \replacewith(\modality{#allmodal}{.. boolean #v0 = #nseBool0;
                boolean #v1 = #exBool1; #lhs = #v0 ^ #v1; ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "compound_assignment"
    };

    compound_assignment_xor_simple {
        \find(\modality{#allmodal}{.. #lhs=#seBool0 ^ #seBool1; ...}\endmodality (post))
        \replacewith({#lhs := \if(#seBool0 = #seBool1) \then(FALSE) \else(TRUE)}
            \modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "assignment_xor"
    };

    // ------------------------------------------------------------------------
    // ----------- Rules for array and attribute expressions
    // ------------------------------------------------------------------------

    eval_order_array_access1 {
        \find(\modality{#allmodal}{..#nv[#e]=#e0;...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nv))
        \replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
                #v0[#e]=#e0;
                 ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentUnfoldLeft"
    };

    eval_order_array_access2 {
        \find(\modality{#allmodal}{..#v[#nse]=#e;...}\endmodality (post))
        \varcond(\newTypeOf(#ar1, #v), \newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{..#typeof(#v) #ar1 = #v;
                #typeof(#nse) #v0=#nse;
                #ar1[#v0]=#e;
                     ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentUnfoldLeft"
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
    eval_order_array_access3 {
        \find(\modality{#allmodal}{..#v[#se]=#nse;...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #v), \newTypeOf(#v1, #nse),
            \newTypeOf(#v2, #se))
        \replacewith(\modality{#allmodal}{..#typeof(#v) #v0=#v;
                #typeof(#se) #v2=#se;
                #typeof(#nse) #v1=#nse;
                #v0[#v2]=#v1; ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentSaveLocation"
    };
}

\rules(programRules:Java) {
    eval_order_array_access3 {
        \find(\modality{#allmodal}{..#v[#se]=#nse;...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #v), \newTypeOf(#v1, #nse),
            \newTypeOf(#v2, #se))
        \replacewith(\modality{#allmodal}{..#typeof(#v) #v0=#v;
                #typeof(#se) #v2=#se;
                #typeof(#nse) #v1=#nse;
                #v0[#v2]=#v1; ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentSaveLocation"
    };

    eval_order_array_access4 {
        \find(\modality{#allmodal}{..#v=#nv[#e];...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nv))
        \replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
                #v=#v0[#e];
                    ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentUnfoldRight"
    };

    eval_order_array_access5 {
        \find(\modality{#allmodal}{..#v=#v0[#nse];...}\endmodality (post))
        \varcond(\newTypeOf(#ar1, #v0), \newTypeOf(#v1, #nse))
        \replacewith(\modality{#allmodal}{..#typeof(#v0) #ar1 = #v0;
                #typeof(#nse) #v1=#nse;
                #v=#ar1[#v1];
                    ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentUnfoldRight"
    };

    eval_order_array_access6 {
        \find(\modality{#allmodal}{..#v=#nv.#length; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nv))
        \replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#length; ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentUnfoldRight"
    };

    // -----------------------------------------------------------------------


    eval_order_access1 {
        \find(\modality{#allmodal}{..#nv.#attribute=#e;...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nv))
        \replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v0.#attribute=#e;...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentUnfoldLeft"
    };

    eval_order_access2 {
        \find(\modality{#allmodal}{.. #v=#nv.#attribute; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nv))
        \replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#attribute;...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentUnfoldRight"
    };

    eval_order_access4_this {
        \find(\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v1, #nse),
            \not \static(#a),
            \isThisReference(#v))
        \replacewith(\modality{#allmodal}{..
                #typeof(#nse) #v1=#nse;
                #v.#a=#v1;...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentSaveLocationThis"
    };

    eval_order_access4 {
        \find(\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #v), \newTypeOf(#v1, #nse),
            \not \static(#a))

        \replacewith(\modality{#allmodal}{.. #typeof(#v) #v0=#v;
                #typeof(#nse) #v1=#nse;
                 #v0.#a=#v1;...}\endmodality (post))

        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentSaveLocation"
    };
}

\rules(programRules:Java, runtimeExceptions:allow) {
    assignment_to_reference_array_component {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find(\modality{#normal}{.. #v[#se]=#se0; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\isReferenceArray(#v))
        "Normal Execution (#v != null)":
            \replacewith({heap := store(heap, #v, arr(#se), #se0)}\modality{#normal}{.. ...}\endmodality (post))
            \add(!(#v = null) & lt(#se, length(#v)) & geq(#se, 0) & arrayStoreValid(#v, #se0) ==>);
        (permissions:on) {
            "Write Permission to #v[#se]":
                \replacewith(\modality{#normal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality (post))
                \add( ==> writePermission(Permission::select(permissions, #v, arr(#se))))
        };
        "Null Reference (#v = null)":
            \replacewith(\modality{#normal}{.. throw new java.lang.NullPointerException(); ...}\endmodality (post))
            \add(#v = null ==>);
        "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
            \replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality (post))
            \add(!(#v = null) & (leq(length(#v), #se) | lt(#se, 0)) ==>);
        "Array Store Exception (incompatible dynamic element type of #v and #se0)":
            \replacewith(\modality{#normal}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality (post))
            \add(!(#v = null) & lt(#se, length(#v)) & geq(#se, 0) & !arrayStoreValid(#v, #se0) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java, runtimeExceptions:allow, JavaCard:on) {
    assignment_to_reference_array_component_transaction {
        \schemaVar \modalOperator {diamond_transaction, box_transaction} #transaction;
        \find(\modality{#transaction}{.. #v[#se]=#se0; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\isReferenceArray(#v))
        "Normal Execution (#v != null)":
            \replacewith(
                {heap := store(heap, #v, arr(#se), #se0)}
                {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                        \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                        \else(\if(boolean::select(savedHeap, #v,
                                    java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                \then(store(savedHeap, #v, arr(#se), #se0))
                                \else(savedHeap))}
                \modality{#transaction}{.. ...}\endmodality (post))
            \add(!(#v = null) & lt(#se, length(#v)) & geq(#se, 0) & arrayStoreValid(#v, #se0) ==>);
        "Null Reference (#v = null)":
            \replacewith(\modality{#transaction}{.. throw new java.lang.NullPointerException(); ...}\endmodality (post))
            \add(#v = null ==>);
        "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
            \replacewith(\modality{#transaction}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality (post))
            \add(!(#v = null) & (leq(length(#v), #se) | lt(#se, 0)) ==>);
        "Array Store Exception (incompatible dynamic element type of #v and #se0)":
            \replacewith(\modality{#transaction}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality (post))
            \add(!(#v = null) & lt(#se, length(#v)) & geq(#se, 0) & !arrayStoreValid(#v, #se0) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment_to_reference_array_component"
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {
    assignment_to_reference_array_component {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find( ==> \modality{#normal}{.. #v[#se]=#se0; ...}\endmodality (post))
        \varcond(\isReferenceArray(#v))
        "Normal Execution (#v != null)":
            \replacewith( ==> {heap := store(heap, #v, arr(#se), #se0)}\modality{#normal}{.. ...}\endmodality (post))
            // \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>)
        ;
        (permissions:on) {
            "Write Permission to #v[#se]":
                \replacewith( ==> writePermission(Permission::select(permissions, #v, arr(#se))))
        };
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>);
        "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
            \replacewith( ==> false)
            \add(!(#v = null) & (leq(length(#v), #se) | lt(#se, 0)) ==>);
        "Array Store Exception (incompatible dynamic element type of #v and #se0)":
            \replacewith( ==> false)
            \add(!(#v = null) & lt(#se, length(#v)) & geq(#se, 0) & !arrayStoreValid(#v, #se0) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
    assignment_to_reference_array_component {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find(\modality{#normal}{.. #v[#se]=#se0; ...}\endmodality (post))
        \varcond(\isReferenceArray(#v))
        \replacewith({heap := store(heap, #v, arr(#se), #se0)}\modality{#normal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:ban, JavaCard:on) {
    assignment_to_reference_array_component_transaction {
        \schemaVar \modalOperator {diamond_transaction, box_transaction} #transaction;
        \find( ==> \modality{#transaction}{.. #v[#se]=#se0; ...}\endmodality (post))
        \varcond(\isReferenceArray(#v))
        "Normal Execution (#v != null)":
            \replacewith( ==>
                {heap := store(heap, #v, arr(#se), #se0)}
                {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                        \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                        \else(\if(boolean::select(savedHeap, #v,
                                    java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                \then(store(savedHeap, #v, arr(#se), #se0))
                                \else(savedHeap))}
                \modality{#transaction}{.. ...}\endmodality (post))
            // \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>)
        ;
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>);
        "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
            \replacewith( ==> false)
            \add(!(#v = null) & (leq(length(#v), #se) | lt(#se, 0)) ==>);
        "Array Store Exception (incompatible dynamic element type of #v and #se0)":
            \replacewith( ==> false)
            \add(!(#v = null) & lt(#se, length(#v)) & geq(#se, 0) & !arrayStoreValid(#v, #se0) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment_to_reference_array_component"
    };
}

\rules(programRules:Java, runtimeExceptions:ignore, JavaCard:on) {
    assignment_to_reference_array_component_transaction {
        \schemaVar \modalOperator {diamond_transaction, box_transaction} #transaction;
        \find(\modality{#transaction}{.. #v[#se]=#se0; ...}\endmodality (post))
        \varcond(\isReferenceArray(#v))
        \replacewith(
            {heap := store(heap, #v, arr(#se), #se0)}
            {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                    \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                    \else(\if(boolean::select(savedHeap, #v,
                                java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                            \then(store(savedHeap, #v, arr(#se), #se0))
                            \else(savedHeap))}
            \modality{#transaction}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment_to_reference_array_component"
    };
}

\rules(programRules:Java, runtimeExceptions:allow) {
    assignment_to_primitive_array_component {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find(\modality{#normal}{..#v[#se]=#se0;...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\not \isReferenceArray(#v))
        "Normal Execution (#v != null)":
            \replacewith({heap := store(heap, #v, arr(#se), #se0)}\modality{#normal}{.. ...}\endmodality (post))
            \add(!(#v = null) & lt(#se, length(#v)) & geq(#se, 0) ==>);
        (permissions:on) {
            "Write Permission to #v[#se]":
                \replacewith(\modality{#normal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality (post))
                \add( ==> writePermission(Permission::select(permissions, #v, arr(#se))))
        };
        "Null Reference (#v = null)":
            \replacewith(\modality{#normal}{..
                    throw new java.lang.NullPointerException();
                    ...}\endmodality (post))
            \add(#v = null ==>);
        "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
            \replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality (post))
            \add(!(#v = null) & (leq(length(#v), #se) | lt(#se, 0)) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:allow, JavaCard:on) {
    assignment_to_primitive_array_component_transaction {
        \schemaVar \modalOperator {diamond_transaction, box_transaction} #transaction;
        \find(\modality{#transaction}{..#v[#se]=#se0;...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\not \isReferenceArray(#v))
        "Normal Execution (#v != null)":
            \replacewith(
                {heap := store(heap, #v, arr(#se), #se0)}
                {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                        \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                        \else(\if(boolean::select(savedHeap, #v,
                                    java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                \then(store(savedHeap, #v, arr(#se), #se0))
                                \else(savedHeap))}
                \modality{#transaction}{.. ...}\endmodality (post))
            \add(!(#v = null) & lt(#se, length(#v)) & geq(#se, 0) ==>);
        "Null Reference (#v = null)":
            \replacewith(\modality{#transaction}{..
                    throw new java.lang.NullPointerException();
                    ...}\endmodality (post))
            \add(#v = null ==>);
        "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
            \replacewith(\modality{#transaction}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality (post))
            \add(!(#v = null) & (leq(length(#v), #se) | lt(#se, 0)) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment_to_primitive_array_component"
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {
    assignment_to_primitive_array_component {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find( ==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality (post))
        \varcond(\not \isReferenceArray(#v))
        "Normal Execution (#v != null)":
            \replacewith( ==> {heap := store(heap, #v, arr(#se), #se0)}\modality{#normal}{.. ...}\endmodality (post))
            // \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
        ;
        (permissions:on) {
            "Write Permission to #v[#se]":
                \replacewith( ==> writePermission(Permission::select(permissions, #v, arr(#se))))
        };
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>);
        "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
            \replacewith( ==> false)
            \add(!(#v = null) & (leq(length(#v), #se) | lt(#se, 0)) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
    assignment_to_primitive_array_component {
        \schemaVar \modalOperator {diamond, box} #normal;
        \find(\modality{#normal}{..#v[#se]=#se0;...}\endmodality (post))
        \varcond(\not \isReferenceArray(#v))
        \replacewith({heap := store(heap, #v, arr(#se), #se0)}\modality{#normal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:ban, JavaCard:on) {
    assignment_to_primitive_array_component_transaction {
        \schemaVar \modalOperator {diamond_transaction, box_transaction} #transaction;
        \find( ==> \modality{#transaction}{..#v[#se]=#se0;...}\endmodality (post))
        \varcond(\not \isReferenceArray(#v))
        "Normal Execution (#v != null)":
            \replacewith( ==>
                {heap := store(heap, #v, arr(#se), #se0)}
                {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                        \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                        \else(\if(boolean::select(savedHeap, #v,
                                    java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                \then(store(savedHeap, #v, arr(#se), #se0))
                                \else(savedHeap))}
                \modality{#transaction}{.. ...}\endmodality (post))
            // \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
        ;
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>);
        "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
            \replacewith( ==> false)
            \add(!(#v = null) & (leq(length(#v), #se) | lt(#se, 0)) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment_to_primitive_array_component"
    };

}

\rules(programRules:Java, runtimeExceptions:ignore, JavaCard:on) {
    assignment_to_primitive_array_component_transaction {
        \schemaVar \modalOperator {diamond_transaction, box_transaction} #transaction;
        \find(\modality{#transaction}{..#v[#se]=#se0;...}\endmodality (post))
        \varcond(\not \isReferenceArray(#v))
        \replacewith(
            {heap := store(heap, #v, arr(#se), #se0)}
            {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                    \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                    \else(\if(boolean::select(savedHeap, #v,
                                java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                            \then(store(savedHeap, #v, arr(#se), #se0))
                            \else(savedHeap))}
            \modality{#transaction}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment_to_primitive_array_component"
    };

}

\rules(programRules:Java, runtimeExceptions:allow) {
    assignment_array2 {
        \find(\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasElementarySort(#v0, G))
        "Normal Execution (#v0 != null)":
            \replacewith({#v := G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality (post))
            \add( ==> (#v0 = null) | leq(length(#v0), #se) | lt(#se, 0));
        (permissions:on) {
            "Read Permission to #v0[#se]":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, #v0, arr(#se))))
        };
        "Null Reference (#v0 = null)":
            \replacewith(\modality{#allmodal}{..
                    throw new java.lang.NullPointerException();
                        ...}\endmodality (post))
            \add(#v0 = null ==>);
        "Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
            \replacewith(\modality{#allmodal}{..
                    throw new java.lang.ArrayIndexOutOfBoundsException();
                    ...}\endmodality (post))
            \add(!(#v0 = null) & (leq(length(#v0), #se) | lt(#se, 0)) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {
    assignment_array2 {
        \find( ==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality (post))
        \varcond(\hasElementarySort(#v0, G))
        "Normal Execution (#v0 != null)":
            \replacewith( ==> {#v := G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality (post))
            // \add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
        ;
        (permissions:on) {
            "Read Permission to #v0[#se]":
                \replacewith( ==> readPermission(Permission::select(permissions, #v0, arr(#se))))
        };
        "Null Reference (#v0 = null)":
            \replacewith( ==> false)
            \add(#v0 = null ==>);
        "Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
            \replacewith( ==> false)
            \add(!(#v0 = null) & (leq(length(#v0), #se) | lt(#se, 0)) ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
    assignment_array2 {
        \find(\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality (post))
        \varcond(\hasElementarySort(#v0, G))
        \replacewith({#v := G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:allow, finalFields:onHeap) {
    assignment_read_attribute {
        \find(\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \not \isThisReference(#v))
        "Normal Execution (#v != null)":
            \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
            \add( ==> (#v = null));
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        };
        "Null Reference (#v = null)":
            \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality (post))
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_this {
        \find(\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \isThisReference(#v))
        "Normal Execution":
            \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:allow, finalFields:immutable) {
    assignment_read_attribute {
        \find(\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \not \isThisReference(#v),
            \not \final(#a))
        "Normal Execution (#v != null)":
            \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
            \add( ==> (#v = null));
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        };
        "Null Reference (#v = null)":
            \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality (post))
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_final {
        \find(\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \not \isThisReference(#v),
            \final(#a))
        "Normal Execution (#v != null)":
            \replacewith({#v0 := G::final(#v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
            \add( ==> (#v = null));
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        };
        "Null Reference (#v = null)":
            \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality (post))
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_this {
        \find(\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \not \isModelField(#a),
            \hasSort(#a, G),
            \isThisReference(#v),
            \not \final(#a))
        "Normal Execution":
            \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_this_final {
        \find(\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \isThisReference(#v),
            \final(#a))
        "Normal Execution":
            \replacewith({#v0 := G::final(#v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:allow) {
    assignment_read_length {
        \find(\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\not \isThisReference(#v))
        "Normal Execution (#v != null)":
            \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality (post))
            \add( ==> (#v = null));
        "Null Reference (#v = null)":
            \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality (post))
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java) {
    assignment_read_length_this {
        \find(\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\isThisReference(#v))
        \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java, runtimeExceptions:ban, finalFields:onHeap) {
    assignment_read_attribute {
        \find( ==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \not \isThisReference(#v))
        "Normal Execution (#v != null)":
            \replacewith( ==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
            // \add (==>(#v=null))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        };
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_this {
        \find( ==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \isThisReference(#v))
        "Normal Execution":
            \replacewith( ==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java, runtimeExceptions:ban, finalFields:immutable) {
    assignment_read_attribute {
        \find( ==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \not \isThisReference(#v),
            \not \final(#a))
        "Normal Execution (#v != null)":
            \replacewith( ==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
            // \add (==>(#v=null))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        };
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_final {
        \find( ==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \not \isThisReference(#v),
            \final(#a))
        "Normal Execution (#v != null)":
            \replacewith( ==> {#v0 := G::final(#v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
            // \add (==>(#v=null))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        };
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_this {
        \find( ==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \not \isModelField(#a),
            \hasSort(#a, G),
            \isThisReference(#v),
            \not \final(#a))
        "Normal Execution":
            \replacewith( ==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_this_final {
        \find( ==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \hasSort(#a, G),
            \isThisReference(#v),
            \final(#a))
        "Normal Execution":
            \replacewith( ==> {#v0 := G::final(#v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #v.#a":
                \replacewith( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {
    assignment_read_length {
        \find( ==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality (post))
        \varcond(\not \isThisReference(#v))
        "Normal Execution (#v != null)":
            \replacewith( ==> {#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality (post))
            // \add (==>(#v=null))
        ;
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
    };

}

\rules(programRules:Java, runtimeExceptions:ignore) {
    assignment_read_attribute {
        \find(\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \not \isModelField(#a),
            \hasSort(#a, G),
            \not \isThisReference(#v))
        \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_attribute_this {
        \find(\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality (post))
        \varcond(
            \not \static(#a),
            \not \isArrayLength(#a),
            \not \isModelField(#a),
            \hasSort(#a, G),
            \isThisReference(#v))
        \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_length {
        \find(\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality (post))
        \varcond(\not \isThisReference(#v))
        \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, runtimeExceptions:allow) {

    assignment_write_attribute {
        \find(\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\not \static(#a), \not \isThisReference(#v))
        "Normal Execution (#v != null)":
            \replacewith({heap := store(heap, #v, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality (post))
            \add( ==> (#v = null));
        (permissions:on) {
            "Write Permission to #v.#a":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality (post))
                \add( ==> writePermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        };
        "Null Reference (#v = null)":
            \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality (post))
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
    };

    assignment_write_attribute_this {
        \find(\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\not \static(#a), \isThisReference(#v))
        "Normal Execution":
            \replacewith({heap := store(heap, #v, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Write Permission to #v.#a":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality (post))
                \add( ==> writePermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentThis"
    };

}

\rules(programRules:Java, runtimeExceptions:ban) {

    assignment_write_attribute {
        \find( ==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality (post))
        \varcond(\not \static(#a), \not \isThisReference(#v))
        "Normal Execution (#v != null)":
            \replacewith( ==> {heap := store(heap, #v, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality (post))
            // \add (==>(#v=null))
        ;
        (permissions:on) {
            "Write Permission to #v.#a":
                \replacewith( ==> writePermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        };
        "Null Reference (#v = null)":
            \replacewith( ==> false)
            \add(#v = null ==>)
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
    };

    assignment_write_attribute_this {
        \find( ==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality (post))
        \varcond(\not \static(#a), \isThisReference(#v))
        "Normal Execution":
            \replacewith( ==> {heap := store(heap, #v, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Write Permission to #v.#a":
                \replacewith( ==> writePermission(Permission::select(permissions, #v, #memberPVToField(#a))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignmentThis"
    };

}

\rules(programRules:Java, runtimeExceptions:ignore) {

    assignment_write_attribute {
        \find(\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality (post))
        \varcond(\not \static(#a))
        \replacewith({heap := store(heap, #v, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
    };

}

\rules(programRules:Java) {

    // ------------------------------------------------------------------------
    // ----------- Rules for modal tautologies
    // ------------------------------------------------------------------------

    box_true {
        \find(\modality{#box}{.. #s ...}\endmodality true)
        \replacewith(true)
        \heuristics(modal_tautology)
    };

    diamond_false {
        \find(\modality{#diamond}{.. #s ...}\endmodality false)
        \replacewith(false)
        \heuristics(modal_tautology)
    };

    diamond_and_left {
        \find(\modality{#diamond}{.. #s ...}\endmodality (post & post1) ==>)
        \replacewith(\modality{#diamond}{.. #s ...}\endmodality post & \modality{#diamond}{.. #s ...}\endmodality post1 ==>)
    };

    box_and_left {
        \find(\modality{#box}{.. #s ...}\endmodality (post & post1) ==>)
        \replacewith(\modality{#box}{.. #s ...}\endmodality post & \modality{#box}{.. #s ...}\endmodality post1 ==>)
    };

    diamond_and_right {
        \find( ==> \modality{#diamond}{.. #s ...}\endmodality (post & post1))
        \replacewith( ==> \modality{#diamond}{.. #s ...}\endmodality post);
        \replacewith( ==> \modality{#diamond}{.. #s ...}\endmodality post1)
    };

    box_and_right {
        \find( ==> \modality{#box}{.. #s ...}\endmodality (post & post1))
        \replacewith( ==> \modality{#box}{.. #s ...}\endmodality post);
        \replacewith( ==> \modality{#box}{.. #s ...}\endmodality post1)
    };

    diamond_or_right {
        \find( ==> \modality{#diamond}{.. #s ...}\endmodality (post | post1))
        \replacewith( ==> \modality{#diamond}{.. #s ...}\endmodality post | \modality{#diamond}{.. #s ...}\endmodality post1)
    };

    box_or_right {
        \find( ==> \modality{#box}{.. #s ...}\endmodality (post | post1))
        \replacewith( ==> \modality{#box}{.. #s ...}\endmodality post | \modality{#box}{.. #s ...}\endmodality post1)
    };

    diamond_or_left {
        \find(\modality{#diamond}{.. #s ...}\endmodality (post | post1) ==>)
        \replacewith(\modality{#diamond}{.. #s ...}\endmodality post | \modality{#diamond}{.. #s ...}\endmodality post1 ==>)
    };

    box_or_left {
        \find(\modality{#box}{.. #s ...}\endmodality (post | post1) ==>)
        \replacewith(\modality{#box}{.. #s ...}\endmodality post | \modality{#box}{.. #s ...}\endmodality post1 ==>)
    };

    /////////////////////////////////////////////////////////////////

    same_diamonds_right {
        \assumes( ==> \<{#s}\> post)
        \find( ==> \<{#s}\> post1)
        \add( ==> \<{#s}\> (post | post1))
    };

    same_diamonds_left {
        \assumes(\<{.. #s ...}\> post ==>)
        \find(\<{.. #s ...}\> post1 ==>)
        \add(\<{.. #s ...}\> (post & post1) ==>)
    };

    same_boxes_right {
        \assumes( ==> \[{.. #s ...}\] post)
        \find( ==> \[{.. #s ...}\] post1)
        \add( ==> \[{.. #s ...}\] (post | post1))
    };

    same_boxes_left {
        \assumes(\[{.. #s ...}\] post ==>)
        \find(\[{.. #s ...}\] post1 ==>)
        \add(\[{.. #s ...}\] (post & post1) ==>)
    };

    boxToDiamond {
        \find(\[{.. #s ...}\] post)
        \replacewith(!\<{.. #s ...}\> !post)
        \heuristics(boxDiamondConv)
    };

    boxToDiamondTransaction
    {
        \find(\box_transaction{.. #s ...}\endmodality post)
        \replacewith(!\diamond_transaction{.. #s ...}\endmodality !post)
        \heuristics(boxDiamondConv)
        \displayname "boxToDiamond"
    };

    diamondToBox {
        \find(\<{.. #s ...}\> post)
        \replacewith(!\[{.. #s ...}\] !post)
        \heuristics(boxDiamondConv)
    };

    diamondToBoxTransaction {
        \find(\diamond_transaction{.. #s ...}\endmodality post)
        \replacewith(!\box_transaction{.. #s ...}\endmodality !post)
        \heuristics(boxDiamondConv)
        \displayname "diamondToBox"
    };

    diamond_split_termination {
        \find(\<{.. #s ...}\> post)
        \replacewith(\[{.. #s ...}\] post & \<{.. #s ...}\> true)
    };

}

\rules(programRules:Java) {
    // for this rule we do not need a separate one for constant
    // fieldreferences as the attribute case does not throw any exception
    // for an implicit "this" and so behaves same for constant and instance
    // attributes
    assignment_write_static_attribute {
        \find(\modality{#allmodal}{.. @(#sv) = #se; ...}\endmodality (post))
        \replacewith({heap := store(heap, null, #memberPVToField(#sv), #se)}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Write Permission to #sv":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (static write)."; ...}\endmodality (post))
                \add( ==> writePermission(Permission::select(permissions, null, #memberPVToField(#sv))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
    };

    // constant case cannot occur as no static initialisation handling happens
    assignment_write_static_attribute_with_variable_prefix {
        \find(\modality{#allmodal}{.. @(#v.#sv) = #se; ...}\endmodality (post))
        \replacewith({heap := store(heap, #v, #memberPVToField(#sv), #se)}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Write Permission to #v.#sv":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (static write)."; ...}\endmodality (post))
                \add( ==> writePermission(Permission::select(permissions, #v, #memberPVToField(#sv))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
    };
}

\rules(programRules:Java, finalFields:onHeap) {
    assignment_read_static_attribute {
        \find(\modality{#allmodal}{.. #v0 = @(#sv); ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(#sv, G))
        \replacewith({#v0 := G::select(heap, null, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #sv":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (static read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, null, #memberPVToField(#sv))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java, finalFields:immutable) {
    assignment_read_static_attribute {
        \find(\modality{#allmodal}{.. #v0 = @(#sv); ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(#sv, G), \not\final(#sv))
        \replacewith({#v0 := G::select(heap, null, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #sv":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (static read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, null, #memberPVToField(#sv))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    assignment_read_static_attribute_final {
        \find(\modality{#allmodal}{.. #v0 = @(#sv); ...}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(#sv, G), \final(#sv))
        \replacewith({#v0 := G::final(null, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #sv":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (static read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, null, #memberPVToField(#sv))))
        }
        \heuristics(simplify_prog, simplify_prog_subset)
    };
}

\rules(programRules:Java) {
    // constant case cannot occur as no static initilisation handling happens
    assignment_read_static_attribute_with_variable_prefix {
        \find(\modality{#allmodal}{.. #loc = @(#v.#sv); ...}\endmodality (post))
        \varcond(\hasSort(#sv, G))
        \replacewith({#loc := G::select(heap, #v, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality (post))
        ;
        (permissions:on) {
            "Read Permission to #v.#sv":
                \replacewith(\modality{#allmodal}{.. assert false : "Access permission check-point (static read)."; ...}\endmodality (post))
                \add( ==> readPermission(Permission::select(permissions, #v, #memberPVToField(#sv))))
        }
        \heuristics(simplify_prog)
        \displayname "assignment"
    };

}

// =====================================================================//
// ======================= static method calls    ======================//
// =====================================================================//

\rules(programRules:Java, initialisation:disableStaticInitialisation) {
    staticMethodCall {
        \find(\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality (post))
        \varcond(\staticMethodReference(#se, #mn, #elist))
        "Normal Execution":
            \replacewith(\modality{#allmodal}{..
                     #method-call(#v0, #se.#mn(#elist));
                    ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    staticMethodCallWithAssignment {
        \find(\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs), \staticMethodReference(#se, #mn, #elist))
        "Normal Execution":
            \replacewith(\modality{#allmodal}{..
                    #typeof(#lhs) #v0;
                          #method-call(#v0, #se.#mn(#elist));
                        #lhs = #v0;
                      ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    staticMethodCallStaticViaTypereference {
        \find(\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  #method-call(#t.#mn(#elist)); ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    staticMethodCallStaticWithAssignmentViaTypereference {
        \find(\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs))
        \replacewith(\modality{#allmodal}{..  #typeof(#lhs) #v0;
                #method-call(#v0, #t.#mn(#elist));
                #lhs = #v0; ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    methodCallWithAssignmentWithinClass {
        \find(\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs), \mayExpandMethod(#mn, #elist))
        \replacewith(\modality{#allmodal}{.. #typeof(#lhs) #v0;
                   #method-call(#ex, #v0, #mn(#elist));
                   #lhs = #v0;
                ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    methodCallWithinClass {
        \find(\modality{#allmodal}{.. #mn(#elist); ...}\endmodality (post))
        \varcond(\mayExpandMethod(#mn, #elist))
        \replacewith(\modality{#allmodal}{..
                #method-call(#mn(#elist)); ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };
}

\rules(programRules:Java, initialisation:enableStaticInitialisation) {

    staticMethodCall {
        \find(\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality (post))
        \varcond(\staticMethodReference(#se, #mn, #elist))
        "Normal Execution":
            \replacewith(\modality{#allmodal}{..
                    #static-initialisation(#se.#mn(#elist));
                    #method-call(#v0, #se.#mn(#elist));
                    ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    staticMethodCallWithAssignment {
        \find(\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality ((post)))
        \varcond(\newTypeOf(#v0, #lhs), \staticMethodReference(#se, #mn, #elist))
        "Normal Execution":
            \replacewith(\modality{#allmodal}{..
                    #static-initialisation(#se.#mn(#elist));
                    #typeof(#lhs) #v0;
                          #method-call(#v0, #se.#mn(#elist));
                        #lhs = #v0;
                      ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    staticMethodCallStaticViaTypereference {
        \find(\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  #static-initialisation(#t.#mn(#elist));
                #method-call(#t.#mn(#elist)); ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    staticMethodCallStaticWithAssignmentViaTypereference {
        \find(\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs))
        \replacewith(\modality{#allmodal}{..  #static-initialisation(#t.#mn(#elist));
                #typeof(#lhs) #v0;
                    #method-call(#v0, #t.#mn(#elist));
                    #lhs = #v0; ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    methodCallWithAssignmentWithinClass {
        \find(\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs), \mayExpandMethod(#mn, #elist))
        \replacewith(\modality{#allmodal}{.. #static-initialisation(#mn(#elist));
                #typeof(#lhs) #v0;
                            #method-call(#ex, #v0, #mn(#elist));
                            #lhs = #v0;
                         ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    methodCallWithinClass {
        \find(\modality{#allmodal}{.#ex.. #mn(#elist); ...}\endmodality (post))
        \varcond(\mayExpandMethod(#mn, #elist))
        \replacewith(\modality{#allmodal}{..
                #static-initialisation(#mn(#elist));
                #method-call(#ex, #mn(#elist)); ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "methodCall"
    };

    passiveMethodCallWithinClass {
        \find(\modality{#allmodal}{.#ex.. @(#mn(#elist)); ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #method-call(#ex, #mn(#elist)); ...}\endmodality (post))
        \displayname "methodCall"
        \heuristics(method_expand)
    };

    passiveMethodCallStatic {
        \find(\modality{#allmodal}{.. @(#t.#mn(#elist)); ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #method-call(#t.#mn(#elist)); ...}\endmodality (post))
        \displayname "methodCall"
        \heuristics(method_expand)
    };

    passiveMethodCallWithAssignmentWithinClass {
        \find(\modality{#allmodal}{.#ex.. #lhs=@(#mn(#elist)); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs))
        \replacewith(\modality{#allmodal}{.. #typeof(#lhs) #v0;
                     #method-call(#ex, #v0, #mn(#elist));
                     #lhs = #v0;
                ...}\endmodality (post))
        \displayname "methodCall"
        \heuristics(method_expand)
    };

    passiveMethodCallStaticWithAssignment {
        \find(\modality{#allmodal}{.. #lhs = @(#t.#mn(#elist)); ...}\endmodality (post))
        \varcond(\newTypeOf(#v0, #lhs))
        \replacewith(\modality{#allmodal}{..  #typeof(#lhs) #v0;
                           #method-call(#v0, #t.#mn(#elist));
                          #lhs = #v0;
                ...}\endmodality (post))
        \displayname "methodCall"
        \heuristics(method_expand)
    };

}

// ===============================================================//
// ============   axioms describing valid jvm states ===========//
// ===============================================================//
\rules(programRules:Java, initialisation:enableStaticInitialisation) {

    class_being_initialized_is_prepared {
        \assumes(boolean::select(heap, null, alphaObj::<classInitializationInProgress>) = TRUE, wellFormed(heap) ==>)
        \find(boolean::select(heap, null, alphaObj::<classPrepared>))
        \sameUpdateLevel
        \replacewith(TRUE)
        \heuristics(confluence_restricted, simplify)
        \displayname "initialized classes have been prepared"
    };

    initialized_class_is_prepared {
        \assumes(boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, wellFormed(heap) ==>)
        \find(boolean::select(heap, null, alphaObj::<classPrepared>))
        \sameUpdateLevel
        \replacewith(TRUE)
        \heuristics(confluence_restricted, simplify)
        \displayname "classes being initialized have been prepared"
    };

    initialized_class_is_not_erroneous {
        \assumes(boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, wellFormed(heap) ==>)
        \find(boolean::select(heap, null, alphaObj::<classErroneous>))
        \sameUpdateLevel
        \replacewith(FALSE)
        \heuristics(confluence_restricted, simplify)
        \displayname "initialized class is not erroneous"
    };

    class_initialized_excludes_class_init_in_progress {
        \assumes(boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, wellFormed(heap) ==>)
        \find(boolean::select(heap, null, alphaObj::<classInitializationInProgress>))
        \sameUpdateLevel
        \replacewith(FALSE)
        \heuristics(confluence_restricted, simplify)
        \displayname "initialisation process has already terminated"
    };

    class_erroneous_excludes_class_in_init {
        \assumes(boolean::select(heap, null, alphaObj::<classErroneous>) = TRUE, wellFormed(heap) ==>)
        \find(boolean::select(heap, null, alphaObj::<classInitializationInProgress>))
        \sameUpdateLevel
        \replacewith(FALSE)
        \heuristics(confluence_restricted, simplify)
        \displayname "initialization process has already terminated (or never begun)"
    };

    erroneous_class_has_no_initialized_sub_class {
        \assumes(boolean::select(heap, null, alphaObj::<classErroneous>) = TRUE, wellFormed(heap) ==>)
        \find(boolean::select(heap, null, betaObj::<classInitialized>))
        \sameUpdateLevel
        \varcond(\sub(betaObj, alphaObj))
        \replacewith(FALSE)
        \heuristics(confluence_restricted, simplify)
        \displayname "erroneous classes have no initialized subclasses"
    };

    superclasses_of_initialized_classes_are_initialized {
        \assumes(boolean::select(heap, null, betaObj::<classInitialized>) = TRUE, wellFormed(heap) ==>)
        \find(boolean::select(heap, null, alphaObj::<classInitialized>))
        \sameUpdateLevel
        \varcond(\isReference [non_null](betaObj), \strict \sub(betaObj, alphaObj))
        \replacewith(TRUE)
        \heuristics(simplify)
    };

    superclasses_of_initialized_classes_are_prepared {
        \assumes(boolean::select(heap, null, betaObj::<classInitialized>) = TRUE, wellFormed(heap) ==>)
        \find(boolean::select(heap, null, alphaObj::<classPrepared>))
        \sameUpdateLevel
        \varcond(\sub(betaObj, alphaObj))
        \replacewith(TRUE)
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/*
 * This file lists includes for default LDTs in KeY.
 *
 * At least the following files use it:
 *  - system/src/de/uka/ilkd/key/proof/io/RuleSource.java
 *  - system/binary/de/uka/ilkd/key/proof/rules/standardRules.key
 *
 * Kai Wallisch 08/2014
 */
\includeLDTs
    optionsDeclarations,
    ruleSetsDeclarations,
    soundDefaultContracts,
    boolean,
    integerHeader,
    javaHeader,
    floatHeader,
    heap,
    locSets,
    permission,
    reach,
    seq,
    map,
    freeADT,
    wellfound,
    charListHeader,
    types;
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains the DECLARATIONS for location sets.
// Find the rules in file locSetRules.key

\sorts {
    LocSet;
}

\functions {
    // unique function symbols
    \unique LocSet empty;
    \unique LocSet allLocs;

    // other constructors
    LocSet singleton(Object, Field);
    LocSet union(LocSet, LocSet);
    LocSet intersect(LocSet, LocSet);
    LocSet setMinus(LocSet, LocSet);
    LocSet infiniteUnion {true}(LocSet);
    LocSet allFields(Object);
    LocSet allObjects(Field);
    LocSet arrayRange(Object, int, int);
    LocSet freshLocs(Heap);
    // work-a-round
    LocSet allElementsOfArray(Heap, Object, LocSet);
    LocSet allElementsOfArrayLocsets(Heap, Object, LocSet);
}

\predicates {
    elementOf(Object, Field, LocSet);
    subset(LocSet, LocSet);
    disjoint(LocSet, LocSet);
    createdInHeap(LocSet, Heap);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains the RULES for location sets.
// Find the DECLARATIONS in file locSet.key

\rules(programRules:Java) {

    // --------------------------------------------------------------------------
    // axioms for elementOf
    // --------------------------------------------------------------------------

    elementOfEmpty {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(elementOf(o, f, empty))

        \replacewith(false)

        \heuristics(concrete)
    };

    elementOfAllLocs {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(elementOf(o, f, allLocs))

        \replacewith(true)

        \heuristics(concrete)
    };

    elementOfSingleton {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;

        \find(elementOf(o, f, singleton(o2, f2)))

        \replacewith(o = o2 & f = f2)

        \heuristics(simplify)
    };

    elementOfUnion {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, union(s, s2)))

        \replacewith(elementOf(o, f, s) | elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfIntersect {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, intersect(s, s2)))

        \replacewith(elementOf(o, f, s) & elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfSetMinus {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, setMinus(s, s2)))

        \replacewith(elementOf(o, f, s) & !elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfInfiniteUnion {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables alpha av;
        \schemaVar \term LocSet s;

        \find(elementOf(o, f, infiniteUnion{av;}(s)))
        \varcond(\notFreeIn(av, o, f))

        \replacewith(\exists av; elementOf(o, f, s))

        \heuristics(simplify)
    };

    elementOfInfiniteUnion2Vars {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables alpha av;
        \schemaVar \variables beta bv;
        \schemaVar \term LocSet s;

        \find(elementOf(o, f, infiniteUnion{av, bv;}(s)))
        \varcond(\notFreeIn(av, o, f), \notFreeIn(bv, o, f))

        \replacewith(\exists av; \exists bv; elementOf(o, f, s))

        \heuristics(simplify)
    };

    elementOfAllFields {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;

        \find(elementOf(o, f, allFields(o2)))

        \replacewith(o = o2)

        \heuristics(concrete)
    };

    allFieldsEq {
        \schemaVar \term Object o1, o2;
        \find(allFields(o1) = allFields(o2))
        \replacewith(o1 = o2)
        \heuristics(simplify)
    };

    elementOfAllObjects {
        \schemaVar \term Object o;
        \schemaVar \term Field f, f2;

        \find(elementOf(o, f, allObjects(f2)))

        \replacewith(f = f2)

        \heuristics(concrete)
    };

    // change upper to exclusive (in line with other definitions?)
    elementOfArrayRange {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term int lower, upper;
        \schemaVar \variables int iv;

        \find(elementOf(o, f, arrayRange(o2, lower, upper)))
        \varcond(\notFreeIn(iv, f, lower, upper))

        \replacewith(o = o2 & \exists iv; (f = arr(iv) & lower <= iv & iv <= upper))

        \heuristics(simplify_enlarging)
    };

    // change upper to exclusive (in line with other definitions?)
    elementOfArrayRangeConcrete {
        \schemaVar \term Object o, o2;
        \schemaVar \term int idx, lower, upper;

        \find(elementOf(o, arr(idx), arrayRange(o2, lower, upper)))

        \replacewith(o = o2 & lower <= idx & idx <= upper)

        \heuristics(simplify)
    };

    elementOfFreshLocs {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(elementOf(o, f, freshLocs(h)))

        \replacewith(o != null & !boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // EQ versions of axioms (these are lemmata)
    // --------------------------------------------------------------------------
    elementOfUnionEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) | elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfIntersectEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) & elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfSetMinusEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) & !elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    elementOfInfiniteUnionEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables alpha av;
        \schemaVar \term LocSet s;
        \schemaVar \term LocSet EQ;

        \assumes(infiniteUnion{av;}(s) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(av, o, f))

        \replacewith(\exists av; elementOf(o, f, s))

        \heuristics(simplify)
    };

    elementOfInfiniteUnion2VarsEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables alpha av;
        \schemaVar \variables beta bv;
        \schemaVar \term LocSet s;
        \schemaVar \term LocSet EQ;

        \assumes(infiniteUnion{av, bv;}(s) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(av, o, f), \notFreeIn(bv, o, f))

        \replacewith(\exists av; \exists bv; elementOf(o, f, s))

        \heuristics(simplify)
    };

    elementOfArrayRangeEQ {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;
        \schemaVar \term int lower, upper;
        \schemaVar \variables int iv;
        \schemaVar \term LocSet EQ;

        \assumes(arrayRange(o2, lower, upper) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(iv, f, lower, upper))

        \replacewith(o = o2 & \exists iv; (f = arr(iv) & lower <= iv & iv <= upper))

        \heuristics(simplify)
    };

    // --------------------------------------------------------------------------
    // axioms for set predicates (reduce to elementOf)
    // --------------------------------------------------------------------------

    equalityToElementOf {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(s = s2)
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) <-> elementOf(ov, fv, s2)))

        \heuristics(semantics_blasting)
    };

    // proven with KeY (CS)
    equalityToElementOfRight {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find( ==> s = s2)
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith( ==> \forall ov; \forall fv; (elementOf(ov, fv, s) <-> elementOf(ov, fv, s2)))

        \heuristics(setEqualityBlastingRight)
    };

    emptyEqualsSingleton {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(empty = singleton(o, f))

        \replacewith(false)

        \heuristics(concrete)
    };

    singletonEqualsEmpty {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(singleton(o, f) = empty)
        \replacewith(false)

        \heuristics(concrete)
    };

    unionWithSingletonEqualsUnionWithSingleton {
        \schemaVar \term LocSet s1, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(union(s1, singleton(o, f)) = union(s2, singleton(o, f)))

        \replacewith(setMinus(s1, singleton(o, f)) = setMinus(s2, singleton(o, f)))
        
        \heuristics(simplify)
    };

    unionWithSingletonEqualsUnionWithSingleton_2 {
        \schemaVar \term LocSet s1, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(union(singleton(o, f), s1) = union(singleton(o, f), s2))

        \replacewith(setMinus(s1, singleton(o, f)) = setMinus(s2, singleton(o, f)))

        \heuristics(simplify)
    };

    subsetToElementOf {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(subset(s, s2))
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) -> elementOf(ov, fv, s2)))
        \heuristics(semantics_blasting)
        //        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetToElementOfRight {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find( ==> subset(s, s2))
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith( ==> \forall ov; \forall fv; (elementOf(ov, fv, s) -> elementOf(ov, fv, s2)))

        \heuristics(setEqualityBlastingRight)
    };

    // proven with KeY (CS)
    elementOfSubsetImpliesElementOfSuperset {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(s, s2) ==>)

        \find(elementOf(o, f, s) ==>)

        \add(elementOf(o, f, s2) ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    noElementOfSupersetImpliesNoElementOfSubset {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(s, s2) ==>)
        \find( ==> elementOf(o, f, s2))
        \add( ==> elementOf(o, f, s))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetSingletonLeft {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(subset(singleton(o, f), s))

        \replacewith(elementOf(o, f, s))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonLeftEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(subset(EQ, s))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonRight {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(subset(s, singleton(o, f)))

        \replacewith(s = empty | s = singleton(o, f))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetSingletonRightEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(s = empty | s = singleton(o, f))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    subsetUnionLeft {
        \schemaVar \term LocSet s, s2, s3;

        \find(subset(union(s, s2), s3))

        \replacewith(subset(s, s3) & subset(s2, s3))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetUnionLeftEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(subset(EQ, s3))
        \sameUpdateLevel

        \replacewith(subset(s, s3) & subset(s2, s3))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelf1 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, union(s, s2)))

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelfEQ1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelf2 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, union(s2, s)))

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfUnionWithItSelfEQ2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s2, s) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelf1 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, intersect(s, s2)))

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelfEQ1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s, s2) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelf2 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, intersect(s2, s)))

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    subsetOfIntersectWithItSelfEQ2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s2, s) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

        \replacewith(subset(s, s2))

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    allFieldsSubsetOf {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(allFields(o), s) ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    elementOfSubsetOfUnion1 {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \assumes(subset(s, union(s2, s3)),
            ==> elementOf(o, f, s2))
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \add(elementOf(o, f, s) <-> elementOf(o, f, intersect(s, s3)) ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    elementOfSubsetOfUnion2 {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \assumes(subset(s, union(s2, s3)),
            ==> elementOf(o, f, s3))
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \add(elementOf(o, f, s) <-> elementOf(o, f, intersect(s, s2)) ==>)

        \heuristics(simplify_enlarging)
    };

    disjointToElementOf {
        \schemaVar \term LocSet s, s2;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(disjoint(s, s2))
        \varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith(\forall ov; \forall fv; (!elementOf(ov, fv, s) | !elementOf(ov, fv, s2)))
        \heuristics(semantics_blasting)
        //        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointDefinition {
        \schemaVar \term LocSet s, s2;

        \find(disjoint(s, s2))

        \replacewith(intersect(s, s2) = empty)
        // \heuristics(semantics_blasting)
        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointNotInOtherLocset1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(s, s2) = empty ==>)
        \find(elementOf(o, f, s) ==>)

        \add( ==> elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointNotInOtherLocset2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(s, s2) = empty ==>)
        \find(elementOf(o, f, s2) ==>)

        \add( ==> elementOf(o, f, s))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset1 {
        \schemaVar \term LocSet s, s2, s3;

        \assumes(intersect(s2, s3) = empty ==>)
        \find(subset(s, s2) ==>)

        \add(intersect(s, s3) = empty ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset2 {
        \schemaVar \term LocSet s, s2, s3;

        \assumes(intersect(s2, s3) = empty ==>)
        \find(subset(s, s3) ==>)

        \add(intersect(s, s2) = empty ==>)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAllFields {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(allFields(o), s) = empty ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \replacewith(false)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointAllFields_2 {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;

        \find(intersect(allFields(o), allFields(o2)) = empty)

        \replacewith(o != o2)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointAllObjects {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(allObjects(f), s) = empty ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

        \replacewith(false)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointInfiniteUnion {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables int iv;

        \find(intersect(infiniteUnion{iv;}(s2), s) = empty)
        \varcond(\notFreeIn(iv, s))

        \replacewith(\forall iv; (intersect(s2, s) = empty))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointInfiniteUnion_2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables int iv;

        \find(intersect(s, infiniteUnion{iv;}(s2)) = empty)
        \varcond(\notFreeIn(iv, s))

        \replacewith(\forall iv; (intersect(s, s2) = empty))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    intersectAllFieldsFreshLocs {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(intersect(allFields(o), freshLocs(h)) = empty)
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointAndSubset_3 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s1, s2) = empty ==>)
        \find(subset(s4, union(s2, s3)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_4 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s1, s2) = empty ==>)
        \find(subset(s4, union(s3, s2)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_5 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s2, s1) = empty ==>)
        \find(subset(s4, union(s2, s3)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    disjointAndSubset_6 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s2, s1) = empty ==>)
        \find(subset(s4, union(s3, s2)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };

    createdInHeapToElementOf {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;

        \find(createdInHeap(s, h))
        \varcond(\notFreeIn(ov, s, h), \notFreeIn(fv, s, h))

        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s)
                -> ov = null
                | boolean::select(h, ov, java.lang.Object::<created>) = TRUE))
        \heuristics(classAxiom)
    };

    // --------------------------------------------------------------------------
    // equality rules
    // --------------------------------------------------------------------------

    // Proven in KeY (DD: 2025-02-20)
    \lemma
    equalityOfSingleton {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Field f1, f2;

        \find(singleton(o1, f1) = singleton(o2, f2))

        \replacewith(o1 = o2 & f1 = f2)

        \heuristics(simplify)
    };

    // --------------------------------------------------------------------------
    // lemmata for empty and allLocs
    // --------------------------------------------------------------------------

    unionWithEmpty {
        \schemaVar \term LocSet s;

        \find(union(empty, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    unionWithAllLocs {
        \schemaVar \term LocSet s;

        \find(union(allLocs, s))

        \replacewith(allLocs)

        \heuristics(concrete)
    };

    intersectWithEmpty {
        \schemaVar \term LocSet s;

        \find(intersect(empty, s))

        \replacewith(empty)

        \heuristics(concrete)
    };

    intersectWithAllLocs {
        \schemaVar \term LocSet s;

        \find(intersect(allLocs, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    // the following set of rules should be the only one needed
    // for empty elimination as the strategies take care to commute the
    // the empty set always on the second place
    // the other rules are left for backward proof loading copatibility
    // begin
    unionWithEmptyRight {
        \schemaVar \term LocSet s;

        \find(union(s, empty))

        \replacewith(s)

        \displayname "unionWithEmpty"
        \heuristics(concrete)
    };

    unionWithAllLocsRight {
        \schemaVar \term LocSet s;

        \find(union(s, allLocs))

        \replacewith(allLocs)

        \displayname "unionWithAllLocs"
        \heuristics(concrete)
    };

    intersectWithEmptyRight {
        \schemaVar \term LocSet s;

        \find(intersect(s, empty))

        \replacewith(empty)

        \displayname "intersectWithEmpty"
        \heuristics(concrete)
    };

    intersectWithAllLocsRight {
        \schemaVar \term LocSet s;

        \find(intersect(s, allLocs))

        \replacewith(s)

        \displayname "intersectWithAllLocs"

        \heuristics(concrete)
    };

    //  end

    setMinusWithEmpty1 {
        \schemaVar \term LocSet s;

        \find(setMinus(s, empty))

        \replacewith(s)

        \displayname "setMinusWithEmpty"
        \heuristics(concrete)
    };

    setMinusWithEmpty2 {
        \schemaVar \term LocSet s;

        \find(setMinus(empty, s))

        \replacewith(empty)

        \displayname "setMinusWithEmpty"
        \heuristics(concrete)
    };

    setMinusWithAllLocs {
        \schemaVar \term LocSet s;

        \find(setMinus(s, allLocs))

        \replacewith(empty)

        \displayname "setMinusWithAllLocs"
        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // lemmata for subset
    // --------------------------------------------------------------------------

    subsetWithEmpty {
        \schemaVar \term LocSet s;

        \find(subset(empty, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    subsetOfEmpty {
        \schemaVar \term LocSet s;

        \find(subset(s, empty))

        \replacewith(s = empty)

        \heuristics(concrete)
    };

    subsetWithAllLocs {
        \schemaVar \term LocSet s;

        \find(subset(s, allLocs))

        \replacewith(true)

        \displayname "subsetOfAllLocs" // should be the name, but for backward compatibility only displayname
        \heuristics(concrete)
    };

    subsetWithAllLocs2 {
        \schemaVar \term LocSet s;

        \find(subset(allLocs, s))
        \replacewith(s = allLocs)

        \displayname "subsetWithAllLocs"
        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // lemmata for disjoint
    // --------------------------------------------------------------------------

    disjointWithEmpty {
        \schemaVar \term LocSet s;

        \find(disjoint(empty, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    disjointWithSingleton1 {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \find(intersect(s, singleton(o, f)) = empty)
        \replacewith(!elementOf(o, f, s))
        \heuristics(simplify)
        \displayname "disjointWithSingleton"
    };

    \lemma
    disjointWithSingleton2 {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \find(intersect(singleton(o, f), s) = empty)
        \replacewith(!elementOf(o, f, s))
        \heuristics(simplify)
        \displayname "disjointWithSingleton"
    };

    \lemma
    disjointArrayRanges {
        \schemaVar \term Object o1, o2;
        \schemaVar \term int lower1, upper1, lower2, upper2;
        \find(intersect(arrayRange(o1, lower1, upper1), arrayRange(o2, lower2, upper2)) = empty)
        \replacewith(!(o1 = o2 & lower1 <= upper1 & lower2 <= upper2 & ((lower1 <= lower2 & lower2 <= upper1) | (lower2 <= lower1 & lower1 <= upper2))))
        \heuristics(simplify)
    };

    \lemma
    disjointArrayRangeAllFields1 {
        \schemaVar \term Object o1, o2;
        \schemaVar \term int lower2, upper2;
        \find(intersect(allFields(o1), arrayRange(o2, lower2, upper2)) = empty)
        \replacewith(!(o1 = o2 & lower2 <= upper2))
        \heuristics(simplify)
        \displayname "disjointArrayRangeAllFields"
    };

    \lemma
    disjointArrayRangeAllFields2 {
        \schemaVar \term Object o1, o2;
        \schemaVar \term int lower1, upper1;
        \find(intersect(arrayRange(o1, lower1, upper1), allFields(o2)) = empty)
        \replacewith(!(o1 = o2 & lower1 <= upper1))
        \heuristics(simplify)
        \displayname "disjointArrayRangeAllFields"
    };

    // --------------------------------------------------------------------------
    // lemmata for createdInHeap
    // --------------------------------------------------------------------------

    createdInHeapWithEmpty {
        \schemaVar \term Heap h;

        \find(createdInHeap(empty, h))

        \replacewith(true)

        \heuristics(concrete)
    };

    createdInHeapWithSingleton {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(createdInHeap(singleton(o, f), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithUnion {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Heap h;

        \find( ==> createdInHeap(union(s, s2), h))

        \replacewith( ==> createdInHeap(s, h));
        \replacewith( ==> createdInHeap(s2, h))

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithSetMinusFreshLocs {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;

        \find(createdInHeap(setMinus(s, freshLocs(h)), h))

        \replacewith(true)

        \heuristics(concrete)
    };

    createdInHeapWithAllFields {
        \schemaVar \term Object o;
        \schemaVar \term Heap h;

        \find(createdInHeap(allFields(o), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithArrayRange {
        \schemaVar \term Object o;
        \schemaVar \term int lower, upper;
        \schemaVar \term Heap h;

        \find(createdInHeap(arrayRange(o, lower, upper), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE | upper < lower)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithSelect {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find( ==> createdInHeap(LocSet::select(h, o, f), h))

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    createdInHeapWithObserver {
        \schemaVar \term LocSet obs;
        \schemaVar \term Heap h;

        \find( ==> createdInHeap(obs, h))
        \varcond(\isObserver(obs, h))

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // EQ versions of lemmata for createdInHeap
    // --------------------------------------------------------------------------


    createdInHeapWithSingletonEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithUnionEQ {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find( ==> createdInHeap(EQ, h))

        \replacewith( ==> createdInHeap(s, h));
        \replacewith( ==> createdInHeap(s2, h))

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithSetMinusFreshLocsEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, freshLocs(h)) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };

    createdInHeapWithAllFieldsEQ {
        \schemaVar \term Object o;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(allFields(o) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithArrayRangeEQ {
        \schemaVar \term Object o;
        \schemaVar \term int lower, upper;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(arrayRange(o, lower, upper) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE | upper < lower)

        \heuristics(simplify_enlarging)
    };

    createdInHeapWithSelectEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(LocSet::select(h, o, f) = EQ ==>)
        \find( ==> createdInHeap(EQ, h))

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    createdInHeapWithObserverEQ {
        \schemaVar \term LocSet obs;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(obs = EQ ==>)
        \find( ==> createdInHeap(EQ, h))
        \varcond(\isObserver(obs, h))

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // other lemmata for proving createdness
    // --------------------------------------------------------------------------

    referencedObjectIsCreatedRight {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes( ==> deltaObject::select(h, o, f) = null)
        \find( ==> boolean::select(h,
                deltaObject::select(h, o, f),
                java.lang.Object::<created>) = TRUE)

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    referencedObjectIsCreatedRightEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Object EQ;

        \assumes(deltaObject::select(h, o, f) = EQ ==> EQ = null)
        \find( ==> boolean::select(h,
                EQ,
                java.lang.Object::<created>) = TRUE)

        \replacewith( ==> wellFormed(h))

        \heuristics(concrete)
    };

    referencedObjectIsCreatedRightFinal {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes( ==> deltaObject::final(o, f) = null)
        \find( ==> boolean::select(h,
                deltaObject::final(o, f),
                java.lang.Object::<created>) = TRUE )

        \replacewith( ==> boolean::select(h, o, java.lang.Object::<created>) = TRUE | o = null )

        \heuristics(simplify_enlarging)
    };

    referencedObjectIsCreatedRighFinalEQ {
        \schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Object EQ;

        \assumes(deltaObject::final(o, f) = EQ ==> EQ = null)
        \find( ==> boolean::select(h,
                EQ,
                java.lang.Object::<created>) = TRUE)

        \add( ==> boolean::select(h, o, java.lang.Object::<created>) = TRUE | o = null )

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // some other lemmata
    // --------------------------------------------------------------------------

    // proven with KeY (CS)
    unionEqualsEmpty {
        \schemaVar \term LocSet s, s2, s3;

        \find(union(s, s2) = empty)

        \replacewith(s = empty & s2 = empty)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    unionEqualsEmptyEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(EQ = empty)
        \sameUpdateLevel

        \replacewith(s = empty & s2 = empty)

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    setMinusOfUnion {
        \schemaVar \term LocSet s, s2, s3;

        \find(setMinus(union(s, s2), s3))

        \replacewith(union(setMinus(s, s3), setMinus(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    setMinusOfUnionEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(setMinus(EQ, s3))
        \sameUpdateLevel

        \replacewith(union(setMinus(s, s3), setMinus(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetWithSetMinusLeft {
        \schemaVar \term LocSet s, s2, s3;

        \find(subset(setMinus(s, s2), s3))

        \replacewith(subset(s, union(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    // proven with KeY (CS)
    subsetWithSetMinusLeftEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, s2) = EQ ==>)
        \find(subset(EQ, s3))
        \sameUpdateLevel

        \replacewith(subset(s, union(s2, s3)))

        \heuristics(simplify_enlarging)
    };

    unionWithItself {
        \schemaVar \term LocSet s;

        \find(union(s, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    intersectWithItself {
        \schemaVar \term LocSet s;

        \find(intersect(s, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    // one of the two below should be obsolete after completing term ordering (not yet done)
    distributeIntersection {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(s1, union(s2, s3)))

        \replacewith(union(intersect(s1, s2), intersect(s1, s3)))

        \heuristics(simplify_enlarging)
    };

    distributeIntersection_2 {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(union(s2, s3), s1))

        \replacewith(union(intersect(s2, s1), intersect(s3, s1)))

        \heuristics(simplify_enlarging)
    };

    intersectWithSingleton {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(intersect(singleton(o, f), s))

        \replacewith(\if(elementOf(o, f, s)) \then(singleton(o, f)) \else(empty))

        \heuristics(simplify_enlarging)
    };

    setMinusItself {
        \schemaVar \term LocSet s;

        \find(setMinus(s, s))

        \replacewith(empty)

        \heuristics(concrete)
    };

    setMinusSingleton {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes( ==> elementOf(o, f, s))

        \find(setMinus(s, singleton(o, f)))

        \replacewith(s)

        \heuristics(simplify)
    };

    intersectionSetMinusItself {
        \schemaVar \term LocSet s1, s2;

        \find(intersect(setMinus(s1, s2), s2))

        \replacewith(empty)

        \heuristics(concrete)
    };

    intersectionSetMinusItself_2 {
        \schemaVar \term LocSet s1, s2;

        \find(intersect(s2, setMinus(s1, s2)))

        \replacewith(empty)

        \heuristics(concrete)
    };

    unionIntersectItself {
        \schemaVar \term LocSet s1, s2;

        \find(union(intersect(s1, s2), s1))

        \replacewith(s1)

        \heuristics(simplify)
    };

    unionIntersectItself_2 {
        \schemaVar \term LocSet s1, s2;

        \find(union(intersect(s2, s1), s1))

        \replacewith(s1)

        \heuristics(simplify)
    };

    unionIntersectItself_3 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(s, intersect(s1, s2)), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_4 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(s, intersect(s2, s1)), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_5 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(intersect(s1, s2), s), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    unionIntersectItself_6 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(intersect(s2, s1), s), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };

    infiniteUnionUnused {
        \schemaVar \variables alpha av;
        \schemaVar \term LocSet s;

        \find(infiniteUnion{av;}(s))
        \varcond(\notFreeIn(av, s))

        \replacewith(s)

        \heuristics(concrete)
    };

    subsetOfItself {
        \schemaVar \term LocSet s;

        \find(subset(s, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    // really needed for efficiency?
    elementOfGuardedSet {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \formula phi;
        \schemaVar \term LocSet s;

        \find(elementOf(o, f, \if(phi) \then(s) \else(empty)))

        \replacewith(phi & elementOf(o, f, s))

        \heuristics(concrete)
    };

    commuteDisjoint {
        \schemaVar \term LocSet commLeft, commRight;

        \find(disjoint(commLeft, commRight))
        \replacewith(disjoint(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteUnion {
        \schemaVar \term LocSet commLeft, commRight;

        \find(union(commLeft, commRight))

        \replacewith(union(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteUnion_2 {
        \schemaVar \term LocSet commLeft, commRight, s;

        \find(union(union(s, commLeft), commRight))

        \replacewith(union(union(s, commRight), commLeft))

        \heuristics(cnf_setComm)
    };

    commuteIntersection {
        \schemaVar \term LocSet commLeft, commRight;

        \find(intersect(commLeft, commRight))

        \replacewith(intersect(commRight, commLeft))

        \heuristics(cnf_setComm)
    };

    commuteIntersection_2 {
        \schemaVar \term LocSet commLeft, commRight, s;

        \find(intersect(intersect(s, commLeft), commRight))

        \replacewith(intersect(intersect(s, commRight), commLeft))

        \heuristics(cnf_setComm)
    };

    associativeLawUnion {
        \schemaVar \term LocSet s1, s2, s3;

        \find(union(s1, union(s2, s3)))

        \replacewith(union(union(s1, s2), s3))

        \heuristics(conjNormalForm)
    };

    associativeLawIntersect {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(s1, intersect(s2, s3)))

        \replacewith(intersect(intersect(s1, s2), s3))

        \heuristics(conjNormalForm)
    };

    // --------------------------------------------------------------------------
    // work-a-round to use \infinite_union in JML set statements
    // --------------------------------------------------------------------------

    definitionAllElementsOfArray {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArray(h, array, singleton(o, f)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array), \notFreeIn(j, o, f))

        \replacewith(infiniteUnion{j;}(\if(0 <= j & j < length(array))
                    \then(singleton(Object::select(h, array, arr(j)), f))
                    \else(empty)))
        \heuristics(simplify)
    };

    definitionAllElementsOfArray2 {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArray(h, array, allFields(o)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array))

        \replacewith(infiniteUnion{j;}(\if(0 <= j & j < length(array))
                    \then(allFields(Object::select(h, array, arr(j))))
                    \else(empty)))
        \heuristics(simplify)
    };

    definitionAllElementsOfArrayLocsets {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArrayLocsets(h, array, singleton(o, f)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array), \notFreeIn(j, o, f))

        \replacewith(infiniteUnion{j;}(\if(0 <= j & j < length(array))
                    \then(LocSet::select(h, Object::select(h, array, arr(j)), f))
                    \else(empty)))
        \heuristics(simplify)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules usable for loop invariant handling

\sorts {
}

\schemaVariables {
    \formula a, b, c, d;
    \term int k, i, j;
    \skolemTerm int sk;
    \variables int v;
}

\rules {

    crossInst {
        \assumes( ==> ((k <= -1 | k >= i) | c))
        \find(\forall v; (((v <= -1 | v >= j) | b) | a) ==>)
        \varcond(\newDependingOn(sk, b))
        \add(sk = k & {\subst v; sk}(((v <= -1 | v >= j) | b) | a) ==>)
        \heuristics(loopInvariant)
    };

    cutUpperBound {
        \assumes(\forall v; (((v <= -1 | v >= j) | b) | a) ==>)
        \find( ==> ((k <= -1 | k >= i) | c))
        \add((k = i) ==>);
        \add((k != i) ==>)
        \heuristics(loopInvariant)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// --------------- loops ------------------------------------------------------//
\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;

    \formula post;

    \program SimpleExpression #se;
    \program Statement #s;
    \program Label #innerLabel, #outerLabel;
    \program Expression #e, #e0, #e1, #e2;
    \program NonSimpleExpression #nse;
    \program ForLoop #forloop;
    \program ProgramMethod #pm;
    \program Type #t;
    \program Variable #v, #a;
    \program NonStringLiteral #lit;
    \program ArrayLength #length;
    \program [list] Catch #cs;
}

\rules(programRules:Java) {

    // Unwinding rules

    loopUnwind {
        \find(\modality{#allmodal}{.. while(#e) #s ...}\endmodality (post))
        \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
        \replacewith(\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel,
                while(#e) #s); ...}\endmodality (post))
        \heuristics(loop_expand)
    };

    doWhileUnwind {
        \find(\modality{#allmodal}{.. do #s while (#e); ...}\endmodality (post))
        \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
        \replacewith(\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel, do #s while(#e);); ...}\endmodality (post))
        // This rule is not only for unwinding, but it transforms
        // a do-while loop into a while loop (plus one body expansion upfront)
        // \heuristics(loop_expand)
        \heuristics(simplify_prog)
    };

    // Make a while loop out of a for loop
    for_to_while {
        \find(\modality{#allmodal}{.. #forloop ...}\endmodality (post))
        \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
        \replacewith(\modality{#allmodal}{.. #for-to-while(#innerLabel, #outerLabel, #forloop) ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    arrayInitialisation {
        \find(\modality{#allmodal}{.#pm@#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality (post))
        // {\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv] := #lit}
        \replacewith({heap := memset(heap,
                    arrayRange(#a, #se, length(#a) - 1),
                    #lit)}\modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(simplify)
    };
}
/* deprecated for-loop treatment
 * (when/if deleting forInitUnfold, also delete meta construct #unpack)
 */
/*
  forInitUnfold {
    \find (\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality(post))
    \replacewith
       (\modality{#allmodal}{..
        #unpack(for(#loopInit; #guard; #forupdates) #s);
            ...}\endmodality(post))
        \heuristics(simplify)
 };


forUnwindEmptyInit {
     \find (\modality{#allmodal}{.. for(; #guard; #forupdates) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel,
              for(; #guard; #forupdates) #s); ...}\endmodality(post))
     \heuristics(loop_expand)


 forUnwindEmptyUpdate {
     \find (\modality{#allmodal}{.. for(#loopInit; #guard;) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel,
       for(#loopInit; #guard;) #s); ...}\endmodality(post))
     \heuristics(loop_expand)
   };


 forUnwindEmptyInitUpdate {
     \find (\modality{#allmodal}{.. for(; #guard;) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel,
                   for(; #guard;) #s); ...}\endmodality(post))
     \heuristics(loop_expand)
   };
*/

// for_inv      { \find (\[{.. for(#i; #e; #sel) {#s} ...}\]post)
//           \varcond(#v new)
//          \replacewith (==> inv);
//          \replacewith (inv ==> \[{.. #unwind-loop (for(#i; #e; #sel)
//           {#s})  ...}\])
//          \replacewith (inv, \<{.. #v = #e; ...}\> #v = false ==>
//           \<{.. boolean #v = #e; ...}\>post) };
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
    \modalOperator {diamond, diamond_transaction} #dia;
    \modalOperator {box, box_transaction} #box;
    \formula post;

    \program SimpleExpression #se;
    \program LeftHandSide #lhs;
    \program Statement #body;
    \program [list] Statement #slist;
    \program Expression #nse;
    \program Label #lb, #lb1;

    \program Variable #x;
}

/////////////////////////////////////////////////////
// Rules transforming loops: Invariant & Unwinding //
/////////////////////////////////////////////////////

\rules(programRules:Java, javaLoopTreatment:efficient) {
    loopScopeInvDia {
        \schemaVar \formula inv;
        \schemaVar \formula freeInv;
        \schemaVar \term any variantTerm;
        \schemaVar \formula loopFormula;
        \schemaVar \program Statement #loopStmt;
        \schemaVar \program Variable #variant;

        \schemaVar \skolemTerm Heap anon_heap_LOOP;
        \schemaVar \skolemTerm Heap anon_savedHeap_LOOP;
        \schemaVar \skolemTerm Heap anon_permissions_LOOP;

        \schemaVar \program Variable #heapBefore_LOOP;
        \schemaVar \program Variable #savedHeapBefore_LOOP;
        \schemaVar \program Variable #permissionsBefore_LOOP;
        \schemaVar \program [list] Statement #localVarDeclsBefore_LOOP;
        \schemaVar \update #updateBefore_LOOP;
        \schemaVar \update #updateFrame_LOOP;

        \find((\modality{#dia} {.. while (#nse) #body ... }\endmodality (post)))

        \varcond(\new(#x, boolean))
        \varcond(\new(#variant, any))
        \varcond(\new(#heapBefore_LOOP, Heap))
        \varcond(\new(#savedHeapBefore_LOOP, Heap))
        \varcond(\new(#permissionsBefore_LOOP, Heap))
        \varcond(\newLocalVars(#localVarDeclsBefore_LOOP, #updateBefore_LOOP, #updateFrame_LOOP, #body))

        \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#nse) #body }\endmodality (post)))
        // Implementation Note (DS, 2019-04-11): We have to separately store the active statement
        //   in a ProgramSV (and cannot just use the loopFormula already stored above) for the
        //   varconds below since otherwise, we get an error because KeY cannot compute the Taclet
        //   Prefix for loopFormula. It's obviously not possible (at least not without a change to
        //   something deep inside the KeY core which I don't dare to do now) to instantiate an
        //   unmatched TermSV in a varcond and use it in subsequent varconds. We could of course also
        //   just always pass the whole input formula, but that is also not really nice and handy.
        \varcond(\storeStmtIn(#loopStmt, \modality{#dia}{ while (#nse) #body }\endmodality (post)))
        \varcond(\hasInvariant(#loopStmt, #dia))
        \varcond(\getInvariant(#loopStmt, #dia, inv))
        \varcond(\getFreeInvariant(#loopStmt, #dia, freeInv))
        \varcond(\getVariant(#loopStmt, variantTerm))

        "Invariant Initially Valid":
            \replacewith(inv);

        "Invariant Preserved and Used":
            \replacewith(
              \modality{#dia}{
                    #typeof(#heapBefore_LOOP) #heapBefore_LOOP;
                    #typeof(#savedHeapBefore_LOOP) #savedHeapBefore_LOOP;
                    #typeof(#permissionsBefore_LOOP) #permissionsBefore_LOOP;
                    #typeof(#variant) #variant;
                    #localVarDeclsBefore_LOOP
              }\endmodality (
                {#createBeforeLoopUpdate(
                        loopFormula,
                        #heapBefore_LOOP,
                        #savedHeapBefore_LOOP,
                        #permissionsBefore_LOOP)
                    || #updateBefore_LOOP
                    || #createLocalAnonUpdate(loopFormula)
                    || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
                {#variant := variantTerm}
                (inv & freeInv ->
                    (\modality{#dia}{
                              ..
                              boolean #x;
                              loop-scope(#x) {
                                if (#nse) {
                                  #body
                                  continue;
                                } else {
                                  break;
                                }
                              }
                              ...
                            }\endmodality (
                            (#x<<loopScopeIndex>> = TRUE -> post) &
                            (#x<<loopScopeIndex>> = FALSE ->
                                inv
                                & {#updateFrame_LOOP} #createFrameCond(
                                    loopFormula,
                                    #heapBefore_LOOP,
                                    #savedHeapBefore_LOOP,
                                    #permissionsBefore_LOOP)
                                & prec(variantTerm, #variant))
                        )))
              )
            )

            \add(#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)

        \heuristics(loop_scope_inv_taclet)
    };

    loopScopeInvBox {
        \schemaVar \formula inv;
        \schemaVar \formula freeInv;
        \schemaVar \formula loopFormula;
        \schemaVar \program Statement #loopStmt;

        \schemaVar \skolemTerm Heap anon_heap_LOOP;
        \schemaVar \skolemTerm Heap anon_savedHeap_LOOP;
        \schemaVar \skolemTerm Heap anon_permissions_LOOP;

        \schemaVar \program Variable #heapBefore_LOOP;
        \schemaVar \program Variable #savedHeapBefore_LOOP;
        \schemaVar \program Variable #permissionsBefore_LOOP;
        \schemaVar \program [list] Statement #localVarDeclsBefore_LOOP;
        \schemaVar \update #updateBefore_LOOP;
        \schemaVar \update #updateFrame_LOOP;

        \find((\modality{#box} {.. while (#nse) #body ... }\endmodality (post)))

        \varcond(\new(#x, boolean))
        \varcond(\new(#heapBefore_LOOP, Heap))
        \varcond(\new(#savedHeapBefore_LOOP, Heap))
        \varcond(\new(#permissionsBefore_LOOP, Heap))
        \varcond(\newLocalVars(#localVarDeclsBefore_LOOP, #updateBefore_LOOP, #updateFrame_LOOP, #body))

        \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#nse) #body }\endmodality (post)))
        \varcond(\storeStmtIn(#loopStmt, \modality{#box}{ while (#nse) #body }\endmodality (post)))
        \varcond(\hasInvariant(#loopStmt, #box))
        \varcond(\getInvariant(#loopStmt, #box, inv))
        \varcond(\getFreeInvariant(#loopStmt, #box, freeInv))

        "Invariant Initially Valid":
            \replacewith(inv);

        "Invariant Preserved and Used":
            \replacewith(
              \modality{#box}{
                                #typeof(#heapBefore_LOOP) #heapBefore_LOOP;
                                #typeof(#savedHeapBefore_LOOP) #savedHeapBefore_LOOP;
                                #typeof(#permissionsBefore_LOOP) #permissionsBefore_LOOP;
                                #localVarDeclsBefore_LOOP
              }
              \endmodality (
                {#createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                    || #createLocalAnonUpdate(loopFormula)
                    || #updateBefore_LOOP
                    || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
                (inv & freeInv ->
                    (\modality{#box}{
                              ..
                              boolean #x;
                              loop-scope(#x) {
                                if (#nse) {
                                  #body
                                  continue;
                                } else {
                                  break;
                                }
                              }
                              ...
                            }\endmodality (
                            (#x<<loopScopeIndex>> = TRUE -> post) &
                            (#x<<loopScopeIndex>> = FALSE ->
                                inv
                                & {#updateFrame_LOOP} #createFrameCond(
                                    loopFormula,
                                    #heapBefore_LOOP,
                                    #savedHeapBefore_LOOP,
                                    #permissionsBefore_LOOP))
                        )))
              )
            )

            \add(#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)

        \heuristics(loop_scope_inv_taclet)
    };
}

\rules(programRules:Java) {
    unwindLoopScope {
        \find((\modality{#allmodal} {.. while (#nse) #body ... }\endmodality (post)))

        \varcond(\new(#x, boolean))

        \replacewith(
            (\modality{#allmodal} {..
                       boolean #x;
                       loop-scope(#x) {
                         if (#nse) { #body continue; }
                         else { break; }
                       }
                    ... }
                     \endmodality (
                    (#x<<loopScopeIndex>> = TRUE -> post) &
                    (#x<<loopScopeIndex>> = FALSE ->
                        (\modality{#allmodal} {..
                                   #reattachLoopInvariant(while (#nse) #body);
                                ... }\endmodality (post)))
                )
            )
        )

        \heuristics(loop_scope_expand)
    };
}

///////////////////////////////////////////////////
// Loop-Scope Based Three-Branch Invariant Rules //
///////////////////////////////////////////////////

\rules(programRules:Java, javaLoopTreatment:teaching) {
    threeBranchLoopScopeInvRuleDia {
        \schemaVar \formula inv;
        \schemaVar \formula freeInv;
        \schemaVar \term any variantTerm;
        \schemaVar \formula loopFormula;
        \schemaVar \program Statement #loopStmt;
        \schemaVar \program Variable #variant;

        \schemaVar \skolemTerm Heap anon_heap_LOOP;
        \schemaVar \skolemTerm Heap anon_savedHeap_LOOP;
        \schemaVar \skolemTerm Heap anon_permissions_LOOP;

        \schemaVar \program Variable #heapBefore_LOOP;
        \schemaVar \program Variable #savedHeapBefore_LOOP;
        \schemaVar \program Variable #permissionsBefore_LOOP;
        \schemaVar \program [list] Statement #localVarDeclsBefore_LOOP;
        \schemaVar \update #updateBefore_LOOP;
        \schemaVar \update #updateFrame_LOOP;

        \find((\modality{#dia} {.. while (#nse) #body ... }\endmodality (post)))

        \varcond(\new(#x, boolean))
        \varcond(\new(#variant, any))
        \varcond(\new(#heapBefore_LOOP, Heap))
        \varcond(\new(#savedHeapBefore_LOOP, Heap))
        \varcond(\new(#permissionsBefore_LOOP, Heap))
        \varcond(\newLocalVars(#localVarDeclsBefore_LOOP, #updateBefore_LOOP, #updateFrame_LOOP, #body))

        \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#nse) #body }\endmodality (post)))
        \varcond(\storeStmtIn(#loopStmt, \modality{#dia}{ while (#nse) #body }\endmodality (post)))
        \varcond(\hasInvariant(#loopStmt, #dia))
        \varcond(\getInvariant(#loopStmt, #dia, inv))
        \varcond(\getFreeInvariant(#loopStmt, #dia, freeInv))
        \varcond(\getVariant(#loopStmt, variantTerm))

        "Invariant Initially Valid":
            \replacewith(inv);

        "Body Preserves Invariant":
            \replacewith(
              \modality{#dia}{
                  #typeof(#heapBefore_LOOP) #heapBefore_LOOP;
                  #typeof(#savedHeapBefore_LOOP) #savedHeapBefore_LOOP;
                  #typeof(#permissionsBefore_LOOP) #permissionsBefore_LOOP;
                  #typeof(#variant) #variant;
                  #localVarDeclsBefore_LOOP
              }
              \endmodality (
                {#createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                    || #createLocalAnonUpdate(loopFormula)
                    || #updateBefore_LOOP
                    || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
                {#variant := variantTerm}
                (inv & freeInv ->
                    (\modality{#dia}{
                              ..
                              boolean #x;
                              loop-scope(#x) {
                                if (#nse) {
                                  #body
                                  continue;
                                } else {
                                  break;
                                }
                              }
                              ...
                            }\endmodality (
                            #x<<loopScopeIndex>> = FALSE ->
                            inv
                            & {#updateFrame_LOOP} #createFrameCond(
                                loopFormula,
                                #heapBefore_LOOP,
                                #savedHeapBefore_LOOP,
                                #permissionsBefore_LOOP)
                            & prec(variantTerm, #variant)
                        )))
              )
            )

            \add(#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>);

        "Use Case":
            \replacewith(
              \modality{#dia}{
                   #typeof(#heapBefore_LOOP) #heapBefore_LOOP;
                   #typeof(#savedHeapBefore_LOOP) #savedHeapBefore_LOOP;
                   #typeof(#permissionsBefore_LOOP) #permissionsBefore_LOOP;
                   #typeof(#variant) #variant;
              }
              \endmodality (
                {#createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                || #createLocalAnonUpdate(loopFormula)
                || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
                {#variant := variantTerm}
                (inv & freeInv ->
                    (\modality{#dia}{
                              ..
                              boolean #x;
                              loop-scope(#x) {
                                if (#nse) {
                                  #body
                                  continue;
                                } else {
                                  break;
                                }
                              }
                              ...
                            }\endmodality (
                            #x<<loopScopeIndex>> = TRUE -> post
                        )))
              )
            )

            \add(#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)

        \heuristics(loop_scope_inv_taclet)
    };

    threeBranchLoopScopeInvRuleBox {
        \schemaVar \formula inv;
        \schemaVar \formula freeInv;
        \schemaVar \formula loopFormula;
        \schemaVar \program Statement #loopStmt;

        \schemaVar \skolemTerm Heap anon_heap_LOOP;
        \schemaVar \skolemTerm Heap anon_savedHeap_LOOP;
        \schemaVar \skolemTerm Heap anon_permissions_LOOP;

        \schemaVar \program Variable #heapBefore_LOOP;
        \schemaVar \program Variable #savedHeapBefore_LOOP;
        \schemaVar \program Variable #permissionsBefore_LOOP;
        \schemaVar \program [list] Statement #localVarDeclsBefore_LOOP;
        \schemaVar \update #updateBefore_LOOP;
        \schemaVar \update #updateFrame_LOOP;

        \find((\modality{#box} {.. while (#nse) #body ... }\endmodality (post)))

        \varcond(\new(#x, boolean))
        \varcond(\new(#heapBefore_LOOP, Heap))
        \varcond(\new(#savedHeapBefore_LOOP, Heap))
        \varcond(\new(#permissionsBefore_LOOP, Heap))
        \varcond(\newLocalVars(#localVarDeclsBefore_LOOP, #updateBefore_LOOP, #updateFrame_LOOP, #body))

        \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#nse) #body }\endmodality (post)))
        \varcond(\storeStmtIn(#loopStmt, \modality{#box}{ while (#nse) #body }\endmodality (post)))
        \varcond(\hasInvariant(#loopStmt, #box))
        \varcond(\getInvariant(#loopStmt, #box, inv))
        \varcond(\getFreeInvariant(#loopStmt, #box, freeInv))

        "Invariant Initially Valid":
            \replacewith(inv);

        "Body Preserves Invariant":
            \replacewith(
              \modality{#box}{   #typeof(#heapBefore_LOOP) #heapBefore_LOOP;
                                 #typeof(#savedHeapBefore_LOOP) #savedHeapBefore_LOOP;
                                 #typeof(#permissionsBefore_LOOP) #permissionsBefore_LOOP;
                                 #localVarDeclsBefore_LOOP
              }
              \endmodality (
                    {#createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                    || #createLocalAnonUpdate(loopFormula)
                    || #updateBefore_LOOP
                    || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
                (inv & freeInv ->
                    (\modality{#box}{
                              ..
                              boolean #x;
                              loop-scope(#x) {
                                if (#nse) {
                                  #body
                                  continue;
                                } else {
                                  break;
                                }
                              }
                              ...
                            }\endmodality (
                            #x<<loopScopeIndex>> = FALSE ->
                            inv
                            & {#updateFrame_LOOP} #createFrameCond(
                                loopFormula,
                                #heapBefore_LOOP,
                                #savedHeapBefore_LOOP,
                                #permissionsBefore_LOOP)
                        )))
             )
            )

            \add(#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>);

        "Use Case":
            \replacewith(
                {#createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                    || #createLocalAnonUpdate(loopFormula)
                    || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
                (inv & freeInv ->
                    (\modality{#box}{
                              ..
                              boolean #x;
                              loop-scope(#x) {
                                if (#nse) {
                                  #body
                                  continue;
                                } else {
                                  break;
                                }
                              }
                              ...
                            }\endmodality (
                            #x<<loopScopeIndex>> = TRUE -> post
                        )))
            )

            \add(#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)

        \heuristics(loop_scope_inv_taclet)
    };
}

////////////////////////////////
// Rules Handling Loop Scopes //
////////////////////////////////

\rules(programRules:Java) {
    lsBreak {
        \find(\modality{#allmodal}{.. loop-scope(#lhs) { break; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  #lhs = true; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsContinue {
        \find(\modality{#allmodal}{.. loop-scope(#lhs) { continue; #slist } ...}\endmodality (post))
        \replacewith({#lhs := FALSE}post)
        \heuristics(simplify_prog)
    };

    lsLblContinueMatch {
        \find(\modality{#allmodal}{.. #lb: loop-scope(#lhs) { continue #lb; #slist } ...}\endmodality (post))
        \replacewith({#lhs := FALSE}post)
        \heuristics(simplify_prog)
    };

    lsLblContinueNoMatch1 {
        \schemaVar \program Statement #lsStmt;

        \find(\modality{#allmodal}{.. loop-scope(#lhs) { continue #lb; #slist } ...}\endmodality (post))
        \varcond(\storeStmtIn(
                #lsStmt,
                \modality{#allmodal}{
                      loop-scope(#lhs) { continue #lb; #slist } }
                    \endmodality (post)))
        \varcond(\not \isLabeled(#lsStmt))

        \replacewith(\modality{#allmodal}{..  #lhs = true; continue #lb; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsLblContinueNoMatch2 {
        \schemaVar \program Statement #lsStmt;

        \find(\modality{#allmodal}{.. #lb1: loop-scope(#lhs) { continue #lb; #slist } ...}\endmodality (post))
        \varcond(\different(#lb1, #lb))

        \replacewith(\modality{#allmodal}{..  #lhs = true; continue #lb; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsLblBreak {
        \find(\modality{#allmodal}{.. loop-scope(#lhs) { break #lb; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  { #lhs = true; break #lb; } ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsThrow {
        \find(\modality{#allmodal}{.. loop-scope(#lhs) { throw #se; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  #lhs = true; throw #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsReturnNonVoid {
        \find(\modality{#allmodal}{.. loop-scope(#lhs) { return #se; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  #lhs = true; return #se; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsReturnVoid {
        \find(\modality{#allmodal}{.. loop-scope(#lhs) { return; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..  #lhs = true; return; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    ////////////////////////////////
    //// Loop Scope-Related Rules //
    ////////////////////////////////

    blockContinue {
        \find(\modality{#allmodal}{.. { continue; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..   continue; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    blockBreak {
        \find(\modality{#allmodal}{.. { break; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..   break; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    blockContinueLabeled {
        \find(\modality{#allmodal}{.. { continue #lb; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..   continue #lb; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };

    blockBreakLabeled {
        \find(\modality{#allmodal}{.. { break #lb; #slist } ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{..   break #lb; ...}\endmodality (post))
        \heuristics(simplify_prog)
    };
}

\sorts {
    Map;
}

\functions {
    /*!
    Return a value from the given Map.
    If value is undefined, `mapUndef` is used.
    */
    any mapGet(Map, any);

    /*!

     */
    \unique any mapUndef;

    // constructors
    Map mapForeach {true, true}(boolean, any);
    Map mapEmpty;
    Map mapSingleton(any, any);
    Map mapOverride(Map, Map);
    Map seq2map(Seq);
    Map mapUpdate(Map, any, any);
    Map mapRemove(Map, any);
}

\predicates {
    inDomain(Map, any);
    inDomainImpliesCreated(Map);
}

\schemaVariables {
    \term Map m, m0, m1;
    \term any key, value;
    \term boolean b;
    \term any x, y, z;
    \term alpha xa;
    \variables alpha v;
    \variables any vy;
}

\rules {

    // --------------------------------------------------------------------------
    // axioms
    // --------------------------------------------------------------------------

    // Added by Kai Wallisch
    defMapEquality {
        \find(m0 = m1)
        \varcond(\notFreeIn(vy, m0, m1))
        \replacewith(\forall vy; ((inDomain(m0, vy) <-> inDomain(m1, vy)) &
                (inDomain(m0, vy) -> mapGet(m0, vy) = mapGet(m1, vy))))
    };

    inDomainOfMapForeach {
        \find(inDomain(mapForeach{v;}(b, y), x))
        \replacewith({\subst v; alpha::cast(x)}b = TRUE
            & alpha::instance(x) = TRUE)
        \heuristics(simplify)
    };

    getOfMapForeach {
        \find(mapGet(mapForeach{v;}(b, y), x))
        \sameUpdateLevel
        \replacewith(\if(inDomain(mapForeach{v;}(b, y), x))
                \then({\subst v; alpha::cast(x)}y)
                \else(mapUndef))
        \heuristics(simplify_enlarging)
    };

    // --------------------------------------------------------------------------
    // definitions (conservative extensions)
    // --------------------------------------------------------------------------

    defMapEmpty {
        \find(mapEmpty)
        \replacewith(mapForeach{vy;}(FALSE, mapUndef))
    };

    defMapSingleton {
        \find(mapSingleton(xa, y))
        \varcond(\notFreeIn(vy, xa, y))
        \replacewith(mapForeach{vy;}(
                \if(vy = any::cast(xa)) \then(TRUE) \else(FALSE), y)
        )
    };

    defMapOverride {
        \find(mapOverride(m0, m1))
        \varcond(\notFreeIn(vy, m0, m1))
        \replacewith(mapForeach{vy;}(
                \if(inDomain(m0, vy) | inDomain(m1, vy)) \then(TRUE) \else(FALSE),
                \if(inDomain(m1, vy))
                    \then(mapGet(m1, vy)) \else(mapGet(m0, vy))
            ))
    };

    defSeq2Map {
        \schemaVar \term Seq s;
        \schemaVar \variables int ix;
        \find(seq2map(s))
        \varcond(\notFreeIn(ix, s))
        \replacewith(mapForeach{ix;}(
                \if(0 <= ix & ix < seqLen(s)) \then(TRUE) \else(FALSE),
                any::seqGet(s, ix)
            ))
    };

    // Added by Kai Wallisch
    defMapUpdate {
        \find(mapUpdate(m, key, value))
        \varcond(\notFreeIn(vy, m, key, value))
        \replacewith(mapForeach{vy;}(
                \if(inDomain(m, vy) | vy = key)
                    \then(TRUE)
                    \else(FALSE),
                \if(vy = key)
                    \then(value)
                    \else(mapGet(m, vy))
            ))
    };

    // Added by Kai Wallisch
    defMapRemove {
        \find(mapRemove(m, key))
        \varcond(\notFreeIn(vy, m, key))
        \replacewith(mapForeach{vy;}(
                \if(inDomain(m, vy) & vy != key)
                    \then(TRUE)
                    \else(FALSE),
                mapGet(m, vy)
            ))
    };

    // Added by Kai Wallisch
    defInDomainImpliesCreated {
        \schemaVar \variables Object o;
        \find(inDomainImpliesCreated(m))
        \varcond(\notFreeIn(o, m))
        \replacewith(\forall o; (inDomain(m, o) ->
                boolean::select(heap, o, java.lang.Object::<created>) = TRUE))
        \heuristics(simplify_enlarging)
    };

    // --------------------------------------------------------------------------
    // derived map equality rules (proven sound in KeY)
    // --------------------------------------------------------------------------

    // Added by Kai Wallisch
    mapEqualityRight {
        \find( ==> m0 = m1)
        \varcond(\notFreeIn(vy, m0, m1))
        \replacewith( ==> \forall vy; ((inDomain(m0, vy) <-> inDomain(m1, vy)) &
                (inDomain(m0, vy) -> mapGet(m0, vy) = mapGet(m1, vy))))
        \heuristics(simplify_enlarging)
    };

    // Added by Kai Wallisch
    mapUpdateUnchanged {
        \find(m = mapUpdate(m, key, value))
        \replacewith(inDomain(m, key) & mapGet(m, key) = value)
        \heuristics(simplify_enlarging)
    };

    // Added by Kai Wallisch
    mapUpdateUnchanged2 {
        \find(mapUpdate(m, key, value) = m)
        \replacewith(inDomain(m, key) & mapGet(m, key) = value)
        \heuristics(simplify_enlarging)
    };

    // Added by Kai Wallisch
    mapRemoveUnchanged {
        \find(m = mapRemove(m, key))
        \replacewith(!inDomain(m, key))
        \heuristics(simplify_enlarging)
    };

    // Added by Kai Wallisch
    mapRemoveUnchanged2 {
        \find(mapRemove(m, key) = m)
        \replacewith(!inDomain(m, key))
        \heuristics(simplify_enlarging)
    };

    // --------------------------------------------------------------------------
    // derived inDomain rules (proven sound in KeY)
    // --------------------------------------------------------------------------

    inDomainOfMapEmpty {
        \find(inDomain(mapEmpty, x))
        \replacewith(false)
        \heuristics(concrete)
    };

    inDomainOfMapSingleton {
        \find(inDomain(mapSingleton(x, y), z))
        \replacewith(x = z)
        \heuristics(simplify)
    };

    inDomainOfMapOverride {
        \find(inDomain(mapOverride(m0, m1), x))
        \replacewith(inDomain(m0, x) | inDomain(m1, x))
        \heuristics(simplify)
    };

    inDomainOfSeq2Map {
        \schemaVar \term Seq s;
        \find(inDomain(seq2map(s), x))
        \replacewith(int::instance(x) = TRUE &
            0 <= int::cast(x) & int::cast(x) < seqLen(s))
        \heuristics(simplify)
    };

    // Added by Kai Wallisch
    inDomainOfMapUpdate {
        \find(inDomain(mapUpdate(m, key, value), x))
        \replacewith(inDomain(m, x) | (x = key))
        \heuristics(simplify_enlarging)
    };

    // Added by Kai Wallisch
    inDomainOfMapRemove {
        \find(inDomain(mapRemove(m, key), x))
        \replacewith(inDomain(m, x) & (x != key))
        \heuristics(simplify_enlarging)
    };

    // Added by Kai Wallisch
    notInDomain {
        \find( ==> inDomain(m, x))
        \add(mapGet(m, x) = mapUndef ==>)
        \heuristics(inReachableStateImplication)
    };

    inDomainConcrete {
        \assumes( ==> mapUndef = y)
        \find(mapGet(m, x) = y ==>)
        \add(inDomain(m, x) ==>)
        \heuristics(inReachableStateImplication)
    };

    // --------------------------------------------------------------------------
    // derived mapGet rules (proven sound in KeY)
    // --------------------------------------------------------------------------

    // Added by Kai Wallisch
    getOfMapEmpty {
        \find(mapGet(mapEmpty, x))
        \sameUpdateLevel
        \replacewith(mapUndef)
        \heuristics(simplify)
    };

    getOfMapSingleton {
        \find(mapGet(mapSingleton(x, y), z))
        \sameUpdateLevel
        \replacewith(\if(x = z) \then(y) \else(mapUndef))
        \heuristics(simplify)
    };

    getOfMapOverride {
        \find(mapGet(mapOverride(m0, m1), x))
        \sameUpdateLevel
        \replacewith(\if(inDomain(m1, x))
                \then(mapGet(m1, x)) \else(mapGet(m0, x)))
        \heuristics(simplify_enlarging)
    };

    getOfSeq2Map {
        \schemaVar \term Seq s;
        \find(mapGet(seq2map(s), x))
        \sameUpdateLevel
        \replacewith(\if(int::instance(x) = TRUE & 0 <= int::cast(x) & int::cast(x) < seqLen(s))
                \then(any::seqGet(s, int::cast(x))) \else(mapUndef))
        \heuristics(simplify_enlarging)
    };

    // Added by Kai Wallisch
    getOfMapUpdate {
        \find(mapGet(mapUpdate(m, key, value), x))
        \sameUpdateLevel
        \replacewith(\if(x = key) \then(value) \else(mapGet(m, x)))
        \heuristics(simplify_enlarging)
    };

    // Added by Kai Wallisch
    getOfMapRemove {
        \find(mapGet(mapRemove(m, key), x))
        \sameUpdateLevel
        \replacewith(\if(x = key) \then(mapUndef) \else(mapGet(m, x)))
        \heuristics(simplify_enlarging)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/** Additional rules for the size of maps.
 * @author Kai Wallisch
 */

\schemaVariables {
    \term Map m, m0, m1;
    \term any key, value, x;
    \variables any vy;
}

\functions {
    int mapSize(Map);
}

\predicates {
    isFinite(Map);
}

\rules {

    // --------------------------------------------------------------------------
    // isFinite axiom
    // --------------------------------------------------------------------------

    defIsFinite {
        \schemaVar \variables any vx;
        \schemaVar \variables int ix;
        \schemaVar \variables Seq s;
        \find(isFinite(m))
        \varcond(\notFreeIn(vx, m), \notFreeIn(s, m))
        \replacewith(\exists s;
            (\forall vx;
                (inDomain(m, vx) <-> (\exists ix; (0 <= ix & ix < seqLen(s) & any::seqGet(s, ix) = vx)))
            ))
    };

    // --------------------------------------------------------------------------
    // isFinite derived rules
    // --------------------------------------------------------------------------

    isFiniteOfMapEmpty {
        \find(isFinite(mapEmpty))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };

    isFiniteOfMapRemove {
        \find(isFinite(mapRemove(m, key)))
        \sameUpdateLevel
        \replacewith(isFinite(m))
        \heuristics(simplify)
    };

    isFiniteOfMapUpdate {
        \find(isFinite(mapUpdate(m, key, value)))
        \sameUpdateLevel
        \replacewith(isFinite(m))
        \heuristics(simplify)
    };

    isFiniteOfMapSingleton {
        \find(isFinite(mapSingleton(key, value)))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };

    isFiniteOfSeq2Map {
        \schemaVar \term Seq s;
        \find(isFinite(seq2map(s)))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };

    // --------------------------------------------------------------------------
    // mapSize axioms
    // --------------------------------------------------------------------------

    sizeOfMapEmpty {
        \find(mapSize(mapEmpty))
        \sameUpdateLevel
        \replacewith(0)
        \heuristics(simplify)
    };

    sizeOfMapRemove {
        \find(mapSize(mapRemove(m, key)))
        \add(isFinite(m) -> (
                mapSize(mapRemove(m, key)) =
                \if(inDomain(m, key)) \then(mapSize(m) - 1) \else(mapSize(m))
            ) ==>)
        \heuristics(inReachableStateImplication)
    };

    // --------------------------------------------------------------------------
    // mapSize derived rules
    // --------------------------------------------------------------------------

    sizeOfMapUpdate {
        \find(mapSize(mapUpdate(m, key, value)))
        \add(isFinite(m) -> (
                mapSize(mapUpdate(m, key, value)) =
                \if(inDomain(m, key)) \then(mapSize(m)) \else(mapSize(m) + 1)
            ) ==>)
        \heuristics(inReachableStateImplication)
    };

    sizeOfMapSingleton {
        \find(mapSize(mapSingleton(key, value)))
        \sameUpdateLevel
        \replacewith(1)
        \heuristics(simplify)
    };

    sizeOfSeq2Map {
        \schemaVar \term Seq s;
        \find(mapSize(seq2map(s)))
        \sameUpdateLevel
        \replacewith(seqLen(s))
        \heuristics(simplify)
    };

    mapSizeNotNegativeForFiniteMaps {
        \find(mapSize(m))
        \add(isFinite(m) -> (mapSize(m) >= 0) ==>)
        \heuristics(inReachableStateImplication)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/*
 * This file contains the known taclet options (aka choices) as well as their documentation.
 */

\optionsDecl {

    /*!
    Treatment of Java assertion statements. Java assertions can be handled in three different ways in KeY.
    */
    assertions: {
        /*!
        If set to 'safe', the following proof obligations have to be shown:
            - The program with assertions removed must fulfill the specification
            - The asserted conditions must hold (without throwing an exception,
              and with termination)
            - The assertions do not have side effects influencing the post
              conditions.
        This is the default option. Proofs with this option are typically harder.

        @choiceDefaultOption
        */
        safe,

        /*! If switched 'on', assertions are treated like Java would treat them:
        Asserted Statements are evaluated and an AssertionException is
        raised if they turn out to be false.*/
        on,

        /*! If switched 'off', assert statements are skipped. */
        off};

    /*! Specifies whether static (class loading) initialization should be
    taken in consideration.

    Both specifications and proof obligations become significantly more
    difficult since class loading may take place at many places.*/
    initialisation: {/*! @choiceUnsound */
        disableStaticInitialisation,
        enableStaticInitialisation
    };

    /*! This option controls how integer numbers are modeled. */
    intRules: {
        /*! 'Arithmetic without overflow checking' treats integers as pure
        mathematical objects. The proof obligations are often easier to
        discharge. However, the model does not allow the verification of all
        properties which hold with Java semantics. Moreover, it allows the
        verification of properties which do not hold on Java's actual
        semantics. This is the default option.

        @choiceDefaultOption @choiceUnsound
        */
        arithmeticSemanticsIgnoringOF,

        /*! 'Arithmetic with overflow checking' also treats integers as
        mathematical objects, but ensures that no overflow occurs.  While
        this model also has a completeness gap, it prevents proving
        incorrect properties.

        @choiceIncomplete*/
        arithmeticSemanticsCheckingOF,

        /*! 'Java semantics' treat integers the same way Java would treat them.
        The different integer types operate within their respective value
        ranges. The bitvector arithmetic is modeled in KeY using modulo
        expressions. This is sound and complete. Proof obligations tend
        to get more complex with this setting.*/
        javaSemantics
    };

    /*! Rules dealing Java language constructs can be turned off by setting this to 'None'. */
    programRules: {Java, /*! @choiceIncomplete */ None};
    /*! Treatment of implicit runtime exceptions */
    runtimeExceptions: {
        /*! If set to 'allow', implicit runtime exceptions are raised as specified
        in the Java language specification.

        @choiceIncomplete
        */
        ban,
        /*!
        If set to 'ban', any occurrence of an implicit runtime exception is
        considered an unrecoverable program failure. For programs which do not
        raise implicit runtime exceptions, this is usually easier to prove than
        'allow'. This is the default option.
        */
        allow,
        /*! If set to 'ignore', it is assumed that no implicit runtime exception occurs.
        Warning: Reasoning with these rules is unsound.

        @choiceUnsound
        */
        ignore
    };

    /*! JavaCard is a dialect of Java designed for the use in SmartCards.  It
    lacks floating point operations and concurrency, but provides stronger
    object persistence guarantees.

    There are two values for this option 'on' and 'off'. Switching
    on or off all taclets axiomatising JavaCard specific features like transaction.
    */
    JavaCard: {off, on};

    /*! Loading rules dealing with Strings (charLists) can be disabled. */
    Strings: {on, /*!     @choiceIncomplete */ off};

    /*!
    Rules for model field representation clauses. JML model fields are given
    a semantics by represents clauses. This switch sets how the rules handle these clauses.
    */
    modelFields: {
        /*!
        * If set to 'treatAsAxiom', the representation is seen as an axiom,
          satisfiability will not be checked. This may introduce inconsistent
          specifications, for example the following contradictory JML clause
          will not be rejected:
             //@ represents modelField == modelField + 1;
          This is the default option since KeY 2.4.
        */
        treatAsAxiom,
        /*!
        If set to 'showSatisfiability', for every expansion of the represents
        clause, it must be shown that the definition is _locally_
        satisfiable. Cross-definition inconsistencies can still be
        formulated, however:
        ```
           //@ represents modelField1 == modelField2;
           //@ represents modelField2 == modelField1 + 1;
        ```
        This had been the default option previously, until KeY 2.2.
        */
        showSatisfiability
    };
    /*! Loading program rules dealing with JML's \bigint datatype can be disabled. */
    bigint: {on, off};
    /*! Loading rules dealing with sequences can be disabled. */
    sequences: {on, off};
    /*! This option allows more fine-grained control over rules dealing with sequences.
    By default, it is disabled because the additional rules are known to have a negative impact on overall performance.
    Activate this option if your problem is concerned with permutations or information flow.*/
    moreSeqRules: {off, on};
    /*! Loading rules dealing with reachability can be disabled. */
    reach: {on, off};
    /*!
    Loading less commonly used rules for (mathematical) integers,
    such as rules for bounded sums and products, modulo, or polynomials,
    can be disabled. If they are loaded, their application in the strategy
    can still be controlled as usual.

    This option is experimental. Depending of your understanding of 'less common',
    you may experience incompleteness. Doing proofs with Java int semantics will not work, definitely.

    Not to be confused with intRules, which controls the semantics of the Java type int.
    */
    integerSimplificationRules: {full, /*! @choiceIncomplete */ minimal}; // ____: further refine this option
    permissions: {off, on};

    /*!
    Treatment of formulas and terms for welldefinedness checks:
    */
    wdOperator: {
        /*!
        More intuitive for software developers and along the lines of
        runtime assertion semantics. Well-Definedness checks will be
        stricter using this operator, since the order of terms/formulas
        matters. It is based on McCarthy logic.
        Cf. "Are the Logical Foundations of Verifying Compiler
        Prototypes Matching User Expectations?" by Patrice Chalin.

        @choiceDefaultOption
        */
        L,
        /*!
        Complete and along the lines of classical logic, where the
        order of terms/formulas is irrelevant. This operator is
        equivalent to the D-operator, but more efficient.
        Cf. "Efficient Well-Definedness Checking" by Ádám Darvas,
        Farhad Mehta, and Arsenii Rudich.
        */
        Y,
        /*!
        Complete and along the lines of classical logic, where the
        order of terms/formulas is irrelevant. This operator is not as
        strict as the L-operator, based on strong Kleene logic. To be
        used with care, since formulas may blow up exponentially.
        Cf. "Well Defined B" by Patrick Behm, Lilian Burdy, and
        Jean-Marc Meynadier*/
        D
    };

    /*!
    Welldefinedness checks of JML specifications can be turned on/off.
    This includes class invariants, operation contracts, model fields
    as well as JML (annotation) statements as loop invariants and
    block contracts. The former ones are checked "on-the-fly", i.e.,
    directly when they are applied in the code while proving an operation
    contract, since the context is needed.
    */
    wdChecks: {off, on};
    /*!
    Specifies whether a special goal "Joined node is weakening" should be
    generated as a child of the partner node of a join operation.

    For join procedures formally proven correct, this should not be necessary.
    Enable this option when you are not sure whether a newly implemented join
    procedure is sound. In this case, the generated "is weakening" goals should
    only be closable if the concrete join instance is correct.
    */
    mergeGenerateIsWeakeningGoal: {off, on};

    /*!
    Method calls in KeY can be either handled by inlining the method body or
    by applying the method's contract. Inlining a method body is only modularly
    sound if it is guaranteed that no new method body can override the known
    implementation.
    */
    methodExpansion: {
        /*! Inlining is modularly sound: Methods can only be inlined if private,
            static, final, or in a final method.
            @choiceDefaultOption
        */
        modularOnly,
        /*! Inlining is liberal: Methods can always be inlined, and all known
            method implementations are taken into consideration. This setting
            is sound under a closed program assumption.
        */
        noRestriction
    };

    /*!
    Final fields can only be written to from within the constructor. This is a
    Java language feature. KeY can exploit this restriction by treating final fields
    as immutable. This can simplify the reasoning about the program significantly.
    But it is still possible to tread final fields as normal mutable fields to
    ensure backward compatibility. If constructor code is to be inlined, there
    can be cases where the immutable treatment is incomplete.
    */
    finalFields: {
        /*! Final fields are treated as immutable entities.
            This is the default option. */
        immutable,

        /*! Final fields are treated like all Java fields.
            This is the original behaviour of KeY. */
        onHeap
    };

    /*!
    Missing documentation
    */
    javaLoopTreatment: {efficient, teaching};

    /*!
    Floating points in Java may have a more precise semantics if the hardware
    supports it. Only if the Java keyword strictfp is specified can we make
    guarantees about the meaning of floating point expressions.
    */
    floatRules: {
        /*! Require the strictfp keyword if floating points are to be treated.
        Otherwise arithmetic remains as underspecified symbols*/
        strictfpOnly,
        /*! Treat all code as if it was specified strictfp. */
        assumeStrictfp
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\sorts {
    Permission;
    PermissionOwnerList;
}

\functions {
    \unique Object currentThread; // distinct object representing
    // the currently running thread

    // Owner list constructors
    PermissionOwnerList emptyPermissionOwnerList;
    PermissionOwnerList consPermissionOwnerList(Object, PermissionOwnerList);

    // Owner list modifiers
    PermissionOwnerList insertPermissionOwner(Object, Object, int, PermissionOwnerList);
    PermissionOwnerList returnPermissionOwner(Object, PermissionOwnerList);

    // Permissions as such

    // Constructors
    Permission emptyPermission;
    Permission slice(PermissionOwnerList, Permission);

    // Modifiers
    Permission transferPermission(boolean, Object, Object, int, Permission);
    Permission returnPermission(Object, Object, Permission);

    // Convenience
    Permission initFullPermission;
    PermissionOwnerList owner1(Object);
    PermissionOwnerList owner2(Object, Object);
    PermissionOwnerList owner3(Object, Object, Object);
    PermissionOwnerList owner4(Object, Object, Object, Object);

    Permission slice1(PermissionOwnerList);
    Permission slice2(PermissionOwnerList, PermissionOwnerList);

}

\predicates {
    checkPermissionOwner(Object, int, PermissionOwnerList);
    //  equalPermissionOwners(PermissionOwnerList,PermissionOwnerList);

    readPermissionObject(Object, Permission);
    writePermissionObject(Object, Permission);
    readPermission(Permission); // abbr. readPermissionObject(currentThread, Permission)
    writePermission(Permission); // abbr. writePermissionObject(currentThread, Permission)
    readPermissionOwe(Object, Object, Permission);
    readPermissionOwe2(Object, Object, Permission);

    // Convenience

    twoPermissions(Object, Object, Permission);
    nonEmptyPermission(Permission);

    permissionsFor(Heap, Heap);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules {

    writePermission {
        \schemaVar \term Permission p;
        \find(writePermission(p))
        \replacewith(writePermissionObject(currentThread, p))
        \heuristics(simplify_enlarging)
    };

    readPermission {
        \schemaVar \term Permission p;
        \find(readPermission(p))
        \replacewith(readPermissionObject(currentThread, p))
        \heuristics(simplify_enlarging)
    };

    permissionDefaultValue {
        \find(Permission::defaultValue)
        \replacewith(initFullPermission)
        \heuristics(simplify)
    };

}

\rules(permissions:off) {

    writePermissionObject {
        \schemaVar \term Permission p;
        \schemaVar \term Object o;
        \find(writePermissionObject(o, p))
        \replacewith(true)
        \heuristics(concrete)
    };

    readPermissionObject {
        \schemaVar \term Permission p;
        \schemaVar \term Object o;
        \find(readPermissionObject(o, p))
        \replacewith(true)
        \heuristics(concrete)
    };

}

\rules(permissions:on) {

    // Permission owner list rules:

    // Comparison: (not needed for now)
    /*
      equalPermissionOwners_ne1 {
        \schemaVar \term Object o;
        \schemaVar \term PermissionOwnerList ol;
        \find(equalPermissionOwners(consPermissionOwnerList(o,ol), emptyPermissionOwnerList))
        \replacewith ( false )
        \heuristics(concrete)
      };

      equalPermissionOwners_ne2 {
        \schemaVar \term Object o;
        \schemaVar \term PermissionOwnerList ol;
        \find(equalPermissionOwners(emptyPermissionOwnerList, consPermissionOwnerList(o,ol)))
        \replacewith ( false )
        \heuristics(concrete)
      };

      equalPermissionOwners_eq1 {
        \find(equalPermissionOwners(emptyPermissionOwnerList, emptyPermissionOwnerList))
        \replacewith ( true )
        \heuristics(concrete)
      };

      equalPermissionOwners_eq2 {
        \schemaVar \term Object o1, o2;
        \schemaVar \term PermissionOwnerList ol1, ol2;
        \find(equalPermissionOwners(consPermissionOwnerList(o1,ol1), consPermissionOwnerList(o2,ol2)))
        \replacewith ( o1 = o2 & equalPermissionOwners(ol1, ol2))
        \heuristics(simplify_expression)
      };
    */

    // Check ownership at position

    checkPermissionOwner_empty {
        \schemaVar \term Object ow;
        \schemaVar \term int depth;
        \find(checkPermissionOwner(ow, depth, emptyPermissionOwnerList))
        "checkPermissionOwner definition":
            \replacewith(false)
        ;
        "checkPermissionOwner precondition":
            \add( ==> depth >= 0)
        \heuristics(concrete)
    };

    checkPermissionOwner_nonempty {
        \schemaVar \term Object ow, o;
        \schemaVar \term int depth;
        \schemaVar \term PermissionOwnerList ol;
        \find(checkPermissionOwner(ow, depth, consPermissionOwnerList(o, ol)))
        "checkPermissionOwner definition":
            \replacewith(\if(depth = 0) \then(ow = o) \else(checkPermissionOwner(ow, depth - 1, ol)))
        ;
        "checkPermissionOwner precondition":
            \add( ==> depth >= 0)
        \heuristics(simplify_expression)
    };

    // Insert new owner at position

    insertPermissionOwner {
        \schemaVar \term Object o, no, owner;
        \schemaVar \term int depth;
        \schemaVar \term PermissionOwnerList ol;
        \find(insertPermissionOwner(o, no, depth, consPermissionOwnerList(owner, ol)))
        "insertPermissionOwner definition":
            \replacewith(
                \if(depth = 0)
                    \then(consPermissionOwnerList(no, consPermissionOwnerList(owner, ol)))
                    \else(
                        consPermissionOwnerList(owner, insertPermissionOwner(o, no, depth - 1, ol))
                    )
            )
        ;
        "insertPermissionOwner precondition":
            \add( ==> depth >= 0 & checkPermissionOwner(o, depth, consPermissionOwnerList(owner, ol)))
        \heuristics(simplify_enlarging)
    };

    // Remove the owner on the top

    returnPermissionOwner {
        \schemaVar \term Object o, owner;
        \schemaVar \term PermissionOwnerList ol;
        \find(returnPermissionOwner(o, consPermissionOwnerList(owner, ol)))
        "returnPermissionOwner definition":
            \replacewith(ol)
        ;
        "returnPermissionOwner precondition":
            \add( ==> checkPermissionOwner(o, 0, consPermissionOwnerList(owner, ol)))
        \heuristics(simplify_expression)
    };

    // Permission transfer rules

    transferPermission_empty {
        \schemaVar \term boolean split;
        \schemaVar \term Object from, to;
        \schemaVar \term int depth;

        \find(transferPermission(split, from, to, depth, emptyPermission))
        \replacewith(emptyPermission)
        \heuristics(concrete)
    };

    transferPermission_slice {
        \schemaVar \term boolean split;
        \schemaVar \term Object from, to;
        \schemaVar \term int depth;
        \schemaVar \term Permission p;
        \schemaVar \term PermissionOwnerList owners;

        \find(transferPermission(split, from, to, depth, slice(owners, p)))
        \replacewith(
            \if(from = to) \then(slice(owners, p)) \else(
                    \if(checkPermissionOwner(from, depth, owners)) \then(
                            slice(
                                insertPermissionOwner(from, to, depth, owners),
                                \if(split = TRUE) \then(slice(owners, p)) \else(transferPermission(split, from, to, depth, p))
                            )
                        ) \else(
                            slice(owners, transferPermission(split, from, to, depth, p))
                        )
                )
        )
        \heuristics(simplify_enlarging)
    };

    returnPermission_empty {
        \schemaVar \term Object from, to;

        \find(returnPermission(from, to, emptyPermission))
        \replacewith(emptyPermission)
        \heuristics(concrete)
    };

    returnPermission_slice_split {
        \schemaVar \term Object from, to;
        \schemaVar \term Permission p;
        \schemaVar \term PermissionOwnerList owners;
        \find(returnPermission(from, to, slice(consPermissionOwnerList(from, owners), slice(owners, p))))
        "returnPermission definition":
            \replacewith(slice(owners, returnPermission(from, to, p)))
        ;
        "returnPermission precondition":
            \add( ==> from != to & checkPermissionOwner(to, 0, owners))
        \heuristics(simplify) // This one needs to be strictly higher priority than the next
    };

    returnPermission_slice {
        \schemaVar \term Object from, to;
        \schemaVar \term Permission p;
        \schemaVar \term PermissionOwnerList owners;

        \find(returnPermission(from, to, slice(owners, p)))
        \replacewith(
            \if(from = to) \then(slice(owners, p)) \else(
                    \if(checkPermissionOwner(from, 0, owners) & checkPermissionOwner(to, 1, owners)) \then(
                            slice(returnPermissionOwner(from, owners), returnPermission(from, to, p))
                        ) \else(
                            slice(owners, returnPermission(from, to, p))
                        )
                )
        )
        \heuristics(simplify_expression)
    };

    // Permission rights checks

    readPermissionSlice {
        \schemaVar \term Object o;
        \schemaVar \term PermissionOwnerList ol;
        \schemaVar \term Permission p;

        \find(readPermissionObject(o, slice(ol, p)))
        \replacewith(checkPermissionOwner(o, 0, ol) | readPermissionObject(o, p))
        \heuristics(simplify_enlarging)
    };

    readPermissionEmpty {
        \schemaVar \term Object o;
        \find(readPermissionObject(o, emptyPermission))
        \replacewith(false)
        \heuristics(concrete)
    };

    writePermissionSlice {
        \schemaVar \term Object o;
        \schemaVar \term PermissionOwnerList ol;
        \schemaVar \term Permission p;

        \find(writePermissionObject(o, slice(ol, p)))
        \replacewith(checkPermissionOwner(o, 0, ol) & writePermissionObject(o, p))
        \heuristics(simplify_enlarging)
    };

    writePermissionEmpty {
        \schemaVar \term Object o;
        \find(writePermissionObject(o, emptyPermission))
        \replacewith(true)
        \heuristics(concrete)
    };

    // Convenience

    initFullPermission {
        \find(initFullPermission)
        \replacewith(slice(consPermissionOwnerList(currentThread, emptyPermissionOwnerList), emptyPermission))
        \heuristics(simplify_enlarging)
    };

    permOwner1 {
        \schemaVar \term Object o1;
        \find(owner1(o1))
        \replacewith(consPermissionOwnerList(o1, emptyPermissionOwnerList))
        \heuristics(simplify_enlarging)
    };

    permOwner2 {
        \schemaVar \term Object o1, o2;
        \find(owner2(o1, o2))
        \replacewith(consPermissionOwnerList(o1, consPermissionOwnerList(o2, emptyPermissionOwnerList)))
        \heuristics(simplify_enlarging)
    };

    permOwner3 {
        \schemaVar \term Object o1, o2, o3;
        \find(owner3(o1, o2, o3))
        \replacewith(consPermissionOwnerList(o1, consPermissionOwnerList(o2, consPermissionOwnerList(o3, emptyPermissionOwnerList))))
        \heuristics(simplify_enlarging)
    };

    permOwner4 {
        \schemaVar \term Object o1, o2, o3, o4;
        \find(owner4(o1, o2, o3, o4))
        \replacewith(consPermissionOwnerList(o1, consPermissionOwnerList(o2, consPermissionOwnerList(o3, consPermissionOwnerList(o4, emptyPermissionOwnerList)))))
        \heuristics(simplify_enlarging)
    };

    permSlice1 {
        \schemaVar \term PermissionOwnerList pol1;
        \find(slice1(pol1))
        \replacewith(slice(pol1, emptyPermission))
        \heuristics(simplify_enlarging)
    };

    permSlice2 {
        \schemaVar \term PermissionOwnerList pol1, pol2;
        \find(slice2(pol1, pol2))
        \replacewith(slice(pol1, slice(pol2, emptyPermission)))
        \heuristics(simplify_enlarging)
    };

    twoPermissions {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p;
        \schemaVar \variables PermissionOwnerList ol1, ol2;
        \find(twoPermissions(o1, o2, p))
        \varcond(
            \notFreeIn(ol1, p),
            \notFreeIn(ol2, p),
            \notFreeIn(ol1, o1),
            \notFreeIn(ol2, o1),
            \notFreeIn(ol1, o2),
            \notFreeIn(ol2, o2))
        \replacewith(\exists ol1, ol2; p = slice(consPermissionOwnerList(o1, ol1), slice(consPermissionOwnerList(o2, ol2), emptyPermission)))
        \heuristics(simplify_enlarging)
    };

    nonEmptyPermission {
        \schemaVar \term Permission p;
        \schemaVar \variables Permission pp;
        \schemaVar \variables PermissionOwnerList ol;
        \find(nonEmptyPermission(p))
        \varcond(\notFreeIn(ol, p), \notFreeIn(pp, p))
        \replacewith(\exists ol; \exists pp; p = slice(ol, pp))
        \heuristics(simplify_enlarging)
    };

    readPermissionOwe {
        \schemaVar \term Permission p;
        \schemaVar \term Object o1, o2;
        \schemaVar \variables Permission pp;
        \schemaVar \variables PermissionOwnerList ol;
        \find(readPermissionOwe(o1, o2, p))
        \varcond(
            \notFreeIn(ol, p),
            \notFreeIn(pp, p),
            \notFreeIn(ol, o1),
            \notFreeIn(pp, o1),
            \notFreeIn(ol, o2),
            \notFreeIn(pp, o2))
        \replacewith(\exists ol; \exists pp; p = slice(consPermissionOwnerList(o1, consPermissionOwnerList(o2, ol)), pp))
        \heuristics(simplify_enlarging)
    };

    readPermissionOwe2 {
        \schemaVar \term Permission p;
        \schemaVar \term Object o1, o2;
        \schemaVar \variables Permission pp;
        \schemaVar \variables PermissionOwnerList ol, ol0;
        \find(readPermissionOwe2(o1, o2, p))
        \varcond(
            \notFreeIn(ol0, p),
            \notFreeIn(ol, p),
            \notFreeIn(pp, p),
            \notFreeIn(ol0, o1),
            \notFreeIn(ol, o1),
            \notFreeIn(pp, o1),
            \notFreeIn(ol0, o2),
            \notFreeIn(ol, o2),
            \notFreeIn(pp, o2))
        \replacewith(\exists ol0; \exists ol; \exists pp; p = slice(ol0, slice(consPermissionOwnerList(o1, consPermissionOwnerList(o2, ol)), pp)))
        \heuristics(simplify_enlarging)
    };

    writePermissionImpliesReadPermission {
        \schemaVar \term Object o;
        \schemaVar \term Permission p;

        \assumes(writePermissionObject(o, p) ==>)
        \find(readPermissionObject(o, p))
        \replacewith(true)
        \heuristics(simplify)
    };

    readPermissionAfterTransferRead {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p;
        \schemaVar \term boolean split;

        \assumes(readPermissionObject(o1, p) ==>)
        \find(readPermissionObject(o2, transferPermission(split, o1, o2, 0, p)))
        \replacewith(true)
        \heuristics(simplify)
    };

    readPermissionAfterTransferReadEQ {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p, p1;
        \schemaVar \term boolean split;

        \assumes(readPermissionObject(o1, p), transferPermission(split, o1, o2, 0, p) = p1 ==>)
        \find(readPermissionObject(o2, p1))
        \replacewith(true)
        \heuristics(simplify)
    };

    readPermissionAfterTransferWrite {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p;
        \schemaVar \term boolean split;

        \assumes(writePermissionObject(o1, p) ==>)
        \find(readPermissionObject(o2, transferPermission(split, o1, o2, 0, p)))
        \replacewith(true)
        \heuristics(simplify)
    };

    readPermissionAfterTransferWriteEQ {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p, p1;
        \schemaVar \term boolean split;

        \assumes(writePermissionObject(o1, p), transferPermission(split, o1, o2, 0, p) = p1 ==>)
        \find(readPermissionObject(o2, p1))
        \replacewith(true)
        \heuristics(simplify)
    };

    writePermissionAfterFullTransfer {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p;

        \assumes(writePermissionObject(o1, p) ==>)
        \find(writePermissionObject(o2, transferPermission(FALSE, o1, o2, 0, p)))
        \replacewith(true)
        \heuristics(simplify)
    };

    writePermissionAfterFullTransferEQ {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p1, p2;

        \assumes(writePermissionObject(o1, p2), transferPermission(FALSE, o1, o2, 0, p2) = p1 ==>)
        \find(writePermissionObject(o2, p1))
        \replacewith(true)
        \heuristics(simplify)
    };

    writePermissionAfterReturn {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p;

        \assumes(writePermissionObject(o1, p) ==>)
        \find(writePermissionObject(o2, returnPermission(o1, o2, p)))
        \replacewith(true)
        \heuristics(simplify)
    };

    writePermissionAfterReturnEQ {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p1, p2;

        \assumes(writePermissionObject(o1, p2), returnPermission(o1, o2, p2) = p1 ==>)
        \find(writePermissionObject(o2, p1))
        \replacewith(true)
        \heuristics(simplify)
    };

    permissionTransferReturnIdentity {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p;

        \find(returnPermission(o2, o1, transferPermission(FALSE, o1, o2, 0, p)))
        \replacewith(p)
        \heuristics(simplify)
    };

    permissionTransferReturnIdentityEQ {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p1, p2;

        \assumes(p2 = transferPermission(FALSE, o1, o2, 0, p1) ==>)
        \find(returnPermission(o2, o1, p2))
        \replacewith(p1)
        \heuristics(simplify)
    };

    writePermissionOtherNoPermissionCurrentRead {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p;

        \assumes(writePermissionObject(o1, p) ==> o2 = o1)
        \find(readPermissionObject(o2, p))
        \replacewith(false)
        \heuristics(simplify)
    };

    writePermissionOtherNoPermissionCurrentWrite {
        \schemaVar \term Object o1, o2;
        \schemaVar \term Permission p;

        \assumes(writePermissionObject(o1, p) ==> o2 = o1)
        \find(writePermissionObject(o2, p))
        \replacewith(false)
        \heuristics(simplify)
    };

    // connection between heap and permissions

    createdOnHeapImpliesCreatedOnPermissions {
        \schemaVar \term Object o;
        \schemaVar \term Heap h, p;

        \assumes(wellFormed(h), wellFormed(p), permissionsFor(p, h), boolean::select(h, o, java.lang.Object::<created>) = TRUE ==>)
        \find(boolean::select(p, o, java.lang.Object::<created>))
        \sameUpdateLevel
        \replacewith(TRUE)

        \heuristics(simplify)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules {

    precOfInt {
        \schemaVar \term int a;
        \schemaVar \term int b;

        \find(prec(a, b))

        \replacewith(0 <= a & a < b)

        \heuristics(simplify)
    };

    precOfIntPair {
        \schemaVar \term int a;
        \schemaVar \term int b;
        \schemaVar \term any x;

        \find(prec(a, pair(b, x)))

        \replacewith(0 <= a & a <= b)

        \heuristics(simplify)
    };

    precOfPairInt {
        \schemaVar \term int a;
        \schemaVar \term int b;
        \schemaVar \term any x;

        \find(prec(pair(a, x), b))

        \replacewith(0 <= a & a < b)

        \heuristics(simplify)
    };

    precOfPair {
        \schemaVar \term any a1;
        \schemaVar \term any a2;
        \schemaVar \term any b1;
        \schemaVar \term any b2;

        \find(prec(pair(a1, b1), pair(a2, b2)))

        \replacewith(prec(a1, a2) | (a1 = a2 & prec(b1, b2)))

        \heuristics(simplify)
    };

    // fixed due to #1451
    precOfSeq {
        \schemaVar \term Seq s1;
        \schemaVar \term Seq s2;
        \schemaVar \variables int iv, jv;

        \find(prec(s1, s2))

        \varcond(\notFreeIn(iv, s1, s2),
            \notFreeIn(jv, s1, s2))

        \replacewith(
            seqLen(s1) = seqLen(s2) &
            \exists iv; (0 <= iv & iv < seqLen(s1) &
                prec(any::seqGet(s1, iv), any::seqGet(s2, iv)) &
                \forall jv; (0 <= jv & jv < iv ->
                    any::seqGet(s1, jv) = any::seqGet(s2, jv)))
            | seqLen(s1) < seqLen(s2)
        )
    };

    measuredByCheck {
        \schemaVar \term any c, m;
        \assumes(measuredBy(m) ==>)
        \find(measuredByCheck(c))
        \sameUpdateLevel
        \replacewith(prec(c, m))
        \heuristics(simplify)
    };

    measuredByCheckEmpty {
        \schemaVar \term any c;
        \assumes(measuredByEmpty ==>)
        \find(measuredByCheck(c))
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(simplify)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules that should always be present,
// but do not depend on a sort. In other words, mainly propositional logic.

// These schema variables are used to write the following rules.
// They will not be visible in later runs of the parser, so you are
// fairly free in choosing their names.


\schemaVariables {
    \formula b, c, d;
    \formula cutFormula;
    \formula [rigid] br, cr;
}

\rules {

    // closing goals
    close {
        \assumes(b ==>)
        \find( ==> b) \closegoal
        \heuristics(closure)
        \displayname "close"
    };
    closeAntec {
        \assumes( ==> b)
        \find(b ==>) \closegoal
        \displayname "close"
    };

    closeFalse {
        \find(false ==>) \closegoal \heuristics(closure)
    };
    closeTrue {
        \find( ==> true) \closegoal \heuristics(closure)
    };

    // simplification rules
    replace_known_left {
        \assumes(b ==>)
        \find(b)
        \sameUpdateLevel
        \replacewith(true)
        \heuristics(replace_known_left)
    };
    replace_known_right {
        \assumes( ==> b)
        \find(b)
        \sameUpdateLevel
        \replacewith(false)
        \heuristics(replace_known_right)
    };

    // junctor rules
    true_left {
        \find(true ==>)
        \replacewith( ==>) \heuristics(concrete)
    };
    false_right {
        \find( ==> false)
        \replacewith( ==>) \heuristics(concrete)
    };

    notLeft {
        \find(!b ==>)
        \replacewith( ==> b) \heuristics(alpha)
    };
    notRight {
        \find( ==> !b)
        \replacewith(b ==>) \heuristics(alpha)
    };

    impLeft {
        \find(b -> c ==>)
        \replacewith( ==> b);
        \replacewith(c ==>)
        \heuristics(beta)
    };
    doubleImpLeft {
        \find(b -> c -> d ==>)
        \replacewith( ==> b);
        \replacewith( ==> c);
        \replacewith(d ==>)
        \heuristics(beta)
    };
    impRight {
        \find( ==> b -> c)
        \replacewith(b ==> c)
        \heuristics(alpha)
    };

    andLeft {
        \find(b & c ==>)
        \replacewith(b, c ==>) \heuristics(alpha)
    };
    andRight {
        \find( ==> b & c)
        \replacewith( ==> b);
        \replacewith( ==> c)
        \heuristics(beta)
    };
    orLeft {
        \find(b | c ==>)
        "#b":
            \replacewith(b ==>);
        "#c":
            \replacewith(c ==>)
        \heuristics(beta)
    };
    orRight {
        \find( ==> b | c)
        \replacewith( ==> b, c) \heuristics(alpha)
    };

    equiv_left {
        \find(b <-> c ==>)
        \replacewith(b, c ==>);
        \replacewith( ==> b, c)
        \heuristics(beta)
    };

    equiv_right {
        \find( ==> b <-> c)
        "Case '->'":
            \replacewith(b ==> c);
        "Case '<-'":
            \replacewith(c ==> b)
        \heuristics(beta)
    };

    /* These `recursive' rules are commented out, because this
       keyword is not yet supported.
    imp_left_rec { \find (b -> c ==>)  \recursive
             \replacewith(==> b);
                     \replacewith(c ==>) };
    and_right_rec { \find (==> b & c)  \recursive
              \replacewith(==> b);
                      \replacewith(==> c) };
    or_left_rec { \find (b | c ==>)  \recursive
            \replacewith(b ==>);
                    \replacewith(c ==>) };
    */

    split_or_strong {
        \find(b | c ==>)
        \replacewith(b ==>);
        \replacewith(c ==> b)
    };

    ///////////////////////////////////////////////////////////////////////////////

    rotate_and {
        \find(b & (c & d))
        \replacewith(c & (b & d))
    };
    rotate_or {
        \find(b | (c | d))
        \replacewith(c | (b | d))
    };

    // equivalence replacement
    insert_eqv_once_lr {
        \find(br <-> cr ==>)
        \addrules(
            insert_eqv {
                \find(br)
                \replacewith(cr)
            })
    };
    insert_eqv_once_rl {
        \find(br <-> cr ==>)
        \addrules(
            insert_eqv {
                \find(cr)
                \replacewith(br)
            })
    };

    insert_eqv_lr {
        \find(br <-> cr ==>)
        \addrules(
            insert_eqv {
                \find(br)
                \replacewith(cr)
                \heuristics(simplify)
            })
    };
    insert_eqv_rl {
        \find(br <-> cr ==>)
        \addrules(
            insert_eqv {
                \find(cr)
                \replacewith(br)
                \heuristics(simplify)
            })
    };

    // simplification
    double_not {
        \find(!(!b))
        \replacewith(b) \heuristics(concrete)
    };

    concrete_not_1 {
        \find(!true)
        \replacewith(false) \heuristics(concrete)
    };
    concrete_not_2 {
        \find(!false)
        \replacewith(true) \heuristics(concrete)
    };

    concrete_impl_1 {
        \find(true -> b)
        \replacewith(b) \heuristics(concrete)
    };
    concrete_impl_2 {
        \find(false -> b)
        \replacewith(true) \heuristics(concrete)
    };
    concrete_impl_3 {
        \find(b -> false)
        \replacewith(!b) \heuristics(concrete)
    };
    concrete_impl_4 {
        \find(b -> true)
        \replacewith(true) \heuristics(concrete)
    };

    concrete_and_1 {
        \find(true & b)
        \replacewith(b) \heuristics(concrete)
    };
    concrete_and_2 {
        \find(false & b)
        \replacewith(false) \heuristics(concrete)
    };
    concrete_and_3 {
        \find(b & true)
        \replacewith(b) \heuristics(concrete)
    };
    concrete_and_4 {
        \find(b & false)
        \replacewith(false) \heuristics(concrete)
    };

    concrete_or_1 {
        \find(true | b)
        \replacewith(true) \heuristics(concrete)
    };
    concrete_or_2 {
        \find(false | b)
        \replacewith(b) \heuristics(concrete)
    };
    concrete_or_3 {
        \find(b | true)
        \replacewith(true) \heuristics(concrete)
    };
    concrete_or_4 {
        \find(b | false)
        \replacewith(b) \heuristics(concrete)
    };

    concrete_or_5 {
        \find((c & b) | (c & (!b)))
        \replacewith(c)
        \heuristics(concrete)
        \displayname "distr_elim"
    };

    concrete_eq_1 {
        \find(true <-> b)
        \replacewith(b) \heuristics(concrete)
    };
    concrete_eq_2 {
        \find(false <-> b)
        \replacewith(!b) \heuristics(concrete)
    };
    concrete_eq_3 {
        \find(b <-> true)
        \replacewith(b) \heuristics(concrete)
    };
    concrete_eq_4 {
        \find(b <-> false)
        \replacewith(!b) \heuristics(concrete)
    };

    // other

    // NOTE (DS, 2019-02-20): Used by the "assume" command in
    //   proof scripts. Obviously unsound. I personally use it
    //   for coupling loops: There, I declare two anonymized
    //   loop counters to be equal to be able to perform relational
    //   reasoning.
    introduceAxiom {
        \add(cutFormula ==>)
    };

    cut {
        "CUT: #cutFormula TRUE":
            \add(cutFormula ==>);
        "CUT: #cutFormula FALSE":
            \add( ==> cutFormula)
        \heuristics(cut)
    };

    cut_direct {
        \find(cutFormula)
        \sameUpdateLevel
        "CUT: #cutFormula TRUE":
            \replacewith(true) \add(cutFormula ==>);
        "CUT: #cutFormula FALSE":
            \replacewith(false) \add( ==> cutFormula)
        \heuristics(cut_direct)
    };

    cut_direct_r {
        \find( ==> b)
        \replacewith( ==> b);
        \add(b ==>)
    };
    cut_direct_l {
        \find(b ==>)
        \replacewith(b ==>);
        \add( ==> b)
    };

    // proofobl not parsed yet.
    // rule_cut { \addrules (rule); \add (==> proofobl(rule)) };

    hide_left {
        \find(b ==>)
        \replacewith( ==>)
        \addrules(
            insert_hidden {
                \add(b ==>)
            })
    };

    hide_right {
        \find( ==> b)
        \replacewith( ==>)
        \addrules(
            insert_hidden {
                \add( ==> b)
            })
    };

    case_distinction_r {
        \find( ==> b)
        \addrules(
            to_true {
                \find( ==> b)
                \replacewith( ==> true)
                \heuristics(simplify)
            });
        \addrules(
            to_false {
                \find( ==> b)
                \replacewith( ==> false)
                \heuristics(simplify)
            })
        \displayname "case_distinction"
    };

    case_distinction_l {
        \find(b ==>)
        \addrules(
            to_true {
                \find(b ==>)
                \replacewith(true ==>)
                \heuristics(simplify)
            });
        \addrules(
            to_false {
                \find(b ==>)
                \replacewith(false ==>)
                \heuristics(simplify)
            })
        \displayname "case_distinction"
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// The rules for these predicates are in reachRules.key

\predicates {
    acc(Heap, LocSet, Object, Object);
    reach(Heap, LocSet, Object, Object, int);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules(reach:on) {

    // --------------------------------------------------------------------------
    // axioms
    // --------------------------------------------------------------------------

    accDefinition {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term deltaObject o2;
        \schemaVar \variables Field fv;

        \find(acc(h, s, o, o2))
        \varcond(
            \notFreeIn(fv, h),
            \notFreeIn(fv, s),
            \notFreeIn(fv, o),
            \notFreeIn(fv, o2))

        \replacewith(o != null & o2 != null & \exists fv; (elementOf(o, fv, s) & deltaObject::select(h, o, fv) = o2))

        \heuristics(simplify)
    };

    reachDefinition {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2;
        \schemaVar \term int n;
        \schemaVar \variables Object ov;

        \find(reach(h, s, o, o2, n))
        \varcond(
            \notFreeIn(ov, h),
            \notFreeIn(ov, s),
            \notFreeIn(ov, o),
            \notFreeIn(ov, o2),
            \notFreeIn(ov, n))

        \replacewith(n >= 0
            & o != null
            & o2 != null
            & (n = 0 & o = o2
                | \exists ov; (reach(h, s, o, ov, n - 1) & acc(h, s, ov, o2))))
    };

    // --------------------------------------------------------------------------
    // lemmata
    // --------------------------------------------------------------------------


    reachZero {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2;

        \find(reach(h, s, o, o2, 0))

        \replacewith(o != null & o = o2)

        \heuristics(simplify)
    };

    reachOne {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2;

        \find(reach(h, s, o, o2, 1))

        \replacewith(acc(h, s, o, o2))

        \heuristics(simplify)
    };

    reachNull {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term int n;

        \find(reach(h, s, o, null, n))

        \replacewith(false)

        \heuristics(simplify)
    };

    reachNull2 {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o2;
        \schemaVar \term int n;

        \find(reach(h, s, null, o2, n))

        \replacewith(false)

        \heuristics(simplify)
    };

    reachAddOne {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2;
        \schemaVar \term int n;
        \schemaVar \variables Object ov;

        \find(reach(h, s, o, o2, 1 + n))
        \varcond(
            \notFreeIn(ov, h),
            \notFreeIn(ov, s),
            \notFreeIn(ov, o),
            \notFreeIn(ov, o2),
            \notFreeIn(ov, n))

        \replacewith(n >= -1
            & o != null
            & o2 != null
            & (n = -1 & o = o2
                | \exists ov; (reach(h, s, o, ov, n) & acc(h, s, ov, o2))))

        \heuristics(simplify)
    };

    reachAddOne2 {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2;
        \schemaVar \term int n;
        \schemaVar \variables Object ov;

        \find(reach(h, s, o, o2, n + 1))
        \varcond(
            \notFreeIn(ov, h),
            \notFreeIn(ov, s),
            \notFreeIn(ov, o),
            \notFreeIn(ov, o2),
            \notFreeIn(ov, n))

        \replacewith(n >= -1
            & o != null
            & o2 != null
            & (n = -1 & o = o2
                | \exists ov; (reach(h, s, o, ov, n) & acc(h, s, ov, o2))))

        \heuristics(simplify)
    };

    reachUniquePathSameSteps {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2, o3;
        \schemaVar \term int n;
        \schemaVar \term Field f;

        \assumes(reach(h, allObjects(f), o, o2, n) ==>)
        \find(reach(h, allObjects(f), o, o3, n) ==>)
        \varcond(\different(o2, o3))

        \add(o2 = o3 ==>)

        \heuristics(inReachableStateImplication)
    };

    reachEndOfUniquePath {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2, o3;
        \schemaVar \term int n, n2;
        \schemaVar \term Field f;

        \assumes(reach(h, allObjects(f), o, o2, n),
            alpha::select(h, o2, f) = null,
            alpha::select(h, o3, f) = null ==>)
        \find(reach(h, allObjects(f), o, o3, n2) ==>)
        \varcond(\different(n, n2))

        \add(o2 = o3 & n = n2 ==>)

        \heuristics(inReachableStateImplication)
    };

    reachEndOfUniquePath2 {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2, o3;
        \schemaVar \term int n, n2;
        \schemaVar \term Field f;

        \assumes(reach(h, allObjects(f), o, o2, n),
            alpha::select(h, o2, f) = null ==>)
        \find(reach(h, allObjects(f), o, o3, n2) ==>)
        \varcond(\different(o, o2), \different(n, n2))

        \add(n2 < n | (o2 = o3 & n = n2) ==>)

        \heuristics(inReachableStateImplication)
    };

    reachDependenciesStoreSimple {
        \schemaVar \term Heap h;
        \schemaVar \term Field f, f2;
        \schemaVar \term any x;
        \schemaVar \term Object o, o2, o3;
        \schemaVar \term int n;

        \find(reach(store(h, o3, f2, x), allObjects(f), o, o2, n))
        \varcond(\metaDisjoint(f, f2))

        \replacewith(reach(h, allObjects(f), o, o2, n))

        \heuristics(simplify)
    };

    reachDependenciesStoreSimpleEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term Field f, f2;
        \schemaVar \term any x;
        \schemaVar \term Object o, o2, o3;
        \schemaVar \term int n;

        \assumes(store(h, o3, f2, x) = h2 ==>)
        \find(reach(h2, allObjects(f), o, o2, n))
        \varcond(\metaDisjoint(f, f2))

        \replacewith(reach(h, allObjects(f), o, o2, n))

        \heuristics(simplify)
    };

    reachDoesNotDependOnCreatedness {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2, o3;
        \schemaVar \term int n;
        \find(reach(create(h, o3), s, o, o2, n))

        \replacewith(reach(h, s, o, o2, n))

        \heuristics(simplify)
    };

    reachDependenciesStore {
        \schemaVar \term Heap h;
        \schemaVar \term Field f;
        \schemaVar \term any x;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2, o3;
        \schemaVar \term int n;
        \schemaVar \variables int nv;

        \find(reach(store(h, o3, f, x), s, o, o2, n))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(nv, h),
            \notFreeIn(nv, o3),
            \notFreeIn(nv, f),
            \notFreeIn(nv, x),
            \notFreeIn(nv, s),
            \notFreeIn(nv, o),
            \notFreeIn(nv, o2),
            \notFreeIn(nv, n))

        "Dependencies changed":
            \add( ==> !(\exists nv; (nv < n & reach(h, s, o, o3, nv)) & elementOf(o3, f, s)));

        "Dependencies unchanged":
            \replacewith(reach(h, s, o, o2, n))
            \add(!(\exists nv; (nv < n & reach(h, s, o, o3, nv)) & elementOf(o3, f, s)) ==>)
    };

    reachDependenciesStoreEQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term Field f;
        \schemaVar \term any x;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2, o3;
        \schemaVar \term int n;
        \schemaVar \variables int nv;

        \assumes(store(h, o3, f, x) = h2 ==>)
        \find(reach(h2, s, o, o2, n))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(nv, h),
            \notFreeIn(nv, o3),
            \notFreeIn(nv, f),
            \notFreeIn(nv, x),
            \notFreeIn(nv, s),
            \notFreeIn(nv, o),
            \notFreeIn(nv, o2),
            \notFreeIn(nv, n))

        "Dependencies changed":
            \add( ==> !(\exists nv; (nv < n & reach(h, s, o, o3, nv)) & elementOf(o3, f, s)));

        "Dependencies unchanged":
            \replacewith(reach(h, s, o, o2, n))
            \add(!(\exists nv; (nv < n & reach(h, s, o, o3, nv)) & elementOf(o3, f, s)) ==>)
    };

    reachDependenciesAnon {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o, o2;
        \schemaVar \term int n;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;
        \schemaVar \variables int nv;

        \find(reach(anon(h, s2, h2), s, o, o2, n))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(ov, h),
            \notFreeIn(ov, s2),
            \notFreeIn(ov, h2),
            \notFreeIn(ov, s),
            \notFreeIn(ov, o),
            \notFreeIn(ov, o2),
            \notFreeIn(ov, n),
            \notFreeIn(fv, h),
            \notFreeIn(fv, s2),
            \notFreeIn(fv, h2),
            \notFreeIn(fv, s),
            \notFreeIn(fv, o),
            \notFreeIn(fv, o2),
            \notFreeIn(fv, n),
            \notFreeIn(nv, h),
            \notFreeIn(nv, s2),
            \notFreeIn(nv, h2),
            \notFreeIn(nv, s),
            \notFreeIn(nv, o),
            \notFreeIn(nv, o2),
            \notFreeIn(nv, n))

        "Dependencies changed":
            \add( ==> \forall ov; \forall fv; !(elementOf(ov, fv, s2) & \exists nv; (nv < n & reach(h, s, o, ov, nv)) & elementOf(ov, fv, s)));

        "Dependencies unchanged":
            \replacewith(reach(h, s, o, o2, n))
            \add(\forall ov; \forall fv; !(elementOf(ov, fv, s2) & \exists nv; (nv < n & reach(h, s, o, ov, nv)) & elementOf(ov, fv, s)) ==>)
    };

    reachDependenciesAnonCoarse {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o, o2;
        \schemaVar \term int n;
        \schemaVar \variables Object ov;
        \schemaVar \variables Field fv;
        \schemaVar \variables int nv;

        \find(reach(anon(h, s2, h2), s, o, o2, n))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(ov, h),
            \notFreeIn(ov, s2),
            \notFreeIn(ov, h2),
            \notFreeIn(ov, s),
            \notFreeIn(ov, o),
            \notFreeIn(ov, o2),
            \notFreeIn(ov, n),
            \notFreeIn(fv, h),
            \notFreeIn(fv, s2),
            \notFreeIn(fv, h2),
            \notFreeIn(fv, s),
            \notFreeIn(fv, o),
            \notFreeIn(fv, o2),
            \notFreeIn(fv, n),
            \notFreeIn(nv, h),
            \notFreeIn(nv, s2),
            \notFreeIn(nv, h2),
            \notFreeIn(nv, s),
            \notFreeIn(nv, o),
            \notFreeIn(nv, o2),
            \notFreeIn(nv, n))

        "Dependencies changed":
            \add( ==> \forall ov; \forall fv; !(elementOf(ov, fv, s2) & \exists nv; (reach(h, s, o, ov, nv)) & elementOf(ov, fv, s)));

        "Dependencies unchanged":
            \replacewith(reach(h, s, o, o2, n))
            \add(\forall ov; \forall fv; !(elementOf(ov, fv, s2) & \exists nv; (reach(h, s, o, ov, nv)) & elementOf(ov, fv, s)) ==>)
    };

    only_created_objects_are_reachable {
        \schemaVar \term Heap h;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2;
        \schemaVar \term int n;

        \assumes(wellFormed(h) ==> o = null)
        \find(reach(h, s, o, o2, n) ==>)
        \add(!boolean::select(h, o, java.lang.Object::<created>) = TRUE
            | boolean::select(h, o2, java.lang.Object::<created>) = TRUE ==>)
        \heuristics(inReachableStateImplication)
    };

    reach_does_not_depend_on_fresh_locs {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2;
        \schemaVar \term int n;

        \assumes( ==> o = null)
        \find(reach(anon(h, empty, h2), s, o, o2, n))

        \replacewith(reach(h, s, o, o2, n));
        \add( ==> wellFormed(h) & boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify)
    };

    reach_does_not_depend_on_fresh_locs_EQ {
        \schemaVar \term Heap h, h2;
        \schemaVar \term LocSet s;
        \schemaVar \term Object o, o2;
        \schemaVar \term int n;
        \schemaVar \term Heap EQ;

        \assumes(anon(h, empty, h2) = EQ ==> o = null)
        \find(reach(EQ, s, o, o2, n))

        \replacewith(reach(h, s, o, o2, n));
        \add( ==> wellFormed(h) & boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules(Strings:on) {

    equalRegEx {
        \schemaVar \term RegEx rexp1, rexp2;
        \schemaVar \variables Seq string;
        \find(rexp1 = rexp2)
        \varcond(\notFreeIn(string, rexp1, rexp2))
        \replacewith(\forall string; (match(rexp1, string) <-> match(rexp2, string)))
    };

    // repeat

    repeatAxiom {
        \schemaVar \term RegEx rexp;
        \schemaVar \term Seq string;
        \schemaVar \term int nTimes;
        \schemaVar \variables int endIdx;

        \find(match(repeat(rexp, nTimes), string))
        \varcond(\notFreeIn(endIdx, rexp, nTimes, string))
        \replacewith(\if(nTimes < 0)
                \then(
                    false
                ) \else(
                    \if(nTimes = 0)
                        \then(
                            string = empty
                        ) \else(
                            \exists endIdx; (
                                endIdx >= 0 &
                                endIdx <= seqLen(string) &
                                match(rexp, seqSub(string, 0, endIdx)) &
                                match(repeat(rexp, nTimes - 1), seqSub(string, endIdx, seqLen(string)))
                            )
                        )
                )
        )
    };

    // optional

    optAxiom {
        \schemaVar \term RegEx rexp;
        \schemaVar \term Seq string;

        \find(match(opt(rexp), string))
        \replacewith(match(repeat(rexp, 0), string) | match(rexp, string))
        \heuristics(simplify)
    };

    // alternative
    altAxiom {
        \schemaVar \term RegEx rexp1, rexp2;
        \schemaVar \term Seq string;

        \find(match(alt(rexp1, rexp2), string))
        \replacewith(match(rexp1, string) | match(rexp2, string))
        \heuristics(simplify)
    };

    // regExConcat
    regExConcatAxiom {
        \schemaVar \term RegEx rexp1, rexp2;
        \schemaVar \term Seq string;
        \schemaVar \variables int endIdx;

        \find(match(regExConcat(rexp1, rexp2), string))
        \varcond(\notFreeIn(endIdx, rexp1, rexp2, string))
        \replacewith(
            \exists endIdx; (
                endIdx >= 0 &
                endIdx <= seqLen(string) &
                match(rexp1, seqSub(string, 0, endIdx)) &
                match(rexp2, seqSub(string, endIdx, seqLen(string)))
            )
        )
        \heuristics(simplify)
    };

    // regEx
    regExAxiom {
        \schemaVar \term Seq stringAsPattern, string;

        \find(match(regEx(stringAsPattern), string))
        \replacewith(string = stringAsPattern)
        \heuristics(concrete)
    };

    // star

    repeatStarAxiom {
        \schemaVar \term RegEx rexp;
        \schemaVar \term Seq string;
        \schemaVar \variables int nTimes;

        \find(match(repeatStar(rexp), string))
        \varcond(\notFreeIn(nTimes, rexp, string))
        \replacewith(\exists nTimes; (nTimes >= 0 & match(repeat(rexp, nTimes), string)))
        \heuristics(simplify)
    };

    // plus
    repeatPlusAxiom {
        \schemaVar \term RegEx rexp;
        \schemaVar \term Seq string;
        \schemaVar \variables int nTimes;

        \find(match(repeatPlus(rexp), string))
        \varcond(\notFreeIn(nTimes, rexp, string))
        \replacewith(\exists nTimes; (nTimes >= 1 & match(repeat(rexp, nTimes), string)))
        \heuristics(simplify)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\sorts {
    RegEx;
}

\functions {
    RegEx regEx(Seq);
    RegEx opt(RegEx);
    RegEx alt(RegEx, RegEx);
    RegEx regExConcat(RegEx, RegEx);

    RegEx repeat(RegEx, int);
    RegEx repeatStar(RegEx);
    RegEx repeatPlus(RegEx);
}

\predicates {
    match(RegEx, Seq);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules(Strings:on) {

    repeatRepeatContraction {
        \schemaVar \term RegEx rexp;
        \schemaVar \term int nTimes1, nTimes2;

        \find(repeat(repeat(rexp, nTimes1), nTimes2))
        \replacewith(
            \if(nTimes1 >= 0 & nTimes2 >= 0)
                \then(repeat(rexp, nTimes1 * nTimes2))
                \else(repeat(repeat(rexp, nTimes1), nTimes2))
        )
        \heuristics(concrete)
    };

    concatRepeatContraction1 {
        \schemaVar \term RegEx rexp;
        \schemaVar \term int nTimes1, nTimes2;

        \find(regExConcat(repeat(rexp, nTimes1), repeat(rexp, nTimes2)))
        \replacewith(
            \if(nTimes1 >= 0 & nTimes2 >= 0)
                \then(repeat(rexp, nTimes1 + nTimes2))
                \else(regExConcat(repeat(rexp, nTimes1), repeat(rexp, nTimes2)))
        )
        \heuristics(concrete)
    };

    concatRepeatContraction2 {
        \schemaVar \term RegEx rexp;
        \schemaVar \term int nTimes;

        \find(regExConcat(repeat(rexp, nTimes), rexp))
        \replacewith(
            \if(nTimes >= 0)
                \then(repeat(rexp, nTimes + 1))
                \else(regExConcat(repeat(rexp, nTimes), rexp))
        )
        \heuristics(concrete)
    };

    concatRepeatContraction2Sym {
        \schemaVar \term RegEx rexp;
        \schemaVar \term int nTimes;

        \find(regExConcat(rexp, repeat(rexp, nTimes)))
        \replacewith(
            \if(nTimes >= 0)
                \then(repeat(rexp, nTimes + 1))
                \else(regExConcat(rexp, repeat(rexp, nTimes)))
        )
        \heuristics(concrete)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules(Strings:on) {

    repeatMatchEmpty {
        \schemaVar \term RegEx rexp;
        \schemaVar \term int nTimes1;

        \find(match(repeat(rexp, nTimes1), seqEmpty))
        \replacewith(
            nTimes1 = 0 | (nTimes1 > 0 & match(rexp, seqEmpty))
        )
        \heuristics(simplify)
    };

    repeatZero {
        \schemaVar \term RegEx rexp;
        \schemaVar \term Seq string;

        \find(repeat(rexp, 0))
        \replacewith(regEx(seqEmpty))
        \heuristics(concrete)
    };

    repeatOnce {
        \schemaVar \term RegEx rexp;

        \find(repeat(rexp, 1))
        \replacewith(rexp)
        \heuristics(concrete)
    };

    // OPTIONAL RegEx Constructor
    optEmpty {
        \schemaVar \term RegEx rexp;

        \find(match(opt(rexp), seqEmpty))
        \replacewith(true)
        \heuristics(concrete)
    };

    // reduce

    regExConcatAltLeft {
        \schemaVar \term RegEx rexp1, rexp2, rexp3;
        \schemaVar \term Seq string;

        \find(match(regExConcat(alt(rexp1, rexp2), rexp3), string))
        \replacewith(
            match(regExConcat(rexp1, rexp3), string)
            |
            match(regExConcat(rexp2, rexp3), string)
        )
        \heuristics(concrete)
    };

    regExConcatAltRight {
        \schemaVar \term RegEx rexp1, rexp2, rexp3;
        \schemaVar \term Seq string;

        \find(match(regExConcat(rexp1, alt(rexp2, rexp3)), string))
        \replacewith(
            match(regExConcat(rexp1, rexp2), string)
            |
            match(regExConcat(rexp1, rexp3), string)
        )
        \heuristics(concrete)
    };

    regExConcatOptLeft {
        \schemaVar \term RegEx rexp1, rexp2;
        \schemaVar \term Seq string;

        \find(match(regExConcat(opt(rexp1), rexp2), string))
        \replacewith(
            match(rexp2, string)
            |
            match(regExConcat(rexp1, rexp2), string)
        )
        \heuristics(concrete)
    };

    regExConcatOptRight {
        \schemaVar \term RegEx rexp1, rexp2;
        \schemaVar \term Seq string;

        \find(match(regExConcat(rexp1, opt(rexp2)), string))
        \replacewith(
            match(rexp1, string)
            |
            match(regExConcat(rexp1, rexp2), string)
        )
        \heuristics(concrete)
    };

    regExConcatConcreteStringLeft {
        \schemaVar \term RegEx rexp;
        \schemaVar \term Seq string, pattern;

        \find(match(regExConcat(regEx(pattern), rexp), string))
        \replacewith(
            seqLen(pattern) <= seqLen(string) &
            match(regEx(pattern), seqSub(string, 0, seqLen(pattern))) &
            match(rexp, seqSub(string, seqLen(pattern), seqLen(string)))
        )
        \heuristics(concrete)
    };

    regExConcatConcreteStringRight {
        \schemaVar \term RegEx rexp;
        \schemaVar \term Seq string, pattern;

        \find(match(regExConcat(rexp, regEx(pattern)), string))
        \replacewith(
            seqLen(pattern) <= seqLen(string) &
            match(rexp, seqSub(string, 0, seqLen(string) - seqLen(pattern))) &
            match(regEx(pattern), seqSub(string, seqLen(string) - seqLen(pattern), seqLen(string)))
        )
        \heuristics(concrete)
    };

    regExConcatRepeatLeft {
        \schemaVar \term RegEx rexp1, rexp2;
        \schemaVar \term Seq string;
        \schemaVar \variables Seq string1, string2;
        \schemaVar \term int nTimes;

        \find(match(regExConcat(repeat(rexp1, nTimes), rexp2), string))
        \varcond(\notFreeIn(string1, string, rexp1, rexp2, nTimes), \notFreeIn(string2, string, rexp1, rexp2, nTimes))
        \replacewith(
            \if(nTimes = 0)
                \then(match(rexp2, string))
                \else(
                    \if(nTimes < 0)
                        \then(false)
                        \else(
                            \exists string1; \exists string2; (
                                match(repeat(rexp1, nTimes), string1) &
                                match(rexp2, string2) &
                                string = seqConcat(string1, string2))
                        )
                )
        )
        \heuristics(simplify)
    };

    regExConcatRepeatRight {
        \schemaVar \term RegEx rexp1, rexp2;
        \schemaVar \term Seq string;
        \schemaVar \variables Seq string1, string2;
        \schemaVar \term int nTimes;

        \find(match(regExConcat(rexp1, repeat(rexp2, nTimes)), string))
        \varcond(\notFreeIn(string1, string, rexp1, rexp2, nTimes), \notFreeIn(string2, string, rexp1, rexp2, nTimes))
        \replacewith(
            \if(nTimes = 0)
                \then(match(rexp1, string))
                \else(
                    \if(nTimes < 0)
                        \then(false)
                        \else(
                            \exists string1; \exists string2; (
                                match(rexp1, string1) &
                                match(repeat(rexp2, nTimes), string2) &
                                string = seqConcat(string1, string2)
                            )
                        )
                )
        )
        \heuristics(simplify)
    };

    concatRepeatContraction3 {
        \schemaVar \term RegEx rexp;
        \schemaVar \term int nTimes;

        \find(regExConcat(repeat(rexp, nTimes), regEx(seqEmpty)))
        \replacewith(
            repeat(rexp, nTimes)
        )
        \heuristics(concrete)
    };

    concatRepeatContraction3Sym {
        \schemaVar \term RegEx rexp;
        \schemaVar \term int nTimes;

        \find(regExConcat(regEx(seqEmpty), repeat(rexp, nTimes)))
        \replacewith(
            repeat(rexp, nTimes)
        )
        \heuristics(concrete)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\include regExHeader;
\include regExAxioms;
\include regExLemmaProven;
// \include "regExLemma.key";
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/*
 * This file contains the known heuristics (rule sets) of KeY.
 */

// ***************************************
// Places in KeY with hard-coded rule sets
// (check there when changing rule sets):
// ***************************************
// 1) NodeInfo#symbolicExecNames
// 2) OneStepSimplifier#ruleSets
// 3) macro implementations (e.g. IntegerSimplificationMacro, FinishSymbolicExecutionMacro, ...)

\heuristicsDecl {
    // These rules are not permitted during symbolic execution
    delayedExpansion;

    // These rules are placed under "More rules" in the dropdown
    // Furthermore, they behave like delayedExpansion rules when using macros
    notHumanReadable;

    modal_tautology;
    simplify_prog;

    // updates
    update_elim;
    update_apply;
    update_join;
    update_apply_on_update;

    // the rule set split if is currently also used to mark program rule applications which
    // would usually be considered to split, but don't because usage of
    // the "if-then-else" operator in logic or by encoding it as
    //   (cond-> <a>phi) & (!cond -> <b>phi)
    split_if;

    split_cond;
    simplify;
    simplify_enlarging;
    simplify_ENLARGING; // Simplification rules which make formulas much bigger
    // and therefore should be used less frequently than
    // the rules from simplify_enlarging set.
    simplify_prog_subset;
    simplify_expression;
    simplify_autoname;
    method_expand;
    query_axiom;
    simplify_instanceof_static;
    evaluate_instanceof;
    instanceof_to_exists;
    loop_expand;
    loop_scope_inv_taclet;
    loop_scope_expand;

    javaIntegerSemantics;
    executeIntegerAssignment;

    javaFloatSemantics;
    executeFloatAssignment;

    triggered;

    comprehension_split;
    comprehensions;
    comprehensions_high_costs;
    comprehensions_low_costs;

    std_taclets;
    closure;
    replace_known_left;
    replace_known_right;
    confluence_restricted;
    delta;
    beta;
    gamma;
    gamma_destructive;
    test_gen;
    test_gen_empty_modality_hide;
    test_gen_quan;
    test_gen_quan_num;
    order_terms;
    apply_equations;
    insert_eq_nonrigid;
    simplify_literals;
    eval_literals;
    int_arithmetic;
    charLiteral_to_intLiteral;
    delta;
    pull_out_quantifier;
    simplify_boolean;
    boolean_cases;
    alpha;
    concrete;
    try_apply_subst;
    type_hierarchy_def;

    userTaclets1;
    userTaclets2;
    userTaclets3;

    cut;
    cut_direct;

    // Set obsolete applies to rules which use is discouraged
    // in both automated and interactive proofs.
    obsolete;

    // sequents
    defOpsSeqEquality;

    // strings
    stringNormalisationReduce;
    integerToString;

    defOpsConcat;
    stringsSimplify;
    defOpsReplaceInline;
    defOpsReplace;
    defOpsStartsEndsWith;
    stringsReduceSubstring;
    stringsConcatNotBothLiterals;
    stringsReduceConcat;
    stringsExpandDefNormalOp;
    stringsContainsDefInline;
    stringsMoveReplaceInside;
    stringsReduceOrMoveOutsideConcat;
    stringsIntroduceNewSym;

    // primary categories for Buchberger
    polySimp_expand;
    polySimp_directEquations;
    polySimp_saturate;
    polySimp_pullOutGcd;
    polySimp_leftNonUnit;

    // secondary categories for Buchberger
    polySimp_elimSubNeg;
    polySimp_dist;
    polySimp_addAssoc;
    polySimp_mulAssoc;
    polySimp_addOrder;
    polySimp_mulOrder;
    polySimp_mulOne;
    polySimp_balance;
    polySimp_elimOneLeft;
    polySimp_elimOneRight;
    polySimp_normalise;
    polySimp_applyEq;
    polySimp_applyEqRigid;
    polySimp_homo;
    polySimp_pullOutFactor;
    polySimp_critPair;
    polySimp_newSym;
    polySimp_applyEqPseudo;

    // the symbols introduced by rules of the following
    // category will be considered as very small by the
    // term ordering
    polySimp_newSmallSym;

    polyDivision;

    // primary categories for Omega
    inEqSimp_expand;
    inEqSimp_directInEquations;
    inEqSimp_saturate;
    inEqSimp_propagation;
    inEqSimp_pullOutGcd;
    inEqSimp_nonLin;
    inEqSimp_special_nonLin;
    inEqSimp_signCases;
    inEqSimp_forNormalisation;

    // secondary categories for Omega
    inEqSimp_moveLeft;
    inEqSimp_makeNonStrict;
    inEqSimp_homo;
    inEqSimp_commute;
    inEqSimp_balance;
    inEqSimp_antiSymm;
    inEqSimp_exactShadow;
    inEqSimp_normalise;
    inEqSimp_subsumption;
    inEqSimp_contradInEqs;
    inEqSimp_contradEqs;
    inEqSimp_strengthen;
    inEqSimp_nonLin_multiply;
    inEqSimp_nonLin_divide;
    inEqSimp_nonLin_pos;
    inEqSimp_nonLin_neg;
    inEqSimp_nonNegSquares;
    inEqSimp_split_eq;
    inEqSimp_pullOutGcd_antec;
    inEqSimp_pullOutGcd_leq;
    inEqSimp_pullOutGcd_geq;
    inEqSimp_and_contradInEqs;
    inEqSimp_andOr_subsumption;
    inEqSimp_and_subsumptionEq;
    inEqSimp_or_tautInEqs;
    inEqSimp_or_weaken;
    inEqSimp_or_antiSymm;

    // primary categories for defined operations
    defOps_div;
    defOps_jdiv;
    defOps_jdiv_inline;
    defOps_mod;
    defOps_expandRanges;
    defOps_expandModulo;
    defOps_expandJNumericOp;
    defOps_modHomoEq;

    // secondary categories for defined operations
    defOps_divModPullOut;

    // used to solve several issues with system invariants
    system_invariant;

    // used to avoid infinite loops when removing casts
    cast_deletion;

    // rules for adding assertions like x.length >= 0,
    // o.a.<created> = TRUE, etc. that can be derived
    // from wellFormed(heap)
    inReachableStateImplication;

    limitObserver;
    classAxiom;
    partialInvAxiom;

    boxDiamondConv;

    // normalisation of formulas that cannot be analysed directly
    // (e.g., quantified formulas)

    // primary categories
    moveQuantToLeft;
    negationNormalForm;
    conjNormalForm;
    apply_equations_andOr;
    elimQuantifier;
    distrQuantifier;
    pullOutQuantifierAll;
    pullOutQuantifierEx;
    swapQuantifiers;

    // secondary categories
    cnf_andAssoc;
    cnf_orAssoc;
    cnf_andComm;
    cnf_orComm;
    cnf_dist;
    cnf_expandIfThenElse;
    elimQuantifierWithCast;
    pullOutQuantifierUnifying;
    cnf_setComm;

    // LocSets
    setEqualityBlastingRight;

    // heap simplification
    pull_out_select;
    simplify_select;
    apply_select_eq;
    apply_auxiliary_eq;
    hide_auxiliary_eq;
    hide_auxiliary_eq_const;
    simplify_heap_high_costs;

    // chrisg: pattern-based automation rules
    auto_induction;
    auto_induction_lemma;
    induction_var;

    // information flow
    information_flow_contract_appl;

    // for equality versions of rules
    no_self_application;
    find_term_not_in_assumes;

    // semantics blasting
    semantics_blasting;

    // automation of loop invariants
    loopInvariant;

    // deletion of merge point statements
    merge_point;

    // included for integer simplification macro
    simplify_int;

    // check for non duplicate apps using eq
    nonDuplicateAppCheckEq;

    // double
    executeDoubleAssignment;
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains only the CORE RULES for the sequence datatype.
// Find the DECLARATIONS in file seq.key and
// definitional extensions in file seqRules.key
// Definitions and derived taclets for permutations may be found
// in file seqPerm.key


\rules(sequences:on) {

    // ===============================================================
    //  Core axioms
    //  (4 in total)
    // ===============================================================

    // --------------------------------------------------------------------
    // Core axiom for length of sequences
    // --------------------------------------------------------------------

    lenNonNegative {
        \schemaVar \term Seq seq;

        \find(seqLen(seq))
        \sameUpdateLevel

        \add(0 <= seqLen(seq) ==>)

        \heuristics(inReachableStateImplication)
    };

    // --------------------------------------------------------------------
    // Core axiom for equality of sequences
    // --------------------------------------------------------------------

    equalityToSeqGetAndSeqLen {
        \schemaVar \term Seq left, right;
        \schemaVar \variables int iv;

        \find(left = right)
        \varcond(\notFreeIn(iv, left, right))

        \replacewith(seqLen(left) = seqLen(right)
            & \forall iv; (0 <= iv & iv < seqLen(left)
                -> any::seqGet(left, iv) = any::seqGet(right, iv)))
        \heuristics(defOpsSeqEquality)
    };

    // --------------------------------------------------------------------
    // Core axiom for sequence definition
    // --------------------------------------------------------------------

    getOfSeqDef {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(alpha::seqGet(seqDef{uSub;}(from, to, t), idx))
        \varcond(\notFreeIn(uSub, from),
            \notFreeIn(uSub, to))
        \replacewith(\if(0 <= idx & idx < (to - from))
                \then((alpha){\subst uSub; (idx + from)}t)
                \else((alpha)seqGetOutside))

        \heuristics(simplify)
    };

    lenOfSeqDef {
        \schemaVar \term int from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqLen(seqDef{uSub;}(from, to, t)))

        \replacewith(\if(from < to) \then((to - from)) \else(0))

        \heuristics(simplify)
    };

    // --------------------------------------------------------------------
    // The core taclets for Seq end here.
    // Consistency of the core theory has to be guaranteed by external means,
    //  e.g. by presenting a model for it.
    // --------------------------------------------------------------------
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules(sequences:on, moreSeqRules:on) {

    // --------------------------------------------------------------------------
    // equality handling (derived rules)
    // --------------------------------------------------------------------------

    eqSeqEmpty {
        \schemaVar \term Seq s;

        \find(s = seqEmpty)
        \replacewith(seqLen(s) = 0)
        \heuristics(simplify)
    };

    eqSeqSingleton {
        \schemaVar \term Seq s;
        \schemaVar \term any x;

        \find(s = seqSingleton(x))
        \replacewith(seqLen(s) = 1 & any::seqGet(s, 0) = x)
        \heuristics(simplify)
    };

    eqSeqSingleton2 {
        \schemaVar \term Seq s, s2;
        \schemaVar \term any x;

        \assumes(seqSingleton(x) = s2 ==>)
        \find(s = s2)
        \replacewith(seqLen(s) = 1 & any::seqGet(s, 0) = x)
        \heuristics(simplify)
    };

    eqSeqConcat {
        \schemaVar \term Seq s, s1, s2;

        \find(s = seqConcat(s1, s2))

        \replacewith(
            seqLen(s) = seqLen(s1) + seqLen(s2)
            & seqSub(s, 0, seqLen(s1)) = s1
            & seqSub(s, seqLen(s1), seqLen(s)) = s2
        )
        \heuristics(simplify_ENLARGING)
    };

    eqSeqConcatEQ {
        \schemaVar \term Seq s, s1, s2, EQ;

        \assumes(seqConcat(s1, s2) = EQ ==>)
        \find(s = EQ)

        \replacewith(
            seqLen(s) = seqLen(s1) + seqLen(s2)
            & seqSub(s, 0, seqLen(s1)) = s1
            & seqSub(s, seqLen(s1), seqLen(s)) = s2
        )
        \heuristics(no_self_application, simplify_ENLARGING)
    };

    eqSeqConcat2 {
        \schemaVar \term Seq s, s1, s2;

        \find(seqConcat(s, s1) = seqConcat(s, s2))

        \replacewith(s1 = s2)
        \heuristics(simplify)
    };

    eqSeqConcat2EQ {
        \schemaVar \term Seq s, s1, s2, EQ;

        \assumes(seqConcat(s, s2) = EQ ==>)
        \find(seqConcat(s, s1) = EQ)

        \replacewith(s1 = s2)
        \heuristics(no_self_application, simplify)
    };

    eqSeqConcat3 {
        \schemaVar \term Seq s, s1, s2;

        \find(seqConcat(s1, s) = seqConcat(s2, s))

        \replacewith(s1 = s2)
        \heuristics(simplify)
    };

    eqSeqConcat3EQ {
        \schemaVar \term Seq s, s1, s2, EQ;

        \assumes(seqConcat(s2, s) = EQ ==>)
        \find(seqConcat(s1, s) = EQ)

        \replacewith(s1 = s2)
        \heuristics(no_self_application, simplify)
    };

    eqSeqConcat4 {
        \schemaVar \term Seq s1, s2;
        \schemaVar \term any x, y;

        \find(seqConcat(s1, seqSingleton(x)) = seqConcat(s2, seqSingleton(y)))

        \replacewith(s1 = s2 & x = y)
        \heuristics(simplify)
    };

    eqSeqConcat4EQ {
        \schemaVar \term Seq s1, s2, EQ;
        \schemaVar \term any x, y;

        \assumes(seqConcat(s2, seqSingleton(x)) = EQ ==>)
        \find(seqConcat(s1, seqSingleton(y)) = EQ)

        \replacewith(s1 = s2 & x = y)
        \heuristics(no_self_application, simplify)
    };

    eqSeqConcat5 {
        \schemaVar \term Seq s1, s2;
        \schemaVar \term any x, y;

        \find(seqConcat(seqSingleton(x), s1) = seqConcat(seqSingleton(y), s2))

        \replacewith(x = y & s1 = s2)
        \heuristics(simplify)
    };

    eqSeqConcat5EQ {
        \schemaVar \term Seq s1, s2, EQ;
        \schemaVar \term any x, y;

        \assumes(seqConcat(seqSingleton(x), s2) = EQ ==>)
        \find(seqConcat(seqSingleton(y), s1) = EQ)

        \replacewith(x = y & s1 = s2)
        \heuristics(no_self_application, simplify)
    };

    eqSeqReverse {
        \schemaVar \term Seq s, s2;
        \schemaVar \variables int iv;

        \find(s = seqReverse(s2))
        \varcond(\notFreeIn(iv, s), \notFreeIn(iv, s2))

        \replacewith(
            seqLen(s) = seqLen(seqReverse(s2))
            & \forall iv; (0 <= iv & iv < seqLen(s)
                -> any::seqGet(s, iv) = any::seqGet(seqReverse(s2), iv)
            )
        )
        \heuristics(simplify_enlarging)
    };

    eqSeqReverse2 {
        \schemaVar \term Seq s, s2, t;
        \schemaVar \variables int iv;

        \assumes(seqReverse(s2) = t ==>)
        \find(s = t)
        \varcond(\notFreeIn(iv, s), \notFreeIn(iv, s2), \notFreeIn(iv, t))

        \replacewith(
            seqLen(s) = seqLen(seqReverse(s2))
            & \forall iv; (0 <= iv & iv < seqLen(s)
                -> any::seqGet(s, iv) = any::seqGet(seqReverse(s2), iv)
            )
        )
        \heuristics(simplify_enlarging, no_self_application)
    };

    eqSeqDef {
        \schemaVar \term Seq s;
        \schemaVar \term int l, u;
        \schemaVar \term any a;
        \schemaVar \variables int i, iv;

        \find(s = seqDef{i;}(l, u, a))
        \varcond(
            \notFreeIn(iv, s),
            \notFreeIn(iv, l),
            \notFreeIn(iv, u),
            \notFreeIn(iv, a))

        \replacewith(
            seqLen(s) = seqLen(seqDef{i;}(l, u, a))
            & \forall iv; (0 <= iv & iv < seqLen(s)
                -> any::seqGet(s, iv) = any::seqGet(seqDef{i;}(l, u, a), iv)
            )
        )
        \heuristics(simplify_enlarging)
    };

    eqSeqDef2 {
        \schemaVar \term Seq s, t;
        \schemaVar \term int l, u;
        \schemaVar \term any a;
        \schemaVar \variables int i, iv;

        \assumes(seqDef{i;}(l, u, a) = t ==>)
        \find(s = t)
        \varcond(
            \notFreeIn(iv, s),
            \notFreeIn(iv, l),
            \notFreeIn(iv, u),
            \notFreeIn(iv, a),
            \notFreeIn(iv, t))

        \replacewith(
            seqLen(s) = seqLen(seqDef{i;}(l, u, a))
            & \forall iv; (0 <= iv & iv < seqLen(s)
                -> any::seqGet(s, iv) = any::seqGet(seqDef{i;}(l, u, a), iv)
            )
        )
        \heuristics(simplify_enlarging)
    };

    \lemma
    eqSameSeq {
        \schemaVar \term Seq seq;
        \schemaVar \term int from, to;
        \schemaVar \variables int iv;

        \find(seqSub(seq, from, to) = seq)
        \sameUpdateLevel
        \varcond(\notFreeIn(iv, from, seq))

        \replacewith((from = 0 & seqLen(seq) = to)
            | (to <= from & seqLen(seq) = 0)
            | (seqLen(seq) = to - from
                & \forall iv; (
                    0 <= iv & iv < seqLen(seq)
                    -> any::seqGet(seq, iv) = any::seqGet(seq, iv + from)))
        )
        \heuristics(simplify)
    };

}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains only the DECLARATIONS.
// DEFINITIONS for the core theory of the sequence datatype are contained in
// seqCoreRules.key, further RULES in the files seqRules.key and seqPerm.key.
// The files seqRules.key and seqPerm.key also contain derivations from
// definitional rules, where applicable.

\sorts {
    Seq;
}

\predicates {
    seqPerm(Seq, Seq);
    seqNPerm(Seq);
}

\functions {
    // getters
    alpha alpha::seqGet(Seq, int);
    int seqLen(Seq);
    int seqIndexOf(Seq, any);
    any seqGetOutside;

    // constructors
    Seq seqEmpty;
    Seq seqSingleton(any);
    Seq seqConcat(Seq, Seq);
    Seq seqSub(Seq, int, int);
    Seq seqReverse(Seq);
    Seq seqUpd(Seq, int, any);
    Seq seqDef {false, false, true}(int, int, any);

    Seq seqSwap(Seq, int, int);
    Seq seqRemove(Seq, int);
    Seq seqNPermInv(Seq);

    Seq array2seq(Heap, Object);

    // placeholder for values in enhanced for loop
    Seq values;

    // work-a-round to use \seq_def in JML set statements
    Seq seq_def_workaround(Heap, int, int, Object);
    Seq seq_def_workaround2(Heap, int, int, Object, LocSet);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains some advanced and experimental rules
// for permutations in the sequence data type
// author P.H. Schmitt


// Find the DECLARATIONS in file seq.key and
// definitional extensions in file seqRules.key

\rules {

    // taclet schiffl-lemma_1 has been removed
    \lemma
    schiffl_lemma_2 {
        \schemaVar \term Seq s, t;
        \schemaVar \variable Seq r;
        \schemaVar \variable int x, y, iv;

        \find(seqPerm(s, t) ==>)
        \varcond(
            \notFreeIn(iv, s, t),
            \notFreeIn(r, s, t),
            \notFreeIn(x, s, t),
            \notFreeIn(y, s, t))

        \add(\forall x; \forall y; (
                any::seqGet(s, x) = any::seqGet(t, x) &
                any::seqGet(s, y) = any::seqGet(t, y) & 0 <= x & x < seqLen(s) &
                0 <= y & y < seqLen(s)
                -> \exists r; (seqLen(r) = seqLen(s) & seqNPerm(r) &
                    (\forall iv; (0 <= iv & iv < seqLen(s) ->
                            any::seqGet(s, iv) = any::seqGet(t, int::seqGet(r, iv)))) &
                    int::seqGet(r, x) = x & int::seqGet(r, y) = y))
            ==>)
    };

    \lemma
    schiffl_thm_1 {
        \schemaVar \term Seq s, t;
        \schemaVar \term int x, y;
        \schemaVar \term any a, b;
        \schemaVar \variables int idx;

        \find(seqPerm(s, t) ==>)
        \varcond(
            \notFreeIn(idx, x),
            \notFreeIn(idx, y),
            \notFreeIn(idx, a),
            \notFreeIn(idx, b),
            \notFreeIn(idx, s),
            \notFreeIn(idx, t))

        \add(seqPerm(s, t) & any::seqGet(s, x) = any::seqGet(t, x) &
            any::seqGet(s, y) = any::seqGet(t, y) & 0 <= x & x < seqLen(s) &
            0 <= y & y < seqLen(s)
            -> seqPerm(seqDef{idx;}(0, s.length, \if(idx = y) \then(b) \else(\if(idx = x) \then(a) \else(any::seqGet(s, idx))))
                , seqDef{idx;}(0, s.length, \if(idx = y) \then(b) \else(\if(idx = x) \then(a) \else(any::seqGet(t, idx)))))
            ==>)
    };

    //  seqUpd(seqUpd(s,x,a),y,b) =
    //  seqDef{idx;}(0, s.length,
    //  \if(idx=y)\then(b)\else(\if(idx=x)\then(a)
    //  \else(int::seqGet(s, idx))))

    //  seqUpd(seqUpd(t,x,a),y,b) =
    //  seqDef{idx;}(0, s.length,
    //  \if(idx=y)\then(b)\else(\if(idx=x)\then(a)
    //  \else(int::seqGet(t, idx))))


}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains the rule set for permutations in
// the sequence data type
// author P.H. Schmitt


// This file contains RULES for the permutation predicates in
// the sequence datatype.

// Find the DECLARATIONS in file seq.key and
// definitional extensions in file seqRules.key

\rules(sequences:on, moreSeqRules:on) {
    // --------------------------------------------------------------------------
    //  Second Extensions by Definitions
    //  These taclets were not part of the original Seq axiomatization by
    //  B.Weiss
    //  These taclets extend the signature of the core theory by indroducing
    //  the relation symbols
    //            seqPerm(Seq,Seq), seqNPerm(Seq)
    //  and the function symbols
    //           Seq seqSwap(Seq,int,int)
    //           Seq seqRemove(Seq,int)
    //  by direct definitions.
    //  Consistency of the extended theory is thus guaranteed.
    //  (Theorem on  conservative extentions)
    // --------------------------------------------------------------------------

    seqNPermDefReplace {
        \schemaVar \term Seq s1;
        \schemaVar \variables int iv, jv;

        \find(seqNPerm(s1))
        \varcond(\notFreeIn(iv, s1), \notFreeIn(jv, s1))

        \replacewith(
            (\forall iv; (0 <= iv & iv < seqLen(s1) ->
                    \exists jv; (0 <= jv & jv < seqLen(s1) & any::seqGet(s1, jv) = iv))))
    };

    seqNPermDefLeft {
        \schemaVar \term Seq s1;
        \schemaVar \variables int iv, jv;

        \find(seqNPerm(s1) ==>)
        \varcond(\notFreeIn(iv, s1), \notFreeIn(jv, s1))

        \add(
            (\forall iv; (0 <= iv & iv < seqLen(s1) ->
                    \exists jv; (0 <= jv & jv < seqLen(s1) & any::seqGet(s1, jv) = iv))) ==>)
    };

    seqPermDefLeft {
        \schemaVar \term Seq s1, s2, s3;
        \schemaVar \variables int iv;
        \schemaVar \variables Seq s;

        \find(seqPerm(s1, s2) ==>)

        \varcond(\notFreeIn(iv, s1, s2),
            \notFreeIn(s, s1, s2))

        \add(
            seqLen(s1) = seqLen(s2) &
            (\exists s; (seqLen(s) = seqLen(s1) & seqNPerm(s) &

                    (\forall iv; (0 <= iv & iv < seqLen(s) ->
                            any::seqGet(s1, iv) = any::seqGet(s2, int::seqGet(s, iv))))))
            ==>)
    };

    seqPermDef {
        \schemaVar \term Seq s1, s2, s3;
        \schemaVar \variables int iv;
        \schemaVar \variables Seq s;

        \find(seqPerm(s1, s2))

        \varcond(\notFreeIn(iv, s1, s2),
            \notFreeIn(s, s1, s2))

        \replacewith(
            seqLen(s1) = seqLen(s2) &
            (\exists s; (seqLen(s) = seqLen(s1) & seqNPerm(s) &

                    (\forall iv; (0 <= iv & iv < seqLen(s) ->
                            any::seqGet(s1, iv) = any::seqGet(s2, int::seqGet(s, iv))))))
        )
    };

    defOfSeqSwap {
        \schemaVar \term Seq s;
        \schemaVar \term int iv, jv;
        \schemaVar \variables int uSub;

        \find(seqSwap(s, iv, jv))

        \varcond(\notFreeIn(uSub, s),
            \notFreeIn(uSub, iv),
            \notFreeIn(uSub, jv))
        \replacewith(seqDef{uSub;}(0, seqLen(s),
                \if(!(0 <= iv & 0 <= jv & iv < seqLen(s) & jv < seqLen(s)))
                    \then(any::seqGet(s, uSub))
                    \else(\if(uSub = iv)
                            \then(any::seqGet(s, jv))
                            \else(\if(uSub = jv)
                                    \then(any::seqGet(s, iv))
                                    \else(any::seqGet(s, uSub))))))

    };

    defOfSeqRemove {
        \schemaVar \term Seq s;
        \schemaVar \term int iv;
        \schemaVar \variables int uSub;

        \find(seqRemove(s, iv))
        \varcond(\notFreeIn(uSub, s),
            \notFreeIn(uSub, iv))

        \replacewith(
            \if(iv < 0 | seqLen(s) <= iv)
                \then(s)
                \else(seqDef{uSub;}(0, seqLen(s) - 1,
                        \if(uSub < iv)
                            \then(any::seqGet(s, uSub))
                            \else(any::seqGet(s, uSub + 1)))))
    };

    // --------------------------------------------------------------------
    // definition for seqNPermInv
    //
    // --------------------------------------------------------------------

    defOfSeqNPermInv {
        \schemaVar \term Seq s;
        \schemaVar \variables int uSub;

        \find(seqNPermInv(s))
        \varcond(\notFreeIn(uSub, s))

        \replacewith(seqDef{uSub;}(0, seqLen(s), seqIndexOf(s, uSub)))

    };

    // ==================================================================
    //  derived taclets involving the functions seqSwap, seqRemove,
    //  and seqNPermInv
    //
    // ==================================================================


    lenOfNPermInv {
        \schemaVar \term Seq s1;
        \find(seqLen(seqNPermInv(s1)))
        \replacewith(seqLen(s1))

        \heuristics(simplify)
    };

    \lemma
    getAnyOfNPermInv {
        \schemaVar \term Seq s1;
        \schemaVar \term int i3;

        \find(any::seqGet(seqNPermInv(s1), i3))
        \replacewith(int::seqGet(seqNPermInv(s1), i3));
        \add( ==> 0 <= i3 & i3 < seqLen(s1))
        \heuristics(simplify)
    };

    getOfNPermInv {
        \schemaVar \term Seq s1;
        \schemaVar \term int i3;
        \schemaVar \skolemTerm int jsk;

        \find(int::seqGet(seqNPermInv(s1), i3))
        \varcond(\newDependingOn(jsk, i3))
        \replacewith(jsk)
        \add(int::seqGet(s1, jsk) = i3 & 0 <= jsk & jsk < seqLen(s1) ==>);
        \add( ==> 0 <= i3 & i3 < seqLen(s1) & seqNPerm(s1))

        \heuristics(simplify)
    };

    lenOfSwap {
        \schemaVar \term Seq s1;
        \schemaVar \term int iv1, iv2;
        \find(seqLen(seqSwap(s1, iv1, iv2)))
        \replacewith(seqLen(s1))

        \heuristics(simplify)
    };

    getOfSwap {
        \schemaVar \term Object o;
        \schemaVar \term Seq s1;
        \schemaVar \term int iv, jv, idx;
        \schemaVar \term Heap h;

        //  Differs from seqOutsideValue in seqStandard-new-verify.key
        //

        \find(alpha::seqGet(seqSwap(s1, iv, jv), idx))
        \replacewith(\if(!(0 <= iv & 0 <= jv & iv < seqLen(s1) & jv < seqLen(s1)))
                \then(alpha::seqGet(s1, idx))
                \else(\if(idx = iv)
                        \then(alpha::seqGet(s1, jv))
                        \else(\if(idx = jv)
                                \then(alpha::seqGet(s1, iv))
                                \else(alpha::seqGet(s1, idx)))))

        \heuristics(simplify_enlarging)
    };

    lenOfRemove {
        \schemaVar \term Seq s1;
        \schemaVar \term int iv1;

        \find(seqLen(seqRemove(s1, iv1)))
        \replacewith(
            \if(0 <= iv1 & iv1 < seqLen(s1))
                \then(seqLen(s1) - 1)
                \else(seqLen(s1)))

        \heuristics(simplify_enlarging)
    };

    //  Differs from seqOutsideValue in seqStandard-new-verify.key
    //

    getOfRemoveAny {
        \schemaVar \term Seq s1;
        \schemaVar \term int i3, i2;

        \find(alpha::seqGet(seqRemove(s1, i2), i3))
        \replacewith(\if(i2 < 0 | seqLen(s1) <= i2)
                \then(alpha::seqGet(s1, i3))
                \else(\if(i3 < i2)
                        \then(alpha::seqGet(s1, i3))
                        \else(\if(i2 <= i3 & i3 < seqLen(s1) - 1)
                                \then(alpha::seqGet(s1, i3 + 1))
                                \else((alpha)seqGetOutside))))

        \heuristics(simplify_enlarging)
    };

    getOfRemoveInt {
        \schemaVar \term Seq s1;
        \schemaVar \term int i3, i2;

        \find(int::seqGet(seqRemove(s1, i2), i3))
        \replacewith(\if(i2 < 0 | seqLen(s1) <= i2)
                \then(int::seqGet(s1, i3))
                \else(\if(i3 < i2)
                        \then(int::seqGet(s1, i3))
                        \else(\if(i2 <= i3 & i3 < seqLen(s1) - 1)
                                \then(int::seqGet(s1, i3 + 1))
                                \else((int)seqGetOutside))))

        \heuristics(simplify_enlarging)
    };

    lenOfRemoveConcrete1 {
        \schemaVar \term Seq s1;

        \assumes(seqLen(s1) >= 1 ==>)
        \find(seqLen(seqRemove(s1, seqLen(s1) - 1)))
        \replacewith(seqLen(s1) - 1)

        \heuristics(simplify)
    };

    lenOfRemoveConcrete2 {
        \schemaVar \term Seq s1;

        \assumes(seqLen(s1) >= 1 ==>)
        \find(seqLen(seqRemove(s1, 0)))
        \replacewith(seqLen(s1) - 1)

        \heuristics(simplify)
    };

    //  Differs from seqOutsideValue in seqStandard-new-verify.key
    //

    getOfRemoveAnyConcrete1 {
        \schemaVar \term Seq s1;
        \schemaVar \term int i3, i2;
        \assumes(seqLen(s1) >= 1 ==>)
        \find(alpha::seqGet(seqRemove(s1, seqLen(s1) - 1), i3))
        \replacewith(\if(i3 < seqLen(s1) - 1)
                \then(alpha::seqGet(s1, i3))
                \else((alpha)seqGetOutside))

        \heuristics(simplify_enlarging)
    };

    //  Differs from seqOutsideValue in seqStandard-new-verify.key
    //

    getOfRemoveAnyConcrete2 {
        \schemaVar \term Seq s1;
        \schemaVar \term int i3, i2;
        \assumes(seqLen(s1) >= 1 ==>)
        \find(alpha::seqGet(seqRemove(s1, 0), i3))
        \replacewith(\if(0 <= i3 & i3 < seqLen(s1) - 1)
                \then(alpha::seqGet(s1, i3 + 1))
                \else((alpha)seqGetOutside))

        \heuristics(simplify_enlarging)
    };

    // --------------------------------------------------------------------------
    //  derived basic properties of permutations on natural
    //  numbers
    //
    // --------------------------------------------------------------------------


    //
    //  The following taclet formalizes a kind of pidgeon hole principle
    //  It is the only taclet whose derivation requires induction
    //

    // seqNPermRange {
    //        \schemaVar \term Seq s;
    //        \schemaVar \variables int iv;
    //      \find(seqNPerm(s) ==> )
    //      \varcond( \notFreeIn (iv,s)  )
    //      \add(\forall iv;((0 <= iv & iv <  seqLen(s))
    //         ->  (0 <= int::seqGet(s,iv) &  int::seqGet(s,iv) < seqLen(s))) ==>)
    //            };
    // Improved version by PHS, correctness proof from Oct.19.2016

    \lemma
    seqNPermRange {
        \schemaVar \term Seq s;
        \schemaVar \variables int iv;
        \find(seqNPerm(s) ==>)
        \varcond(\notFreeIn(iv, s))
        \add(\forall iv; ((0 <= iv & iv < seqLen(s))
                -> (0 <= int::seqGet(s, iv) & int::seqGet(s, iv) < seqLen(s) &
                    int::instance(any::seqGet(s, iv)) = TRUE)) ==>)

    };

    //
    //  The following taclet formalizes the mathematical fact
    //  that every sujective function from a finite set into
    //  itself is injective.
    //  It can be proved using the previous taclet without induction.
    //

    seqNPermInjective {
        \schemaVar \term Seq s;
        \schemaVar \variables int iv, jv;
        \find(seqNPerm(s) ==>)
        \varcond(\notFreeIn(iv, s), \notFreeIn(jv, s))
        \add(\forall iv; (\forall jv; (
                    (0 <= iv & iv < seqLen(s) & 0 <= jv & jv < seqLen(s)
                        & int::seqGet(s, iv) = int::seqGet(s, jv))
                    -> iv = jv)) ==>)

    };

    // More transitivity rules (used for automation, see at end)

    \lemma
    seqPermTrans {
        \schemaVar \term Seq s1, s2, s3;

        \assumes(seqPerm(s2, s3) ==>)
        \find(seqPerm(s1, s2) ==>)
        \add(seqPerm(s1, s3) ==>)
    };

    // DB: changed 25/10/2013 to be applied on RHS
    \lemma
    seqPermRefl {
        \schemaVar \term Seq s;
        \find(seqPerm(s, s))
        \replacewith(true)
        \heuristics(concrete)
    };

    seqPermEmpty1 {
        \schemaVar \term Seq s;
        \find(seqPerm(seqEmpty, s))
        \replacewith(seqEmpty = s)
        \heuristics(simplify)
        \displayname "seqPermEmpty"
    };

    seqPermEmpty2 {
        \schemaVar \term Seq s;
        \find(seqPerm(s, seqEmpty))
        \replacewith(seqEmpty = s)
        \heuristics(simplify)
        \displayname "seqPermEmpty"
    };

    seqNPermSwapNPerm {
        \schemaVar \term Seq s1;
        \schemaVar \variables int iv, jv;

        \find(seqNPerm(s1) ==>)
        \varcond(\notFreeIn(iv, s1), \notFreeIn(jv, s1))

        \add(\forall iv; (\forall jv; (
                    (0 <= iv & 0 <= jv & iv < seqLen(s1) & jv < seqLen(s1))
                    -> seqNPerm(seqSwap(s1, iv, jv)))) ==>)

    };

    // changed; proven in KeY -- DB 29/10/2013
    seqNPermEmpty {
        \find(seqNPerm(seqEmpty))
        \replacewith(true)
        \heuristics(concrete)
    };

    // changed; proven in KeY -- DB 29/10/2013
    seqNPermSingletonConrete {
        \find(seqNPerm(seqSingleton(0)))
        \replacewith(true)
        \heuristics(concrete)
    };

    // changed; proven in KeY -- DB 29/10/2013
    seqNPermSingleton {
        \schemaVar \term int si;
        \find(seqNPerm(seqSingleton(si)))
        \replacewith(si = 0)
        \heuristics(simplify)
    };

    seqNPermComp {
        \schemaVar \term Seq s1, s2;
        \schemaVar \variables int u;
        \assumes(seqNPerm(s2) & seqLen(s1) = seqLen(s2) ==>)
        \find(seqNPerm(s1) ==>)
        \varcond(\notFreeIn(u, s1), \notFreeIn(u, s2))

        \add(seqNPerm(seqDef{u;}(0, seqLen(s1),
                    int::seqGet(s1, int::seqGet(s2, u)))) ==>)

    };

    seqGetSInvS {
        \schemaVar \term Seq s;
        \schemaVar \term int t;

        \find(int::seqGet(s, int::seqGet(seqNPermInv(s), t)))
        \replacewith(t);
        \add( ==> seqNPerm(s) & 0 <= t & t < seqLen(s))

        // \heuristics(simplify)

    };

    seqNPermInvNPermLeft {
        \schemaVar \term Seq s1;

        \find(seqNPerm(s1) ==>)
        \add(seqNPerm(seqNPermInv(s1)) ==>)
    };

    // DB: changed 25/10/2013 to be applied on RHS
    seqPermSym {
        \schemaVar \term Seq s1, s2;
        \find(seqPerm(s1, s2))
        \replacewith(seqPerm(s2, s1))
    };

    seqNPermInvNPermReplace {
        \schemaVar \term Seq s1;

        \find(seqNPerm(seqNPermInv(s1)))
        \replacewith(seqNPerm(s1))
    };

    seqPermConcatFW {
        \schemaVar \term Seq s1, s2, t1, t2;

        \assumes(seqPerm(s1, t1) ==>)
        \find(seqPerm(s2, t2) ==>)
        \add(seqPerm(seqConcat(s1, s2), seqConcat(t1, t2)) ==>)
    };

    seqPermConcatBW {
        \schemaVar \term Seq s1, s2, t1, t2;

        \assumes(seqPerm(s1, t1) ==>)
        \find( ==> seqPerm(seqConcat(s1, s2), seqConcat(t1, t2)))
        \replacewith( ==> seqPerm(s2, t2))

        \heuristics(simplify)
    };

    \lemma
    seqPermSplit {
        \schemaVar \term Seq s1, s2, t1, t2;
        \find( ==> seqPerm(seqConcat(s1, s2), seqConcat(t1, t2)))
        \replacewith( ==> seqPerm(s1, t1) & seqPerm(s2, t2))
    };

    seqnormalizeDef {
        \schemaVar \term Seq s1;
        \schemaVar \term int le, ri;
        \schemaVar \term any t;
        \schemaVar \variables int u;

        \find(seqDef{u;}(le, ri, t))
        \varcond(\notFreeIn(u, le), \notFreeIn(u, ri))
        \replacewith(\if(le < ri)
                \then(seqDef{u;}(0, (ri - le), ({\subst u; (u + le)}t)))
                \else(seqEmpty))

    };

    \lemma
    seqNPermRight {
        \schemaVar \term Seq s;
        \schemaVar \variables int iv, jv;

        \find( ==> seqNPerm(s))
        \varcond(\notFreeIn(iv, s), \notFreeIn(jv, s))
        \add( ==> \forall iv; (\forall jv; (
                    (0 <= iv & iv < seqLen(s) & 0 <= jv & jv < seqLen(s)
                        & int::seqGet(s, iv) = int::seqGet(s, jv))
                    -> iv = jv))
            & \forall iv; (0 <= iv & iv < seqLen(s) -> 0 <= int::seqGet(s, iv) & int::seqGet(s, iv) < seqLen(s))
            & \forall iv; (0 <= iv & iv < seqLen(s) -> int::instance(any::seqGet(s, iv)) = TRUE))
    };

    \lemma
    seqPermFromSwap {
        \schemaVar \term Seq s1, s2, t1, t2;
        \schemaVar \variables int iv, jv;

        \assumes(seqPerm(s1, t1) ==>)
        \find( ==> seqPerm(s2, t2))
        \varcond(
            \notFreeIn(iv, s1),
            \notFreeIn(iv, s2),
            \notFreeIn(iv, t1),
            \notFreeIn(iv, t2),
            \notFreeIn(jv, s1),
            \notFreeIn(jv, s2),
            \notFreeIn(jv, t1),
            \notFreeIn(jv, t2))
        \replacewith( ==> t1 = t2 &
            \exists iv; \exists jv; (0 <= iv & 0 <= jv & iv < s2.length & jv < s2.length &
                s1 = seqSwap(s2, iv, jv)))
    };

    \lemma
    seqSwapPreservesSeqPerm {
        \schemaVar \term Seq s;
        \schemaVar \term int x;
        \schemaVar \term int y;

        \find(==> seqPerm(s, seqSwap(s, x, y)))
        \add( ==> 0 <= x & x < seqLen(s) & 0 <= y & y < seqLen(s))
        \heuristics(simplify_enlarging)
    };

    \lemma
    seqSwapPreservesSeqPermEQ {
        \schemaVar \term Seq s;
        \schemaVar \term Seq EQ;
        \schemaVar \term int x;
        \schemaVar \term int y;

        \assumes (seqSwap(s, x, y) = EQ ==>)
        \find(==> seqPerm(s, EQ))
        \add( ==> 0 <= x & x < seqLen(s) & 0 <= y & y < seqLen(s))
        \heuristics(simplify_enlarging)
    };

    /* seqPermOrder {
     \schemaVar \term Seq commEqLeft, commEqRight;
     \find(seqPerm(commEqLeft, commEqRight))
     \replacewith(seqPerm(commEqRight, commEqLeft))
     \heuristics(order_terms)
    };*/

    // These rules are variants of seqPermTrans used to prove transitive
    // seqPerm challenges automatically.

    \lemma
    seqPermTransAlt0 {
        \schemaVar \term Seq s1, s2, s3, x, y;

        \assumes(seqPerm(s2, s3) ==> seqPerm(x, y))
        \find(seqPerm(s1, s2) ==>)
        \add(seqPerm(s1, s3) ==>)
        \heuristics(inReachableStateImplication)
        \displayname "seqPermTrans"
    };

    \lemma
    seqPermTransAlt1 {
        \schemaVar \term Seq a, b, c, x, y;
        \assumes(seqPerm(a, b) ==> seqPerm(x, y))
        // apply this rule only if there is a seqPerm goal to prove!
        \find(seqPerm(a, c) ==>)
        \add(seqPerm(b, c) ==>)
        \heuristics(inReachableStateImplication)
        \displayname "seqPermTrans"
    };

    \lemma
    seqPermTransAlt2 {
        \schemaVar \term Seq a, b, c, x, y;
        \assumes(seqPerm(a, c) ==> seqPerm(x, y))
        // apply this rule only if there is a seqPerm goal to prove!
        \find(seqPerm(b, c) ==>)
        \add(seqPerm(a, b) ==>)
        \heuristics(inReachableStateImplication)
        \displayname "seqPermTrans"
    };

    \lemma
    seqPermTransAlt3 {
        \schemaVar \term Seq a, b, c, x, y;
        \assumes(seqPerm(a, c) ==> seqPerm(x, y))
        // apply this rule only if there is a seqPerm goal to prove!
        \find(seqPerm(b, a) ==>)
        \add(seqPerm(b, c) ==>)
        \heuristics(inReachableStateImplication)
        \displayname "seqPermTrans"
    };

    // Proven by ulbrich in Isabelle/HOL
    seqPermCountsInt {
        \schemaVar \term Seq s1, s2;
        \schemaVar \variables int iv;
        \schemaVar \variables any element;

        \find(seqPerm(s1, s2))

        \varcond(
            \notFreeIn(element, s1, s2),
            \notFreeIn(iv, s1, s2)
        )

        \replacewith(
            (\forall element;
                bsum{iv;}(0, s1.length, \if(any::seqGet(s1, iv) = element) \then(1) \else(0)) =
                bsum{iv;}(0, s2.length, \if(any::seqGet(s2, iv) = element) \then(1) \else(0))
            )
        )
    };

    \lemma
    seqPermForall {
        \schemaVar \term Seq s1;
        \schemaVar \term Seq s2;
        \schemaVar \formula phi;
        \schemaVar \variable int iv;
        \schemaVar \variable any x;
        \assumes(seqPerm(s1, s2) ==>)
        \varcond(\notFreeIn(iv, phi), \notFreeIn(iv, s1), \notFreeIn(iv, s2))
        \add(\forall iv; (0 <= iv & iv < seqLen(s1) -> {\subst x; any::seqGet(s1, iv)}phi)
            <->
            \forall iv; (0 <= iv & iv < seqLen(s1) -> {\subst x; any::seqGet(s2, iv)}phi) ==>)
    };

    \lemma
    seqPermExists {
        \schemaVar \term Seq s1;
        \schemaVar \term Seq s2;
        \schemaVar \formula phi;
        \schemaVar \variable int iv;
        \schemaVar \variable any x;
        \assumes(seqPerm(s1, s2) ==>)
        \varcond(\notFreeIn(iv, phi), \notFreeIn(iv, s1), \notFreeIn(iv, s2))
        \add(\exists iv; (0 <= iv & iv < seqLen(s1) & {\subst x; any::seqGet(s1, iv)}phi)
            <->
            \exists iv; (0 <= iv & iv < seqLen(s1) & {\subst x; any::seqGet(s2, iv)}phi) ==>)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains only the RULES for the definitional
// extension of the sequence datatype.
// The core theory is contained in file  seqCoreRules.key
// Find the DECLARATIONS in file seq.key.
// RULES for permutations are contained in the file seqPerm.key.

\sorts {
    \generic alpha, beta;
}

\rules(sequences:on) {
    // --------------------------------------------------------------------------
    //  These taclets were not part of the original Seq axiomatization by
    //  B.Weiss
    //  These taclets extend the signature of the core theory by indroducing
    //  function  symbols via explicit definition.
    //  Consistency of the extended theory is thus guaranteed by
    //  the Theorem on  conservative extentions.
    // --------------------------------------------------------------------------


    defOfEmpty {
        \schemaVar \term any te;
        \schemaVar \variables int uSub;

        \find(seqEmpty)

        \varcond(\notFreeIn(uSub, te))
        \replacewith(seqDef{uSub;}(0, 0, te))
    };

    defOfSeqSingleton {
        \schemaVar \term any x;
        \schemaVar \variables int uSub;

        \find(seqSingleton(x))

        \varcond(\notFreeIn(uSub, x))
        \replacewith(seqDef{uSub;}(0, 1, x))
    };

    defOfSeqConcat {
        \schemaVar \term Seq seq1, seq2;
        \schemaVar \variables int uSub;

        \find(seqConcat(seq1, seq2))

        \varcond(\notFreeIn(uSub, seq1),
            \notFreeIn(uSub, seq2))
        \replacewith(seqDef{uSub;}(0, seqLen(seq1) + seqLen(seq2),
                \if(uSub < seqLen(seq1))
                    \then(any::seqGet(seq1, uSub))
                    \else(any::seqGet(seq2, uSub - seqLen(seq1)))))

    };

    // --------------------------------------------------------------------
    //  This definition of "seqSub" differs from the original one.
    //  Now seqSub(seq,from,from) is the empty sequence, previously it
    //  was the singleton <seq(from)>.
    //  The new semantics however is in line with all other definitions
    //  involving a lower and and upper bound. The upper bound is always
    //  strict.
    // --------------------------------------------------------------------

    defOfSeqSub {
        \schemaVar \term Seq seq;
        \schemaVar \term int from, to;
        \schemaVar \variables int uSub;

        \find(seqSub(seq, from, to))
        \varcond(\notFreeIn(uSub, seq),
            \notFreeIn(uSub, from),
            \notFreeIn(uSub, to))
        \replacewith(seqDef{uSub;}(from, to, any::seqGet(seq, uSub)))

    };

    defOfSeqReverse {
        \schemaVar \term Seq seq;
        \schemaVar \variables int uSub;

        \find(seqReverse(seq))

        \varcond(\notFreeIn(uSub, seq))
        \replacewith(seqDef{uSub;}(0, seqLen(seq), any::seqGet(seq, seqLen(seq) - uSub - 1)))

    };

    defOfSeqUpd {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;
        \schemaVar \term any value;
        \schemaVar \variables int uSub;

        \find(seqUpd(seq, idx, value))

        \varcond(\notFreeIn(uSub, idx), \notFreeIn(uSub, value), \notFreeIn(uSub, seq))
        \replacewith(seqDef{uSub;}(0, seqLen(seq), \if(uSub=idx) \then(value) \else(any::seqGet(seq,uSub))))
    };

    // --------------------------------------------------------------------
    // rule for seqIndexOf
    // This is logically equivalent to a conditional (partial)
    // definition of  seqIndexOf
    // See also  taclet "seqIndexOf2" below
    // --------------------------------------------------------------------


    seqIndexOf {
        \schemaVar \term Seq s;
        \schemaVar \term any t;
        \schemaVar \skolemTerm int jsk;
        \schemaVar \variables int n, m;

        \find(seqIndexOf(s, t))
        \varcond(
            \notFreeIn(n, s),
            \notFreeIn(n, t),
            \notFreeIn(m, s),
            \notFreeIn(m, t))
        \add((\exists n; (0 <= n & n < seqLen(s) & any::seqGet(s, n) = t))
            ->
            (0 <= seqIndexOf(s, t) & seqIndexOf(s, t) < seqLen(s) &
                any::seqGet(s, seqIndexOf(s, t)) = t &
                \forall m; ((0 <= m & m < seqIndexOf(s, t)) -> any::seqGet(s, m) != t)) ==>)
    };

    // ====================================================================
    //
    //  Derived taclets
    //  All the following taclets can be derived from the taclets occuring prior
    //  to this point in this file.
    //  The taclets differ from the original axiomatization by
    //   (1) the right hand bound in seqDef is now strict
    //   (2) the default value is explicitely given by  seqGetOutside
    //       instead of   any::seqGet(seqEmpty, 0)
    //
    // ====================================================================


    \lemma
    seqSelfDefinition {
        \schemaVar \term Seq seq;
        \schemaVar \variables Seq s;
        \schemaVar \variables int u;
        \find(seq)
        \add(\forall s; (s = seqDef{u;}(0, seqLen(s), any::seqGet(s, u))) ==>)
    };

    \lemma
    seqOutsideValue {
        \schemaVar \variables Seq s;
        \schemaVar \variables int iv;
        \find(seqGetOutside)
        \add(\forall s; (\forall iv; ((iv < 0 | seqLen(s) <= iv)
                    -> any::seqGet(s, iv) = seqGetOutside)) ==>)
    };

    // --------------------------------------------------------------------
    // derived rule for generic types
    // --------------------------------------------------------------------

    \lemma
    castedGetAny {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;

        \find((beta)any::seqGet(seq, idx))

        \replacewith(beta::seqGet(seq, idx))

        \heuristics(simplify)
    };

    \lemma
    seqGetAlphaCast {
        \schemaVar \term Seq seq;
        \schemaVar \term int at;

        \find(alpha::seqGet(seq, at))
        \add((alpha)any::seqGet(seq, at) = alpha::seqGet(seq, at) ==>)
        \heuristics(inReachableStateImplication)
    };

    // --------------------------------------------------------------------
    // derived rule for getOfseqX
    // --------------------------------------------------------------------

    \lemma
    getOfSeqSingleton {
        \schemaVar \term any x;
        \schemaVar \term int idx;

        \find(alpha::seqGet(seqSingleton(x), idx))

        \replacewith(\if(idx = 0)
                \then((alpha)x)
                \else((alpha)seqGetOutside))

        \heuristics(simplify)
    };

    \lemma
    getOfSeqSingletonConcrete {
        \schemaVar \term any x;
        \find(alpha::seqGet(seqSingleton(x), 0))
        \replacewith((alpha)x)
        \heuristics(concrete)
    };

    \lemma
    getOfSeqConcat {
        \schemaVar \term Seq seq, seq2;
        \schemaVar \term int idx;

        \find(alpha::seqGet(seqConcat(seq, seq2), idx))

        \replacewith(\if(idx < seqLen(seq))
                \then(alpha::seqGet(seq, idx))
                \else(alpha::seqGet(seq2, idx - seqLen(seq))))

        \heuristics(simplify_enlarging)
    };

    \lemma
    getOfSeqSub {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx, from, to;

        \find(alpha::seqGet(seqSub(seq, from, to), idx))

        \replacewith(\if(0 <= idx & idx < (to - from))
                \then(alpha::seqGet(seq, idx + from))
                \else((alpha)seqGetOutside))

        \heuristics(simplify_enlarging)
    };

    \lemma
    getOfSeqReverse {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;

        \find(alpha::seqGet(seqReverse(seq), idx))

        \replacewith(alpha::seqGet(seq, seqLen(seq) - 1 - idx))

        \heuristics(simplify_enlarging)
    };

    \lemma
    getOfSeqUpd {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx, jdx;
        \schemaVar \term any value;

        \find(alpha::seqGet(seqUpd(seq, idx, value), jdx))
        \replacewith(\if(0<=jdx & jdx < seqLen(seq) & idx=jdx) \then((alpha)value) \else(alpha::seqGet(seq, jdx)))
        \heuristics(simplify_enlarging)
    };

    // --------------------------------------------------------------------
    // derived rule for lenOfX
    // --------------------------------------------------------------------

    \lemma
    lenOfSeqEmpty {
        \find(seqLen(seqEmpty))

        \replacewith(0)

        \heuristics(concrete)
    };

    \lemma
    lenOfSeqSingleton {
        \schemaVar \term alpha x;

        \find(seqLen(seqSingleton(x)))

        \replacewith(1)

        \heuristics(concrete)
    };

    \lemma
    lenOfSeqConcat {
        \schemaVar \term Seq seq, seq2;

        \find(seqLen(seqConcat(seq, seq2)))

        \replacewith(seqLen(seq) + seqLen(seq2))

        \heuristics(simplify)
    };

    \lemma
    lenOfSeqSub {
        \schemaVar \term Seq seq;
        \schemaVar \term int from, to;

        \find(seqLen(seqSub(seq, from, to)))

        \replacewith(\if(from < to) \then(to - from) \else(0))

        \heuristics(simplify)
    };

    \lemma
    lenOfSeqReverse {
        \schemaVar \term Seq seq;

        \find(seqLen(seqReverse(seq)))

        \replacewith(seqLen(seq))

        \heuristics(simplify)
    };

    \lemma
    lenOfSeqUpd {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;
        \schemaVar \term any value;

        \find(seqLen(seqUpd(seq, idx, value)))
        \replacewith(seqLen(seq))
        \heuristics(simplify)
    };


    // --------------------------------------------------------------------------
    // derived EQ versions
    // --------------------------------------------------------------------------

    \lemma
    equalityToSeqGetAndSeqLenLeft {
        \schemaVar \term Seq s, s2;
        \schemaVar \variables int iv;

        \find(s = s2 ==>)
        \varcond(\notFreeIn(iv, s, s2))

        \add(seqLen(s) = seqLen(s2)
            & \forall iv; (0 <= iv & iv < seqLen(s)
                -> any::seqGet(s, iv) = any::seqGet(s2, iv)) ==>)

        \heuristics(inReachableStateImplication)
        // uncertain about heuristics??
    };

    \lemma
    equalityToSeqGetAndSeqLenRight {
        \schemaVar \term Seq s, s2;
        \schemaVar \variables int iv;

        \find( ==> s = s2)
        \varcond(\notFreeIn(iv, s, s2))

        \replacewith( ==> seqLen(s) = seqLen(s2)
            & \forall iv; (0 <= iv & iv < seqLen(s)
                -> any::seqGet(s, iv) = any::seqGet(s2, iv)))

        \heuristics(simplify_enlarging)
    };

    \lemma
    getOfSeqSingletonEQ {
        \schemaVar \term any x;
        \schemaVar \term int idx;
        \schemaVar \term Seq EQ;

        \assumes(seqSingleton(x) = EQ ==>)
        \find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel

        \replacewith(\if(idx = 0)
                \then((alpha)x)
                \else((alpha)seqGetOutside))

        \heuristics(no_self_application, simplify_enlarging)
        \displayname "getOfSeqSingleton"
    };

    \lemma
    getOfSeqConcatEQ {
        \schemaVar \term Seq seq, seq2;
        \schemaVar \term int idx;
        \schemaVar \term Seq EQ;

        \assumes(seqConcat(seq, seq2) = EQ ==>)
        \find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel

        \replacewith(\if(idx < seqLen(seq))
                \then(alpha::seqGet(seq, idx))
                \else(alpha::seqGet(seq2, idx - seqLen(seq))))

        \heuristics(no_self_application, simplify_enlarging)
        \displayname "getOfSeqConcat"
    };

    \lemma
    getOfSeqSubEQ {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx, from, to;
        \schemaVar \term Seq EQ;

        \assumes(seqSub(seq, from, to) = EQ ==>)
        \find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel

        \replacewith(\if(0 <= idx & idx < (to - from))
                \then(alpha::seqGet(seq, idx + from))
                \else((alpha)seqGetOutside))

        \heuristics(no_self_application, simplify_enlarging)
        \displayname "getOfSeqSub"
    };

    \lemma
    getOfSeqReverseEQ {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;
        \schemaVar \term Seq EQ;

        \assumes(seqReverse(seq) = EQ ==>)
        \find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel

        \replacewith(alpha::seqGet(seq, seqLen(seq) - 1 - idx))

        \heuristics(no_self_application, simplify_enlarging)
        \displayname "getOfSeqReverse"
    };

    \lemma
    lenOfSeqEmptyEQ {
        \schemaVar \term alpha x;
        \schemaVar \term Seq EQ;

        \assumes(seqEmpty = EQ ==>)
        \find(seqLen(EQ))
        \sameUpdateLevel
        \replacewith(0)

        \heuristics(concrete)
        \displayname "lenOfSeqEmpty"
    };

    \lemma
    lenOfSeqSingletonEQ {
        \schemaVar \term alpha x;
        \schemaVar \term Seq EQ;

        \assumes(seqSingleton(x) = EQ ==>)
        \find(seqLen(EQ))
        \sameUpdateLevel
        \replacewith(1)

        \heuristics(concrete)
        \displayname "lenOfSeqSingleton"
    };

    \lemma
    lenOfSeqConcatEQ {
        \schemaVar \term Seq seq, seq2;
        \schemaVar \term Seq EQ;

        \assumes(seqConcat(seq, seq2) = EQ ==>)
        \find(seqLen(EQ))
        \sameUpdateLevel

        \replacewith(seqLen(seq) + seqLen(seq2))

        \heuristics(simplify)
        \displayname "lenOfSeqConcat"
    };

    \lemma
    lenOfSeqSubEQ {
        \schemaVar \term Seq seq;
        \schemaVar \term int from, to;
        \schemaVar \term Seq EQ;

        \assumes(seqSub(seq, from, to) = EQ ==>)
        \find(seqLen(EQ))
        \sameUpdateLevel

        \replacewith(\if(from < to) \then(to - from) \else(0))

        \heuristics(simplify, find_term_not_in_assumes)
        \displayname "lenOfSeqSub"
    };

    \lemma
    lenOfSeqReverseEQ {
        \schemaVar \term Seq seq;
        \schemaVar \term Seq EQ;

        \assumes(seqReverse(seq) = EQ ==>)
        \find(seqLen(EQ))
        \sameUpdateLevel

        \replacewith(seqLen(seq))

        \heuristics(simplify)
        \displayname "lenOfSeqReverse"
    };

    \lemma
    getOfSeqDefEQ {
        \schemaVar \term int idx, from, to;
        \schemaVar \term Seq EQ;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \assumes(seqDef{uSub;}(from, to, t) = EQ ==>)
        \find(alpha::seqGet(EQ, idx))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, from),
            \notFreeIn(uSub, to))
        \replacewith(\if(0 <= idx & idx < (to - from))
                \then((alpha){\subst uSub; (idx + from)}t)
                \else((alpha)seqGetOutside))

        \heuristics(simplify_enlarging)
        \displayname "getOfSeqDef"
    };

    \lemma
    lenOfSeqDefEQ {
        \schemaVar \term int from, to;
        \schemaVar \term Seq EQ;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \assumes(seqDef{uSub;}(from, to, t) = EQ ==>)
        \find(seqLen(EQ))
        \sameUpdateLevel

        \replacewith(\if(from <= to) \then((to - from)) \else(0))

        \heuristics(simplify)
        \displayname "lenOfSeqDef"
    };

    // --------------------------------------------------------------------------
    // derived taclets involving  seqEmpty
    // --------------------------------------------------------------------------

    \lemma
    seqConcatWithSeqEmpty1 {
        \schemaVar \term Seq seq;

        \find(seqConcat(seq, seqEmpty))

        \replacewith(seq)

        \heuristics(concrete)
        \displayname "seqConcatWithEmpty"
    };

    \lemma
    seqConcatWithSeqEmpty2 {
        \schemaVar \term Seq seq;

        \find(seqConcat(seqEmpty, seq))

        \replacewith(seq)

        \heuristics(concrete)
        \displayname "seqConcatWithEmpty"
    };

    \lemma
    seqReverseOfSeqEmpty {
        \find(seqReverse(seqEmpty))

        \replacewith(seqEmpty)

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // derived taclets for special instantiations
    // --------------------------------------------------------------------------

    subSeqCompleteSeqDef {
        \schemaVar \term int u;
        \schemaVar \term any a;
        \schemaVar \variables int i;

        \find(seqSub(seqDef{i;}(0, u, a), 0, u))

        \replacewith(seqDef{i;}(0, u, a))
        \heuristics(concrete)
    };

    \lemma
    subSeqComplete {
        \schemaVar \term Seq seq;

        \find(seqSub(seq, 0, seqLen(seq)))
        \replacewith(seq)
        \heuristics(concrete)
    };

    subSeqCompleteSeqDefEQ {
        \schemaVar \term int u;
        \schemaVar \term any a;
        \schemaVar \variables int i;
        \schemaVar \term Seq EQ;

        \assumes(seqDef{i;}(0, u, a) = EQ ==>)
        \find(seqSub(EQ, 0, u))
        \replacewith(seqDef{i;}(0, u, a))
        \heuristics(no_self_application, concrete)
    };

    subSeqEmpty {
        \schemaVar \term Seq seq;
        \schemaVar \term int i;
        \find(seqSub(seq, i, i))
        \replacewith(seqEmpty)
        \heuristics(concrete)
    };

    \lemma
    subSeqTailR {
        \schemaVar \term Seq seq;
        \schemaVar \term any x;

        \find(seqSub(seqConcat(seqSingleton(x), seq), 1, seqLen(seq) + 1))

        \replacewith(seq)

        \heuristics(concrete)
        \displayname "subSeqTail"
    };

    \lemma
    subSeqTailL {
        \schemaVar \term Seq seq;
        \schemaVar \term any x;

        \find(seqSub(seqConcat(seqSingleton(x), seq), 1, 1 + seqLen(seq)))

        \replacewith(seq)

        \heuristics(concrete)
        \displayname "subSeqTail"
    };

    subSeqSingleton {
        \schemaVar \term Seq seq;
        \schemaVar \term any x;

        \find(seqSub(seqSingleton(x), 0, 1))

        \replacewith(seqSingleton(x))

        \heuristics(concrete)
    };

    subSeqSingletonEQ {
        \schemaVar \term Seq seq;
        \schemaVar \term any x;
        \schemaVar \term Seq EQ;

        \assumes(seqSingleton(x) = EQ ==>)
        \find(seqSub(EQ, 0, 1))

        \replacewith(seqSingleton(x))

        \heuristics(concrete)
    };

    \lemma
    subSeqTailEQR {
        \schemaVar \term Seq seq;
        \schemaVar \term any x;
        \schemaVar \term int EQ;

        \assumes(seqLen(seq) = EQ ==>)
        \find(seqSub(seqConcat(seqSingleton(x), seq), 1, EQ + 1))
        \sameUpdateLevel

        \replacewith(seq)

        \heuristics(concrete)
        \displayname "subSeqTail"
    };

    \lemma
    subSeqTailEQL {
        \schemaVar \term Seq seq;
        \schemaVar \term any x;
        \schemaVar \term int EQ;

        \assumes(seqLen(seq) = EQ ==>)
        \find(seqSub(seqConcat(seqSingleton(x), seq), 1, 1 + EQ))
        \sameUpdateLevel

        \replacewith(seq)

        \heuristics(concrete)
        \displayname "subSeqTail"
    };

    subSeqSingleton2 {
        \schemaVar \term Seq seq;
        \schemaVar \term any x;
        \schemaVar \term int l, u;

        \find(seqSub(seqSingleton(x), l, u))

        \replacewith(seqConcat(seqSub(seqEmpty,
                    \if(l < 0) \then(l) \else(0),
                    \if(u < 0) \then(u) \else(0)),
                seqConcat(\if(l <= 0 & u >= 1)
                        \then(seqSingleton(x))
                        \else(seqEmpty),
                    seqSub(seqEmpty,
                        \if(l > 0) \then(l) \else(1),
                        \if(u > 0) \then(u) \else(1)))))

        \heuristics(simplify_enlarging)
    };

    subSeqSingleton2EQ {
        \schemaVar \term Seq seq;
        \schemaVar \term any x;
        \schemaVar \term int l, u;
        \schemaVar \term Seq EQ;

        \assumes(seqSingleton(x) = EQ ==>)
        \find(seqSub(EQ, l, u))

        \replacewith(seqConcat(seqSub(seqEmpty,
                    \if(l < 0) \then(l) \else(0),
                    \if(u < 0) \then(u) \else(0)),
                seqConcat(\if(l <= 0 & u >= 1)
                        \then(seqSingleton(x))
                        \else(seqEmpty),
                    seqSub(seqEmpty,
                        \if(l > 0) \then(l) \else(1),
                        \if(u > 0) \then(u) \else(1)))))

        \heuristics(no_self_application, simplify_enlarging)
    };

    subSeqConcat {
        \schemaVar \term Seq s1, s2;
        \schemaVar \term int l, u;

        \find(seqSub(seqConcat(s1, s2), l, u))

        \replacewith(seqConcat(seqSub(s1, l, \if(seqLen(s1) < u) \then(seqLen(s1)) \else(u)),
                seqSub(s2, \if(l < seqLen(s1)) \then(0) \else(l - seqLen(s1)), u - seqLen(s1))))

        \heuristics(simplify_enlarging)
    };

    // fix
    subSeqConcatEQ {
        \schemaVar \term Seq s1, s2;
        \schemaVar \term int l, u;
        \schemaVar \term Seq EQ;

        \assumes(seqConcat(s1, s2) = EQ ==>)
        \find(seqSub(EQ, l, u))

        \replacewith(seqConcat(seqSub(s1, l, \if(seqLen(s1) < u) \then(seqLen(s1)) \else(u)),
                seqSub(s2, \if(l < seqLen(s1)) \then(0) \else(l - seqLen(s1)), u - seqLen(s1))))

        \heuristics(no_self_application, simplify_enlarging)
    };

    subSeqHeadSeqDef {
        \schemaVar \term Seq seq;
        \schemaVar \term any a;
        \schemaVar \term int u;
        \schemaVar \variables int i;

        \find(seqSub(seqConcat(seqDef{i;}(0, u, a), seq), 0, u))
        \replacewith(seqDef{i;}(0, u, a))
        \heuristics(concrete)
    };

    subSeqHeadSeqDefEQ {
        \schemaVar \term Seq seq;
        \schemaVar \term any a;
        \schemaVar \term int u;
        \schemaVar \variables int i;
        \schemaVar \term Seq EQ;

        \assumes(seqDef{i;}(0, u, a) = EQ ==>)
        \find(seqSub(seqConcat(EQ, seq), 0, u))

        \replacewith(seqDef{i;}(0, u, a))

        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // other derived taclets
    // --------------------------------------------------------------------------

    \lemma
    seqDef_split {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(from, to, t))
        \varcond(
            \notFreeIn(uSub1, from),
            \notFreeIn(uSub1, idx),
            \notFreeIn(uSub1, to),
            \notFreeIn(uSub, from),
            \notFreeIn(uSub, idx),
            \notFreeIn(uSub, to),
            \notFreeIn(uSub1, t))
        \replacewith(\if(from <= idx & idx < to)
                \then(seqConcat(
                        seqDef{uSub;}(from, idx, t),
                        seqDef{uSub1;}(idx, to, {\subst uSub; uSub1}t)))
                \else(seqDef{uSub;}(from, to, t)))
    };

    \lemma
    seqDef_induction_upper {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(from, to, t))
        \varcond(\notFreeIn(uSub, from),
            \notFreeIn(uSub, to))
        \replacewith(seqConcat(
                seqDef{uSub;}(from, to - 1, t),
                \if(from < to) \then(seqSingleton({\subst uSub; (to - 1)}t))
                    \else(seqEmpty)))
    };

    \lemma
    seqDef_induction_upper_concrete {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(from, 1 + to, t))
        \varcond(\notFreeIn(uSub, from),
            \notFreeIn(uSub, to))
        \replacewith(seqConcat(
                seqDef{uSub;}(from, to, t),
                \if(from <= to) \then(seqSingleton({\subst uSub; (to)}t))
                    \else(seqEmpty)))
        \heuristics(simplify_enlarging)
    };

    \lemma
    seqDef_induction_lower {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(from, to, t))
        \varcond(\notFreeIn(uSub, from),
            \notFreeIn(uSub, to))
        \replacewith(seqConcat(
                \if(from < to) \then(seqSingleton({\subst uSub; (from)}t))
                    \else(seqEmpty),
                seqDef{uSub;}(from + 1, to, t)))
    };

    \lemma
    seqDef_induction_lower_concrete {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(-1 + from, to, t))
        \varcond(\notFreeIn(uSub, from),
            \notFreeIn(uSub, to))
        \replacewith(seqConcat(
                \if(-1 + from < to) \then(seqSingleton({\subst uSub; (-1 + from)}t))
                    \else(seqEmpty),
                seqDef{uSub;}(from, to, t)))
        \heuristics(simplify)
    };

    \lemma
    seqDef_split_in_three {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(from, to, t))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(uSub, idx),
            \notFreeIn(uSub1, t),
            \notFreeIn(uSub1, idx),
            \notFreeIn(uSub, from),
            \notFreeIn(uSub1, to))
        "Precondition":
            \add( ==> (from <= idx & idx < to));
        "Splitted SeqDef":
            \replacewith(
                seqConcat(seqDef{uSub;}(from, idx, t),
                    seqConcat(seqSingleton({\subst uSub; idx}t),
                        seqDef{uSub1;}(idx + 1, to, {\subst uSub; uSub1}t))))
    };

    \lemma
    seqDef_empty {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(from, idx, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, from),
            \notFreeIn(uSub, idx))
        "Precondition":
            \add( ==> idx <= from);
        "Empty SeqDef":
            \replacewith(seqEmpty)
    };

    \lemma
    seqDef_one_summand {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(from, idx, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, from),
            \notFreeIn(uSub, idx))
        \replacewith(\if(from + 1 = idx)
                \then(seqSingleton({\subst uSub; from}t))
                \else(seqDef{uSub;}(from, idx, t)))
    };

    \lemma
    seqDef_lower_equals_upper {
        \schemaVar \term int idx, from, to;
        \schemaVar \term any t;
        \schemaVar \variables int uSub, uSub1, uSub2;

        \find(seqDef{uSub;}(idx, idx, t))
        \sameUpdateLevel
        \varcond(\notFreeIn(uSub, idx))
        \replacewith(seqEmpty)
        \heuristics(simplify)
    };

    \lemma // in KeY -- DB 29/10/2013
    seqDefOfSeq {
        \schemaVar \term int x;
        \schemaVar \term Seq s;
        \schemaVar \variables int u, v;
        //    \find(seqDef{u;}(0,x,alpha::seqGet(s,u)))
        // changed by PHS 17.12.2013
        // original version caused inconsistency
        // proof by DB 29.10.2013 was based on
        // another incorrect taclet that has in the
        // meantime been removed.
        \find(seqDef{u;}(0, x, any::seqGet(s, u)))
        \varcond(\notFreeIn(u, x, s), \notFreeIn(v, x, s))
        \replacewith(\if(seqLen(s) = x)
                \then(s)
                \else(\if(seqLen(s) > x)
                        \then(seqSub(s, 0, x))
                        \else(seqConcat(s,
                                seqDef{v;}(seqLen(s), x, seqGetOutside))
                        )))
        \heuristics(simplify_enlarging)
    };

    \lemma // in KeY -- DB 29/10/2013
    seqSelfDefinitionEQ2 {
        \schemaVar \term Seq s;
        \schemaVar \term int x;
        \schemaVar \variables int u;
        \assumes(seqLen(s) = x ==>)
        \find(seqDef{u;}(0, x, any::seqGet(s, u)))
        \sameUpdateLevel
        \varcond(\notFreeIn(u, x, s))
        \replacewith(s)
        \heuristics(simplify)
        \displayname "seqSelfDefinition"
    };

    // --------------------------------------------------------------------------
    // derived taclets for seqIndexOf
    // --------------------------------------------------------------------------

    // The following rule has been removed since we agreed
    // to longer support \ifEx.


    //  seqIndexOf2 {
    //  \schemaVar \term Seq s;
    //  \schemaVar \term any t;
    //  \schemaVar \variables int n;
    //  \find( seqIndexOf(s,t) )
    //  \varcond ( \notFreeIn(n, s), \notFreeIn(n, t) )
    //  \replacewith( \ifEx n;
    //                (0 <= n & n < seqLen(s) & any::seqGet(s,n)=t)
    //                \then (n)
    //                \else (seqIndexOf(s,t)) )
    // };

    \lemma
    indexOfSeqSingleton {
        \schemaVar \term any x;
        \find(seqIndexOf(seqSingleton(x), x))
        \sameUpdateLevel
        \replacewith(0)
        \heuristics(concrete)
    };

    \lemma
    indexOfSeqConcatFirst {
        \schemaVar \term Seq s1, s2;
        \schemaVar \term any x;
        \schemaVar \variables int idx;
        \find(seqIndexOf(seqConcat(s1, s2), x))
        \sameUpdateLevel
        \varcond(\notFreeIn(idx, s1, s2, x))
        \replacewith(seqIndexOf(s1, x));
        \add( ==> \exists idx; (0 <= idx & idx < seqLen(s1) &
                any::seqGet(s1, idx) = x))
    };

    \lemma
    indexOfSeqConcatSecond {
        \schemaVar \term Seq s1, s2;
        \schemaVar \term any x;
        \schemaVar \variables int idx;
        \find(seqIndexOf(seqConcat(s1, s2), x))
        \sameUpdateLevel
        \varcond(\notFreeIn(idx, s1, s2, x))
        \replacewith(add(seqIndexOf(s2, x), seqLen(s1)));
        \add( ==> (!\exists idx;
                (0 <= idx & idx < seqLen(s1) & any::seqGet(s1, idx) = x)
                & \exists idx;
                (0 <= idx & idx < seqLen(s2) & any::seqGet(s2, idx) = x)))
    };

    \lemma
    indexOfSeqSub {
        \schemaVar \term Seq s;
        \schemaVar \term int from, to, n;
        \schemaVar \term any x;
        \schemaVar \variables int nx;

        \find(seqIndexOf(seqSub(s, from, to), x))
        \sameUpdateLevel
        \varcond(
            \notFreeIn(nx, s),
            \notFreeIn(nx, x),
            \notFreeIn(nx, from),
            \notFreeIn(nx, to))
        \replacewith(sub(seqIndexOf(s, x), from));
        \add( ==> from <= seqIndexOf(s, x) & seqIndexOf(s, x) < to & 0 <= from &
            \exists nx; ((0 <= nx & nx < seqLen(s) & any::seqGet(s, nx) = x)))
    };

    // --------------------------------------------------------------------------
    // work-a-round to use \seq_def in JML set statements
    // --------------------------------------------------------------------------

    definitionSeqdefWorkaround {
        \schemaVar \term int lower;
        \schemaVar \term int upper;
        \schemaVar \term Object array;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(seq_def_workaround(h,
                lower,
                upper,
                array
            )
        )
        \varcond(
            \notFreeIn(j, h),
            \notFreeIn(j, array),
            \notFreeIn(j, lower),
            \notFreeIn(j, upper))

        \replacewith(seqDef{j;}(lower,
                upper,
                any::select(h, array, arr(j))
            )
        )
        \heuristics(concrete)
    };

    definitionSeqdefWorkaround2 {
        \schemaVar \term int lower;
        \schemaVar \term int upper;
        \schemaVar \term Object array, o;
        \schemaVar \term Heap h;
        \schemaVar \term Field f;
        \schemaVar \variables int j;

        \find(seq_def_workaround2(h,
                lower,
                upper,
                array,
                singleton(o, f)
            )
        )
        \varcond(
            \notFreeIn(j, h),
            \notFreeIn(j, f),
            \notFreeIn(j, array),
            \notFreeIn(j, lower),
            \notFreeIn(j, upper))

        \replacewith(seqDef{j;}(lower,
                upper,
                any::select(h,
                    Object::select(h, array, arr(j)),
                    f
                )
            )
        )
        \heuristics(concrete)
    };

    // --------------------------------------------------------------------------
    // Definition of array2seq
    // --------------------------------------------------------------------------

    array2seqDef {
        \schemaVar \term Object a;
        \schemaVar \term Heap h;
        \schemaVar \variables int u;
        \find(array2seq(h, a))
        \varcond(\notFreeIn(u, a, h))
        \replacewith(seqDef{u;}(0, length(a), any::select(h, a, arr(u))))
        \heuristics(simplify_enlarging)
    };

    // --------------------------------------------------------------------------
    // Derived taclets for array2seq
    // --------------------------------------------------------------------------

    \lemma
    lenOfArray2seq {
        \schemaVar \term Object a;
        \schemaVar \term Heap h;
        \find(seqLen(array2seq(h, a)))
        \replacewith(length(a))
    };

    \lemma
    getAnyOfArray2seq {
        \schemaVar \term Object a;
        \schemaVar \term int idx;
        \schemaVar \term Heap h;
        \find(any::seqGet(array2seq(h, a), idx))
        \replacewith(any::select(h, a, arr(idx)));
        \add( ==> 0 <= idx & idx < length(a))
    };

    \lemma
    getOfArray2seq {
        \schemaVar \term Object a;
        \schemaVar \term int idx;
        \schemaVar \term Heap h;
        \find(alpha::seqGet(array2seq(h, a), idx))
        \replacewith(alpha::select(h, a, arr(idx)));
        \add( ==> 0 <= idx & idx < length(a))
    };

}
\optionsDecl {
    /*!
    When there is no explicit contract for a method, KeY adds a default contract. This option determines whether to use
    a sound or unsound default. Using the unsound default may be useful during development.
    */
    soundDefaultContracts: {
            /*!
            Unspecified methods get the following default contract:

            public behavior
                ensures true;
                diverges true;
                signals_only Throwable;
                assignable \everything;
            */
            on,

            /*!
            Unspecified method get the following unsound default contract:

            public normal_behavior
                ensures true;
                assignable \strictly_nothing;
            */
            off
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\include ldt;

// Please note that the order in which these files are read does matter in
// order to prove derived taclets sound in KeY (you may only use taclets which
// appear before the one you are about to prove). Do not change this order
// without a good reason.

// general propositional and first-order rules
\include propRule;
\include firstOrderRules;
\include ifThenElseRules;
\include formulaNormalisationRules;
\include updateRules;

// integer rules
\include integerRulesCommon;
\include intRules,
    intRulesUncheckedSemantics,
    intRulesCheckedSemantics,
    intRulesJavaSemantics;
\include integerSimplificationRules;
\include intDiv;
\include bsum, bprod;
\include binaryAxioms, binaryLemmas;
\include intPow;

// float rules
\include floatRulesCommon;
\include floatRules,
    floatRulesVerifyNormal,
    floatRulesAssumeStrictfp;

// \include abs;

// other theories
\include genericRules; // must go before heap, seq
\include booleanRules;
\include epsilon;
\include locSetsRules; // must go before heap
\include heapRules;
\include permissionRules;
\include reachRules;
\include seqCoreRules, seqRules;
\include seqPerm;
\include seqPerm2;

// rules for Java (order does not matter, since not provable anyway)
\include javaRules;
\include loopRules;
\include activeUse;
\include instanceAllocation;
\include java5;
\include integerAssignment2UpdateRules;
\include floatAssignment2UpdateRules;
\include bigint;
\include adtProgramDecompositionRules;

// wellfounded relation
\include precRules;

// rules for strings and regular expressions
\include charListRules;
\include regExTheory; // ____: fix rules and uncomment

// rules for information flow verification
\include seqEq;
\include infFlow;

// size rules for maps
\include mapSize;

// rules for well-definedness
\include wd;

// rules for invariant handling
\include loopInvariantRules;

// rules for for-loops
\include forLoopRules;

// rules for completion scopes
\include execRules;

// rules for loop scope invariant rules
\include loopScopeRules;
\sorts {
  SORT;
  \generic alph;
  \generic bet;
  \generic alphSub \extends alph;
}

\functions {
  SORT anySORT;
  SORT alph::ssort;
}

\predicates {
  ssubsort(SORT, SORT);
}

\rules {
  ssubsortDirect {
    \find(ssubsort(alphSub::ssort, alph::ssort))
    \replacewith(true)
    \heuristics(simplify)
  };

  ssubsortTop {
    \schemaVar \term SORT s;
    \find(ssubsort(s, anySORT))
    \replacewith(true)
    \heuristics(simplify)
  };

  subsortTrans {
    \schemaVar \term SORT s1, s2, s3;
    \assumes (ssubsort(s1, s2), ssubsort(s2, s3) ==>)
    \add(ssubsort(s1, s3) ==>)
    \heuristics(simplify_enlarging)
  };

  ssubsortSup {
    \find(ssubsort(alph::ssort, alphSub::ssort))
    \varcond(\not \same(alphSub, alph))
    \replacewith(false)
    \heuristics(simplify)
  };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\rules {

    // --------------------------------------------------------------------------
    // dropping overwritten and ignored update parts
    // --------------------------------------------------------------------------

    simplifyUpdate1 {
        \schemaVar \update u;
        \schemaVar \term any t, result;

        \find({u}t)
        \varcond(\dropEffectlessElementaries(u, t, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    simplifyUpdate2 {
        \schemaVar \update u;
        \schemaVar \formula phi, result;

        \find({u}phi)
        \varcond(\dropEffectlessElementaries(u, phi, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    simplifyUpdate3 {
        \schemaVar \update u, u2, result;

        \find({u}u2)
        \varcond(\dropEffectlessElementaries(u, u2, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    simplifyIfThenElseUpdate1 {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result, t;

        \find(\if(phi) \then({u1}t) \else({u2}t))
        \varcond(\simplifyIfThenElseUpdate(phi, u1, u2, t, result))

        \replacewith(result)
        \displayname "simplifyIfThenElse"
    };

    simplifyIfThenElseUpdate2 {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result, t;

        \find(\if(phi) \then(t) \else({u2}t))
        \varcond(\simplifyIfThenElseUpdate(phi, u1, u2, t, result))

        \replacewith(result)
        \displayname "simplifyIfThenElse"
    };

    simplifyIfThenElseUpdate3 {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result, t;

        \find(\if(phi) \then({u1}t) \else(t))
        \varcond(\simplifyIfThenElseUpdate(phi, u1, u2, t, result))

        \replacewith(result)
        \displayname "simplifyIfThenElse"
    };

    simplifyIfThenElseUpdate4 {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result, t;

        \find(\if(phi) \then(t) \else(t))
        \varcond(\simplifyIfThenElseUpdate(phi, u1, u2, t, result))

        \replacewith(result)
        \displayname "simplifyIfThenElse"
    };

    // --------------------------------------------------------------------------
    // converting sequential updates to parallel ones
    // (these rules should have better priority than the applyOnRigid rules)
    // --------------------------------------------------------------------------

    sequentialToParallel1 {
        \schemaVar \update u, u2;
        \schemaVar \term any t;

        \find({u}{u2}t)

        \replacewith({u || {u}u2}t)

        \heuristics(update_join)
    };

    sequentialToParallel2 {
        \schemaVar \update u, u2;
        \schemaVar \formula phi;

        \find({u}{u2}phi)

        \replacewith({u || {u}u2}phi)

        \heuristics(update_join)
    };

    sequentialToParallel3 {
        \schemaVar \update u, u2, u3;

        \find({u}{u2}u3)

        \replacewith({u || {u}u2}u3)

        \heuristics(update_join)
    };

    // --------------------------------------------------------------------------
    // update application
    // --------------------------------------------------------------------------

    applyOnRigidTerm {
        \schemaVar \update u;
        \schemaVar \term any t, result;

        \find({u}t)
        \varcond(\applyUpdateOnRigid(u, t, result))

        \replacewith(result)

        \heuristics(update_apply)
    };

    applyOnRigidFormula {
        \schemaVar \update u;
        \schemaVar \formula phi, result;

        \find({u}phi)
        \varcond(\applyUpdateOnRigid(u, phi, result))

        \replacewith(result)

        \heuristics(update_apply)
    };

    applyOnElementary {
        \schemaVar \update u;
        \schemaVar \program Variable #pv;
        \schemaVar \term any t;

        \find({u}( \updateTerm(#pv := t)) )

        \replacewith( \updateTerm(#pv := {u}t) )

        \heuristics(update_apply_on_update)
    };

    applyOnParallel {
        \schemaVar \update u, u2, u3;

        \find({u}(\updateTerm(u2 || u3) ) )

        \replacewith( \updateTerm( {u}u2 || {u}u3 ))

        \heuristics(update_apply_on_update)
    };

    applyOnSkip {
        \schemaVar \update u;

        \find({u}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };

    applyOnPV {
        \schemaVar \program Variable #pv;
        \schemaVar \term any t;

        \find(  {#pv := t}#pv )

        \replacewith(t)

        \heuristics(update_elim)
    };

    // --------------------------------------------------------------------------
    // rules for skip
    // --------------------------------------------------------------------------

    parallelWithSkip1 {
        \schemaVar \update u;

        \find(\updateTerm( skip || u))

        \replacewith(u)

        \heuristics(update_elim)
    };

    parallelWithSkip2 {
        \schemaVar \update u;

        \find(\updateTerm(u || skip))

        \replacewith(u)

        \heuristics(update_elim)
    };

    applySkip1 {
        \schemaVar \term any t;

        \find({skip}t)

        \replacewith(t)

        \heuristics(concrete)
    };

    applySkip2 {
        \schemaVar \formula phi;

        \find({skip}phi)

        \replacewith(phi)

        \heuristics(update_elim)
    };

    applySkip3 {
        \schemaVar \update u;

        \find({skip}u)

        \replacewith(u)

        \heuristics(update_elim)
    };

    // sort updates
    /**    commuteSimpleUpdates {
              \schemaVar \program Variable loc1, loc2;
        \schemaVar \term any val1, val2;
            \schemaVar \update u;

            \find ( loc1:=val1 || loc2 := val2 )
            \varcond(\different(loc1, loc2))
            \replacewith( loc2:=val2 || loc1 := val1 )
        };

        elimSelfUpdateFor {
            \schemaVar \update u;
            \schemaVar \program Variable loc;
            \schemaVar \formula phi;

            \find ( {loc:=loc || u} phi )
            \replacewith( {u} phi )
        \heuristics(update_elim)
        };

        elimSelfSingleUpdateFor {
            \schemaVar \program Variable loc;
            \schemaVar \formula phi;

            \find ( {loc:=loc} phi )
            \replacewith( phi )
        \heuristics(update_elim)

            \displayname "elimSelfUpdate"
        };

        elimSelfUpdateTrm {
            \schemaVar \update u;
            \schemaVar \program Variable loc;
            \schemaVar \term any t;

            \find ( {loc:=loc || u} t )
            \replacewith( {u} t )
        \heuristics(update_elim)

            \displayname "elimSelfUpdate"
        };

        elimSelfSingleUpdateTrm {
            \schemaVar \program Variable loc;
            \schemaVar \term any t;

            \find ( {loc:=loc} t )
            \replacewith( t )
        \heuristics(update_elim)

            \displayname "elimSelfUpdate"
        };
    */
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \formula a, b, c;
    \term any s, t;
    \variables alpha i;
    \variables int j;
    \skolemTerm int jPrime;
    \termlabel l;
}

\rules(wdChecks:on, wdOperator:L) {

    wd_Logical_Op_Neg {

        \find(
            WD(!a)
        )
        \replacewith(
            WD(a)
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_And {

        \find(
            WD((a & b)<<l>>)
        )
        \varcond(
            \not \hasLabel(l, SC)
        )
        \replacewith(
            WD(a) & WD(b)
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_AndSC {

        \find(
            WD(((a & b)<<l>>))
        )
        \varcond(
            \hasLabel(l, SC)
        )
        \replacewith(
            WD(a) & (a -> WD(b))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Or {

        \find(
            WD((a | b)<<l>>)
        )
        \varcond(
            \not \hasLabel(l, SC)
        )
        \replacewith(
            WD(a) & WD(b)
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_OrSC {

        \find(
            WD(((a | b)<<l>>))
        )
        \varcond(
            \hasLabel(l, SC)
        )
        \replacewith(
            WD(a) & (!a -> WD(b))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Imp {

        \find(
            WD((a -> b))
        )
        \replacewith(
            WD(a) & (a -> WD(b))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Eqv {

        \find(
            WD((a <-> b))
        )
        \replacewith(
            WD(a) & WD(b)
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Cond_Expr {

        \find(
            wd(\if(a) \then(s) \else(t))
        )
        \replacewith(
            WD(a) & (a -> wd(s)) & (!a -> wd(t))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Cond_Form {

        \find(
            WD(\if(a) \then(b) \else(c))
        )
        \replacewith(
            WD(a) & (a -> WD(b)) & (!a -> WD(c))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_ExCond_Expr {

        \find(
            wd(\ifEx j; (a) \then(s) \else(t))
        )
        \varcond(
            \notFreeIn(j, t)
        )
        \replacewith(
            (\forall j; WD(a)) & ((\forall j; !a) -> wd(t))
            & (\forall j; (a -> wd(s)))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_ExCond_Form {

        \find(
            WD(\ifEx j; (a)\then(b)\else(c))
        )
        \varcond(
            \notFreeIn(j, c)
        )
        \replacewith(
            (\forall j; WD(a)) & ((\forall j; !a) -> WD(c))
            & (\forall j; (a -> WD(b)))
        )
        \heuristics(simplify)
    };

    wd_Logical_Quant_All {

        \find(
            WD(\forall i; a)
        )
        \replacewith(
            \forall i; WD(a)
        )
        \heuristics(simplify)
    };

    wd_Logical_Quant_Exist {

        \find(
            WD(\exists i; a)
        )
        \replacewith(
            \forall i; WD(a)
        )
        \heuristics(simplify)
    };
}

\rules(wdChecks:on, wdOperator:D) {

    wd_Logical_Op_Neg {

        \find(
            WD(!a)
        )
        \replacewith(
            WD(a)
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_And {

        \find(
            WD((a & b))
        )
        \replacewith(
            (WD(a) & !a) | (WD(b) & !b) | (WD(a) & WD(b))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Or {

        \find(
            WD((a | b))
        )
        \replacewith(
            (WD(a) & a) | (WD(b) & b) | (WD(a) & WD(b))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Imp {

        \find(
            WD((a -> b))
        )
        \replacewith(
            (WD(a) & !a) | (WD(b) & b) | (WD(a) & WD(b))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Eqv {

        \find(
            WD((a <-> b))
        )
        \replacewith(
            WD(a) & WD(b)
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Cond_Expr {

        \find(
            wd(\if(a) \then(s) \else(t))
        )
        \replacewith(
            (WD(a) & wd(s) & a) | (WD(a) & wd(t) & !a) | (wd(s) & wd(t) & (s = t))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Cond_Form {

        \find(
            WD(\if(a) \then(b) \else(c))
        )
        \replacewith(
            (WD(a) & WD(b) & a) | (WD(a) & WD(c) & !a) | (WD(b) & WD(c) & (b <-> c))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_ExCond_Expr {

        \find(
            wd(\ifEx j; (a)\then(s)\else(t))
        )
        \varcond(
            \notFreeIn(j, t),
            \notFreeIn(j, jPrime),
            \newDependingOn(jPrime, a)
        )
        \replacewith(
            (\exists j; (WD(a) & wd(s) & a
                    & ((wellOrderLeqInt(jPrime, j) & (jPrime != j)) -> {\subst j; jPrime}(WD(a) & !a))))
            | (\forall j; (WD(a) & wd(t) & !a))
            | (\forall j; (wd(s) & wd(t) & (s = t)))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_ExCond_Form {

        \find(
            WD(\ifEx j; (a)\then(b)\else(c))
        )
        \varcond(
            \notFreeIn(j, c),
            \notFreeIn(j, jPrime),
            \newDependingOn(jPrime, a)
        )
        \replacewith(
            (\exists j; (WD(a) & WD(b) & a
                    & ((wellOrderLeqInt(jPrime, j) & (jPrime != j)) -> {\subst j; jPrime}(WD(a) & !a))))
            | (\forall j; (WD(a) & WD(c) & !a))
            | (\forall j; (WD(b) & WD(c) & (b <-> c)))
        )
        \heuristics(simplify)
    };

    wd_Logical_Quant_All {

        \find(
            WD(\forall i; a)
        )
        \replacewith(
            (\exists i; (WD(a) & !a)) | (\forall i; WD(a))
        )
        \heuristics(simplify)
    };

    wd_Logical_Quant_Exist {

        \find(
            WD(\exists i; a)
        )
        \replacewith(
            (\exists i; (WD(a) & a)) | (\forall i; WD(a))
        )
        \heuristics(simplify)
    };
}

\rules(wdChecks:on, wdOperator:Y) {

    wd_T_Logical_Op_Neg {

        \find(
            T(!a)
        )
        \replacewith(
            F(a)
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Op_Neg {

        \find(
            F(!a)
        )
        \replacewith(
            T(a)
        )
        \heuristics(simplify)
    };

    wd_T_Logical_Op_And {

        \find(
            T((a & b))
        )
        \replacewith(
            T(a) & T(b)
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Op_And {

        \find(
            F((a & b))
        )
        \replacewith(
            F(a) | F(b)
        )
        \heuristics(simplify)
    };

    wd_T_Logical_Op_Or {

        \find(
            T((a | b))
        )
        \replacewith(
            T(a) | T(b)
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Op_Or {

        \find(
            F((a | b))
        )
        \replacewith(
            F(a) & F(b)
        )
        \heuristics(simplify)
    };

    wd_T_Logical_Op_Imp {

        \find(
            T((a -> b))
        )
        \replacewith(
            F(a) | T(b)
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Op_Imp {

        \find(
            F((a -> b))
        )
        \replacewith(
            T(a) & F(b)
        )
        \heuristics(simplify)
    };

    wd_T_Logical_Op_Eqv {

        \find(
            T((a <-> b))
        )
        \replacewith(
            (T(a) & T(b)) | (F(a) & F(b))
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Op_Eqv {

        \find(
            F((a <-> b))
        )
        \replacewith(
            (T(a) & F(b)) | (F(a) & T(b))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_Cond_Expr {

        \find(
            wd(\if(a) \then(s) \else(t))
        )
        \replacewith(
            (T(a) & wd(s)) | (F(a) & wd(t)) | (wd(s) & wd(t) & (s = t))
        )
        \heuristics(simplify)
    };

    wd_T_Logical_Op_Cond_Form {

        \find(
            T(\if(a) \then(b) \else(c))
        )
        \replacewith(
            (T(a) & T(b)) | (F(a) & T(c)) | (T(b) & T(c))
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Op_Cond_Form {

        \find(
            F(\if(a) \then(b) \else(c))
        )
        \replacewith(
            (T(a) & F(b)) | (F(a) & F(c)) | (F(b) & F(c))
        )
        \heuristics(simplify)
    };

    wd_Logical_Op_ExCond_Expr {

        \find(
            wd(\ifEx j; (a)\then(s)\else(t))
        )
        \varcond(
            \notFreeIn(j, t),
            \notFreeIn(j, jPrime),
            \newDependingOn(jPrime, a)
        )
        \replacewith(
            (\exists j; (T(a) & wd(s)
                    & ((wellOrderLeqInt(jPrime, j) & (jPrime != j)) -> {\subst j; jPrime}F(a))))
            | (\forall j; (F(a) & wd(t)))
            | (\forall j; (wd(s) & wd(t) & (s = t)))
        )
        \heuristics(simplify)
    };

    wd_T_Logical_Op_ExCond_Form {

        \find(
            T(\ifEx j; (a)\then(b)\else(c))
        )
        \varcond(
            \notFreeIn(j, c),
            \notFreeIn(j, jPrime),
            \newDependingOn(jPrime, a)
        )
        \replacewith(
            (\exists j; (T(a) & T(b)
                    & ((wellOrderLeqInt(jPrime, j) & (jPrime != j)) -> {\subst j; jPrime}F(a))))
            | (\forall j; (F(a) & T(c)))
            | (\forall j; (T(b) & T(c)))
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Op_ExCond_Form {

        \find(
            F(\ifEx j; (a)\then(b)\else(c))
        )
        \varcond(
            \notFreeIn(j, c),
            \notFreeIn(j, jPrime),
            \newDependingOn(jPrime, a)
        )
        \replacewith(
            (\exists j; (T(a) & F(b)
                    & ((wellOrderLeqInt(jPrime, j) & (jPrime != j)) -> {\subst j; jPrime}F(a))))
            | (\forall j; (F(a) & F(c)))
            | (\forall j; (F(b) & F(c)))
        )
        \heuristics(simplify)
    };

    wd_T_Logical_Quant_All {

        \find(
            T(\forall i; a)
        )
        \replacewith(
            \forall i; T(a)
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Quant_All {

        \find(
            F(\forall i; a)
        )
        \replacewith(
            \exists i; F(a)
        )
        \heuristics(simplify)
    };

    wd_T_Logical_Quant_Exist {

        \find(
            T(\exists i; a)
        )
        \replacewith(
            \exists i; T(a)
        )
        \heuristics(simplify)
    };

    wd_F_Logical_Quant_Exist {

        \find(
            F(\exists i; a)
        )
        \replacewith(
            \forall i; F(a)
        )
        \heuristics(simplify)
    };

    // Split and resolve rules

    wd_Y_Split {

        \find(
            WD(a)
        )
        \varcond(
            \hasSubFormulas(a)
        )
        \replacewith(
            T(a) | F(a)
        )
        \heuristics(simplify)
    };

    wd_T_Resolve {

        \find(
            T(a)
        )
        \varcond(
            \not \hasSubFormulas(a)
        )
        \replacewith(
            WD(a) & a
        )
        \heuristics(simplify)
    };

    wd_F_Resolve {

        \find(
            F(a)
        )
        \varcond(
            \not \hasSubFormulas(a)
        )
        \replacewith(
            WD(a) & !a
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \formula f;
    \term any s, t;
    \term alpha u;
    \variables alpha v;
    \termlabel l;
}

\rules(wdChecks:on) {
    wd_Constant_Formula {

        \find(
            WD((f)<<l>>)
        )
        \varcond(
            \isConstant(f),
            \not \hasLabel(l, undef)
        )
        \replacewith(
            true
        )
        \heuristics(simplify)
    };

    wd_Constant_Term {

        \find(
            wd((t)<<l>>)
        )
        \varcond(
            \isConstant(t),
            \not \hasLabel(l, undef)
        )
        \replacewith(
            true
        )
        \heuristics(simplify)
    };

    wd_Undef_Formula {

        \find(
            WD((f)<<l>>)
        )
        \varcond(
            \isConstant(f),
            \hasLabel(l, undef)
        )
        \replacewith(
            false
        )
        \heuristics(simplify)
    };

    wd_Undef_Term {

        \find(
            wd((t)<<l>>)
        )
        \varcond(
            \isConstant(t),
            \hasLabel(l, undef)
        )
        \replacewith(
            false
        )
        \heuristics(simplify)
    };

    wd_Subst_Formula {

        \find(
            WD({\subst v; u}f)
        )
        \replacewith(
            wd(u) & {\subst v; u}WD(f)
        )
        \heuristics(simplify)
    };

    wd_T_Subst_Formula {

        \find(
            T({\subst v; u}f)
        )
        \replacewith(
            wd(u) & {\subst v; u}T(f)
        )
        \heuristics(simplify)
    };

    wd_F_Subst_Formula {

        \find(
            F({\subst v; u}f)
        )
        \replacewith(
            wd(u) & {\subst v; u}F(f)
        )
        \heuristics(simplify)
    };

    wd_Subst_Term {

        \find(
            wd({\subst v; u}t)
        )
        \replacewith(
            wd(u) & {\subst v; u}wd(t)
        )
        \heuristics(simplify)
    };

    wd_Type_Cast {

        \find(
            wd(alpha::cast(t))
        )
        \replacewith(
            wd(t) & (alpha::instance(t) = TRUE)
        )
        \heuristics(simplify)
    };

    wd_Type_ExactInstance {

        \find(
            wd(alpha::exactInstance(t))
        )
        \replacewith(
            wd(t)
        )
        \heuristics(simplify)
    };

    wd_Type_Instance {

        \find(
            wd(alpha::instance(t))
        )
        \replacewith(
            wd(t)
        )
        \heuristics(simplify)
    };

    wd_Pair {

        \find(
            wd(pair(s, t))
        )
        \replacewith(
            wd(s) & wd(t)
        )
        \heuristics(simplify)
    };

    wd_Equality_Pred {

        \find(
            WD((s = t))
        )
        \replacewith(
            wd(s) & wd(t)
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\transformers {
    \formula wd(any);
    \formula WD(\formula);
    \formula T(\formula);
    \formula F(\formula);
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term any a, b;
    \term int i;
    \term Heap g, h;
    \term Object o;
    \term Field f;
    \term LocSet l;
}

\rules(wdChecks:on) {
    wd_Heap_ArrLength {

        \find(
            wd(length(o))
        )
        \varcond(
            \isArray(o)
        )
        \replacewith(
            wd(o) & o != null
        )
        \heuristics(simplify)
    };

    wd_Heap_Create {

        \find(
            wd(create(h, o))
        )
        \replacewith(
            wd(h) & wd(o) & wellFormed(h) & o != null
        )
        \heuristics(simplify)
    };

    wd_Heap_Reference_Created {

        \find(
            wd(alpha::select(h, o, java.lang.Object::<created>))
        )
        \replacewith(
            wd(h) & wd(o) & wellFormed(h) & o != null
        )
        \heuristics(simplify)
    };

    wd_Heap_Reference {

        \find(
            wd(alpha::select(h, o, f))
        )
        \varcond(
            \not \isArray(o),
            \not \isStaticField(f)
        )
        \replacewith(
            wd(h) & wd(o) & wd(f) & wellFormed(h) & o != null
            & (f = java.lang.Object::<created> | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
        )
        \heuristics(simplify)
    };

    wd_Heap_Reference_Static {

        \find(
            wd(alpha::select(h, o, f))
        )
        \varcond(
            \not \isArray(o),
            \isStaticField(f)
        )
        \replacewith(
            wd(h) & wd(o) & wd(f) & wellFormed(h) & o = null
        )
        \heuristics(simplify)
    };

    wd_Heap_Reference_Array {

        \find(
            wd(alpha::select(h, o, arr(i)))
        )
        \varcond(
            \isArray(o)
        )
        \replacewith(
            wd(h) & wd(o) & wd(i) & wellFormed(h) & o != null
            & boolean::select(h, o, java.lang.Object::<created>) = TRUE
            & leq(0, i) & lt(i, length(o))
        )
        \heuristics(simplify)
    };

    wd_Heap_Anon {

        \find(
            wd(anon(h, l, g))
        )
        \replacewith(
            wd(h) & wd(l) & wd(g) & wellFormed(h) & wellFormed(g)
        )
        \heuristics(simplify)
    };

    wd_Heap_Memset {

        \find(
            wd(memset(h, l, a))
        )
        \replacewith(
            wd(h) & wd(l) & wd(a) & wellFormed(h)
        )
        \heuristics(simplify)
    };

    wd_Heap_Store {

        \find(
            wd(store(h, o, f, a))
        )
        \replacewith(
            wd(h) & wd(o) & wd(f) & wd(a) & wellFormed(h) & o != null
            & boolean::select(h, o, java.lang.Object::<created>) = TRUE
        )
        \heuristics(simplify)
    };

    wd_Heap_Pred_WellFormed {

        \find(
            WD(wellFormed(h))
        )
        \replacewith(
            wd(h)
        )
        \heuristics(simplify)
    };

    wd_Heap_Pred_ArrStoreValid {
        \find(
            WD(arrayStoreValid(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_Heap_Pred_NonNull {
        \find(
            WD(nonNull(h, o, i))
        )
        \replacewith(
            wd(h) & wd(o) & wd(i)
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
 * These files contain the rules for resolving the well-definedness
 * transformers (WD(Formula) and wd(any)). For formulas, these
 * rules are defined for the three different operators L, D and Y
 * (for more information on those, please consult the explanations in
 * the taclet options).
 * If you want to add new theories to KeY, please also write rules
 * defining the well-definedness of your new functions and predicates
 * and include them here.
 *
 * author Michael Kirsten
 */

\include wdHeader;
\include wdGeneralRules;
\include wdNumericalRules;
\include wdLocSetRules;
\include wdHeapRules;
\include wdReachRules;
\include wdSeqRules;
\include wdStringRules;
\include wdRegExRules;
\include wdFormulaRules;
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term int i, j;
    \term Heap h;
    \variables alpha a;
    \variables beta b;
    \variables Field c;
    \term Object o;
    \term Field f;
    \term LocSet l, s;
}

\rules(wdChecks:on) {
    wd_LocSet_AllFields {

        \find(
            wd(allFields(o))
        )
        \varcond(
            \not \isArray(o)
        )
        \replacewith(
            wd(o)
        )
        \heuristics(simplify)
    };

    wd_LocSet_AllFieldsArr {

        \find(
            wd(allFields(o))
        )
        \varcond(
            \isArray(o)
        )
        \replacewith(
            wd(o) & o != null
        )
        \heuristics(simplify)
    };

    wd_LocSet_AllObjects {

        \find(
            wd(allObjects(f))
        )
        \replacewith(
            wd(f)
        )
        \heuristics(simplify)
    };

    wd_LocSet_FreshLocs {

        \find(
            wd(freshLocs(h))
        )
        \replacewith(
            wd(h) & wellFormed(h)
        )
        \heuristics(simplify)
    };

    wd_LocSet_Singleton {

        \find(
            wd(singleton(o, f))
        )
        \varcond(
            \not \isArray(o),
            \not \isStaticField(f)
        )
        \replacewith(
            wd(o) & wd(f) & o != null
        )
        \heuristics(simplify)
    };

    wd_LocSet_Singleton_Static {

        \find(
            wd(singleton(o, f))
        )
        \varcond(
            \not \isArray(o),
            \isStaticField(f)
        )
        \replacewith(
            wd(o) & wd(f) & o = null
        )
        \heuristics(simplify)
    };

    wd_LocSet_Singleton_Arr {

        \find(
            wd(singleton(o, arr(i)))
        )
        \varcond(
            \isArray(o)
        )
        \replacewith(
            wd(o) & wd(i) & o != null & leq(0, i) & lt(i, length(o))
        )
        \heuristics(simplify)
    };

    wd_LocSet_Singleton_Quant {

        \find(
            \forall c; wd(singleton(o, f))
        )
        \varcond(
            \not \isArray(o)
        )
        \replacewith(
            \forall c; (wd(o) & wd(f))
        )
        \heuristics(simplify)
    };

    wd_LocSet_Union {

        \find(
            wd(union(l, s))
        )
        \replacewith(
            wd(l) & wd(s)
        )
        \heuristics(simplify)
    };

    wd_LocSet_Intersect {
        \find(
            wd(intersect(l, s))
        )
        \replacewith(
            wd(l) & wd(s)
        )
        \heuristics(simplify)
    };

    wd_LocSet_Diff {

        \find(
            wd(setMinus(l, s))
        )
        \replacewith(
            wd(l) & wd(s)
        )
        \heuristics(simplify)
    };

    wd_LocSet_ArrRange {

        \find(
            wd(arrayRange(o, i, j))
        )
        \varcond(
            \isArray(o)
        )
        \replacewith(
            wd(o) & wd(i) & wd(j) & o != null & leq(0, i) & leq(i, j) & lt(j, length(o))
        )
        \heuristics(simplify)
    };

    wd_LocSet_AllElemsArr {

        \find(
            wd(allElementsOfArray(h, o, l))
        )
        \varcond(
            \isArray(o)
        )
        \replacewith(
            wd(h) & wd(o) & wd(l) & wellFormed(h) & o != null
            & boolean::select(h, o, java.lang.Object::<created>) = TRUE
        )
        \heuristics(simplify)
    };

    wd_LocSet_AllElemsArrLocsets {

        \find(
            wd(allElementsOfArrayLocsets(h, o, l))
        )
        \varcond(
            \isArray(o)
        )
        \replacewith(
            wd(h) & wd(o) & wd(l) & wellFormed(h) & o != null
            & boolean::select(h, o, java.lang.Object::<created>) = TRUE
        )
        \heuristics(simplify)
    };

    wd_LocSet_InfiniteUnion {

        \find(
            wd(infiniteUnion{a;}(l))
        )
        \replacewith(
            \forall a; wd(l)
        )
        \heuristics(simplify)
    };

    wd_LocSet_InfiniteUnion2 {

        \find(
            wd(infiniteUnion{a, b;}(l))
        )
        \replacewith(
            \forall a; (\forall b; wd(l))
        )
        \heuristics(simplify)
        \displayname "wd_LocSet_InfiniteUnion"
    };

    wd_LocSet_Pred_ElementOf {

        \find(
            WD(elementOf(o, f, l))
        )
        \varcond(
            \not \isStaticField(f)
        )
        \replacewith(
            wd(o) & wd(f) & wd(l) & o != null
        )
        \heuristics(simplify)
    };

    wd_LocSet_Pred_ElementOf_Static {

        \find(
            WD(elementOf(o, f, l))
        )
        \varcond(
            \isStaticField(f)
        )
        \replacewith(
            wd(o) & wd(f) & wd(l) & o = null
        )
        \heuristics(simplify)
    };

    wd_LocSet_Pred_Subset {

        \find(
            WD(subset(l, s))
        )
        \replacewith(
            wd(l) & wd(s)
        )
        \heuristics(simplify)
    };

    wd_LocSet_Pred_Disjoint {
        \find(
            WD(disjoint(l, s))
        )
        \replacewith(
            wd(l) & wd(s)
        )
        \heuristics(simplify)
    };

    wd_LocSet_Pred_InHeap {

        \find(
            WD(createdInHeap(l, h))
        )
        \replacewith(
            wd(l) & wd(h) & wellFormed(h)
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term int a, b, c;
    \term boolean f;
    \variables int i;
    \variables alpha j;
    \term numbers n;
}

\rules(wdChecks:on) {
    wd_Numerical_Const {

        \find(
            wd(n)
        )
        \replacewith(
            true
        )
        \heuristics(simplify)
    };

    wd_Numerical_Const_Z {

        \find(
            wd(Z(n))
        )
        \replacewith(
            true
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Const"
    };

    wd_Numerical_Const_C {

        \find(
            wd(C(n))
        )
        \replacewith(
            true
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Const"
    };

    wd_Numerical_Op_Neg {
        \find(
            wd(neg(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_BitNegInt {
        \find(
            wd(javaBitwiseNegateInt(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Neg"
    };

    wd_Numerical_Op_BitNegLong {
        \find(
            wd(javaBitwiseNegateLong(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Neg"
    };

    wd_Numerical_Op_CheckedBitNegInt {
        \find(
            wd(checkedBitwiseNegateInt(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Neg"
    };

    wd_Numerical_Op_CheckedBitNegLong {
        \find(
            wd(checkedBitwiseNegateLong(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Neg"
    };

    wd_Numerical_Op_MinusJInt {

        \find(
            wd(unaryMinusJint(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Minus"
    };

    wd_Numerical_Op_MinusJLong {

        \find(
            wd(unaryMinusJlong(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Minus"
    };

    wd_Numerical_Op_CheckedMinusInt {

        \find(
            wd(checkedUnaryMinusInt(a))
        )
        \replacewith(
            wd(a) & inRangeInt(checkedUnaryMinusInt(a))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedMinusLong {

        \find(
            wd(checkedUnaryMinusLong(a))
        )
        \replacewith(
            wd(a) & inRangeInt(checkedUnaryMinusLong(a))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_MinusInt {

        \find(
            wd(javaUnaryMinusInt(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Minus"
    };

    wd_Numerical_Op_MinusLong {

        \find(
            wd(javaUnaryMinusLong(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Minus"
    };

    wd_Numerical_Op_MinusIntOverFlow {

        \find(
            wd(javaUnaryMinusIntOverFlow(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Minus"
    };

    wd_Numerical_Op_MinusLongOverFlow {

        \find(
            wd(javaUnaryMinusLongOverFlow(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Minus"
    };

    wd_Numerical_Cast_Byte {

        \find(
            wd(javaCastByte(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_Short {

        \find(
            wd(javaCastShort(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_Int {

        \find(
            wd(javaCastInt(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_Long {

        \find(
            wd(javaCastLong(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_Char {

        \find(
            wd(javaCastChar(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_ByteOverFlow {

        \find(
            wd(javaCastByteOverFlow(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_ShortOverFlow {

        \find(
            wd(javaCastShortOverFlow(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_IntOverFlow {

        \find(
            wd(javaCastIntOverFlow(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_LongOverFlow {

        \find(
            wd(javaCastLongOverFlow(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Cast_CharOverFlow {

        \find(
            wd(javaCastCharOverFlow(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Cast"
    };

    wd_Numerical_Mod_Byte {

        \find(
            wd(moduloByte(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Mod"
    };

    wd_Numerical_Mod_Short {

        \find(
            wd(moduloShort(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Mod"
    };

    wd_Numerical_Mod_Int {

        \find(
            wd(moduloInt(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Mod"
    };

    wd_Numerical_Mod_Long {

        \find(
            wd(moduloLong(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Mod"
    };

    wd_Numerical_Mod_Char {

        \find(
            wd(moduloChar(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Mod"
    };

    wd_Numerical_Op_Add {

        \find(
            wd(add(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_AddJInt {

        \find(
            wd(addJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Add"
    };

    wd_Numerical_Op_AddJLong {

        \find(
            wd(addJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Add"
    };

    wd_Numerical_Op_CheckedAddInt {

        \find(
            wd(checkedAddInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedAddInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedAddLong {

        \find(
            wd(checkedAddLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedAddLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_AddInt {

        \find(
            wd(javaAddInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Add"
    };

    wd_Numerical_Op_AddLong {

        \find(
            wd(javaAddLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Add"
    };

    wd_Numerical_Op_AddIntOverFlow {

        \find(
            wd(javaAddIntOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Add"
    };

    wd_Numerical_Op_AddLongOverFlow {

        \find(
            wd(javaAddLongOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Add"
    };

    wd_Numerical_Op_Sub {

        \find(
            wd(sub(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedSubInt {

        \find(
            wd(checkedSubInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedSubInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedSubLong {

        \find(
            wd(checkedSubLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedSubLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_SubJInt {

        \find(
            wd(subJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Sub"
    };

    wd_Numerical_Op_SubJLong {

        \find(
            wd(subJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Sub"
    };

    wd_Numerical_Op_SubInt {

        \find(
            wd(javaSubInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Sub"
    };

    wd_Numerical_Op_SubLong {

        \find(
            wd(javaSubLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Sub"
    };

    wd_Numerical_Op_SubIntOverFlow {

        \find(
            wd(javaSubIntOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Sub"
    };

    wd_Numerical_Op_SubLongOverFlow {

        \find(
            wd(javaSubLongOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Sub"
    };

    wd_Numerical_Op_Mul {

        \find(
            wd(mul(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedMulInt {

        \find(
            wd(checkedMulInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedMulInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedMulLong {

        \find(
            wd(checkedMulLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedMulLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_MulJInt {

        \find(
            wd(mulJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mul"
    };

    wd_Numerical_Op_MulJLong {

        \find(
            wd(mulJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mul"
    };

    wd_Numerical_Op_MulInt {

        \find(
            wd(javaMulInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mul"
    };

    wd_Numerical_Op_MulLong {

        \find(
            wd(javaMulLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mul"
    };

    wd_Numerical_Op_MulIntOverFlow {

        \find(
            wd(javaMulIntOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mul"
    };

    wd_Numerical_Op_MulLongOverFlow {

        \find(
            wd(javaMulLongOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mul"
    };

    wd_Numerical_Op_Div {

        \find(
            wd(div(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_JDiv {

        \find(
            wd(jdiv(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Div"
    };

    wd_Numerical_Op_CheckedDivInt {

        \find(
            wd(checkedDivInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedDivInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedDivLong {

        \find(
            wd(checkedDivLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedDivLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_DivJInt {

        \find(
            wd(divJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Div"
    };

    wd_Numerical_Op_DivJLong {

        \find(
            wd(divJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Div"
    };

    wd_Numerical_Op_DivInt {

        \find(
            wd(javaDivInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Div"
    };

    wd_Numerical_Op_DivLong {

        \find(
            wd(javaDivLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Div"
    };

    wd_Numerical_Op_DivIntOverFlow {

        \find(
            wd(javaDivIntOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Div"
    };

    wd_Numerical_Op_DivLongOverFlow {

        \find(
            wd(javaDivLongOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Div"
    };

    wd_Numerical_Op_CheckedShiftRightInt {

        \find(
            wd(checkedShiftRightInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedShiftRightInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedShiftRightLong {

        \find(
            wd(checkedShiftRightLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedShiftRightLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_ShiftRightInt {

        \find(
            wd(shiftrightJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftRight"
    };

    wd_Numerical_Op_ShiftRightLong {

        \find(
            wd(shiftrightJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftRight"
    };

    wd_Numerical_Op_CheckedShiftLeftInt {

        \find(
            wd(checkedShiftLeftInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedShiftLeftInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedShiftLeftLong {

        \find(
            wd(checkedShiftLeftLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedShiftLeftLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_ShiftLeftInt {

        \find(
            wd(shiftleftJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftLeft"
    };

    wd_Numerical_Op_ShiftLeftLong {

        \find(
            wd(shiftleftJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftLeft"
    };

    wd_Numerical_Op_CheckedUShiftRightInt {

        \find(
            wd(checkedUnsignedShiftRightInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedUnsignedShiftRightInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedUShiftRightLong {

        \find(
            wd(checkedUnsignedShiftRightLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedUnsignedShiftRightLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_UShiftRightInt {

        \find(
            wd(unsignedshiftrightJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftRight"
    };

    wd_Numerical_Op_UShiftRightLong {

        \find(
            wd(unsignedshiftrightJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftRight"
    };

    wd_Numerical_Op_OrJInt {

        \find(
            wd(orJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Or"
    };

    wd_Numerical_Op_OrJLong {

        \find(
            wd(orJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Or"
    };

    wd_Numerical_Op_CheckedBitwiseOrInt {

        \find(
            wd(checkedBitwiseOrInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedBitwiseOrInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedBitwiseOrLong {

        \find(
            wd(checkedBitwiseOrLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedBitwiseOrLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_BitOrInt {

        \find(
            wd(javaBitwiseOrInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Or"
    };

    wd_Numerical_Op_BitOrLong {

        \find(
            wd(javaBitwiseOrLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Or"
    };

    wd_Numerical_Op_CheckedBitwiseAndInt {

        \find(
            wd(checkedBitwiseAndInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedBitwiseAndInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_checkedBitwiseAndLong {

        \find(
            wd(checkedBitwiseAndLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedBitwiseAndLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_AndJInt {

        \find(
            wd(andJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_And"
    };

    wd_Numerical_Op_AndJLong {

        \find(
            wd(andJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_And"
    };

    wd_Numerical_Op_BitAndInt {

        \find(
            wd(javaBitwiseAndInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_And"
    };

    wd_Numerical_Op_BitAndLong {

        \find(
            wd(javaBitwiseAndLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_And"
    };

    wd_Numerical_Op_CheckedBitwiseXOrInt {

        \find(
            wd(checkedBitwiseXOrInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedBitwiseXOrInt(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_CheckedBitwiseXOrLong {

        \find(
            wd(checkedBitwiseXOrLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & inRangeInt(checkedBitwiseXOrLong(a, b))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_XorJInt {

        \find(
            wd(xorJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Xor"
    };

    wd_Numerical_Op_XorJLong {

        \find(
            wd(xorJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Xor"
    };

    wd_Numerical_Op_BitXOrInt {

        \find(
            wd(javaBitwiseXOrInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Xor"
    };

    wd_Numerical_Op_BitXOrLong {

        \find(
            wd(javaBitwiseXOrLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Xor"
    };

    wd_Numerical_Op_Mod {

        \find(
            wd(mod(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Op_JMod {

        \find(
            wd(jmod(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mod"
    };

    wd_Numerical_Op_ModJInt {

        \find(
            wd(modJint(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mod"
    };

    wd_Numerical_Op_ModJLong {

        \find(
            wd(modJlong(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mod"
    };

    wd_Numerical_Op_JavaMod {

        \find(
            wd(javaMod(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mod"
    };

    wd_Numerical_Op_JavaModOverFlow {

        \find(
            wd(javaModOverFlow(a, b))
        )
        \replacewith(
            wd(a) & wd(b) & (b != 0)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_Mod"
    };

    wd_Numerical_Op_JavaShiftRightInt {

        \find(
            wd(javaShiftRightInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftRight"
    };

    wd_Numerical_Op_JavaShiftRightLong {

        \find(
            wd(javaShiftRightLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftRight"
    };

    wd_Numerical_Op_JavaShiftLeftInt {

        \find(
            wd(javaShiftLeftInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftLeft"
    };

    wd_Numerical_Op_JavaShiftLeftLong {

        \find(
            wd(javaShiftLeftLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftLeft"
    };

    wd_Numerical_Op_JavaUnsignedShiftRightInt {

        \find(
            wd(javaUnsignedShiftRightInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftRight"
    };

    wd_Numerical_Op_JavaUnsignedShiftRightLong {

        \find(
            wd(javaUnsignedShiftRightLong(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
        \displayname "wd_Numerical_Op_ShiftRight"
    };

    wd_Numerical_Quant_Bsum {

        \find(
            wd(bsum{i;}(a, b, c))
        )
        \varcond(
            \notFreeIn(i, a),
            \notFreeIn(i, b)
        )
        \replacewith(
            wd(a) & wd(b) & \forall i; ((leq(a, i) & lt(i, b)) -> wd(c))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Quant_Sum {

        \find(
            wd(sum{j;}(f, c))
        )
        \replacewith(
            \forall j; wd(f) & \forall j; ((f = TRUE) -> wd(c))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Quant_Bprod {

        \find(
            wd(bprod{i;}(a, b, c))
        )
        \varcond(
            \notFreeIn(i, a),
            \notFreeIn(i, b)
        )
        \replacewith(
            wd(a) & wd(b) & \forall i; ((leq(a, i) & lt(i, b)) -> wd(c))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Quant_Prod {

        \find(
            wd(prod{j;}(f, c))
        )
        \replacewith(
            \forall j; wd(f) & \forall j; ((f = TRUE) -> wd(c))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Quant_Min {

        \find(
            wd(min{j;}(f, c))
        )
        \replacewith(
            \forall j; wd(f) & \forall j; ((f = TRUE) -> wd(c))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Quant_Max {

        \find(
            wd(max{j;}(f, c))
        )
        \replacewith(
            \forall j; wd(f) & \forall j; ((f = TRUE) -> wd(c))
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_InByte {

        \find(
            WD(inByte(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_InChar {

        \find(
            WD(inChar(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_InShort {

        \find(
            WD(inShort(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_InInt {

        \find(
            WD(inInt(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_InLong {

        \find(
            WD(inLong(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_inRangeByte {

        \find(
            WD(inRangeByte(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_inRangeChar {

        \find(
            WD(inRangeChar(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_inRangeShort {

        \find(
            WD(inRangeShort(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_inRangeInt {

        \find(
            WD(inRangeInt(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_inRangeLong {

        \find(
            WD(inRangeLong(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_Lt {

        \find(
            WD(lt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_Leq {

        \find(
            WD(leq(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_Gt {

        \find(
            WD(gt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_Geq {

        \find(
            WD(geq(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_Numerical_Pred_WellOrdered {

        \find(
            WD(wellOrderLeqInt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term int i;
    \term Heap h;
    \term Object o, p;
    \term LocSet l;
}

\rules(wdChecks:on) {
    wd_Reach_Pred_Acc {

        \find(
            WD(acc(h, l, o, p))
        )
        \replacewith(
            wd(h) & wd(l) & wd(o) & wd(p) & wellFormed(h)
        )
        \heuristics(simplify)
    };

    wd_Reach_Pred_Reach {

        \find(
            WD(reach(h, l, o, p, i))
        )
        \replacewith(
            wd(h) & wd(l) & wd(o) & wd(p) & wd(i) & wellFormed(h)
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term int n;
    \term Seq s;
    \term RegEx a, b;
}

\rules(wdChecks:on) {
    wd_RegEx {

        \find(
            wd(regEx(s))
        )
        \replacewith(
            wd(s)
        )
        \heuristics(simplify)
    };

    wd_RegEx_Opt {

        \find(
            wd(opt(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_RegEx_Alt {

        \find(
            wd(alt(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_RegEx_Concat {

        \find(
            wd(regExConcat(a, b))
        )
        \replacewith(
            wd(a) & wd(b)
        )
        \heuristics(simplify)
    };

    wd_RegEx_Repeat {

        \find(
            wd(repeat(a, n))
        )
        \replacewith(
            wd(a) & leq(0, n)
        )
        \heuristics(simplify)
    };

    wd_RegEx_Star {

        \find(
            wd(repeatStar(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_RegEx_Plus {

        \find(
            wd(repeatPlus(a))
        )
        \replacewith(
            wd(a)
        )
        \heuristics(simplify)
    };

    wd_RegEx_Pred_Match {

        \find(
            WD(match(a, s))
        )
        \replacewith(
            wd(a) & wd(s)
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term any t;
    \term int m, n;
    \variables int i;
    \term Seq s, q;
}

\rules(wdChecks:on) {
    wd_Seq_Length {

        \find(
            wd(seqLen(s))
        )
        \replacewith(
            wd(s)
        )
        \heuristics(simplify)
    };

    wd_Seq_Singleton {

        \find(
            wd(seqSingleton(t))
        )
        \replacewith(
            wd(t)
        )
        \heuristics(simplify)
    };

    wd_Seq_Reverse {

        \find(
            wd(seqReverse(s))
        )
        \replacewith(
            wd(s)
        )
        \heuristics(simplify)
    };

    wd_Seq_NPermInv {

        \find(
            wd(seqNPermInv(s))
        )
        \replacewith(
            wd(s) & seqNPerm(s)
        )
        \heuristics(simplify)
    };

    wd_Seq_Get {

        \find(
            wd(alpha::seqGet(s, n))
        )
        \replacewith(
            wd(s) & wd(n) & leq(0, n) & lt(n, seqLen(s))
        )
        \heuristics(simplify)
    };

    wd_Seq_IndexOf {

        \find(
            wd(seqIndexOf(s, t))
        )
        \replacewith(
            wd(s) & wd(t)
        )
        \heuristics(simplify)
    };

    wd_Seq_Concat {

        \find(
            wd(seqConcat(s, q))
        )
        \replacewith(
            wd(s) & wd(q)
        )
        \heuristics(simplify)
    };

    wd_Seq_Remove {

        \find(
            wd(seqRemove(s, n))
        )
        \replacewith(
            wd(s) & wd(n) & leq(0, n) & lt(n, seqLen(s))
        )
        \heuristics(simplify)
    };

    wd_Seq_Sub {

        \find(
            wd(seqSub(s, m, n))
        )
        \replacewith(
            wd(s) & wd(m) & wd(n) & leq(0, m) & leq(m, n) & leq(n, seqLen(s))
        )
        \heuristics(simplify)
    };

    wd_Seq_Swap {

        \find(
            wd(seqSwap(s, m, n))
        )
        \replacewith(
            wd(s) & wd(m) & wd(n) & leq(0, m) & leq(0, n) & lt(m, seqLen(s)) & lt(n, seqLen(s))
        )
        \heuristics(simplify)
    };

    wd_Seq_Def {

        \find(
            wd(seqDef{i;}(m, n, t))
        )
        \varcond(
            \notFreeIn(i, m),
            \notFreeIn(i, n)
        )
        \replacewith(
            wd(m) & wd(n) & leq(m, n) & \forall i; ((leq(m, i) & lt(i, n)) -> wd(t))
        )
        \heuristics(simplify)
    };

    wd_Seq_Pred_Perm {

        \find(
            WD(seqPerm(s, q))
        )
        \replacewith(
            wd(s) & wd(q)
        )
        \heuristics(simplify)
    };

    wd_Seq_Pred_NPerm {

        \find(
            WD(seqNPerm(s))
        )
        \replacewith(
            wd(s)
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

\schemaVariables {
    \term int i, j;
    \term Seq c, l;
}

\rules(wdChecks:on) {
    wd_String_Translate {

        \find(
            wd(clTranslateInt(i))
        )
        \replacewith(
            wd(i)
        )
        \heuristics(simplify)
    };

    wd_String_RmvZeros {

        \find(
            wd(clRemoveZeros(c))
        )
        \replacewith(
            wd(c)
        )
        \heuristics(simplify)
    };

    wd_String_Hash {

        \find(
            wd(clHashCode(c))
        )
        \replacewith(
            wd(c)
        )
        \heuristics(simplify)
    };

    wd_String_IndexOfChar {

        \find(
            wd(clIndexOfChar(c, i, j))
        )
        \replacewith(
            wd(i) & wd(j) & wd(c) & leq(0, i) & leq(i, j) & lt(j, seqLen(c))
        )
        \heuristics(simplify)
    };

    wd_String_IndexOfStr {

        \find(
            wd(clIndexOfCl(l, i, c))
        )
        \replacewith(
            wd(c) & wd(i) & wd(l) & leq(0, i) & lt(add(i, seqLen(c)), seqLen(l))
        )
        \heuristics(simplify)
    };

    wd_String_LastIndexOfChar {

        \find(
            wd(clLastIndexOfChar(c, i, j))
        )
        \replacewith(
            wd(i) & wd(j) & wd(c) & leq(0, i) & leq(i, j) & lt(j, seqLen(c))
        )
        \heuristics(simplify)
    };

    wd_String_LastIndexOfStr {

        \find(
            wd(clLastIndexOfCl(l, i, c))
        )
        \replacewith(
            wd(c) & wd(i) & wd(l) & leq(0, i) & lt(add(i, seqLen(c)), seqLen(l))
        )
        \heuristics(simplify)
    };

    wd_String_Replace {

        \find(
            wd(clReplace(c, i, j))
        )
        \replacewith(
            wd(i) & wd(j) & wd(c) & leq(0, i) & leq(0, j) & lt(i, seqLen(c)) & lt(j, seqLen(c))
        )
        \heuristics(simplify)
    };

    wd_String_Pred_StartsWith {

        \find(
            WD(clStartsWith(l, c))
        )
        \replacewith(
            wd(c) & wd(l)
        )
        \heuristics(simplify)
    };

    wd_String_Pred_EndsWith {

        \find(
            WD(clEndsWith(l, c))
        )
        \replacewith(
            wd(c) & wd(l)
        )
        \heuristics(simplify)
    };

    wd_String_Pred_Contains {

        \find(
            WD(clContains(l, c))
        )
        \replacewith(
            wd(c) & wd(l)
        )
        \heuristics(simplify)
    };
}
/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This files declares rules which are used and needed for
// general (non-integer) invariants. In particular lexicographic
// ordering on pairs and sequences is implemented at the moment.
// The supported types are: integers and sequences and
// arbitrarily nested pairs of these types.

// The central predicate is "prec" (for predecessor) which
// captures a wellfounded (Notherian) relation on the type
// any. Its valuation is left underspecified for most cases
// and defined only for sensible applications.

// Additionally, this file also declares predicates to deal with measured-by
// clauses proof obligation. The measuredBy predicate encapsulates the top-level
// measured by clause for the given proof obligation. The measuredByCheck predicate
// is introduced when the measured-by clause is supposed to be checked during the proof.
// The dedicated rules replace this predicate with a suitable prec predicate after finding
// the measuredBy in the assumptions.

\sorts {
    Pair;
}

\functions {
    // The constructor is unique which makes it also an injection.
    \unique Pair pair(any, any);
    any first(Pair);
    any second(Pair);
}

\predicates {
    prec(any, any);
    measuredBy(any);
    measuredByEmpty;
    measuredByCheck(any);
}
