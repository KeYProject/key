// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


/** Abstract datatype of (untyped) partial maps.
 * @author Daniel Bruns
 */

\sorts {
    Map;
}


\functions {
    //getters
    any mapGet(Map, any);
    \unique any mapUndef;
    
    //constructors
    Map mapForeach{true,true}(boolean, any);
    Map mapEmpty;
    Map mapSingleton(any, any);
    Map mapOverride(Map, Map);
    Map seq2map(Seq);
    Map mapUpdate(Map, any, any);
    Map mapRemove(Map, any);
}

\predicates {
    inDomain(Map, any);
    inDomainImpliesCreated(Map);
}

\schemaVariables {
   \term Map m, m0, m1;
   \term any key, value;
   \term boolean b;
   \term any x, y, z;
   \term alpha xa;
   \variables alpha v;
   \variables any vy;
}

\rules {

    //--------------------------------------------------------------------------
    // axioms
    //--------------------------------------------------------------------------
    
    // Added by Kai Wallisch
    defMapEquality {
		\find(m0 = m1)
		\varcond(\notFreeIn(vy,m0,m1))
		\replacewith( \forall vy; ( ( inDomain(m0, vy) <-> inDomain(m1, vy) ) & 
				( inDomain(m0, vy) -> mapGet(m0, vy) = mapGet(m1, vy) ) ) )
	};
    
    inDomainOfMapForeach {
        \find(inDomain(mapForeach{v;}(b,y),x))
        \replacewith({\subst v; alpha::cast(x)} b = TRUE
					& alpha::instance(x) = TRUE )
        \heuristics(simplify)
    };

    getOfMapForeach {
        \find(mapGet(mapForeach{v;}(b,y),x))
        \sameUpdateLevel
        \replacewith(\if(inDomain(mapForeach{v;}(b,y),x))
                     \then({\subst v; alpha::cast(x)}y)
                     \else(mapUndef))
      	\heuristics(simplify_enlarging)
    };

    //--------------------------------------------------------------------------
    // definitions (conservative extensions)
    //--------------------------------------------------------------------------

    defMapEmpty {
        \find(mapEmpty)
        \replacewith(mapForeach{vy;}(FALSE,mapUndef))
    };

    defMapSingleton {
        \find(mapSingleton(xa, y))
        \varcond(\notFreeIn(vy,xa,y))
        \replacewith(mapForeach{vy;}(
		\if(vy=any::cast(xa))\then(TRUE)\else(FALSE),y)
        )
    };

    defMapOverride {
        \find(mapOverride(m0,m1))
        \varcond(\notFreeIn(vy,m0,m1))
        \replacewith(mapForeach{vy;}(
		\if(inDomain(m0,vy)|inDomain(m1,vy))\then(TRUE)\else(FALSE),
		\if(inDomain(m1,vy))
			\then(mapGet(m1,vy))\else(mapGet(m0,vy))
	))
    };

    defSeq2Map {
        \schemaVar \term Seq s;
        \schemaVar \variables int ix;
        \find(seq2map(s))
        \varcond(\notFreeIn(ix,s))
        \replacewith(mapForeach{ix;}(
		\if(0 <= ix & ix < seqLen(s))\then(TRUE)\else(FALSE),
		any::seqGet(s,ix)
	))
    };
    
    // Added by Kai Wallisch
	defMapUpdate {
		\find(mapUpdate(m,key,value))
		\varcond(\notFreeIn(vy,m,key,value))
		\replacewith(mapForeach{vy;}(
			\if(inDomain(m,vy) | vy = key)
				\then(TRUE)
				\else(FALSE),
			\if(vy = key)
				\then(value)
				\else(mapGet(m,vy)) 
		))
	};
	
    // Added by Kai Wallisch
	defMapRemove {
		\find(mapRemove(m,key))
		\varcond(\notFreeIn(vy,m,key))
		\replacewith(mapForeach{vy;}(
			\if(inDomain(m,vy) & vy != key)
				\then(TRUE)
				\else(FALSE),
			mapGet(m,vy)
		))
	};
	
    // Added by Kai Wallisch
	defInDomainImpliesCreated {
		\schemaVar \variables Object o;
		\find(inDomainImpliesCreated(m))
		\varcond(\notFreeIn(o,m))
		\replacewith( \forall o; ( inDomain(m,o) ->
			boolean::select( heap, o, java.lang.Object::<created> ) = TRUE ) )
		\heuristics(simplify_enlarging)
	};
	
    //--------------------------------------------------------------------------
    // derived map equality rules (proven sound in KeY)
    //--------------------------------------------------------------------------
   
	// Added by Kai Wallisch
	mapEqualityRight {
		\find( ==> m0 = m1 )
		\varcond(\notFreeIn(vy,m0,m1))
		\replacewith( ==> \forall vy; ( (inDomain(m0, vy)<->inDomain(m1, vy)) & 
				(inDomain(m0, vy) -> mapGet(m0, vy) = mapGet(m1, vy)) ) )
        \heuristics(simplify_enlarging)
	};
   
	// Added by Kai Wallisch
	mapUpdateUnchanged {
   	 \find( m = mapUpdate(m, key, value) )
   	 \replacewith(inDomain(m, key) & mapGet(m, key) = value )
	 \heuristics(simplify_enlarging)
	};
	
	// Added by Kai Wallisch
	mapUpdateUnchanged2 {
   	 \find( mapUpdate(m, key, value) = m )
   	 \replacewith(inDomain(m, key) & mapGet(m, key) = value )
	 \heuristics(simplify_enlarging)
	};
	
   
	// Added by Kai Wallisch
	mapRemoveUnchanged {
   	 \find( m = mapRemove(m, key) )
   	 \replacewith(!inDomain(m, key))
	 \heuristics(simplify_enlarging)
	};
	
	// Added by Kai Wallisch
	mapRemoveUnchanged2 {
   	 \find( mapRemove(m, key) = m )
   	 \replacewith(!inDomain(m, key))
	 \heuristics(simplify_enlarging)
	};

    //--------------------------------------------------------------------------
    // derived inDomain rules (proven sound in KeY)
    //--------------------------------------------------------------------------

    inDomainOfMapEmpty {
        \find(inDomain(mapEmpty, x))
        \replacewith(false)
        \heuristics(concrete)
    };

    inDomainOfMapSingleton {
        \find(inDomain(mapSingleton(x,y),z))
        \replacewith(x=z)
        \heuristics(simplify)
    };

    inDomainOfMapOverride {
        \find(inDomain(mapOverride(m0,m1),x))
        \replacewith(inDomain(m0,x)|inDomain(m1,x))
        \heuristics(simplify)
    };

    inDomainOfSeq2Map {
        \schemaVar \term Seq s;
        \find(inDomain(seq2map(s),x))
        \replacewith(int::instance(x) = TRUE & 
		0 <= int::cast(x) & int::cast(x) < seqLen(s))
        \heuristics(simplify)
    };
    
    // Added by Kai Wallisch
    inDomainOfMapUpdate {
        \find(inDomain(mapUpdate(m,key,value),x))
        \replacewith(inDomain(m,x) | (x = key))
        \heuristics(simplify_enlarging)
    };
    
    // Added by Kai Wallisch
    inDomainOfMapRemove {
        \find(inDomain(mapRemove(m,key),x))
        \replacewith(inDomain(m,x) & (x != key))
        \heuristics(simplify_enlarging)
    };
    
	// Added by Kai Wallisch
	notInDomain{
		\find (==> inDomain(m,x))
		\add(mapGet(m,x) = mapUndef ==> )
        \heuristics(inReachableStateImplication)
	};
	
    inDomainConcrete {
        \assumes(==> mapUndef = y)
        \find(mapGet(m,x) = y ==>)
        \add(inDomain(m,x) ==>)
        \heuristics(inReachableStateImplication)
    };
    
    //--------------------------------------------------------------------------
    // derived mapGet rules (proven sound in KeY)
    //--------------------------------------------------------------------------
    
    // Added by Kai Wallisch
    getOfMapEmpty {
        \find(mapGet(mapEmpty,x))
        \sameUpdateLevel
        \replacewith(mapUndef)
        \heuristics(simplify)
    };

    getOfMapSingleton {
        \find(mapGet(mapSingleton(x,y),z))
        \sameUpdateLevel
        \replacewith(\if(x=z)\then(y)\else(mapUndef))
        \heuristics(simplify)
    };

    getOfMapOverride {
        \find(mapGet(mapOverride(m0,m1),x))
        \sameUpdateLevel
	\replacewith(\if(inDomain(m1,x))
		\then(mapGet(m1,x))\else(mapGet(m0,x)))
      	\heuristics(simplify_enlarging)
    };

    getOfSeq2Map {
        \schemaVar \term Seq s;
        \find(mapGet(seq2map(s),x))
        \sameUpdateLevel
        \replacewith(\if(int::instance(x) = TRUE & 0 <= int::cast(x) & int::cast(x) < seqLen(s))
                     \then(any::seqGet(s,int::cast(x)))\else(mapUndef))
      	\heuristics(simplify_enlarging)
    };
    
    // Added by Kai Wallisch
    getOfMapUpdate {
        \find(mapGet(mapUpdate(m,key,value),x))
        \sameUpdateLevel
        \replacewith(\if(x = key)\then(value)\else(mapGet(m,x)))
        \heuristics(simplify_enlarging)
    };
    
    // Added by Kai Wallisch
    getOfMapRemove {
        \find(mapGet(mapRemove(m,key),x))
        \sameUpdateLevel
        \replacewith(\if(x = key)\then(mapUndef)\else(mapGet(m,x)))
        \heuristics(simplify_enlarging)
    };

} 

