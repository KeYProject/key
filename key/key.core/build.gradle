plugins {
    id 'ca.coglinc.javacc' version '2.4.0'
    id 'antlr'
}

repositories { jcenter() }

configurations { antlr4 }

dependencies {
    api project(':key.util')
    api group: group, name: 'recoderkey', version: '1.0'
    implementation group: 'net.java.dev.javacc', name:'javacc', version:'4.0'
    implementation group: 'org.antlr', name:'antlr-runtime', version:'3.5.2'
    implementation group: 'antlr', name: 'antlr', version: '2.7.7'

    javacc  group: 'net.java.dev.javacc', name:'javacc', version:'4.0'
    antlr   group: 'org.antlr', name:'antlr', version:'3.5.2'   // use ANTLR version 3

    antlr4 "org.antlr:antlr4:4.7.1"
    implementation "org.antlr:antlr4-runtime:4.7.1"
    implementation group: 'com.google.guava', name: 'guava', version: '28.1-jre'
}

// The target directory for JavaCC (parser generation)
def javaCCOutputDir = file("${buildDir}/generated-src/javacc")
def javaCCOutputDirMain = file("$javaCCOutputDir/main")

sourceSets.main.java.srcDirs(javaCCOutputDirMain, "$projectDir/build/generated-src/antlr4/main/")

// Generate code from ANTLR grammars.
generateGrammarSource {
    maxHeapSize = "64m"
    arguments += ["-visitor", "-listener", "-long-messages"]
}

// Generate code from ANTLR grammars in testing.
generateTestGrammarSource {
    maxHeapSize = "64m"
    arguments += ["-visitor", "-listener", "-long-messages"]
}

// Generate code from JavaCC grammars.
compileJavacc {
    outputDirectory = javaCCOutputDirMain
    inputDirectory = file("src/main/javacc")
    doLast {
        // Some manual overwriting of Token files needed
        copy {
            from("src/main/javacc/de/uka/ilkd/key/parser/schemajava/Token.java")
            into "$javaCCOutputDirMain/de/uka/ilkd/key/parser/schemajava/"
        }
        copy {
            from("src/main/javacc/de/uka/ilkd/key/parser/proofjava/Token.java")
            into "$javaCCOutputDirMain/de/uka/ilkd/key/parser/proofjava/"
        }
    }
}

tasks.withType(Test) {
    enableAssertions = true
}

test {
    /*filter {
        // use testProofRules or testRunAllProofs, avoid double execution on jenkins
        excludeTestsMatching "ProveRulesTest"
        excludeTestsMatching "RunAllProofsTestSuite"
        excludeTestsMatching "RunAllProofsInfFlow"
        excludeTestsMatching "RunAllProofsTestWithComputeCostProfiling"
        excludeTestsMatching "RunAllProofsFunctional"
        excludeTestsMatching "TestParallelParsing"
        excludeTestsMatching "TestCvc4"
    }*/
    filter {
        // To make test cases deterministic there is only one class per
        // project called "Tests" that programmatically collects
        // all test cases.
        // See these classes for configuring the test runs!
        // CAUTION! "excludeCategories" more filters are to be defined in the class!
        includeTestsMatching "de.uka.ilkd.key.Tests"
    }
    // pass debug flag from command line:
    systemProperty "key.test.autosuite.debug", System.getProperty("key.test.autosuite.debug")

    // TODO @AW. That is already in key/build.gradle. Here or there?
    // useJUnit {
    //         excludeCategories 'org.key_project.util.testcategories.Performance'
    //         excludeCategories 'org.key_project.util.testcategories.Interactive'
    // }
}

testFast {
    filter {
        // To make test cases deterministic there is only one class per
        // project called "Tests" that programmatically collects
        // all test cases.
        // See these classes for configuring the test runs!
        // CAUTION! "excludeCategories" more filters are to be defined in the class!
        includeTestsMatching "de.uka.ilkd.key.FastTests"
    }
}


task testProveRules(type: Test) {
    description 'Proves KeY taclet rules tagged as lemma'
    group "verification"
    filter { includeTestsMatching "ProveRulesTest" }
}

task testRunAllProofs(type: Test) {
    description 'Proof/reload all keyfiles tagged for regression testing'
    group "verification"
    filter { 
        // TODO does not exist any more: includeTestsMatching "RunAllProofsTestSuite"
        includeTestsMatching "RunAllProofsInfFlow"
        includeTestsMatching "RunAllProofsFunctional"
    }
}


task generateRunAllProofs(type: JavaExec) {
    //Test runtime
    classpath = sourceSets.test.runtimeClasspath
    main = "de.uka.ilkd.key.proof.runallproofs.GenerateUnitTests"
    args "$buildDir/generated-src/rap-unittests/test"
}
sourceSets.test.java.srcDir "$buildDir/generated-src/rap-unittests/test"


//Generation of the three version files within the resources by executing `git'.
task generateVersionFiles() {
    def outputFolder = file("build/resources/main/de/uka/ilkd/key/util")
    def sha1 = new File(outputFolder, "sha1")
    def branch = new File(outputFolder, "branch")
    def versionf = new File(outputFolder, "version")

    outputs.files sha1, branch, versionf

    def gitRevision = gitRevParse('--short HEAD')
    def gitBranch = gitRevParse('--abbrev-ref HEAD')

    doLast {
        sha1.text = gitRevision
        branch.text = gitBranch
        versionf.text = rootProject.version
    }
}

// @AW: Say something here. From POV this explain by itself.
processResources.dependsOn generateVersionFiles

def antlr4Output = "$projectDir/build/generated-src/antlr4/main/de/uka/ilkd/key/nparser"
task runAntlr4(type: JavaExec) {
    //see incremental task api, prevents rerun if nothing has changed.
    inputs.dir "src/main/antlr4/"
    outputs.dir "$projectDir/build/generated/antlr4/main/"
    classpath = configurations.antlr4
    main = "org.antlr.v4.Tool"
    args = ["-visitor",
            "-Xexact-output-dir", "-o", antlr4Output,
            "-package", "de.uka.ilkd.key.nparser",
            "src/main/antlr4/KeYLexer.g4", "src/main/antlr4/KeYParser.g4"]
    doFirst {
        file(antlr4Output).mkdirs()
        println("create $antlr4Output")
    }
}
compileJava.dependsOn runAntlr4

task debugLexer(type: JavaExec) {
    main = "de.uka.ilkd.key.nparser.DebugKeyLexer"
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
}

task ptest(type: Test) { group "verification"}

// @AW: Delete? weigl: depends: If want that gradle check validates everything then not.
// check.dependsOn << testProofRules << testRunAllProofs
