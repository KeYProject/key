\rules {

   // arbitrary fixed length bitvector operations
   shiftRightDef {
   	\schemaVar \term int left, right;

	\find ( shiftright(left, right) )
	\replacewith ( \if ( right < 0 )
		       \then ( shiftleft(left, -right) )
		       \else ( div (left, pow(2, right) ) )
     )

	 \heuristics (simplify_enlarging)	 
   };

   shiftLeftDef {
   	\schemaVar \term int left, right;

	\find ( shiftleft(left, right) )
	\replacewith ( \if ( right < 0 )
		       \then ( shiftright(left, -right) )
		       \else ( mul (left, pow(2, right) ) )
     )

	 \heuristics (simplify_enlarging)	 
   };
   

	javaShiftRightIntDef {
	   	\schemaVar \term int left, right;
	
		\find ( shiftrightJint(left, right) )		
		// usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
		\replacewith ( moduloInt(shiftright(left, mod(right,32) ) ) ) 
	    \heuristics (simplify_enlarging)
	};

	javaShiftRightLongDef {
	   	\schemaVar \term int left, right;
	
		\find ( shiftrightJlong(left, right) )		
		// usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
		\replacewith ( moduloLong(shiftright(left, mod(right, 64) ) ) )
	    
	    \heuristics (simplify_enlarging)
	};

	javaShiftLeftIntDef {
	   	\schemaVar \term int left, right;
	
		\find ( shiftleftJint(left, right) )		
		// usage of the mathematical mod is crucial as -1 % 32 = 31 (!)
		\replacewith ( moduloInt(shiftleft(left, mod(right,32) ) ) ) 
	    \heuristics (simplify_enlarging)
	};

	javaShiftLeftLongDef {
	   	\schemaVar \term int left, right;
	
		\find ( shiftleftJlong(left, right) )		
		// usage of the mathematical mod is crucial as -1 % 64 = 63 (!)
		\replacewith ( moduloLong(shiftleft(left, mod(right, 64) ) ) )
	    
	    \heuristics (simplify_enlarging)
	};


   unsignedShiftRightJintDef {
   	 \schemaVar \term int left, right;
	 \find ( unsignedshiftrightJint(left, right) )
	 \replacewith ( \if (left >= 0) \then (shiftrightJint(left, right)) 
	 			    \else (addJint(shiftrightJint(left, right), shiftleftJint(2,31-mod(right, 32))) )) 
	 \heuristics (simplify_enlarging)
   };

   
   xorJIntDef {
   	 \schemaVar \term int left, right;
   	 
   	 \find ( xorJint(left, right) )
   	 \replacewith ( moduloInt( binaryXOr(left,right) ) )	
     
     \heuristics(simplify)
   };

   orJIntDef {
   	 \schemaVar \term int left, right;
   	 
   	 \find ( orJint(left, right) )
   	 \replacewith ( moduloInt( binaryOr(left,right) ) )	
     
     \heuristics(simplify)
   };


   andJIntDef {
   	 \schemaVar \term int left, right;
   	 \find ( andJint(left, right) )
   	 \replacewith ( moduloInt( binaryAnd(left, right) ) )	
     
     \heuristics(simplify)
   };

}