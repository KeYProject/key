<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>

    <comment>Snippets for the preamble of the SMT translation</comment>

    <!-- This is auto-loaded as it defines properties of the type hierarchy and fundamental functions -->
    <entry key="types.auto">true</entry>

    <entry key="types.axioms">
<!-- subtype is reflexive -->
<!-- (assert (forall ((t1 T)) (subtype t1 t1)))-->
<!-- not necessary: (assert (forall ((u U) (t T)) (=> (instanceof u t) (instanceof u t)))) -->

<!-- subtype is antisymmetric -->
<!-- (assert (forall ((t1 T) (t2 T)) (! (=> (and (subtype t1 t2) (subtype t2 t1)) (= t1 t2)) :pattern ((subtype t1 t2) (subtype t2 t1))))) -->
<!-- naive version: -->
<!-- (assert (forall ((u U) (t1 T) (t2 T)) (=> (and (=> (instanceof u t1) (instanceof u t2)) (=> (instanceof u t2) (instanceof u t1))) (= t1 t2))))-->
<!-- simplified (both implications to equivalence/equality): -->
(assert (forall ((u U) (t1 T) (t2 T)) (=> (= (instanceof u t1) (instanceof u t2)) (= t1 t2))))

<!-- subtype is transitive -->
<!--(assert (forall ((t1 T) (t2 T) (t3 T)) (! (=> (and (subtype t1 t2) (subtype t2 t3)) (subtype t1 t3)) :pattern ((subtype t1 t2) (subtype t2 t3)))))-->
(assert (forall ((t1 T) (t2 T) (t3 T))
        (=> (forall ((u U)) (and (=> (instanceof u t1) (instanceof u t2)) (=> (instanceof u t2) (instanceof u t3))))
            (forall ((u U)) (=> (instanceof u t1) (instanceof u t3))))))

<!--(assert (forall ((u U) (t T)) (! (subtype (typeof (cast u t)) t) :pattern ((cast u t)))))-->
(assert (forall ((u U) (t T)) (instanceof (cast u t) t)))

<!--(assert (forall ((u U) (t T)) (! (=> (subtype (typeof u) t) (= (cast u t) u)) :pattern ((cast u t)))))-->
(assert (forall ((u U) (t T)) (! (=> (instanceof u t) (= (cast u t) u)) :pattern ((cast u t)))))
    </entry>

    <entry key="types.decls">
<!--(declare-fun subtype (T T) Bool)-->
<!--(declare-fun typeof (U) T)-->
(declare-fun cast (U T) U)
    </entry>


    <!-- the theory for null is very small and hence always added -->
    <entry key="null.auto">true</entry>

    <entry key="null.axioms">
<!--(assert (= (typeof null) sort_Null))-->
(assert (exactinstanceof null sort_Null))
    </entry>

    <entry key="null.decls">
(declare-const null U)
(declare-const sort_Null T)
    </entry>


    <!-- This is auto-loaded as it introduces U and T as the most important SMT sorts.
         Its name starts with "0" to make it be loaded first.
    -->
    <entry key="0general.auto">true</entry>

    <entry key="0general.decls">
(declare-sort T 0)
(declare-sort U 0)
(declare-const sort_any T)
    </entry>

    <entry key="opts">
(set-option :print-success true)
<!--(set-option :produce-unsat-cores true)-->
(set-option :produce-models true)
(set-option :produce-proofs true)
<!-- this does not work since output is printed to stderr and thus treated as error by the GUI
    (set-option :verbose 10000000)-->
<!--(set-option :auto-config false)-->
(set-option :pp.pretty-proof true)
(set-logic ALL)
    </entry>

    <!-- These two predicates are used throughout the preamble and are required to be present.
         They are rewritten to typeof expressions.
     -->
    <entry key="instanceof.auto">true</entry>

    <entry key="instanceof.decls">
(declare-fun instanceof (U T) Bool)
(declare-fun exactinstanceof (U T) Bool)
    </entry>
    <entry key="instanceof.axioms">
<!--
(assert (forall ((u U) (t T)) (! (= (instanceof u t) (subtype (typeof u) t)) :pattern ((instanceof u t)))))
(assert (forall ((u U) (t T)) (! (= (exactinstanceof u t) (= (typeof u) t)) :pattern ((exactinstanceof u t)))))
-->
(assert (forall ((u U) (t T)) (=> (exactinstanceof u t) (instanceof u t))))
    </entry>

    <!-- This predicate is needed to distinguish between instanceof applications from the original sequent
         and those introduced during translation as typeguards (necessary for Z3 proof replay) -->
    <entry key="typeguard.decls">
(declare-fun typeguard (U T) Bool)
    </entry>
    <entry key="typeguard.axioms">
(assert (forall ((u U) (t T)) (! (= (typeguard u t) (instanceof u t)) :pattern ((typeguard u t)))))
    </entry>

</properties>


