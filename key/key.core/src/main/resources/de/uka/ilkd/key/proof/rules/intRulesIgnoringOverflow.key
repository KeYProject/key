/* This file is part of KeY - https://key-project.org
 * KeY is licensed by the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0 */



\schemaVariables {
  \term int left, right, i, i0, i1 ;
  \term numbers iz, jz;
}



\rules(programRules:Java, intRules:arithmeticSemanticsIgnoringOF) {
//------------------------------------------------------------------------
// ------------ Rules to expand the predicates inByte, inShort, inInt, and inLong
//------------------------------------------------------------------------
  inByte {\find (inByte(i)) \replacewith ( true )
          \heuristics(concrete) };

  inChar {\find (inChar(i)) \replacewith ( true )
          \heuristics(concrete) };

  inShort {\find (inShort(i)) \replacewith ( true )
          \heuristics(concrete) };

  inInt {\find (inInt(i)) \replacewith ( true )
          \heuristics(concrete) };

  inLong {\find (inLong(i)) \replacewith ( true )
          \heuristics(concrete) };

//--------------------------------------------------------------------------
// Axioms defining the integer translation functions
//--------------------------------------------------------------------------

  translateJavaUnaryMinusInt {
     \find (javaUnaryMinusInt(left))
     \replacewith(neg(left))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaUnaryMinus"
  };

  translateJavaUnaryMinusLong {
     \find (javaUnaryMinusLong(left))
     \replacewith(neg(left))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaUnaryMinus"
  };

/** inverting bits is not canonical defineable in this semantics
  translateJavaBitwiseNegation {
     \find(javaBitwiseNegation(left))
     \replacewith(???)
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaUnaryMinus"
  };
*/

  translateJavaAddInt {
     \find(javaAddInt(left,right))
     \replacewith(add(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaAdd"
  };

  translateJavaAddLong{
     \find(javaAddLong(left,right))
     \replacewith(add(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaAdd"
  };

  translateJavaSubInt{
     \find(javaSubInt(left,right))
     \replacewith(sub(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaSub"
  };

  translateJavaSubLong{
     \find(javaSubLong(left,right))
     \replacewith(sub(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaSub"
  };

  translateJavaMulInt{
     \find(javaMulInt(left,right))
     \replacewith(mul(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaMul"
  };

  translateJavaMulLong{
     \find(javaMulLong(left,right))
     \replacewith(mul(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaMul"
  };

  translateJavaMod{
     \find(javaMod(left,right))
     \replacewith(jmod(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaMod"
  };

  translateJavaDivInt{
     \find(javaDivInt(left,right))
     \replacewith(jdiv(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaDiv"
  };

  translateJavaDivLong{
     \find(javaDivLong(left,right))
     \replacewith(jdiv(left,right))
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaDiv"
  };

  translateJavaCastByte{
     \find(javaCastByte(left))
     \replacewith(left)
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaCast"
  };

  translateJavaCastShort{
     \find(javaCastShort(left))
     \replacewith(left)
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaCast"
  };

  translateJavaCastInt{
     \find(javaCastInt(left))
     \replacewith(left)
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaCast"
  };

  translateJavaCastLong{
     \find(javaCastLong(left))
     \replacewith(left)
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaCast"
  };

  translateJavaCastChar{
     \find(javaCastChar(left))
     \replacewith(left)
     \heuristics(javaIntegerSemantics,simplify)
     \displayname "translateJavaCast"
  };

/**
  Bitwise operators like shift, and, or, xor working on integers are not
  implemented for these semantics. The reason is that their representation as
  functions on the whole numbers is rather cumbersome and in addition some of
  them depend on overflow.

  translateJavaShiftRightInt{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaShiftRight"
  };

  translateJavaShiftRightLong{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaShiftRight"
  };

  translateJavaShiftLeftInt{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaShiftLeft"
  };

  translateJavaShiftLeftLong{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaShiftLeft"
  };

  translateJavaUnsignedShiftRightInt{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaUnsignedShiftRight"
  };

  translateJavaUnsignedShiftRightLong{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaUnsignedShiftRight"
  };

  translateJavaOrInt{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaOr"
  };

  translateJavaOrLong{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaOr"
  };

  translateJavaBinaryAndInt{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaBinaryAnd"
  };

  translateJavaBinaryAndLong{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaBinaryAnd"
  };

  translateJavaXOrInt{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaXOr"
  };

  translateJavaXOrLong{
      \heuristics(javaIntegerSemantics)
      \displayname "translateJavaXOr"
  };
*/
}
