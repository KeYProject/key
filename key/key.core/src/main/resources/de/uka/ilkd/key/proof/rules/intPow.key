//
//  This file contains rule for integer powers and logs.
//

\schemaVariables{
    \term int base, exp, exp_2, x, x_2;
}

\rules {
    powDef {
        \schemaVar \variables int i;

        \find(pow(base, exp))
        \varcond(\notFreeIn(i, exp, base))
        \replacewith(
            \if (exp >= 0)
                \then (bprod{i;}(0, exp, base))
                \else (undefinedPow(base,exp))
        )
    };

    // Proven
    \lemma powConcrete0 {
        \find(pow(base, 0))
        \replacewith(
            1
        )
        \heuristics(simplify)
    };

    // Proven
    \lemma powConcrete1 {
        \find(pow(base, 1))
        \replacewith(
            base
        )
        \heuristics(simplify)
    };

    // Proven
    \lemma powSplitFactor {
        \find(pow(base, exp))
        \add(
            exp >= 1 & base > 1 ->
                pow(base, exp) = base * pow(base, exp - 1) ==>
        )
    };

    // Proven
    \lemma powAdd {
        \find(pow(base, exp + exp_2))
        \add(
            exp >= 0 & exp_2 >= 0 & base > 1 ->
                pow(base, exp + exp_2) = pow(base, exp) * pow(base, exp_2) ==>
        )
    };

    // Proven
    \lemma powMono {
        \find(pow(base, exp) <= pow(base, exp_2))
        \add(
            exp >= 0 & exp_2 >= exp & base > 1 ->
                pow(base, exp) <= pow(base, exp_2) ==>
        )
    };

    // Proven
    \lemma powMonoConcrete {
        \find(==> pow(base, exp) <= pow(base, exp_2))
        \replacewith(
            ==> exp >= 0 & exp_2 >= exp & base > 1
        )
        \heuristics(simplify)
    };

    // Proven
    \lemma powMonoConcreteRev {
        \find(==> pow(base, exp_2) >= pow(base, exp))
        \replacewith(
            ==> exp >= 0 & exp_2 >= exp & base > 1
        )
        \heuristics(simplify)
    };

    // Proven
    \lemma powPositive {
        \find(pow(base, exp))
        \add(
            exp >= 0 & base > 1 ->
                pow(base, exp) >= 1 ==>
        )
    };

    // Proven
    \lemma powPositiveConcrete {
        \find(==> pow(base, exp) >= 0)
        \replacewith(
            ==> exp >= 0 & base > 1
        )
        \heuristics(simplify)
    };

    // Proven
    \lemma powGeq1Concrete {
        \find(==> pow(base, exp) >= 1)
        \replacewith(
            ==> exp >= 0 & base > 1
        )
        \heuristics(simplify)
    };

    logDefinition {
        \find(log(base, x))
        \replacewith(
            \if (x >= 1 & base > 1)
                \then (
                    \if (x < base)
                        \then (0)
                        \else (1 + log(base, x / base))
                )
                \else (undefinedLog(base,x))
        )
    };

    // Proven
    \lemma logSelf {
        \find(log(base, base))
        \add(base > 1 -> log(base, base) = 1 ==>)
    };

    // Proven
    \lemma logSelfConcrete {
        \find(log(base, base))
        \replacewith(\if(base > 1) \then(1) \else(undefinedLog(base, base)))
        \heuristics(simplify)
    };

    // Proven
    \lemma logConcrete0 {
        \find(log(base, 1))
        \add(
            base > 1 ->
                log(base, 1) = 0 ==>
        )
    };

    // Proven
    \lemma log1Concrete {
        \find(log(base, 1))
        \replacewith(\if(base > 1) \then(0) \else(undefinedLog(base, 1)))
        \heuristics(simplify)
    };

    // Proven
    \lemma logProduct {
        \find(log(base, x * base))
        \add(
            x >= 1 & base > 1 -> log(base, x * base) = log(base, x) + 1 ==>
        )
    };

    // Proven
    \lemma logTimesBaseConcrete {
        \find(log(base, x * base))
        \replacewith(
            \if(x >= 1 & base > 1)
                \then(log(base, x) + 1)
                \else(undefinedLog(base, x * base))
        )
        \heuristics(simplify)
    };

    // TODO
    // Works only when (x / 2) * (x_2 / 2) == (x * x_2) / 4
    // => if not x, x_2 % 2 == 0
    // Hard to show
    /*
    \lemma log2Mul {
        \find(log(2, x * x_2))
        \add(
            x >= 1 & x_2 >= 1 -> log(2, x * x_2) = log(2, x) + log(2, x_2) ==>
        )
    };
    */

    // Proven
    \lemma logProdIdentity {
        \schemaVar \variables int i;
        \find(log(base, bprod{i;}(0, exp, base)))
        \varcond(\notFreeIn(i, exp, base))
        \add(
            exp >= 0 & base > 1 -> log(base, bprod{i;}(0, exp, base)) = exp ==>
        )
    };

    // Proven
    \lemma logProdIdentityConcrete {
        \schemaVar \variables int i;
        \find(log(base, bprod{i;}(0, exp, base)))
        \varcond(\notFreeIn(i, exp, base))
        \replacewith(
            \if(base > 1)
                \then(
                    \if(exp < 0)
                        \then(0)
                        \else(exp)
                )
                \else(undefinedLog(base, bprod{i;}(0, exp, base)))
        )
    };

    // Proven
    \lemma logPowIdentity {
        \schemaVar \variables int i;
        \find(log(base, x))
        \varcond(\notFreeIn(i, x, base))
        \add(
            base > 1 -> \forall i; (i >= 0 -> log(base, pow(base, i)) = i) ==>
        )
    };

    // Proven
    \lemma logPowIdentityConcrete {
        \find(log(base, pow(base, exp)))
        \replacewith(
            \if(base > 1)
                \then(
                    \if(exp >= 0)
                        \then(exp)
                        \else(log(base, undefinedPow(base, exp)))
                )
                \else(undefinedLog(base, pow(base, exp)))
        )
        \heuristics(simplify)
    };

    // Proven
    \lemma logPositive {
        \find(log(base, x))
        \add(
            base > 1 & x >= 1 -> log(base, x) >= 0 ==>
        )
    };

    // Proven
    \lemma logPositiveConcrete {
        \find(==> log(base, x) >= 0)
        \replacewith(
            ==> base > 1 & x >= 1
        )
        \heuristics(simplify)
    };

    // Proven
    \lemma logMono {
        \find(log(base, x) <= log(base, x_2))
        \add(
            x >= 1 & x_2 >= x & base > 1 ->
                log(base, x) <= log(base, x_2) ==>
        )
    };

    // Proven
    \lemma logMonoConcrete {
        \find(==> log(base, x) <= log(base, x_2))
        \replacewith(
            ==> x >= 1 & x_2 >= x & base > 1
        )
        \heuristics(simplify)
    };

    // Proven
    \lemma powLogLess {
        \find(pow(base, log(base, exp)))
        \add(
            exp >= 1 & base > 1 ->
                pow(base, log(base, exp)) <= exp ==>
        )
    };

    // Proven
    // This could be extended to all bases, but e.g. base = 3 and x = 2 doesn't work
    \lemma powLogMore2 {
        \find(pow(base, log(base, x)))
        \add(
            base = 2 & x >= 1 -> x - pow(base, log(base, x)) < pow(base, log(base, x)) ==>
        )
    };

    // Proven
    \lemma logLessThanPow {
        \find(log(base, x) < exp)
        \add(
            base > 1 & x >= 1 & x < pow(base, exp) & exp >= 1 -> log(base, x) < exp ==>
        )
    };
}
