\schemaVariables{
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
}

//======================================================================================================================
// 												General Rules
//======================================================================================================================

\rules { 
	
// unfold boundaries
	unfoldBounds {
		\schemaVar \term numbers a,b;
		\schemaVar \term int x;
		 
		\assumes(x <= Z(b) ==>)
		\find(x >= Z(a) ==> )
		
		\replacewith( x=Z(a) ==>);
		 
		\replacewith( x>=Z(a) + 1 ==>)
		
		\heuristics(dep_pred_unroll_fixed_bounds)
		
	};
	
	parallelUpdateAssociative {
	    \schemaVar \update u1, u2, u3;
	    
	    \find (u1 || (u2 || u3))
	    \replacewith(u1 || u2 || u3)
	    
	    \heuristics(simplify)
	
	};
}

//======================================================================================================================
//												Data Dependence Rules
//======================================================================================================================


\rules(programRules:Java, runtimeExceptions:ban, dependencies: on) {  

//======================================================================================================================
//													Assignment Rules 
//======================================================================================================================

	assignment  { 
		\schemaVar \program Variable #loc;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;
		
		\find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
		\replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post)) 
		
		\heuristics(simplify_prog, simplify_prog_subset)
	};
	
	assignment_read_attribute { 
		\schemaVar \program Variable #v0, #v, #a;
		\schemaVar \formula post;
		
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
		\varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		\event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v=null))
		;
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)	
		\heuristics(simplify_prog, simplify_prog_subset)
	};
	
	assignment_read_attribute_this { 
		\schemaVar \program Variable #v0, #v, #a;
		\schemaVar \formula post;
		
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
		\varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		\replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		\event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		
		\heuristics(simplify_prog, simplify_prog_subset)
	};
	
	/* assignment_read_length { 
	\schemaVar \program Variable #v0, #v;
	\schemaVar \formula post;
	
	\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
	\varcond(\not\isThisReference(#v))
	"Normal Execution (#v != null)":
	\replacewith(==> {#v0 := length(#v)}
	
	\modality{#allmodal}{.. ...}\endmodality(post))
	//\add (==>(#v=null))
	;
	"Null Reference (#v = null)":
	\replacewith(==> false)
	\add (#v=null ==>)	
	\heuristics(simplify_prog, simplify_prog_subset)
	};*/  
	
	
	assignment_write_attribute { 
	
		\schemaVar \program Variable #v, #a;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;
		
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
		\varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) || 
		\event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		
		//\add (==>(#v=null))
		;
		
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)	 
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment"
	};  
	
	assignment_write_attribute_this { 
	
		\schemaVar \program Variable #v, #a;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;
		
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
		\varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		\replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		\event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		//{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentThis"
	};  

//======================================================================================================================
//												Array Assignment Rules 
//======================================================================================================================

	assignment_read_length { 
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program ArrayLength #length;
		\schemaVar \formula post;
		
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {#v0 := length(#v)}
		//To Be Fixed. We need the LocSet here.
		/*{\event(read,singleton(length(#v)),timestamp)}
		{timestamp:=timestamp + 1}
		{\event(write,singleton(#v0),timestamp)}
		{timestamp:=timestamp + 1}*/
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v=null))
		;
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)	
		\heuristics(simplify_prog, simplify_prog_subset)
	};  
	
	assignment_array_read_EventUpdate{
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;
		
		\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
		\varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		\replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}
		{\event(read,singleton(#v0,arr(#se)),timestamp)}
		//{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
		;
		"Null Reference (#v0 = null)":
		\replacewith(==> false)
		\add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
		\replacewith(==> false)
		\add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
		
		\heuristics(simplify_prog, simplify_prog_subset)
	};
	
	//\rules(programRules:Java, runtimeExceptions:allow, dependencies:off) {
	//assignment_to_primitive_array_component {
	//\schemaVar \modalOperator { diamond, box } #normal; 
	//\find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	//\varcond(\not \isReferenceArray(#v))
	//"Normal Execution (#v != null)":
	//\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
	//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
	//(permissions:on) {
	//"Write Permission to #v[#se]":
	//\replacewith(\modality{#normal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality(post))
	//\add(==> writePermission(Permission::select(permissions, #v, arr(#se))))
	//};
	//"Null Reference (#v = null)":
	//\replacewith(\modality{#normal}{..
	//throw new java.lang.NullPointerException(); 
	//...}\endmodality(post))
	//\add (#v=null ==>);
	//"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
	//\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
	//\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	//\heuristics(simplify_prog, simplify_prog_subset)
	//};
	//}
	
	assignment_to_primitive_array_component_EventUpdate { 
		\schemaVar \program Variable #v;
		\schemaVar \program SimpleExpression #se,#se0;
		\schemaVar \formula post;
		
		\schemaVar \modalOperator { diamond, box } #normal; 
		\find (==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
		\varcond(\not \isReferenceArray(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)}
		{\event(write,singleton(#v,arr(#se)),timestamp)}\modality{#normal}{.. ...}\endmodality(post))
		//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
		;
		(permissions:on) {
		"Write Permission to #v[#se]":
		\replacewith(==> writePermission(Permission::select(permissions, #v, arr(#se))))
		};
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>);
		"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		\replacewith(==> false)
		\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};
	
//======================================================================================================================
//														Axioms
//======================================================================================================================

	noRaWOnEmptySet{
	
		\find(noRaW(empty))
		\replacewith(true)
		
		\heuristics(concrete)
	};
	
	noWaROnEmptySet{
	
		\find(noWaR(empty))
		\replacewith(true)
		
		\heuristics(concrete)
	};
	
	noWaWOnEmptySet{
	
		\find(noWaW(empty))
		\replacewith(true)
		
		\heuristics(concrete)
	};
	
	noWOnEmptySet{
	
		\find(noW(empty))
		\replacewith(true)
		
		\heuristics(concrete)
	};
	
	noROnEmptySet{
	
		\find(noR(empty))
		\replacewith(true)
		
		\heuristics(concrete)
	}; 
	
	rPredOnEmptySet{//New
		\schemaVar \term int id;
		
		\find(rPred(empty,id))
		\replacewith(false)
		
		\heuristics(concrete)
	}; 
	
	wPredOnEmptySet{//New
		\schemaVar \term int id;
		
		\find(wPred(empty,id))
		\replacewith(false)
		
		\heuristics(concrete)
	}; 
	
	noRAtHistoryOnEmptySet{
		\schemaVar \term int id;
		
		\find(noRAtHistory(empty,id))
		\replacewith(true)
		
		\heuristics(concrete)
	};
	
	noWAtHistoryOnEmptySet{
		\schemaVar \term int id;
		
		\find(noWAtHistory(empty,id))
		\replacewith(true)
		
		\heuristics(concrete)
	};
	
	noRaWAtHistoryOnEmptySet{
		\schemaVar \term int id;
		
		\find(noRaWAtHistory(empty,id))
		\replacewith(true)
		
		\heuristics(concrete)
	};
	
	noWaRAtHistoryOnEmptySet{
		\schemaVar \term int id;
		
		\find(noWaRAtHistory(empty,id))
		\replacewith(true)
		
		\heuristics(concrete)
	};
	
	noWaWAtHistoryOnEmptySet{
		\schemaVar \term int id;
		
		\find(noWaWAtHistory(empty,id))
		\replacewith(true)
		
		\heuristics(concrete)
	};

//======================================================================================================================
//	Update, Event Update, and Inverse Event Update  apply on Update, Event Update, and Inverse Event Update Rules
//======================================================================================================================
	
	applyUpdateOnEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term int ts;
	 	
	 	\find({u}(\event(rw, loc, ts)))
	 	
	 	\replacewith(\event({u}rw, {u}loc, {u}ts))
	 	
	 	\heuristics(update_apply_on_update)
	};
	
	applyUpdateParallelToEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;
	
		\find({u || \event(rw, loc, ts)}(pv := t))
		
		\replacewith((pv := {u || \event(rw, loc, ts)}t))
		
		\heuristics(update_apply_on_update)//userTaclets1)
	};

	applyUpdateOnInverseEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term int ts;
	 	
	 	\find({u}(\invEvUp(rw, loc, ts)))
	 	
	 	\replacewith(\invEvUp({u}rw, {u}loc, {u}ts))
	 	
	 	\heuristics(update_apply_on_update)
	};
	
	applyEventOnEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;
	 	
	 	\find({\event(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))
	 	
	 	\replacewith(\event({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))
	 	
	 	\heuristics(update_apply_on_update)
	};
 
	applyInverseEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;
		
		\find({\invEvUp(rw, loc, label)}(pv := t))
		
		\replacewith((pv := {\invEvUp(rw, loc, label)}t))
		
		\heuristics(update_apply_on_update)
	};
	
	applyUpdateParallelToInvEvUpOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \update u, invEvent;
	
		\find({u || invEvent}(pv := t))
		\varcond(\onlyInverseEventUpdates(invEvent))
		
		\replacewith((pv := {u || invEvent}t))
		
		\heuristics(update_apply_on_update)//userTaclets1)
	};
	
	applyInvEvUpParallelToUpdateOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \update u, invEvent;
	
		\find({invEvent || u}(pv := t))
		\varcond(\onlyInverseEventUpdates(invEvent))
		
		\replacewith((pv := {invEvent || u}t))
		
		\heuristics(update_apply_on_update)//userTaclets1)
	}; 
	
	applyInverseEventOnEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;
	 	
	 	\find({\invEvUp(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))
	 	
	 	\replacewith(\event({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))
	 	
	 	\heuristics(update_apply_on_update)
	};
 
	applyEventOnInverseEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;
	 	
	 	\find({\event(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))
	 	
	 	\replacewith(\invEvUp({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))
	 	
	 	\heuristics(update_apply_on_update)
	};

	applyInverseEventOnInverseEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;
	 	
	 	\find({\invEvUp(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))
	 	
	 	\replacewith(\invEvUp({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))
	 	
	 	\heuristics(update_apply_on_update)
	};
	
//======================================================================================================================
//										Event and Inverse Event Update Elimination Rules
//======================================================================================================================
	//---------------------------------------------------> Events:	 
	elimUpdateOnRigidTerm1 {
	    \schemaVar \term[rigid] any t;
		\schemaVar \update u;
		
		\find({u}t)
		
		\replacewith(t)
		
		\heuristics(update_elim)
	};
 
	elimEventOnRigidTerm2 {
		\schemaVar \term any t, result;
		\schemaVar \update u;	
		
		\find({u}t)
		\varcond(\applyEventOnRigid(u, t, result))
		
		\replacewith(result)
		
		\heuristics(update_elim)
	};

	elimEventOnRigidFormula1 {  
	    \schemaVar \formula[rigid] phi;
		\schemaVar \update u;
		
		\find({u}phi)
		
		\replacewith(phi)
		
		\heuristics(update_elim)
	};
 
	elimEventOnRigidFormula2 {
		\schemaVar \formula phi, result;
		\schemaVar \update u;
		
		\find({u}phi)
		\varcond(\applyEventOnRigid(u, phi, result))
		
		\replacewith(result)
		
		\heuristics(update_elim)
	};

	applyEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;	
		\schemaVar \term int ts;
		
		\find({\event(rw, loc, ts)}(pv := t))
		
		\replacewith((pv := {\event(rw, loc, ts)}t))
		
		\heuristics(update_apply_on_update)
	};
   
	elimEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
			
		\find({\event(rw, loc, ts)}pv)
		
		\replacewith(pv)
		
		\heuristics(update_elim)
	};
    
	elimEventOnSkip {
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		
		\find({\event(rw, loc, ts)}skip)
		
		\replacewith(skip)
		
		\heuristics(update_elim)
	};
	
	applyUpdateParallelToEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;
			
		\find({u || \event(rw, loc, ts)}pv)
		
		\replacewith({u}pv)
		
		\heuristics(update_apply)//userTaclets1)
	};
    
	applyUpdateParallelToEventOnSkip {
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;
		
		\find({u || \event(rw, loc, ts)}skip)
		
		\replacewith(skip)
		
		\heuristics(update_elim)//userTaclets1)
	};
	//---------------------------------------------------> Inverse Events:
	elimInverseEventOnRigidTerm1 {
		\schemaVar \term[rigid] any t;
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;
		
		\find({\invEvUp(rw, loc, label)} t)
		
		\replacewith(t)
		
		\heuristics(update_elim)
	};

	elimInverseEventOnRigidTerm2 {
		\schemaVar \term any t, result;
		\schemaVar \update u;	
		
		\find({u}t)
		\varcond(\applyInverseEventOnRigid(u, t, result))
		
		\replacewith(result)
		
		\heuristics(update_elim)
	};

	elimInverseEventOnRigidFormula1 {  
		\schemaVar \formula[rigid] phi;
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}phi)

		\replacewith(phi)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidFormula2 {
		\schemaVar \formula phi, result;
		\schemaVar \update u;

		\find({u}phi)
		\varcond(\applyInverseEventOnRigid(u, phi, result))

		\replacewith(result)

		\heuristics(update_elim)
	};

	elimInverseEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;
		
		\find({\invEvUp(rw, loc, label)}pv)
		
		\replacewith(pv)
		
		\heuristics(update_elim)
	};

	elimInverseEventOnSkip {
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;
		
		\find({\invEvUp(rw, loc, label)}skip)
		
		\replacewith(skip)
		
		\heuristics(update_elim)
	};	
	
	applyUpdateParallelToInvEvUpOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \update u, invEvent;
			
		\find({u || invEvent}pv)
		\varcond(\onlyInverseEventUpdates(invEvent))
		
		\replacewith({u}pv)
		
		\heuristics(update_apply)//userTaclets1)
	};
 
	 applyInvEvUpParallelToUpdateOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \update u, invEvent;
			
		\find({invEvent || u}pv)
		\varcond(\onlyInverseEventUpdates(invEvent))
		
		\replacewith({u}pv)
		
		\heuristics(update_apply)//userTaclets1)
	 };
    
	 applyUpdateParallelToInvEvUpOnSkip {
		\schemaVar \update u, invEvent;
		
		\find({u || invEvent}skip)
		\varcond(\onlyInverseEventUpdates(invEvent))
		
		\replacewith(skip)
		
		\heuristics(update_elim)//userTaclets1)
	 };
 
	applyInvEvUpParallelToUpdateOnSkip {
		\schemaVar \update u, invEvent;
		
		\find({invEvent || u}skip)
		\varcond(\onlyInverseEventUpdates(invEvent))
		
		\replacewith(skip)
		
		\heuristics(update_elim)//userTaclets1)
	};

//======================================================================================================================
//													Splitting Rules
//======================================================================================================================
	//---------------------------------------------------> Dependence Predicates:
	splitNoRaW {
	    \schemaVar \term LocSet loc1, loc2;
	 
	    \find(noRaW(union(loc1,loc2)))
	    \replacewith(noRaW(loc1) & noRaW(loc2))
	    
	    \heuristics(simplify)
	};
 
	splitNoWaR {
	    \schemaVar \term LocSet loc1, loc2;
	 
	    \find(noWaR(union(loc1,loc2)))
	    \replacewith(noWaR(loc1) & noWaR(loc2))
	    
	    \heuristics(simplify)
	};
 
	splitNoWaW {
	    \schemaVar \term LocSet loc1, loc2;
	 
	    \find(noWaW(union(loc1,loc2)))
	    \replacewith(noWaW(loc1) & noWaW(loc2))
	    
	    \heuristics(simplify)
	};
 
	splitNoR {
		\schemaVar \term LocSet loc1, loc2;
	 
	    \find(noR(union(loc1,loc2)))
	    \replacewith(noR(loc1) & noR(loc2))
	    
	    \heuristics(simplify)
	};
 
	splitNoW {
		\schemaVar \term LocSet loc1, loc2;
	 
		\find(noW(union(loc1,loc2)))
		\replacewith(noW(loc1) & noW(loc2))
	    
	    \heuristics(simplify)
	};
	
	//---------------------------------------------------> Dependence Predicates with EQ:
	splitNoRaWEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRaW(EQ)) \sameUpdateLevel
	    \replacewith(noRaW(loc1) & noRaW(loc2))
	  
	    \heuristics(simplify)
	};
 
	splitNoWaREQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaR(EQ)) \sameUpdateLevel
	    \replacewith(noWaR(loc1) & noWaR(loc2))
	    
	    \heuristics(simplify)
	};
 
	splitNoWaWEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaW(EQ)) \sameUpdateLevel
	    \replacewith(noWaW(loc1) & noWaW(loc2))
	  
	    \heuristics(simplify)
	};
 
	splitNoREQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noR(EQ)) \sameUpdateLevel
	    \replacewith(noR(loc1) & noR(loc2))
	  
	    \heuristics(simplify)
	};
 
	splitNoWEQ {
		\schemaVar \term LocSet EQ, loc1, loc2;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noW(EQ)) \sameUpdateLevel
	    \replacewith(noW(loc1) & noW(loc2))
	    
	    \heuristics(simplify)
	};
	
	//---------------------------------------------------> History Predicates:
	splitNoRaWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;
	 
	    \find(noRaWAtHistory(union(loc1,loc2), label))
	    \replacewith(noRaWAtHistory(loc1, label) & noRaWAtHistory(loc2, label))
	    
	    \heuristics(simplify)
	};
	
	splitNoWaRAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;
	 
	    \find(noWaRAtHistory(union(loc1,loc2), label))
	    \replacewith(noWaRAtHistory(loc1, label) & noWaRAtHistory(loc2, label))
	    
	    \heuristics(simplify)
	};
	
	splitNoWaWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;
	 
	    \find(noWaWAtHistory(union(loc1,loc2), label))
	    \replacewith(noWaWAtHistory(loc1, label) & noWaWAtHistory(loc2, label))
	    
	    \heuristics(simplify)
	};

	splitNoRAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;
	 
	    \find(noRAtHistory(union(loc1,loc2), label))
	    \replacewith(noRAtHistory(loc1, label) & noRAtHistory(loc2, label))
	    
	    \heuristics(simplify)
	};
	
	splitNoWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;
	 
	    \find(noWAtHistory(union(loc1,loc2), label))
	    \replacewith(noWAtHistory(loc1, label) & noWAtHistory(loc2, label))
	    
	    \heuristics(simplify)
	};
	
	//---------------------------------------------------> History Predicates with EQ:
	splitNoRaWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRaWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noRaWAtHistory(loc1, label) & noRaWAtHistory(loc2, label))
	  
	    \heuristics(simplify)
	};
	
	splitNoWaRAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaRAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWaRAtHistory(loc1, label) & noWaRAtHistory(loc2, label))
	  
	    \heuristics(simplify)
	};

	splitNoWaWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWaWAtHistory(loc1, label) & noWaWAtHistory(loc2, label))
	  
	    \heuristics(simplify)
	};
 
	splitNoRAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noRAtHistory(loc1, label) & noRAtHistory(loc2, label))
	  
	    \heuristics(simplify)
	};
	
	splitNoWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;
	 
	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWAtHistory(loc1, label) & noWAtHistory(loc2, label))
	  
	    \heuristics(simplify)
	};

//======================================================================================================================
//												Data Dependence Known
//======================================================================================================================
	//---------------------------------------------------> Data Dependence Predicates:
	// To Prove
	noRKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noR(loc1) ==> )
		\find(==> noR(loc2))	
		\replacewith(==> noR(setMinus(loc2,loc1)), subset(loc2,loc1))
		\heuristics(dep_pred_known)//_3,noEqApp)
	};
	
	//--------------------------------------------
	// These rules (and similar ones for other predicates) were causing Loops:
	
	// noRKnownForSupersetOrSubsetDef{
	//	\schemaVar \term LocSet loc1, loc2;
	//	
	//	\assumes(noR(loc1) ==> )
	//	\find(==> noR(loc2))
	//	
	//	\replacewith(==>noR(setMinus(loc2,loc1)))
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations_def)
	//	};
	// noRKnownForSupersetOrSubset2{
	//	\schemaVar \term LocSet loc1, loc2;
	//	
	//	\assumes(noR(loc1) ==> )
	//	\find(==> noR(loc2))
	//	
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations)
	//	};
	//----------------------------------------------

	noWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noW(loc1) ==> )
		\find(==> noW(loc2))
		\replacewith(==> subset(loc2,loc1), noW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known)//_3,noEqApp)
	};

	noRaWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noRaW(loc1) ==> )
		\find(==> noRaW(loc2))
		
		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)//_3)
	};

	noWaRKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noWaR(loc1) ==> )
		\find(==> noWaR(loc2))
		
		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)//_3
	};
	
	noWaWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noWaW(loc1) ==> )
		\find(==> noWaW(loc2))
		
		\replacewith(==> subset(loc2,loc1), noWaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};
 
	// To Prove
	noRKnownForSupersetOrSubsetOfNoRaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noR(loc1) ==> )
		\find(==>noRaW(loc2))
		
		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(saturate_dep_locset_relations_def)
	};
	
	//Old Version:
		
	//noReadKnownForSupersetOrSubsetOfNoRaW2{
	//	\schemaVar \term LocSet loc1, loc2;
	//	
	//	\assumes(noR(loc1) ==> )
	//	\find(==>noRaW(loc2))
	//	
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations)
	//};

	noWKnownForSupersetOrSubsetOfNoRaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noW(loc1) ==> )
		\find(==>noRaW(loc2))
		
		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(saturate_dep_locset_relations_def)
	};

	noWKnownForSupersetOrSubsetOfNoWaR{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noW(loc1) ==> )
		\find(==>noWaR(loc2))
		
		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)))
		\heuristics(saturate_dep_locset_relations_def)
	};

	noRKnownForSupersetOrSubsetOfNoWaR{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noR(loc1) ==> )
		\find(==>noWaR(loc2))
		
		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)) )
		\heuristics(saturate_dep_locset_relations_def)
	};

	noWKnownForSupersetOrSubsetOfNoWaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;
		
		\assumes(noW(loc1) ==> )
		\find(==>noWaW(loc2))
		
		\replacewith(==> subset(loc2,loc1), noWaW(setMinus(loc2,loc1)))
		\heuristics(saturate_dep_locset_relations_def) 
	};
	
	//---------------------------------------------------> History Data Dependence Predicates:
	noRAtHistoryOnBothSides{
		\schemaVar \term int id1, id2;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \update u;
		 
		\assumes(noRAtHistory(loc1,id1)==>)
		\find(==>noRAtHistory(loc2,id2))
		\replacewith(==>\if(id1 <= id2 ) \then(noRAtHistory(setMinus(loc2,loc1),id2)) \else(noRAtHistory(loc2,id2)))
		 
		\heuristics(dep_pred_known,noEqApp)
	};

	// To Prove
	noRAndNoRAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;
		 
		 \assumes(noR(loc1)==>)
		 \find(==>noRAtHistory(loc2,id2))
		 \replacewith(==>noRAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);
		 
		 \add(intersect(loc1,loc2)=empty==>)
		 
		 \heuristics(dep_pred_known)
	};

	noWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;
		 
		 \assumes(noWAtHistory(loc1,id1)==>)
		 \find(==> noWAtHistory(loc2,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWAtHistory(setMinus(loc2,loc1),id2)) \else(noWAtHistory(loc2,id2)))
		
		 \heuristics(dep_pred_known,noEqApp)
	};
	
	noWAndNoWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;
		 
		 \assumes(noW(loc1)==>)
		 \find(==>noWAtHistory(loc2,id2))
		 \replacewith(==>noWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);
		 
		 \add(intersect(loc1,loc2)=empty==>)
		 
		 \heuristics(dep_pred_known)
	};
	
	noRaWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;
		 
		 \assumes(noRaWAtHistory(loc1,id1)==>)
		 \find(==>noRaWAtHistory(loc2,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noRaWAtHistory(setMinus(loc2,loc1),id2)) \else(noRaWAtHistory(loc2,id2)))
		
		 \heuristics(dep_pred_known,noEqApp)
	};
	
	noRaWAndNoRaWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;
		 
		 \assumes(noRaW(loc1)==>)
		 \find(==>noRaWAtHistory(loc2,id2))
		 \replacewith(==>noRaWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);
		 
		 \add(intersect(loc1,loc2)=empty==>)
		 
		 \heuristics(dep_pred_known)
	};
	
	noWaRAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;
		 
		 \assumes(noWaRAtHistory(loc1,id1)==>)
		 \find(==>noWaRAtHistory(loc2,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWaRAtHistory(setMinus(loc2,loc1),id2)) \else(noWaRAtHistory(loc2,id2)))
		 
		 \heuristics(dep_pred_known,noEqApp)
	};
	
	noWaRAndNoWaRAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;
		 
		 \assumes(noWaR(loc1)==>)
		 \find(==>noWaRAtHistory(loc2,id2))
		 \replacewith(==>noWaRAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);
		 
		 \add(intersect(loc1,loc2)=empty==>)
		 
		 \heuristics(dep_pred_known)
	};
	
	noWaWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;
		 
		 \assumes(noWaWAtHistory(loc1,id1)==>)
		 \find(==>noWaWAtHistory(loc2,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWaWAtHistory(setMinus(loc2,loc1),id2)) \else(noWaWAtHistory(loc2,id2)))
		 
		 
		 \heuristics(dep_pred_known,noEqApp)
	};
	
	noWaWAndNoWaWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2; 
		 
		 \assumes(noWaW(loc1)==>)
		 \find(==>noWaWAtHistory(loc2,id2))
		 \replacewith(==>noWaWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);
		 
		 \add(intersect(loc1,loc2)=empty==>)
		 
		 \heuristics(dep_pred_known)
	};


//======================================================================================================================
//							Update and Event Update Application on Data Dependence Predicates
//======================================================================================================================
	//---------------------------------------------------> Eliminate State Updates:
	elimStateUpdatesBeforeNoRaW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		
		\find({pv:=t || u} noRaW(tr))
		\replacewith({u}noRaW(tr))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoWaR{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		
		\find({pv:=t || u} noWaR(tr))
		\replacewith({u}noWaR(tr))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoWaW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		
		\find({pv:=t || u} noWaW(tr))
		\replacewith({u}noWaW(tr))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoR{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		
		\find({pv:=t || u} noR(tr))
		\replacewith({u}noR(tr))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		
		\find({pv:=t || u} noW(tr))
		\replacewith({u}noW(tr))
		\heuristics(update_elim)
	};
	
	//---------------------------------------------------> {event} Data Dependence Predicates:   
	// To Prove
	writeEventBeforeNoRaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		
		\find({\event(write, loc1, ts)} noRaW(loc2))
		
		\replacewith(noRaW({\event(write, loc1, ts)}loc2))
		
		\heuristics(update_apply)//userTaclets1)
	};
	
	// To Prove
	readEventBeforeNoRaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
		
		\find({\event(read, loc1, ts)} noRaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))
			
		\replacewith(noRaW(tempVar))
		\add(tempVar = {\event(read, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );
		
		\replacewith(noW(intersect(loc1, tempVar)) & noRaW(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(read, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )
		
		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoWaR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
		
		\find({\event(write, loc1, ts)} noWaR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))
			
		\replacewith(noWaR(tempVar))
		\add(tempVar = {\event(write, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );
		
		\replacewith(noR(intersect(loc1, tempVar)) & noWaR(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(write, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )
		
		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoWaR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		
		\find({\event(read, loc1, ts)} noWaR(loc2))
		
		\replacewith( noWaR({\event(read, loc1, ts)}loc2))
		
		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoWaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
		
		\find({\event(write, loc1, ts)} noWaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))
			
		\replacewith(noWaW(tempVar))
		\add(tempVar = {\event(write, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );
		
		\replacewith(noW(intersect(loc1, tempVar)) & noWaW(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(write, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )
		
		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoWaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		
		\find({\event(read, loc1, ts)} noWaW(loc2))
		
		\replacewith( noWaW({\event(read, loc1, ts)}loc2))
		
		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
		
		\find(==> {\event(write, loc1, ts)} noW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))        
	    
	    \replacewith(==> noW(tempVar))
	    \add(tempVar = {\event(write, loc1, ts)}loc2,
	    	intersect(loc1, tempVar) = empty ==> );
	    
	    \replacewith(==> false)
	    \add(tempVar = {\event(write, loc1, ts)}loc2,
	    	!(intersect(loc1, tempVar) = empty) ==> )
	    
		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		
		\find({\event(read, loc1, ts)} noW(loc2))
		
		\replacewith( noW({\event(read, loc1, ts)}loc2))
		
		\heuristics(update_apply)//userTaclets1)
	};  

	// To Prove
	writeEventBeforeNoR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		
		\find({\event(write, loc1, ts)} noR(loc2))
		
		\replacewith(noR({\event(write, loc1, ts)}loc2))
		
		\heuristics(update_apply)//userTaclets1)
	};

	// To Prove
	readEventBeforeNoR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
		
		\find(==> {\event(read, loc1, ts)} noR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))        
	    
	    \replacewith(==> noR(tempVar))
	    \add(tempVar = {\event(read, loc1, ts)}loc2,
	    	intersect(loc1, tempVar) = empty ==> );
	    
	    \replacewith(==> false)
	    \add(tempVar = {\event(read, loc1, ts)}loc2,
	    	!(intersect(loc1, tempVar) = empty) ==> )
	    
		\heuristics(update_apply)//userTaclets1)
	};
	
	//---------------------------------------------------> {u || event} Data Dependence Predicates:
	updateParallelToReadEventOnNoRaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(read, loc1, ts)} noRaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))
	 	
	     \replacewith(==> {u}noRaW(tempVar))
	     \add(tempVar = {\event(read, loc1, ts)}loc2, 
	          intersect(loc1, tempVar) = empty ==> ); 
	 	
	    \replacewith(==> ({u}noW(intersect(tempVar, loc1))) & {u}noRaW(setMinus(tempVar, loc1)))
	     \add(tempVar = {\event(read, loc1, ts)}loc2, 
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};
 
	updateParallelToWriteEventOnNoRaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(write, loc1, ts)} noRaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))        
	     
	     \replacewith(==> {u}noRaW(tempVar))
	     \add(tempVar = {\event(write, loc1, ts)}loc2 ==> )
	     
	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToWriteEventOnNoWaR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(write, loc1, ts)} noWaR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))      
	 	
	     \replacewith(==> {u}noWaR(tempVar))
	     \add(tempVar = {\event(write, loc1, ts)}loc2,
	     	intersect(tempVar, loc1) = empty ==> );
	 	
	     \replacewith(==> ({u}noR(intersect(tempVar, loc1))) & {u}noWaR(setMinus(tempVar, loc1)))
	     \add(tempVar = {\event(write, loc1, ts)}loc2,
	     	!(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};
	updateParallelToReadEventOnNoWaR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(read, loc1, ts)} noWaR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))        
	     
	     \replacewith(==> {u}noWaR(tempVar))
	     \add(tempVar = {\event(read, loc1, ts)}loc2 ==>)
	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToWriteEventOnNoWaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(write, loc1, ts)} noWaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))  
	 	
	     \replacewith(==> {u}noWaW(tempVar))
	     \add(tempVar = {\event(write, loc1, ts)}loc2,
	     	intersect(tempVar, loc1) = empty ==> );
	 	
	     \replacewith(==> {u}noW(intersect(tempVar, loc1)) & {u}noWaW(setMinus(tempVar, loc1)))
	     \add(tempVar = {\event(write, loc1, ts)}loc2,
	     	!(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};
 
	updateParallelToReadEventOnNoWaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(read, loc1, ts)} noWaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))        
	     
	     \replacewith(==> {u}noWaW(tempVar))
	     \add(tempVar = {\event(read, loc1, ts)}loc2 ==> )
	     \heuristics(update_apply)//userTaclets1)
	 };

	updateParallelToReadEventOnNoR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(read, loc1, ts)} noR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))        
	     \replacewith(==> {u}noR(tempVar))
	     \add(tempVar = {\event(read, loc1, ts)}loc2, 
	          intersect(loc1, tempVar) = empty ==> );  
	 	
	     \replacewith(==> false)
	     \add(tempVar = {\event(read, loc1, ts)}loc2, 
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};
 
 	updateParallelToWriteEventOnNoR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(write, loc1, ts)} noR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))        
	     
	     \replacewith(==> {u}noR(tempVar))
	     \add(tempVar = {\event(write, loc1, ts)}loc2 ==> )
	     
	     \heuristics(update_apply)//userTaclets1)
 	};

 	updateParallelToWriteEventOnNoW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(write, loc1, ts)} noW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))        
	     \replacewith(==> {u}noW(tempVar))
	     \add(tempVar = {\event(write, loc1, ts)}loc2, 
	          intersect(loc1, tempVar) = empty ==> );  
	 	
	     \replacewith(==> false)
	     \add(tempVar = {\event(write, loc1, ts)}loc2, 
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
 	};
 
 	updateParallelToReadEventOnNoW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;
	 	
	 	\find(==> {u || \event(read, loc1, ts)} noW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))        
	     
	     \replacewith(==> {u}noW(tempVar))
	     \add(tempVar = {\event(read, loc1, ts)}loc2 ==> )
	     
	     \heuristics(update_apply)//userTaclets1)
 	};
 	
 	//---------------------------------------------------> {u} Data Dependence Predicates:
 	simplifyNONEventUpdateNoR {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;
 		
 		\find({u1||u2}noR(loc))
 		
 		\varcond(\noEventUpdate(u1))   
 		
 		\replacewith({u2}noR(loc))
 		
 		\heuristics(update_apply)
 	};
 	
 	simplifyNONEventUpdateNoW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;
 		
 		\find({u1||u2}noW(loc))
 		
 		\varcond(\noEventUpdate(u1))   
 		
 		\replacewith({u2}noW(loc))
 		
 		\heuristics(update_apply)
 	};
 	
 	simplifyNONEventUpdateNoRaW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;
		
 		\find({u1||u2}noRaW(loc))
		
 		\varcond(\noEventUpdate(u1))   
		
 		\replacewith({u2}noRaW(loc))
		
 		\heuristics(update_apply)
	};
 	   
 	simplifyNONEventUpdateNoWaR {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;
	
 		\find({u1||u2}noWaR(loc))
	
 		\varcond(\noEventUpdate(u1))
	
 		\replacewith({u2}noWaR(loc))
	
 		\heuristics(update_apply)
 	};
 	   
 	simplifyNONEventUpdateNoWaW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;
 		
 		\find({u1||u2}noWaW(loc))
 		
 		\varcond(\noEventUpdate(u1))
 	             
 		\replacewith({u2}noWaW(loc))
 		
 		\heuristics(update_apply)
 	};

//======================================================================================================================
//										Non-Event and Non-InverseEvent Update Propagation Rules
//======================================================================================================================
    
	propagateNonEventUpdateONnoRaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		
		\find({u}noRaW(loc))
		\varcond(\noEventUpdate(u), \noInverseEventUpdate(u)) 
		
		\replacewith(noRaW({u}loc))
		
		\heuristics(update_apply)
	};
 
	propagateNonEventUpdateONnoWaR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		
		\find({u}noWaR(loc))
		
		\varcond(\noEventUpdate(u), \noInverseEventUpdate(u)) 
		
		\replacewith(noWaR({u}loc))
		
		\heuristics(update_apply)
	};
 
	propagateNonEventUpdateONnoWaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		
		\find({u}noWaW(loc))
		
		\varcond(\noEventUpdate(u), \noInverseEventUpdate(u)) 
		
		\replacewith(noWaW({u}loc))
		
		\heuristics(update_apply)
	};
 
	propagateNonEventUpdateONnoR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		
		\find({u}noR(loc))
		
		\varcond(\noEventUpdate(u), \noInverseEventUpdate(u)) 
		
		\replacewith(noR({u}loc))
		
		\heuristics(update_apply)
	};
 
	propagateNonEventUpdateONnoW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		
		\find({u}noW(loc))
		
		\varcond(\noEventUpdate(u), \noInverseEventUpdate(u)) 
		
		\replacewith(noW({u}loc))
		
		\heuristics(update_apply)
	};
	
//======================================================================================================================
//													Event Shifting Rules
//======================================================================================================================
	shiftEventParallelToUpdate {
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	\schemaVar \update u;
	 	
	 	\find(\event(rw, loc, ts) || u)
	 	
	 	\varcond(\noEventUpdate(u)) 
	 	
	 	\replacewith(u || \event(rw, loc, ts))
	 	
	 	\heuristics(update_apply)
	};
	
	shiftEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	
	 	\find(\event(rw, loc, ts) || pv:=t)
	 	
	 	\replacewith(pv:=t || \event(rw, loc, ts))
	 	
	 	\heuristics(update_apply)
	};
	
	shiftOnlyEventParallelToElementry {// Ask Richard: What is its difference with the rule above
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update evUp;
	 	
	 	\find(evUp || pv:=t)
	 	\varcond(\onlyEventUpdates(evUp))
	 	
	 	\replacewith(pv:=t || evUp)
	 	
	 	\heuristics(update_apply)
	};

	shiftEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	
	 	\find(u || \event(rw, loc, ts) || pv:=t)
	 	
	 	\replacewith(u || pv:=t || \event(rw, loc, ts))
	 	
	 	\heuristics(update_apply)
	 };
	 
	shiftEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		
		\find(\event(rw, loc, ts) || pv:=t || u)
		
		\replacewith(pv:=t || \event(rw, loc, ts) || u)
		
		\heuristics(update_apply)
	};

	shiftOnlyEventWithUpdateAtFirstPlace {
	 	\schemaVar \update evUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	
	 	\find(u || evUp || pv:=t)
	 	\varcond(\onlyEventUpdates(evUp))
	 	
	 	\replacewith(u || pv:=t || evUp)
	 	
	 	\heuristics(update_apply)
	};

	shiftOnlyEventWithUpdateAtLastPlace {
	 	\schemaVar \update evUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	
	 	\find( pv:=t || evUp || u)
	 	\varcond(\onlyEventUpdates(evUp),\noEventUpdate(u))
	 	
	 	\replacewith(pv:=t || u || evUp)
	 	
	 	\heuristics(update_apply)
	};

//======================================================================================================================
//									Inverse Event Update Application on History Predicates
//======================================================================================================================
	simplifyNONInverseEventUpdateNoRAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;
		
		\find({u1||u2}noRAtHistory(loc, id))
		
		\varcond(\noInverseEventUpdate(u1))   
		
		\replacewith({u2}noRAtHistory({u1}loc, {u1}id))
		
		\heuristics(update_apply)
	};
	
	simplifyNONInverseEventUpdateNoWAtHistory {
	   \schemaVar \update u1,u2;
	   \schemaVar \term LocSet loc;
	   \schemaVar \term int id;
		
		\find({u1||u2}noWAtHistory(loc, id))
		
		\varcond(\noInverseEventUpdate(u1))   
		
		\replacewith({u2}noWAtHistory({u1}loc, {u1}id))
		
		\heuristics(update_apply)
	};  
	
	simplifyNONInverseEventUpdateNoRaWAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;
	 	
		\find({u1||u2}noRaWAtHistory(loc, id))
		
		\varcond(\noInverseEventUpdate(u1))   
		
		\replacewith({u2}noRaWAtHistory({u1}loc, {u1}id))
		
		\heuristics(update_apply)
	};
	   
	simplifyNONInverseEventUpdateNoWaRAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;
		
		\find({u1||u2}noWaRAtHistory(loc, id))
		
		\varcond(\noInverseEventUpdate(u1))
		
		\replacewith({u2}noWaRAtHistory({u1}loc, {u1}id))
		
		\heuristics(update_apply)
	};
	   
	simplifyNONInverseEventUpdateNoWaWAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;
		
		\find({u1||u2}noWaWAtHistory(loc, id))
		
		\varcond(\noInverseEventUpdate(u1))
	             
		\replacewith({u2}noWaWAtHistory({u1}loc, {u1}id))
		
		\heuristics(update_apply)
	};

//======================================================================================================================
//										Non-InverseEventUpdate Application on Read and Write Predicates
//======================================================================================================================
	simplifyUpdateOnReadPred {
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
	
		\find({u}rPred(loc, ts))
		\varcond(\noInverseEventUpdate(u))  
		
		\replacewith(rPred({u}loc, {u}ts))
		
		\heuristics(update_apply)
	};
		
	simplifyUpdateOnWritePred {
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
	
		\find({u}wPred(loc, ts))
		\varcond(\noInverseEventUpdate(u))   
		
		\replacewith(wPred({u}loc, {u}ts))
		
		\heuristics(update_apply)
	};

//======================================================================================================================
//								Read and Write Predicates in Relation to noX and noXAtHitory
//======================================================================================================================
	//---------------------------------------------------> With noX
	//To Prove
	rPredAndNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1;
		
		\assumes(rPred(loc1,label1) ==>)
		\find(==> noR(loc2))
		
		\replacewith(==>false)
		\add(intersect(loc1,loc2)!=empty==>);
		
		\add(intersect(loc1,loc2)=empty==>)
		
		\heuristics(dep_pred_known_3)//,simplify)
	};

	wPredAndNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1;
		
		\assumes(wPred(loc1,label1) ==>)
		\find(==> noW(loc2))
		
		\replacewith(==>false)
		\add(intersect(loc1,loc2)!=empty==>);
		
		\add(intersect(loc1,loc2)=empty==>)
		
		\heuristics(dep_pred_known_3)
	};

	wPredAndNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;
		
		\assumes(wPred(loc1,label1)==>)
		\find(==> noWaR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(loc2)))
	
		\replacewith(==> noWaR(setMinus(loc2,loc1)) & noRAtHistory(tempVar,label1 + 1))
		\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);
		
		
		\add(intersect(loc1,loc2)=empty==>)
		
		\heuristics(dep_pred_known_2)
	};

	//To Prove
	rPredAndNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;
		
		\assumes(rPred(loc1,label1)==>)
		\find(==> noRaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
		        \new(tempVar, \dependingOn(loc2)))
		
		\replacewith(==> noRaW(setMinus(loc2,loc1)) & noWAtHistory(tempVar, label1 + 1))
		
		\add(tempVar = intersect(loc1,loc2), !tempVar=empty ==>);
		
		\add(intersect(loc1,loc2)=empty==>)
		
		\heuristics(dep_pred_known_2)
	};

	//--------------SPECIAL TO NOWAW----------------------------
	//To Prove
	wPredAndNoWaWPrecise{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1,label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find(wPred(loc2,label2) ==>  )
		\add( \if (label1 = label2) \then (loc1 = loc2) 
		      \else ( 
		         !intersect(loc1,loc2)=empty -> !noWaW( intersect(loc1,loc2) ) ) ==>)
		
		\heuristics(no_self_application, dep_pred_known_2)//,simplify)
	};

	wPredAndNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;
		
		\assumes(wPred(loc1,label1)==>)
		\find(==> noWaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(loc2)), \notFreeIn(label2, label1), \notFreeIn(loc3, label1))
	
		\replacewith(==> noWaW(setMinus(loc2, loc1)) & noWAtHistory(tempVar, label1 + 1) & (\forall loc3; (\forall label2; (0<=label2 & label2<label1 & !(intersect(tempVar, loc3) = empty) -> !wPred(loc3,label2) ) ) ) )
		\add(tempVar=intersect(loc1,loc2)==>)
		
		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
	};

	//---------------------------------------------------> With noXAtHistory
		
	//---------------------------------------------------> A. Same Label --- 1. xPred ==> noXHistory
	// To Prove
	rPredANDNoRHistoryRightSameLabel{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noRAtHistory(loc2,label))

		\replacewith(==> intersect(loc1,loc2)=empty & noRAtHistory(loc2,label + 1))

		\heuristics(dep_pred_known_3,noEqApp)//,simplify)
	};
	
	// To Prove
	rPredANDnoWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(rPred(loc1,label) ==>)
		\find(==> noWAtHistory(loc2,label))
		\replacewith(==> noWAtHistory(loc2,label+1))
		
		\heuristics(simplify)
	};
	
	// To Prove
	rPredANDnoRAWHistoryRightSameLabel {// add -> replace
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(rPred(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noWAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(simplify,noEqApp)
	};
	
	rPredANDNoWARHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(rPred(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(loc2,label+1))
		
		\heuristics(simplify)
	};
	
	rPredANDnoWAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(rPred(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\replacewith(==> noWaWAtHistory(loc2,label+1))
		
		\heuristics(simplify)
	};

	wPredANDNoRHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(wPred(loc1,label) ==>)
		\find(==> noRAtHistory(loc2,label))
		\replacewith(==> noRAtHistory(loc2,label+1))
		
		\heuristics(simplify)
	};
	
	wPredANDNoWHistoryRightSameLabel{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noWAtHistory(loc2,label))

		\replacewith(==> intersect(loc1,loc2)=empty & noWAtHistory(loc2,label + 1))

		\heuristics(dep_pred_known_3,noEqApp)//,simplify)
	};
	
	wPredANDNoRAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(wPred(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(loc2,label+1))
		
		\heuristics(simplify)
	};
	
	wPredANDnoWARHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(wPred(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\add(==> noWaRAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noRAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(simplify,noEqApp)
	};
	
	wPredANDnoWAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(wPred(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\add(==> noWaWAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noWAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(simplify,noEqApp)
	};
	
	//---------------------------------------------------> A. Same Label --- 2. xPred & noXHistory ==>
	rPredANDnoRAtHistorySameLabel {//necessary?
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(rPred(loc1,label) ==>)
		\find(noRAtHistory(loc2,label)==>)
		\add(intersect(loc1,loc2) = empty ==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};
	
//	rPredAndNoRaWAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//		
//		\assumes(rPred(loc1,label)==>)
//		\find(noRaWAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//	
//		\replacewith( noRaWAtHistory(setMinus(loc2, loc1),label) & noWAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//		
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};
	
	// To Prove
	rPredANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(rPred(loc1,label) ==>)
		\find(noRaWAtHistory(loc2,label)==>)
		\add(noWAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

	wPredANDnoWAtHistorySameLabel {// necessary?
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(wPred(loc1,label) ==>)
		\find(noWAtHistory(loc2,label)==>)
		\add(intersect(loc1,loc2) = empty ==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};
	
//	wPredAndNoWaRAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//		
//		\assumes(wPred(loc1,label)==>)
//		\find(noWaRAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//	
//		\replacewith( noWaRAtHistory(setMinus(loc2, loc1),label) & noRAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//		
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};

	wPredANDnoWARHistSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(wPred(loc1,label) ==>)
		\find(noWaRAtHistory(loc2,label)==>)
		\add(noRAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};
	
//	wPredAndNoWaWAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//		
//		\assumes(wPred(loc1,label)==>)
//		\find(noWaWAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//	
//		\replacewith( noWaWAtHistory(setMinus(loc2, loc1),label) & noWAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//		
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};
	
	wPredANDnoWAWHistSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(wPred(loc1,label) ==>)
		\find(noWaWAtHistory(loc2,label)==>)
		\add(noWAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};
	
	//---------------------------------------------------> B. Different Label --- 1. xPred BEFORE noXAtHistory ==>
	// To Prove
	rPredBEFOREnoRaWAtHistory {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(rPred(loc1,label1) ==>)
		\find   (noRaWAtHistory(loc2,label2)==>)
		\add(\if(label1=label2+1) 
		\then(noWAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noRaWAtHistory(loc2,label2)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	//rPredBEFOREnoWaRHistory {// OLD
	//\schemaVar \term LocSet loc1,loc2;
	//\schemaVar \term int label1, label2;
	//
	//\assumes(rPred(loc1,label1) ==>)
	//\find(noWaRAtHistory(loc2,label2)==>)
	//\add(\if(label1=label2+1) 
	//\then(noWAtHistory(intersect(loc1,loc2),label1+1))
	//\else(noWaRAtHistory(loc2,label2))==>)
	//\heuristics(dep_pred_known,noEqApp)
	//};
	wPredBEFOREnoWaRHistory {//NEW
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find   (noWaRAtHistory(loc2,label2)==>)
		\add(\if(label1=label2+1) 
		\then(noRAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noWaRAtHistory(loc2,label2)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	
	wPredBEFOREnoWaWHist {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find   (noWaWAtHistory(loc2,label2)==>)
		\add(\if(label1=label2+1) 
		\then(noWAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noWaWAtHistory(loc2,label2)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	//---------------------------------------------------> B. Different Label --- 2. xPred AFTER noXAtHistory ==>
	// To Prove
	rPredAFTERnoRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(rPred(loc1,label1) ==>)
		\find(noRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noRAtHistory(setMinus(loc2,loc1),label1))
		\else(noRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	
	// To Prove
	rPredAFTERnoWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(rPred(loc1,label1) ==>)
		\find(noWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noWAtHistory(loc2,label1))
		\else(noWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	
	rPredAFTERnoRaWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(rPred(loc1,label1) ==>)
		\find(noRaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noRaWAtHistory(setMinus(loc2,loc1),label1))
		\else(noRaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	
	rPredAFTERnoWaRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(rPred(loc1,label1) ==>)
		\find(noWaRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noWaRAtHistory(loc2,label1))
		\else(noWaRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	rPredAFTERnoWAWHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(rPred(loc1,label1) ==>)
		\find(noWaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noWaWAtHistory(loc2,label1))
		\else(noWaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredAFTERnoRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find(noRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noRAtHistory(loc2,label1))
		\else(noRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	
	wPredAFTERnoWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find(noWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noWAtHistory(setMinus(loc2,loc1),label1))
		\else(noWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	
	wPredAFTERnoRaWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find(noRaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noRaWAtHistory(loc2,label1))
		\else(noRaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	
	wPredAFTERnoWaRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find(noWaRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noWaRAtHistory(setMinus(loc2,loc1),label1))
		\else(noWaRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	
	wPredAFTERnoWAWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find(noWaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1) 
		\then(noWaWAtHistory(setMinus(loc2,loc1),label1))
		\else(noWaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	//---------------------------------------------------> B. Different Label --- 3. xPred BEFORE  ==> noXAtHistory
	// To Prove
	rPredBEFOREnoRAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(rPred(loc1,label1) ==>)
		\find   (==> noRAtHistory(loc2,label2))
		\replacewith(==> \if(label1=label2+1) \then(intersect(loc1, loc2) = empty) \else(noRAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};
	
	// To Prove
	rPredBEFOREnoRaWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(rPred(loc1,label1) ==>)
		\find (==> noRaWAtHistory(loc2,label2))
		\replacewith(==>\if(label1=label2+1) 
		\then(noRaWAtHistory(setMinus(loc2,loc1), label2) & noWAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noRaWAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredBEFOREnoWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find (==> noWAtHistory(loc2,label2))
		\replacewith(==> \if(label1=label2+1) \then(intersect(loc1, loc2) = empty) \else(noWAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};
	
	wPredBEFOREnoWaRAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find (==> noWaRAtHistory(loc2,label2))
		\replacewith(==>\if(label1=label2+1) 
		\then(noWaRAtHistory(setMinus(loc2,loc1), label2) & noRAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noWaRAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};
	
	wPredBEFOREnoWaWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;
		
		\assumes(wPred(loc1,label1) ==>)
		\find   (==> noWaWAtHistory(loc2,label2))
		\replacewith(==>\if(label1=label2+1) 
		\then(noWaWAtHistory(setMinus(loc2,loc1), label2) & 
		noWAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noWaWAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};


//======================================================================================================================
//											noXAtHistory & noXAtHistory Rules
//======================================================================================================================
	//---------------------------------------------------> Different Labels: like the rule below (commented out), are taken care of with the rules relating xPreds to noXAtHistory Preds
	//noWaHnoWAWHistFull {
	//\schemaVar \term LocSet loc1,loc2;
	//\schemaVar \term int label1,label2;
	//
	//\assumes(noWAtHistory(loc1,label1) ==>)
	//\find(==> noWaWAtHistory(loc2,label2))
	//\replacewith(==> \if(label1<=label2) \then (noWaWAtHistory(setMinus(loc2,loc1),label2+1)) \else (noWaWAtHistory(loc2,label2)))
	//
	//\heuristics(simplify_enlarging,noEqApp)
	//
	//};
	
	//---------------------------------------------------> Same Label
	noRAtHistoryANDnoRAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noRAtHistory(loc1,label) ==>)
		\find(==> noRAtHistory(loc2,label))
		\replacewith(==> noRAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};

	noRAtHistoryANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noRAtHistory(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};

	noRAtHistoryANDnoWaRAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noRAtHistory(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};

	noWAtHistoryANDnoWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noWAtHistory(loc1,label) ==>)
		\find(==> noWAtHistory(loc2,label))
		\replacewith(==> noWAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};
	
	noWAtHistoryANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noWAtHistory(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};
	noWAtHistoryANDnoWaRAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noWAtHistory(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};
	noWAtHistoryANDnoWaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noWAtHistory(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\replacewith(==> noWaWAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};

	noRaWAtHistoryANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noRaWAtHistory(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};
	
	noWaRAtHistoryANDnoWaRAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noWaRAtHistory(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};
	
	noWaWAtHistoryANDnoWaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
		
		\assumes(noWaWAtHistory(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\replacewith(==> noWaWAtHistory(setMinus(loc2,loc1),label))
		
		\heuristics(dep_pred_known,noEqApp)
	};

//======================================================================================================================
//										Read and Write Predicates Relation
//======================================================================================================================
	
	wPredrPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
	
		\assumes(wPred(loc1,label) ==>)
		\find(rPred(loc2,label))
		\replacewith(false)
	
	    \heuristics(concrete)
	};

	wPredwPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
	
		\assumes(wPred(loc1,label) ==>)
		\find(wPred(loc2,label))
		\replacewith(loc1=loc2)
	
	    \heuristics(simplify,no_self_application)
	};


	rPredrPred {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
	
		\assumes(rPred(loc1,label) ==>)
		\find(rPred(loc2,label))
		\replacewith(loc1=loc2)
	
	    \heuristics(simplify,no_self_application)
	};

	rPredwPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;
	
		\assumes(rPred(loc1,label) ==>)
		\find(wPred(loc2,label))
		\replacewith(false)
	
	    \heuristics(concrete)
	};

//======================================================================================================================
//											Update Application on noX At History Predicates 
//======================================================================================================================
	
	elimStateUpdatesBeforeNoRaWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;
		
		\find({pv:=t || u} noRaWAtHistory(tr, id))
		\replacewith({u}noRaWAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoRaWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;
		
		\find({u || pv:=t} noRaWAtHistory(tr, id))
		\replacewith({u}noRaWAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoWaRAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;
		
		\find({pv:=t || u} noWaRAtHistory(tr, id))
		\replacewith({u}noWaRAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoWaRAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;
		
		\find({u || pv:=t} noWaRAtHistory(tr, id))
		\replacewith({u}noWaRAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoWaWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;
		 
		\find({pv:=t || u} noWaWAtHistory(tr, id))
		\replacewith({u}noWaWAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoWaWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;
		 
		\find({u || pv:=t} noWaWAtHistory(tr, id))
		\replacewith({u}noWaWAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoRAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;
		 
		\find({pv:=t || u} noRAtHistory(tr, id))
		\replacewith({u}noRAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoRAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;
		 
		\find({u || pv:=t} noRAtHistory(tr, id))
		\replacewith({u}noRAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;
		
		\find({pv:=t || u} noWAtHistory(tr, id))
		\replacewith({u}noWAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	elimStateUpdatesBeforeNoWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;
		
		\find({u || pv:=t} noWAtHistory(tr, id))
		\replacewith({u}noWAtHistory(tr, id))
		\heuristics(update_elim)
	};
	
	updateOnNoRAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;
		  
		 \find({u}noRAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u)) 
		 \replacewith(noRAtHistory({u}loc,{u}id))
		 	
		 \heuristics(update_apply)
	};
	
	updateOnNoWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;
		 
		 \find({u}noWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u)) 
		 \replacewith(noWAtHistory({u}loc,{u}id))
		 	
		 \heuristics(update_apply)
	};
	
	updateOnNoRaWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;
		 
		 \find({u}noRaWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u)) 
		 \replacewith(noRaWAtHistory({u}loc,{u}id))
		 	
		 \heuristics(update_apply)
	};
	
	updateOnNoWaRAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;
		 
		 \find({u}noWaRAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u)) 
		 \replacewith(noWaRAtHistory({u}loc,{u}id))
		 	
		 \heuristics(update_apply)
	};
	
	updateOnNoWaWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;
		 
		 \find({u}noWaWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u)) 
		 \replacewith(noWaWAtHistory({u}loc,{u}id))
		 	
		 \heuristics(update_apply)
	};

//======================================================================================================================
//										Data Dependence Simplification rules for heuristics 
//======================================================================================================================
 	//---------------------------------------------------> Same location sets
	rPredAndNoROnSameLocations{
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		
		\assumes(rPred(loc, label) ==>)
		\find(noR(loc)) \sameUpdateLevel
		\replacewith(false)
		\heuristics(concrete)
	};
	wPredAndNoWOnSameLocations{
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		
		\assumes(wPred(loc, label) ==>)
		\find(noW(loc)) \sameUpdateLevel
		\replacewith(false)
		\heuristics(concrete)
	};
	noRAndNoRaWOnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noR(loc) ==>)
		\find(noRaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
		
	noWAndNoRaWOnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noW(loc) ==>)
		\find(noRaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
	
	noRAndNoWaROnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noR(loc) ==>)
		\find(noWaR(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
	
	noWAndNoWaROnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noW(loc) ==>)
		\find(noWaR(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
		
	noWAndNoWaWOnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noW(loc) ==>)
		\find(noWaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

//======================================================================================================================
//											Inverse Event Updte Application
//======================================================================================================================
 	//---------------------------------------------------> Nothing Inverse Event Update
	nothingToSkip{
		\schemaVar \term LocSet loc1;
		\schemaVar \term int label;
		
		\find(\invEvUp(nothing, loc1, label))
		\replacewith(skip)
		\heuristics(update_apply)
	};
	
	nothingInverseOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		
		\find({\invEvUp(nothing, loc1, label)}noR(loc2))
		\replacewith(noR(loc2))
		\heuristics(update_apply)
	};
	
	nothingInverseOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		
		\find({\invEvUp(nothing, loc1, label)}noW(loc2))
		\replacewith(noW(loc2))
		\heuristics(update_apply)
	};
	
	nothingInverseOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		
		\find({\invEvUp(nothing, loc1, label)}noRaW(loc2))
		\replacewith(noRaW(loc2))
		\heuristics(update_apply)
	};
	
	nothingInverseOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		
		\find({\invEvUp(nothing, loc1, label)}noWaR(loc2))
		\replacewith(noWaR(loc2))
		\heuristics(update_apply)
	};
	
	nothingInverseOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		
		\find({\invEvUp(nothing, loc1, label)}noWaW(loc2))
		\replacewith(noWaW(loc2))
		\heuristics(update_apply)
	};
	
	nothingInverseLastInParallelOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;
		
		\find({u || \invEvUp(nothing, loc1, label)}noR(loc2))
		\replacewith({u}noR(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;
		
		\find({u || \invEvUp(nothing, loc1, label)}noW(loc2))
		\replacewith({u}noW(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;
		
		\find({u || \invEvUp(nothing, loc1, label)}noRaW(loc2))
		\replacewith({u}noRaW(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;
		
		\find({u || \invEvUp(nothing, loc1, label)}noWaR(loc2))
		\replacewith({u}noWaR(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;
		
		\find({u || \invEvUp(nothing, loc1, label)}noWaW(loc2))
		\replacewith({u}noWaW(loc2))
		\heuristics(update_apply)
	};

 	//---------------------------------------------------> {\invEvUp()} NoX
	//Rules here can also happen on the right side. So probably I have to delete the ==>.
	// Now they are part of To Prove rules. But I think they are just rewrite rules.
	readInverseEvUpOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({\invEvUp(read,loc1,label)} noR(loc2)==>)
		
		\replacewith(noRAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)
		
		\heuristics(update_apply)
	  };  
	  
	writeInverseEvUpOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({\invEvUp(write,loc1,label)} noR(loc2)==>)
		
		\replacewith(noRAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)
		
		\heuristics(update_apply)
	  };  

	readInverseEvUpOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		 	
		\find({\invEvUp(read,loc1,label)} noW(loc2)==>)
		
		\replacewith(noWAtHistory({\invEvUp(read,loc1,label)}loc2, 1)==>)
		\heuristics(update_apply)
	 };
	 
	 writeInverseEvUpOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		 	
		\find({\invEvUp(write,loc1,label)} noW(loc2)==>)
		
		\replacewith(noWAtHistory({\invEvUp(write,loc1,label)}loc2, 1)==>)
		\heuristics(update_apply)
	 }; 

	readInverseEvUpOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		 	
		\find({\invEvUp(read,loc1,label)} noRaW(loc2)==>)
		
		\replacewith(noRaWAtHistory({\invEvUp(read,loc1,label)}loc2, 1)==>)
	
		\heuristics(update_apply)
	 };
	 
	 writeInverseEvUpOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		 	
		\find({\invEvUp(write,loc1,label)} noRaW(loc2)==>)
		
		\replacewith(noRaWAtHistory({\invEvUp(write,loc1,label)}loc2, 1)==>)
	
		\heuristics(update_apply)
	 }; 

	readInnverseEvUpOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		 	
		\find({\invEvUp(read,loc1,label)} noWaR(loc2)==>)
		
		\replacewith(noWaRAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)
		
		\heuristics(update_apply)
	 };
	 
	 writeInnverseEvUpOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		 	
		\find({\invEvUp(write,loc1,label)} noWaR(loc2)==>)
		
		\replacewith(noWaRAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)
		
		\heuristics(update_apply)
	 }; 

	readInverseEvUpOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		 	
		\find({\invEvUp(read,loc1,label)} noWaW(loc2)==>)
		
		\replacewith(noWaWAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)
		
		\heuristics(update_apply)
	 };
	 
	 writeInverseEvUpOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		 	
		\find({\invEvUp(write,loc1,label)} noWaW(loc2)==>)
		
		\replacewith(noWaWAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)
		
		\heuristics(update_apply)
	 };
 
	//---------------------------------------------------> { update || \invEvUp} noX
	updateParallelToReadInverseEvUpOnNoR{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({u || \invEvUp(read,loc1,label)} noR(loc2))
		
		\replacewith({u}noRAtHistory({\invEvUp(read,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	 };  
	 updateParallelToWriteInverseEvUpOnNoR{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({u || \invEvUp(write,loc1,label)} noR(loc2))
		
		\replacewith({u}noRAtHistory({\invEvUp(write,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	 }; 

	updateParallelToReadInverseEvUpOnNoW{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({u || \invEvUp(read,loc1,label)} noW(loc2))
		
		\replacewith({u}noWAtHistory({\invEvUp(read,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	 }; 
	updateParallelToWriteInverseEvUpOnNoW{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({u || \invEvUp(write,loc1,label)} noW(loc2))
		
		\replacewith({u}noWAtHistory({\invEvUp(write,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	}; 
 
	updateParallelToReadInverseEvUpOnNoRaW{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({u || \invEvUp(read,loc1,label)} noRaW(loc2))
		
		\replacewith({u}noRaWAtHistory({\invEvUp(read,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	};
	
	updateParallelToWriteInverseEvUpOnNoRaW{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({u || \invEvUp(write,loc1,label)} noRaW(loc2))
		
		\replacewith({u}noRaWAtHistory({\invEvUp(write,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	 };
 
	updateParallelToReadInverseEvUpOnNoWaR{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({u || \invEvUp(read,loc1,label)} noWaR(loc2))
		
		\replacewith({u}noWaRAtHistory({\invEvUp(read,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	};
	
	updateParallelToWriteInverseEvUpOnNoWaR{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		
		\find({u || \invEvUp(write,loc1,label)} noWaR(loc2))
		
		\replacewith({u}noWaRAtHistory({\invEvUp(write,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	}; 

	updateParallelToReadInverseEvUpOnNoWaW{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;
		
		\find({u || \invEvUp(read,loc1,label)} noWaW(loc2))
		
		\replacewith({u}noWaWAtHistory({\invEvUp(read,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	}; 

	updateParallelToWriteInverseEvUpOnNoWaW{
		\schemaVar \update u;  
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;
		
		\find({u || \invEvUp(write,loc1,label)} noWaW(loc2))
		
		\replacewith({u}noWaWAtHistory({\invEvUp(write,loc1,label)}loc2,1))
		
		\heuristics(update_apply)
	}; 

	//---------------------------------------------------> {\invEvUp()} noXAtHistory
	// To Prove, probably it should be a rewrite rule
	readInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		 	
		\find({\invEvUp(read,loc1,label1)} noRAtHistory(loc2, label2)==>)
		
		\replacewith(noRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)
		
		\heuristics(update_apply)
	};
	
	// To Prove, probably it should be a rewrite rule
	writeInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		 	
		\find({\invEvUp(write,loc1,label1)} noRAtHistory(loc2, label2)==>)
		
		\replacewith(noRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)
		
		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		 	
		\find({\invEvUp(read,loc1,label1)} noWAtHistory(loc2, label2)==>)
		
		\replacewith(noWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};
	
	writeInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		 	
		\find({\invEvUp(write,loc1,label1)} noWAtHistory(loc2, label2)==>)
		
		\replacewith(noWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};

	readInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		 	
		\find({\invEvUp(read,loc1,label1)} noRaWAtHistory(loc2, label2)==>)
		
		\replacewith(noRaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)	==>)
		
		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		 	
		\find({\invEvUp(write,loc1,label1)} noRaWAtHistory(loc2, label2)==>)
		
		\replacewith(noRaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)	==>)
		
		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		
		\find({\invEvUp(read,loc1,label1)} noWaRAtHistory(loc2, label2)==>)
		
		\replacewith(noWaRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)
	
		\heuristics(update_apply)
	};
	
	writeInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		
		\find({\invEvUp(write,loc1,label1)} noWaRAtHistory(loc2, label2)==>)
		
		\replacewith(noWaRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)
	
		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		 	
		\find({\invEvUp(read,loc1,label1)} noWaWAtHistory(loc2, label2)==>)
		 
		\replacewith(noWaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)
	
		\heuristics(update_apply)
	};
	
	writeInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		 	
		\find({\invEvUp(write,loc1,label1)} noWaWAtHistory(loc2, label2)==>)
		 
		\replacewith(noWaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)
	
		\heuristics(update_apply)
	};
	//---------------------------------------------------> {u || \invEvUp()} noXAtHistory
	updateParallelToReadInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(read,loc1,label1)} noRAtHistory(loc2, label2)==>)
		
		\replacewith({u}noRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};
	updateParallelToWriteInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(write,loc1,label1)} noRAtHistory(loc2, label2)==>)
		
		\replacewith({u}noRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(read,loc1,label1)} noWAtHistory(loc2, label2)==>)
		
		\replacewith({u}noWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};
	updateParallelToWriteInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(write,loc1,label1)} noWAtHistory(loc2, label2)==>)
		
		\replacewith({u}noWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(read,loc1,label1)} noRaWAtHistory(loc2, label2)==>)
		
		\replacewith({u}noRaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};
	
	updateParallelToWriteInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(write,loc1,label1)} noRaWAtHistory(loc2, label2)==>)
		
		\replacewith({u}noRaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	}; 

	updateParallelReadInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(read,loc1,label1)} noWaRAtHistory(loc2, label2)==>)
		
		\replacewith({u}noWaRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};
	updateParallelWriteInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(write,loc1,label1)} noWaRAtHistory(loc2, label2)==>)
		
		\replacewith({u}noWaRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(read,loc1,label1)} noWaWAtHistory(loc2, label2)==>)
		
		\replacewith({u}noWaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};
	
	updateParallelToWriteInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;
		
		\find({u || \invEvUp(write,loc1,label1)} noWaWAtHistory(loc2, label2)==>)
		
		\replacewith({u}noWaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)
		
		\heuristics(update_apply)
	};
  
//======================================================================================================================
//												Converting noX To noXAtHistory
//======================================================================================================================
	// To Prove, probably it should be a rewrite rule
	noRtoNoRH {
	    \schemaVar \term LocSet loc;
		\find(noR(loc))
		\replacewith(noRAtHistory(loc, 0))
		\heuristics(concrete)	
	};
	
	noWtoNoWH {
	    \schemaVar \term LocSet loc;
		\find(noW(loc))
		\replacewith(noWAtHistory(loc, 0))
		\heuristics(concrete)	
	};
	
	noWaWtoNoWaWH {
	    \schemaVar \term LocSet loc;
		\find(noWaW(loc))
		\replacewith(noWaWAtHistory(loc, 0))
		\heuristics(concrete)	
	};
	
	noWaRtoNoWaRH {
	    \schemaVar \term LocSet loc;
		\find(noWaR(loc))
		\replacewith(noWaRAtHistory(loc, 0))
		\heuristics(concrete)	
	};
	
	noRaWtoNoRaWH {
	    \schemaVar \term LocSet loc;
		\find(noRaW(loc))
		\replacewith(noRaWAtHistory(loc, 0))
		\heuristics(concrete)	
	};

}