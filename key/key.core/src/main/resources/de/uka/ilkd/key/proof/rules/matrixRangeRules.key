\rules(programRules:Java) {
   //axioms - wellFormedMatrix
   wellFormedMatrixDef {
        \schemaVar \term Object matrix;
        \schemaVar \term Heap heapSV;
        \schemaVar \variables int row1, row2;
        \schemaVar \variables Object matrix2;

        \find (wellFormedMatrix(matrix, heapSV) ==>)
        \varcond(\notFreeIn(matrix2, matrix, heapSV), \notFreeIn(row1, heapSV, matrix),
                 \notFreeIn(row2, heapSV, matrix),
                 \hasElementarySort(matrix, ElementSort))
        \add(
            matrix != null
            &
            (\forall row1; ElementSort::select(heapSV, matrix, arr(row1)) != null)
            &
            (\forall row1; matrix != ElementSort::select(heapSV, matrix, arr(row1)))
            &
            (\forall row1; \forall row2;
               (row1 != row2 -> ElementSort::select(heapSV, matrix, arr(row1)) != ElementSort::select(heapSV, matrix, arr(row2))))
            &
             (\forall matrix2; ( matrix != matrix2 ->
               \forall row1; \forall row2;
                 ( any::select(heapSV, matrix, arr(row1)) != any::select(heapSV, matrix2, arr(row2)))) )
            & (\forall row1;\forall row2;
                 length(ElementSort::select(heapSV, matrix, arr(row1))) = length(ElementSort::select(heapSV, matrix, arr(row2))))
        ==>)
        \heuristics(simplify_ENLARGING, noEqApp)
   };



   wellFormedMatrixDismissStoreOfPrimitiveType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    \varcond(\not\isReference(\typeof(value))) // value is of primitive type e.g. int, boolean, etc.
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreOfPrimitiveTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;
    \schemaVar \term Heap EQ;

    \assumes(store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \varcond(\not\isReference(\typeof(value))) // value is of primitive type e.g. int, boolean, etc.
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };


   wellFormedMatrixDismissStoreOfNonArrayType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(value))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreOfNonArrayTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV, EQ;


    \assumes (store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(value))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreForNonArrayType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    // obj is not an array, we must exclude ArraySort explicitly as there might be an array lurking behind this type
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(obj))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreForNonArrayTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV,EQ;

    \assumes(store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    // obj is not an array, we must exclude ArraySort explicitly as there might be an array lurking behind this type
    \sameUpdateLevel
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(obj))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissCreated {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Heap heapSV;

    \assumes(==> matrix = obj)
    \find(wellFormedMatrix(matrix, create(heapSV, obj)))
    \sameUpdateLevel
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify_ENLARGING)
   };

   wellFormedMatrixDismissCreated {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Heap heapSV;
    \schemaVar \term Heap EQ;

    \assumes(create(heapSV, obj) = EQ ==> matrix = obj)
    \find(wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify_ENLARGING)
   };

   wellFormedMatrixAnon {
    \schemaVar \term ArraySort matrix;
    \schemaVar \term LocSet ls;
    \schemaVar \term Heap h1,h2;

    \find(==> wellFormedMatrix(matrix, anon(h1, ls, h2)))
    \replacewith(==> \if (intersect(ls, arrayRange(matrix, 0, length(matrix))) = empty) // <= must be matrixRange
                     \then (wellFormedMatrix(matrix, h1))
                     \else (wellFormedMatrix(matrix, anon(h1, ls, h2))) )
    \heuristics(simplify_ENLARGING) // <--noEqApp?
   };

   wellFormedMatrixAnonEQ {
    \schemaVar \term ArraySort matrix;
    \schemaVar \term LocSet ls;
    \schemaVar \term Heap h1,h2;
    \schemaVar \term Heap EQ;

    \assumes(anon(h1, ls, h2) = EQ ==>)
    \find(==> wellFormedMatrix(matrix, EQ))
    \replacewith(==> \if (intersect(ls, arrayRange(matrix, 0, length(matrix))) = empty) // <= must be matrixRange
                     \then (wellFormedMatrix(matrix, h1))
                     \else (wellFormedMatrix(matrix, anon(h1, ls, h2))) )
    \heuristics(simplify_ENLARGING) // <--noEqApp?
   };


   wellFormedMatrixUnaffected {
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Heap successorHeap;
        \schemaVar \term Heap heapSV;

        \assumes(wellFormedMatrix(matrix, heapSV) ==>)
        \find(successorHeap)
        \sameUpdateLevel
        \varcond(\different(heapSV, successorHeap))
        \add(==>wellFormedMatrix(matrix, successorHeap));
        \add(wellFormedMatrix(matrix, successorHeap)==>)

        \heuristics(self_app_prevention)
   };


   // axioms

    matrixRangeDef {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \variables int rowIdx;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \varcond(\notFreeIn(rowIdx, matrix, heapSV, rowStart, rowEnd, colStart, colEnd),
                                  \hasElementarySort(matrix,ElementSort))
        \replacewith(infiniteUnion{rowIdx;}(\if (rowIdx >= rowStart & rowIdx <= rowEnd)
                                            \then (arrayRange(ElementSort::select(heapSV, matrix, arr(rowIdx)), colStart, colEnd))
                                            \else (empty)))
    };

   // lemmas

   // empty ranges
   matrixRange_emptyBounds {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \replacewith( \if (rowStart > rowEnd | colStart > colEnd)
                      \then (empty)
                      \else (
                           matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                      )
                    )
        \heuristics(simplify_matrix_range_literal)
   };

   matrixRangeEmptyColumns {
           \schemaVar \term int rowStart, rowEnd, colStart;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \find (matrixRange(heapSV, matrix,
                              rowStart, rowEnd,
                              colStart, -1 + colStart))
           \replacewith(empty)
           \heuristics(simplify)
   };

   matrixRangeEmptyColumns2a {
              \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
              \schemaVar \term Heap heapSV;
              \schemaVar \term ArraySort matrix;
              \assumes(colEnd <= -1 + colStart ==>)
              \find (matrixRange(heapSV, matrix,
                                 rowStart, rowEnd,
                                 colStart, colEnd))
              \sameUpdateLevel
              \replacewith(empty)
              \heuristics(simplify)
      };


   matrixRangeEmptyColumns3 {
              \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
              \schemaVar \term Heap heapSV;
              \schemaVar \term ArraySort matrix;
              \assumes(colStart > colEnd ==>)
              \find (matrixRange(heapSV, matrix,
                                 rowStart, rowEnd,
                                 colStart, colEnd))
              \sameUpdateLevel
              \replacewith(empty)
              \heuristics(simplify)
      };

      matrixRangeEmptyColumns3a {
                    \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
                    \schemaVar \term Heap heapSV;
                    \schemaVar \term ArraySort matrix;
                    \assumes(colStart >= 1 + colEnd ==>)
                    \find (matrixRange(heapSV, matrix,
                                       rowStart, rowEnd,
                                       colStart, colEnd))
                    \sameUpdateLevel
                    \replacewith(empty)
                    \heuristics(simplify)
            };


   matrixRangeSingleRow {
        \schemaVar \term int rowStart, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowStart, colStart, colEnd))
        \varcond(\hasElementarySort(matrix, ElementSort))
        \replacewith(arrayRange(ElementSort::select(heapSV, matrix, arr(rowStart)), colStart, colEnd))
        \heuristics (simplify)
   };

   matrixRangeEmptyRow {
        \schemaVar \term int rowStart, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, -1 + rowStart, colStart, colEnd))
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRangeEmptyRow2 {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \assumes (rowEnd < rowStart ==>)
        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRangeEmptyRow2a {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \assumes (rowEnd <= -1 + rowStart ==>)
        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRangeEmptyRow3a {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \assumes (rowStart >= 1 + rowEnd ==>)
        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRangeSimplifyHeap1 {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV, otherHeapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \term any value;

        \assumes( store(otherHeapSV, obj, f, value) = heapSV ==> )
        \find(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \varcond(\disjointModuloNull(\typeof(obj), ArraySort))
        \replacewith(matrixRange(otherHeapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \heuristics(simplify)
   };

   matrixRangeNegativeRowEnd {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term numbers a;

        \find(matrixRange(heapSV, matrix, rowStart, Z(neglit(a)), colStart, colEnd))
        \sameUpdateLevel
        \replacewith(empty)
        \add(rowStart > Z(neglit(a)) ==>);
        \add(rowStart <= Z(neglit(a)) ==>)
        \heuristics(beta)
   };

   matrixRangeNegativeColEnd {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term numbers a;

        \find(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, Z(neglit(a))))
        \sameUpdateLevel
        \replacewith(empty)
        \add(colStart > Z(neglit(a)) ==>);
        \add(colStart <= Z(neglit(a)) ==>)
        \heuristics(beta)
   };

   // intersections
   matrixRange_intersectionSingleton {
      \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
      \schemaVar \term Heap heapSV;
      \schemaVar \term ArraySort matrix;
      \schemaVar \term Object obj;
      \schemaVar \term Field f;
      \schemaVar \variables int j, k,l;

      \assumes(wellFormedMatrix(matrix, heapSV) ==>)
      \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  singleton(obj, f)
                  ))
      \sameUpdateLevel
      \varcond(\notFreeIn(j, rowStart, rowEnd, f),
               \notFreeIn(k, rowStart, rowEnd, heapSV, matrix, obj),
               \notFreeIn(l, colStart, colEnd, f),
               \hasElementarySort(matrix, ElementSort))
      \replacewith(
                \if ( \exists k; ( k>=rowStart & k<=rowEnd & ElementSort::select(heapSV, matrix, arr(k)) = obj ) ) \then (
                    \if ( \exists l; (l>=colStart & l<=colEnd & f = arr(l) ) )
                    \then (singleton(obj, f))
                    \else (empty)
                ) \else (
                    empty
                )
        )
        \heuristics (simplify_ENLARGING)
   };

   matrixRange_intersectionSingletonKnownRowAndCol {
      \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIdx, colIdx;
      \schemaVar \term Heap heapSV;
      \schemaVar \term ArraySort matrix;
      \schemaVar \term Object obj;

      \assumes(wellFormedMatrix(matrix, heapSV),
               ElementSort::select(heapSV, matrix, arr(rowIdx)) = obj ==>)
      \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  singleton(obj, arr(colIdx))
                  ))
      \sameUpdateLevel
      \varcond(\hasElementarySort(matrix, ElementSort))
      \replacewith(
                \if ( rowIdx >= rowStart & rowIdx <= rowEnd &
                      colIdx >= colStart & colIdx <= colEnd)
                \then ( singleton(obj, arr(colIdx)) )
                \else ( empty )
        )
        \heuristics (simplify_enlarging)
   };

   matrixRange_intersectionSingletonConcrete {
      \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIdx;
      \schemaVar \term Heap heapSV;
      \schemaVar \term ArraySort matrix;

      \assumes(wellFormedMatrix(matrix, heapSV) ==>)
      \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  singleton(matrix, arr(rowIdx))
             ) )
      \sameUpdateLevel
      \replacewith( empty )
      \heuristics (simplify)
   };

   matrixRange_intersectionArrayRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term int start, end;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k;

        // rule assumes that the array 'matrix' in matrix[][] is not contained in 'matrix[]'
        \assumes(wellFormedMatrix(matrix, heapSV) ==>)
        \find (intersect(
                    matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                    arrayRange(obj, start, end)
                    ))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, heapSV, matrix, obj),
                 \hasElementarySort(matrix, ElementSort) )
        \replacewith(
                  \if ( \exists k; ( k>=rowStart & k<=rowEnd & ElementSort::select(heapSV, matrix, arr(k)) = obj ) )
                  \then (
                      arrayRange(obj, maximum(colStart, start), minimum(colEnd, end))
                  ) \else (
                      empty
                  )
          )
          \heuristics (simplify_ENLARGING)
     };

   matrixRange_intersectionArrayRangeKnownRow {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIdx;
           \schemaVar \term int start, end;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object obj;

           \assumes(wellFormedMatrix(matrix, heapSV),
                    ElementSort::select(heapSV, matrix, arr(rowIdx)) = obj ==>)
           \find (intersect(
                       matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                       arrayRange(obj, start, end)
                  ))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort) )
           \replacewith(
                     \if ( rowIdx >= rowStart & rowIdx <= rowEnd )
                     \then (
                         arrayRange(obj, maximum(colStart, start), minimum(colEnd, end))
                     ) \else (
                         empty
                     )
                 )
           \heuristics (simplify_enlarging)
   };

      matrixRange_intersectionArrayRangeConcrete {
              \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIdx;
              \schemaVar \term int start, end;
              \schemaVar \term Heap heapSV;
              \schemaVar \term ArraySort matrix;
              \schemaVar \term Object obj;

              \assumes(wellFormedMatrix(matrix, heapSV) ==>)
              \find (intersect(
                          matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                          arrayRange(matrix, start, end)
                     ))
              \sameUpdateLevel
              \replacewith( empty )
              \heuristics (simplify)
      };

   matrixRange_intersectionMatrixRange {
       \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
       \schemaVar \term int rowStart2, rowEnd2, colStart2, colEnd2;
       \schemaVar \term Heap heapSV;
       \schemaVar \term ArraySort matrix, matrix2;
       \schemaVar \term Field f;
       \schemaVar \variables int k,l;

       \assumes(wellFormedMatrix(matrix, heapSV), wellFormedMatrix(matrix2, heapSV) ==>)
       \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  matrixRange(heapSV, matrix2, rowStart2, rowEnd2, colStart2, colEnd2)
             ))
       \sameUpdateLevel
       \varcond(\notFreeIn(k, rowStart, rowEnd, f),
                \notFreeIn(l, colStart, colEnd, f))
       \replacewith(
             \if (matrix = matrix2) \then (
                    matrixRange(heapSV, matrix,
                                maximum(rowStart, rowStart2), minimum(rowEnd, rowEnd2),
                                maximum(colStart, colStart2), minimum(colEnd, colEnd2) )
             ) \else (
                  empty
             )
       )
       \heuristics (simplify_ENLARGING)
   };

   elementOfMatrixRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k,l;

        \assumes (wellFormedMatrix(matrix, heapSV)==>)
        \find (elementOf(obj, f, matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, f),
                 \notFreeIn(l, matrix, obj, rowStart, rowEnd, heapSV),
                 \hasElementarySort(matrix, ElementSort))

        \replacewith(
                      (\exists l; ( obj = ElementSort::select(heapSV, matrix, arr(l)) & l>=rowStart & l<=rowEnd)) &
                      (\exists k; (f = arr(k) & k >= colStart & k <= colEnd ))
                    )

        \heuristics(simplify_ENLARGING)
   };

      elementOfMatrixRangeEQ {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object obj;
           \schemaVar \term Field f;
           \schemaVar \variables int k,l;
           \schemaVar \term LocSet EQ;


           \assumes (wellFormedMatrix(matrix, heapSV), matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd) = EQ ==>)
           \find (elementOf(obj, f, EQ))
           \sameUpdateLevel
           \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, f),
                    \notFreeIn(l, matrix, obj, rowStart, rowEnd, heapSV),
                    \hasElementarySort(matrix, ElementSort))

           \replacewith( (\exists l; ( obj = ElementSort::select(heapSV, matrix, arr(l)) & l>=rowStart & l<=rowEnd)) &
                         (\exists k; (f = arr(k) & k >= colStart & k<=colEnd ) )
                       )

           \heuristics(simplify_ENLARGING)
      };

   elementOfMatrixRangeConcrete {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k,l;


        \assumes (wellFormedMatrix(matrix, heapSV)==>)
        \find (elementOf(obj, f, matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
        \sameUpdateLevel
        \varcond(\hasElementarySort(matrix, ElementSort),
                 \disjointModuloNull(\typeof(obj), ElementSort))

        \replacewith( false )

        \heuristics(concrete)
   };

   matrixRangeSetMinusSingletonSimple1 {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object obj;
           \schemaVar \term Field f;

           \assumes(wellFormedMatrix(matrix, heapSV) ==>)
           \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                          singleton(obj,f)))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort), \disjointModuloNull(\typeof(obj),ElementSort))
           \replacewith(
              matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
           )
           \heuristics(simplify)
   };

   matrixRangeSetMinusSingleton {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd, colIndex;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object o;
           \schemaVar \variable int k;

           \assumes(wellFormedMatrix(matrix, heapSV) ==>)
           \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                          singleton(o,arr(colIndex))))
           \sameUpdateLevel
           \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, colIndex, heapSV, matrix, o),
                    \hasElementarySort(matrix, ElementSort))
           \replacewith(
              \if (o = matrix | colIndex < colStart | colIndex > colEnd)
              \then (
                 matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
              ) \else (
                 \ifEx k; (k>=rowStart & k<=rowEnd & o = ElementSort::select(heapSV, matrix, arr(k)))
                 \then (
                    union(union(union(matrixRange(heapSV, matrix, rowStart, k-1, colStart, colEnd), matrixRange(heapSV, matrix, k+1, rowEnd, colStart, colEnd)),
                                            arrayRange(matrix, colStart, colIndex-1)), arrayRange(matrix, colIndex+1, colEnd))
                 ) \else (
                    matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                 )
              )
           )
          \heuristics(locset_expand_setMinus_low_priority)
      };

      matrixRangeSetMinusSingleton2 {
          \schemaVar \term int rowStart, rowEnd, colStart, colEnd, colIndex;
          \schemaVar \term Heap heapSV;
          \schemaVar \term ArraySort matrix;
          \schemaVar \term Object o;
          \schemaVar \term int rowIdx;

          \assumes(wellFormedMatrix(matrix, heapSV), ElementSort::select(heapSV, matrix, arr(rowIdx)) = o ==>)
          \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                               singleton(o,arr(colIndex))))
          \sameUpdateLevel
          \varcond(\hasElementarySort(matrix, ElementSort))
          \replacewith(
                   \if (o = matrix | colIndex < colStart | colIndex > colEnd)
                   \then (
                      matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                   ) \else (
                      \if (rowIdx >=rowStart & rowIdx<=rowEnd)
                      \then (
                         union(union(union(matrixRange(heapSV, matrix, rowStart, rowIdx-1, colStart, colEnd),
                                               matrixRange(heapSV, matrix, rowIdx+1, rowEnd, colStart, colEnd)),
                                                 arrayRange(matrix, colStart, colIndex-1)),
                                                     arrayRange(matrix, colIndex+1, colEnd))
                      ) \else (
                         matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                      )
                   )
                )
          \heuristics(locset_expand_setMinus)
      };

      matrixRangeSetMinusSingleton3 {
          \schemaVar \term int rowStart, rowEnd, colStart, colEnd, colIndex;
          \schemaVar \term Heap heapSV;
          \schemaVar \term ArraySort matrix;
          \schemaVar \term int rowIdx;

          \assumes(wellFormedMatrix(matrix, heapSV) ==>)
          \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                         singleton(ElementSort::select(heapSV, matrix, arr(rowIdx)),arr(colIndex))))
          \sameUpdateLevel
          \varcond(\hasElementarySort(matrix, ElementSort))
          \replacewith(
             \if (ElementSort::select(heapSV, matrix, arr(rowIdx)) = matrix | colIndex < colStart | colIndex > colEnd)
             \then (
                matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
             ) \else (
                \if (rowIdx >=rowStart & rowIdx<=rowEnd)
                \then (
                   union(union(union(matrixRange(heapSV, matrix, rowStart, rowIdx-1, colStart, colEnd),
                                         matrixRange(heapSV, matrix, rowIdx+1, rowEnd, colStart, colEnd)),
                                           arrayRange(matrix, colStart, colIndex-1)),
                                               arrayRange(matrix, colIndex+1, colEnd))
                ) \else (
                   matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                )
             )
          )
          \heuristics(locset_expand_setMinus)
      };

      matrixRangeSetMinusArrayRange {
          \schemaVar \term ArraySort matrix;
          \schemaVar \term Object b;
          \schemaVar \term int lRowA, hRowA, lColA, hColA, rowIdx;
          \schemaVar \term int lColB, hColB;
          \schemaVar \term Heap heapSV;

          \assumes(wellFormedMatrix(matrix, heapSV), ElementSort::select(heapSV, matrix, arr(rowIdx)) = b ==>)

          \find(setMinus(matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA),
                         arrayRange(b, lColB, hColB)))
          \sameUpdateLevel
          \varcond(\hasElementarySort(matrix, ElementSort))
          \replacewith(\if (ElementSort::instance(b) = FALSE |
                            lColB > hColA | hColB < lColA |
                            !(rowIdx >=lRowA & rowIdx <= hRowA))
                       \then ( matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA) )
                       \else (
                          union(matrixRange(heapSV, matrix,
                                            lRowA, rowIdx - 1,
                                            lColA, hColA),
                          union(matrixRange(heapSV, matrix,
                                      	   rowIdx, rowIdx,
                                      	   lColA, lColB - 1),
                          union(matrixRange(heapSV, matrix,
                                            rowIdx, rowIdx,
                                            hColB + 1, hColA),
                                matrixRange(heapSV, matrix,
                                      	  rowIdx + 1, hRowA,
                                      	  lColA, hColA)
                          ))))
          )
          \heuristics(simplify_ENLARGING)
    };

   matrixRangeSetMinusArrayRangeSimplify {
       \schemaVar \term ArraySort matrix;
       \schemaVar \term Object b;
       \schemaVar \term int lRowA, hRowA, lColA, hColA, rowIdx;
       \schemaVar \term int lColB, hColB;
       \schemaVar \term Heap heapSV;

       \assumes(wellFormedMatrix(matrix, heapSV) ==>)

       \find(setMinus(matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA),
                      arrayRange(b, lColB, hColB)))
       \sameUpdateLevel
       \varcond(\hasElementarySort(matrix, ElementSort), \disjointModuloNull(\typeof(b), ElementSort))
       \replacewith( matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA) )
       \heuristics(simplify_ENLARGING)
   };

 arrayRangeSetMinusMatrixRange {
          \schemaVar \term ArraySort matrix;
          \schemaVar \term Object b;
          \schemaVar \term int lRowA, hRowA, lColA, hColA;
          \schemaVar \term int lColB, hColB;
          \schemaVar \term Heap heapSV;
          \schemaVar \variable int rowIdx;

          \assumes(wellFormedMatrix(matrix, heapSV) ==>)

          \find(setMinus(arrayRange(b, lColB, hColB),
                         matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA)))
          \sameUpdateLevel
          \varcond(\hasElementarySort(matrix, ElementSort), \notFreeIn(rowIdx, lRowA, hRowA))
          \replacewith(\if (ElementSort::instance(b) = FALSE |
                            lColB > hColA | hColB < lColA |
                            !\exists rowIdx; (rowIdx >=lRowA & rowIdx <= hRowA))
                       \then ( arrayRange(b, lColB, hColB) )
                       \else (
                          union (
                           arrayRange(b, lColB, lColA + 1),
                           arrayRange(b, hColA + 1, hColB)
                          )
                       )
          )
          \heuristics(simplify_ENLARGING)
    };

    arrayRangeSetMinusMatrixRange {
          \schemaVar \term ArraySort matrix;
          \schemaVar \term Object b;
          \schemaVar \term int lRowA, hRowA, lColA, hColA, rowIdx;
          \schemaVar \term int lColB, hColB;
          \schemaVar \term Heap heapSV;

          \assumes(wellFormedMatrix(matrix, heapSV)==>)

          \find(setMinus(arrayRange(b, lColB, hColB),
                         matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA) ))
          \sameUpdateLevel
          \varcond(\hasElementarySort(matrix, ElementSort), \disjointModuloNull(\typeof(b), ElementSort))
          \replacewith( arrayRange(b, lColB, hColB) )
          \heuristics(simplify)
    };

      matrixRangeSetMinusMatrixRange2 {
          \schemaVar \term Object a,b;
          \schemaVar \term int lRowA, hRowA, lColA, hColA;
          \schemaVar \term int lRowB, hRowB, lColB, hColB;
          \schemaVar \term Heap heapSV;

          \assumes(wellFormedMatrix(a, heapSV) ==>)

          \find(setMinus(matrixRange(heapSV, a, lRowA, hRowA, lColA, hColA),
                         matrixRange(heapSV, b, lRowB, hRowB, lColB, hColB)))
          \sameUpdateLevel
          \replacewith(\if (a != b | hRowB < lRowA | lRowB > hRowA |
                            lColB > hColA | hColB < lColA )
                       \then ( matrixRange(heapSV, a, lRowA, hRowA, lColA, hColA) )
                       \else (
                          union(matrixRange(heapSV, a,
                                            lRowA, lRowB - 1,
                                            lColA, hColA),
                          union(matrixRange(heapSV, a,
                                      	   lRowB, hRowB,
                                      	   lColA, lColB - 1),
                          union(matrixRange(heapSV, a,
                                            lRowB, hRowB,
                                            hColB + 1, hColA),
                                matrixRange(heapSV, a,
                                      	  hRowB + 1, hRowA,
                                      	  lColA, hColA)
                          ))))
          )
          \heuristics(simplify_ENLARGING)
    };

      matrixRangeSetMinusMatrixRange {
      	\schemaVar \term Object a,b;
      	\schemaVar \term int lRowA, hRowA, lColA, hColA;
      	\schemaVar \term int lRowB, hRowB, lColB, hColB;
      	\schemaVar \term Heap heapSV, heapSV2;

       // \assumes(wellFormedMatrix(a, heapSV), wellFormedMatrix(b, heapSV2) ==>)

      	\find(setMinus(matrixRange(heapSV, a,lRowA, hRowA, lColA, hColA), matrixRange(heapSV2, b,lRowB, hRowB, lColB, hColB)))

      	\replacewith(\if (a != b | hRowA < lRowB | hRowB < lRowA | hColA < lColB | hColB < lColA) \then
      	             (matrixRange(heapSV, a,lRowA, hRowA, lColA, hColA))
                     \else (\if(lRowA<lRowB)
                            \then(\if(hRowA<hRowB)
                                  \then(\if(lColB<lColA)
                                        \then(\if(hColB<hColA)
                                              \then(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB+1,hRowA,hColB+1,hColA)))
                                              \else(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA)))
                                        \else(\if(hColB<hColA)
                                              \then(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowA,lColA,lColB-1)),matrixRange(heapSV, a,lRowB,hRowA,hColB+1,hColA)))
                                              \else(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowA,lColA,lColB-1)))))
                                  \else(\if(lColB<lColA)
                                        \then(\if(hColB<hColA)
                                              \then(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,hColB+1,hColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                              \else(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))
                                        \else(\if(hColB<hColA)
                                              \then(union(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,lColA,lColB-1)),matrixRange(heapSV, a,lRowB,hRowB,hColB+1,lColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                              \else(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,lColA,hColB-1)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))))
                            \else(\if(hRowA<hRowB)
                                      \then(\if(lColB<lColA)
                                            \then(\if(hColB<hColA)
                                                  \then(matrixRange(heapSV, a,lRowA,hRowA,hColB+1,hColA))
                                                  \else(empty))
                                            \else(\if(hColB<hColA)
                                                  \then(union(matrixRange(heapSV, a,lRowA,hRowA,lColA,lColB-1),matrixRange(heapSV, a,lRowA,hRowA,hColB+1,hColA)))
                                                  \else(matrixRange(heapSV, a,lRowA,hRowA,lColA,hColB-1))))
                                      \else(\if(lColB<lColA)
                                          \then(\if(hColB<hColA)
                                                \then(union(matrixRange(heapSV, a,lRowA,hRowB,hColB+1,hColA),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                                \else(matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                          \else(\if(hColB<hColA)
                                                \then(union(union(matrixRange(heapSV, a,lRowA,hRowB,lColA,hColB-1),matrixRange(heapSV, a,lRowA,hRowB,hColB+1,lColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                                \else(union(matrixRange(heapSV, a,lRowA,hRowB,lColA,lColB-1),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))))))
      		//\heuristics(locset_expand_setMinus_low_priority)
        };

}
