\rules(programRules:Java) {
   //axioms - wellFormedMatrix
   wellFormedMatrixDef {
        \schemaVar \term Object matrix;
        \schemaVar \term Heap heapSV;
        \schemaVar \variables int row1, row2;
        \schemaVar \variables Object matrix2;

        \find (wellFormedMatrix(matrix, heapSV) ==>)
        \varcond(\notFreeIn(matrix2, matrix, heapSV), \notFreeIn(row1, heapSV, matrix),
                 \notFreeIn(row2, heapSV, matrix),
                 \hasElementarySort(matrix, ElementSort))
        \add(
            matrix != null
            &
            (\forall row1; ElementSort::select(heapSV, matrix, arr(row1)) != null)
            &
            (\forall row1; matrix != ElementSort::select(heapSV, matrix, arr(row1)))
            &
            (\forall row1; \forall row2;
               (row1 != row2 -> ElementSort::select(heapSV, matrix, arr(row1)) != ElementSort::select(heapSV, matrix, arr(row2))))
            &
             (\forall matrix2; ( matrix != matrix2 ->
               \forall row1; \forall row2;
                 ( any::select(heapSV, matrix, arr(row1)) != any::select(heapSV, matrix2, arr(row2)))) )
            & (\forall row1;\forall row2;
                 length(ElementSort::select(heapSV, matrix, arr(row1))) = length(ElementSort::select(heapSV, matrix, arr(row2))))
        ==>)
        \heuristics(simplify_ENLARGING, noEqApp)
   };

   wellFormedMatrixDismissStoreOfPrimitiveType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    \varcond(\not\isReference(\typeof(value))) // value is of primitive type e.g. int, boolean, etc.
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreOfPrimitiveTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;
    \schemaVar \term Heap EQ;

    \assumes(store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \varcond(\not\isReference(\typeof(value))) // value is of primitive type e.g. int, boolean, etc.
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };


   wellFormedMatrixDismissStoreOfNonArrayType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(value))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreOfNonArrayTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV, EQ;


    \assumes (store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(value))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreForNonArrayType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    // obj is not an array, we must exclude ArraySort explicitly as there might be an array lurking behind this type
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(obj))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreForNonArrayTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV,EQ;

    \assumes(store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    // obj is not an array, we must exclude ArraySort explicitly as there might be an array lurking behind this type
    \sameUpdateLevel
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(obj))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissCreated {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Heap heapSV;

    \assumes(==> matrix = obj)
    \find(wellFormedMatrix(matrix, create(heapSV, obj)))
    \sameUpdateLevel
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify_ENLARGING)
   };

   wellFormedMatrixAnon {
    \schemaVar \term ArraySort matrix;
    \schemaVar \term LocSet ls;
    \schemaVar \term Heap h1,h2;

    \find(==> wellFormedMatrix(matrix, anon(h1, ls, h2)))
    \sameUpdateLevel
    \replacewith(==> \if (intersect(ls, arrayRange(matrix, 0, length(matrix))) = empty) // <= must be matrixRange
                     \then (wellFormedMatrix(matrix, h1))
                     \else (wellFormedMatrix(matrix, anon(h1, ls, h2))) )
    \heuristics(simplify_ENLARGING) // <--noEqApp?
   };

   wellFormedMatrixUnaffected {
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Heap successorHeap;
        \schemaVar \term Heap heapSV;

        \assumes(wellFormedMatrix(matrix, heapSV) ==>)
        \find(successorHeap)
        \sameUpdateLevel
        \varcond(\different(heapSV, successorHeap))
        \add(==>wellFormedMatrix(matrix, successorHeap));
        \add(wellFormedMatrix(matrix, successorHeap)==>)

        \heuristics(self_app_prevention)
   };


   // axioms

    matrixRangeDef {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \variables int rowIdx;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \varcond(\notFreeIn(rowIdx, matrix, heapSV, rowStart, rowEnd, colStart, colEnd),
                                  \hasElementarySort(matrix,ElementSort))
        \replacewith(infiniteUnion{rowIdx;}(\if (rowIdx >= rowStart & rowIdx <= rowEnd)
                                            \then (arrayRange(ElementSort::select(heapSV, matrix, arr(rowIdx)), colStart, colEnd))
                                            \else (empty)))
    };

   // lemmas

   // empty ranges
   matrixRange_emptyBounds {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        /*\replacewith( \if (rowStart > rowEnd | colStart > colEnd)
                      \then (empty)
                      \else (
                           matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                      )
                    ) */
        \add((rowStart > rowEnd | colStart > colEnd)-> matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd) = empty ==>)
        \heuristics (dep_pred_known, noEqApp)
   };

   matrixRange_emptyNoRows {
        \schemaVar \term int rowStart, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowStart, colStart, colEnd))
        \replacewith(arrayRange(matrix, colStart, colEnd))
        \heuristics (simplify)
   };

   matrixRangeSimplifyHeap1 {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV, otherHeapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \term any value;

        \assumes( store(otherHeapSV, obj, f, value) = heapSV ==> )
        \find(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \varcond(\not\sub(\typeof(obj), ArraySort))
        \replacewith(matrixRange(otherHeapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \heuristics(simplify)
   };

/* to be deleted   matrixRange_NoCols {
        \schemaVar \term int rowStart, rowEnd, colStart;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colStart))
        \replacewith(empty)
        \heuristics (simplify)
   };
*/
   // intersections
   matrixRange_intersectionSingleton {
      \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
      \schemaVar \term Heap heapSV;
      \schemaVar \term ArraySort matrix, obj;
      \schemaVar \term Field f;
      \schemaVar \variables int j, k,l;

      \assumes(wellFormedMatrix(matrix, heapSV) ==>)
      \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  singleton(obj, f)
                  ))
      \sameUpdateLevel
      \varcond(\notFreeIn(j, rowStart, rowEnd, f),
               \notFreeIn(k, rowStart, rowEnd, heapSV, matrix, obj),
               \notFreeIn(l, colStart, colEnd, f))
      \replacewith(
                \if ( \exists k; ( k>=rowStart & k<=rowEnd & ArraySort::select(heapSV, matrix, arr(k)) = obj ) ) \then (
                    \if ( \exists l; (l>=colStart & l<=colEnd & f = arr(l) ) )
                    \then (singleton(obj, f))
                    \else (empty)
                ) \else (
                    empty
                )
        )
        \heuristics (simplify_ENLARGING)
   };

   matrixRange_intersectionArrayRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term int start, end;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix, obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k;

        // rule assumes that the array 'matrix' in matrix[][] is not contained in 'matrix[]'
        \assumes(wellFormedMatrix(matrix, heapSV) ==>)
        \find (intersect(
                    matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                    arrayRange(obj, start, end)
                    ))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, heapSV, matrix, obj) )
        \replacewith(
                  \if ( \exists k; ( k>=rowStart & k<=rowEnd & ArraySort::select(heapSV, matrix, arr(k)) = obj ) ) \then (
                      arrayRange(obj, maximum(colStart, start), minimum(colEnd, end))
                  ) \else (
                      empty
                  )
          )
          \heuristics (simplify_ENLARGING)
     };

   matrixRange_intersectionMatrixRange {
       \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
       \schemaVar \term int rowStart2, rowEnd2, colStart2, colEnd2;
       \schemaVar \term Heap heapSV;
       \schemaVar \term ArraySort matrix, matrix2;
       \schemaVar \term Field f;
       \schemaVar \variables int k,l;

       \assumes(wellFormedMatrix(matrix, heapSV), wellFormedMatrix(matrix2, heapSV) ==>)
       \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  matrixRange(heapSV, matrix2, rowStart2, rowEnd2, colStart2, colEnd2)
             ))
       \sameUpdateLevel
       \varcond(\notFreeIn(k, rowStart, rowEnd, f),
                \notFreeIn(l, colStart, colEnd, f))
       \replacewith(
             \if (matrix = matrix2) \then (
                    matrixRange(heapSV, matrix,
                                maximum(rowStart, rowStart2), minimum(rowEnd, rowEnd2),
                                maximum(colStart, colStart2), minimum(colEnd, colEnd2) )
             ) \else (
                  empty
             )
       )
       \heuristics (simplify_ENLARGING)
   };

   elementOfMatrixRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k,l;


        \assumes (wellFormedMatrix(matrix, heapSV)==>)
        \find (elementOf(obj, f, matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, f),
                 \notFreeIn(l, matrix, obj, rowStart, rowEnd, heapSV),
                 \hasElementarySort(matrix, ElementSort))

        \replacewith(
                      (\exists l; ( obj = ElementSort::select(heapSV, matrix, arr(l)) & l>=rowStart & l<=rowEnd)) &
                      (\exists k; (f = arr(k) & k >= colStart & k <= colEnd ))
                    )

        \heuristics(simplify_ENLARGING)
   };

      elementOfMatrixRangeEQ {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object obj;
           \schemaVar \term Field f;
           \schemaVar \variables int k,l;
           \schemaVar \term LocSet EQ;


           \assumes (wellFormedMatrix(matrix, heapSV), matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd) = EQ ==>)
           \find (elementOf(obj, f, EQ))
           \sameUpdateLevel
           \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, f),
                    \notFreeIn(l, matrix, obj, rowStart, rowEnd, heapSV),
                    \hasElementarySort(matrix, ElementSort))

           \replacewith( (\exists l; ( obj = ElementSort::select(heapSV, matrix, arr(l)) & l>=rowStart & l<=rowEnd)) &
                         (\exists k; (f = arr(k) & k >= colStart & k<=colEnd ) )
                       )

           \heuristics(simplify_ENLARGING)
      };

   elementOfMatrixRangeConcrete {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k,l;


        \assumes (wellFormedMatrix(matrix, heapSV)==>)
        \find (elementOf(obj, f, matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
        \sameUpdateLevel
        \varcond(\hasElementarySort(matrix, ElementSort), \not\sub(\typeof(obj), ElementSort))

        \replacewith( false )

        \heuristics(concrete)
   };



      matrixRangeSetMinusSingletonSimple1 {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object obj;
           \schemaVar \term Field f;

           \assumes(wellFormedMatrix(matrix, heapSV) ==>)
           \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                          singleton(obj,f)))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort), \not\sub(\typeof(obj),ElementSort))
           \replacewith(
              matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
           )
           \heuristics(simplify)
      };

      matrixRangeSetMinusSingleton {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd, colIndex;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object o;
           \schemaVar \variable int k;

           \assumes(wellFormedMatrix(matrix, heapSV) ==>)
           \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                          singleton(o,arr(colIndex))))
           \sameUpdateLevel
           \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, colIndex, heapSV, matrix, o),
                    \hasElementarySort(matrix, ElementSort))
           \replacewith(
              \if (o = matrix | colIndex < colStart | colIndex > colEnd)
              \then (
                 matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
              ) \else (
                 \ifEx k; (k>=rowStart & k<=rowEnd & o = ElementSort::select(heapSV, matrix, arr(k)))
                 \then (
                    union(union(union(matrixRange(heapSV, matrix, rowStart, k-1, colStart, colEnd), matrixRange(heapSV, matrix, k+1, rowEnd, colStart, colEnd)),
                                            arrayRange(matrix, colStart, colIndex-1)), arrayRange(matrix, colIndex+1, colEnd))
                 ) \else (
                    matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                 )
              )
           )
          	\heuristics(locset_expand_setMinus_low_priority)
      };

      matrixRangeSetMinusMatrixRange {
      	\schemaVar \term Object a,b;
      	\schemaVar \term int lRowA, hRowA, lColA, hColA;
      	\schemaVar \term int lRowB, hRowB, lColB, hColB;
      	\schemaVar \term Heap heapSV, heapSV2;

       // \assumes(wellFormedMatrix(a, heapSV), wellFormedMatrix(b, heapSV2) ==>)

      	\find(setMinus(matrixRange(heapSV, a,lRowA, hRowA, lColA, hColA), matrixRange(heapSV2, b,lRowB, hRowB, lColB, hColB)))

      	\replacewith(\if (a != b | hRowA < lRowB | hRowB < lRowA | hColA < lColB | hColB < lColA) \then
      	             (matrixRange(heapSV, a,lRowA, hRowA, lColA, hColA))
                     \else (\if(lRowA<lRowB)
                            \then(\if(hRowA<hRowB)
                                  \then(\if(lColB<lColA)
                                        \then(\if(hColB<hColA)
                                              \then(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB+1,hRowA,hColB+1,hColA)))
                                              \else(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA)))
                                        \else(\if(hColB<hColA)
                                              \then(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowA,lColA,lColB-1)),matrixRange(heapSV, a,lRowB,hRowA,hColB+1,hColA)))
                                              \else(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowA,lColA,lColB-1)))))
                                  \else(\if(lColB<lColA)
                                        \then(\if(hColB<hColA)
                                              \then(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,hColB+1,hColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                              \else(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))
                                        \else(\if(hColB<hColA)
                                              \then(union(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,lColA,lColB-1)),matrixRange(heapSV, a,lRowB,hRowB,hColB+1,lColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                              \else(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,lColA,hColB-1)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))))
                            \else(\if(hRowA<hRowB)
                                      \then(\if(lColB<lColA)
                                            \then(\if(hColB<hColA)
                                                  \then(matrixRange(heapSV, a,lRowA,hRowA,hColB+1,hColA))
                                                  \else(empty))
                                            \else(\if(hColB<hColA)
                                                  \then(union(matrixRange(heapSV, a,lRowA,hRowA,lColA,lColB-1),matrixRange(heapSV, a,lRowA,hRowA,hColB+1,hColA)))
                                                  \else(matrixRange(heapSV, a,lRowA,hRowA,lColA,hColB-1))))
                                      \else(\if(lColB<lColA)
                                          \then(\if(hColB<hColA)
                                                \then(union(matrixRange(heapSV, a,lRowA,hRowB,hColB+1,hColA),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                                \else(matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                          \else(\if(hColB<hColA)
                                                \then(union(union(matrixRange(heapSV, a,lRowA,hRowB,lColA,hColB-1),matrixRange(heapSV, a,lRowA,hRowB,hColB+1,lColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                                \else(union(matrixRange(heapSV, a,lRowA,hRowB,lColA,lColB-1),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))))))
      		\heuristics(locset_expand_setMinus_low_priority)
        };

}
