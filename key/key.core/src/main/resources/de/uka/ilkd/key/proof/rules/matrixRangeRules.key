\rules(programRules:Java) {
   //axioms - wellFormedMatrix
   wellFormedMatrixDef {
        \schemaVar \term Object matrix;
        \schemaVar \term Heap heapSV;
        \schemaVar \variables int row1, row2;
        \schemaVar \variables Object matrix2;

        \find (wellFormedMatrix(matrix, heapSV) ==>)
        \varcond(\notFreeIn(matrix2, matrix, heapSV), \notFreeIn(row1, heapSV, matrix),
                 \notFreeIn(row2, heapSV, matrix),
                 \hasElementarySort(matrix, ElementSort))
        \add(
            matrix != null
            &
            (\forall row1; ElementSort::select(heapSV, matrix, arr(row1)) != null)
            &
            (\forall row1; matrix != ElementSort::select(heapSV, matrix, arr(row1)))
            &
            (\forall row1; \forall row2;
               (row1 != row2 -> ElementSort::select(heapSV, matrix, arr(row1)) != ElementSort::select(heapSV, matrix, arr(row2))))
            &
             (\forall matrix2; ( matrix != matrix2 ->
               \forall row1; \forall row2;
                 ( any::select(heapSV, matrix, arr(row1)) != any::select(heapSV, matrix2, arr(row2)))) )
            & (\forall row1;\forall row2;
                 length(ElementSort::select(heapSV, matrix, arr(row1))) = length(ElementSort::select(heapSV, matrix, arr(row2))))
        ==>)
        \heuristics(simplify_ENLARGING, noEqApp)
   };

   wellFormedMatrixDismissStoreOfPrimitiveType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    \varcond(\not\isReference(\typeof(value))) // value is of primitive type e.g. int, boolean, etc.
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreOfNonArrayType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(value))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreForNonArrayType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    // obj is not an array, we must exclude ArraySort explicitly as there might be an array lurking behind this type
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(obj))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissCreated {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Heap heapSV;

    \assumes(==> matrix = obj)
    \find(wellFormedMatrix(matrix, create(heapSV, obj)))
    \sameUpdateLevel
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify_ENLARGING)
   };

   wellFormedMatrixAnon {
    \schemaVar \term ArraySort matrix;
    \schemaVar \term LocSet ls;
    \schemaVar \term Heap h1,h2;

    \find(==> wellFormedMatrix(matrix, anon(h1, ls, h2)))
    \sameUpdateLevel
    \replacewith(==> \if (intersect(ls, arrayRange(matrix, 0, length(matrix))) = empty) // <= must be matrixRange
                     \then (wellFormedMatrix(matrix, h1))
                     \else (wellFormedMatrix(matrix, anon(h1, ls, h2))) )
    \heuristics(simplify_ENLARGING) // <--noEqApp?
   };

   // axioms

    matrixRangeDef {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \variables int rowIdx;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \varcond(\notFreeIn(rowIdx, matrix, heapSV, rowStart, rowEnd, colStart, colEnd),
                                  \hasElementarySort(matrix,ElementSort))
        \replacewith(union(infiniteUnion{rowIdx;}(\if (rowIdx >= rowStart & rowIdx < rowEnd)
                                             \then (arrayRange(ElementSort::select(heapSV, matrix, arr(rowIdx)), colStart, colEnd))
                                             \else (empty)),
                           arrayRange(matrix, rowStart, rowEnd)))
    };

   // lemmas

   // empty ranges
   matrixRange_emptyBounds {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \replacewith( \if (rowStart>=rowEnd)
                      \then (empty)
                      \else (
                        \if (colStart >= colEnd) \then (
                           arrayRange(matrix, rowStart, rowEnd)
                        ) \else (
                           matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                        )
                      )
                    )
        \heuristics (simplify_ENLARGING, noEqApp)
   };

   matrixRange_emptyNoRows {
        \schemaVar \term int rowStart, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowStart, colStart, colEnd))
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRange_NoCols {
        \schemaVar \term int rowStart, rowEnd, colStart;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colStart))
        \replacewith(arrayRange(matrix, rowStart, rowEnd))
        \heuristics (simplify)
   };

   // intersections
   matrixRange_intersectionSingleton {
      \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
      \schemaVar \term Heap heapSV;
      \schemaVar \term ArraySort matrix, obj;
      \schemaVar \term Field f;
      \schemaVar \variables int j, k,l;

      \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  singleton(obj, f)
                  ))
      \varcond(\notFreeIn(j, rowStart, rowEnd, f),
               \notFreeIn(k, rowStart, rowEnd, heapSV, matrix, obj),
               \notFreeIn(l, colStart, colEnd, f))
      \replacewith(
            \if (obj = matrix & \exists j; ( j>=rowStart & j<rowEnd & f = arr(j) )) \then (
                singleton(obj, f)
            ) \else (
                \if ( \exists k; ( k>=rowStart & k<rowEnd & ArraySort::select(heapSV, matrix, arr(k)) = obj ) ) \then (
                    \if ( \exists l; (l>=colStart & l<colEnd & f = arr(l) ) )
                    \then (singleton(obj, f))
                    \else (empty)
                ) \else (
                    empty
                )
            )
        )
        \heuristics (simplify_ENLARGING)
   };

   matrixRange_intersectionArrayRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term int start, end;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix, obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k;

        // rule assumes that the array 'matrix' in matrix[][] is not contained in 'matrix[]'
        \assumes(wellFormedMatrix(matrix, heapSV) ==>)
        \find (intersect(
                    matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                    arrayRange(obj, start, end)
                    ))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, heapSV, matrix, obj) )
        \replacewith(
              \if (obj = matrix) \then (
                  intersect( arrayRange(matrix, rowStart, rowEnd),
                             arrayRange(obj, start, end) )
              ) \else (
                  \if ( \exists k; ( k>=rowStart & k<rowEnd & ArraySort::select(heapSV, matrix, arr(k)) = obj ) ) \then (
                      arrayRange(obj, maximum(colStart, start), minimum(colEnd, end))
                  ) \else (
                      empty
                  )
              )
          )
          \heuristics (simplify_ENLARGING)
     };

   matrixRange_intersectionMatrixRange {
       \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
       \schemaVar \term int rowStart2, rowEnd2, colStart2, colEnd2;
       \schemaVar \term Heap heapSV;
       \schemaVar \term ArraySort matrix, matrix2;
       \schemaVar \term Field f;
       \schemaVar \variables int k,l;

       \assumes(wellFormedMatrix(matrix, heapSV), wellFormedMatrix(matrix2, heapSV) ==>)
       \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  matrixRange(heapSV, matrix2, rowStart2, rowEnd2, colStart2, colEnd2)
             ))
       \sameUpdateLevel
       \varcond(\notFreeIn(k, rowStart, rowEnd, f),
                \notFreeIn(l, colStart, colEnd, f))
       \replacewith(
             \if (matrix = matrix2) \then (
                    matrixRange(heapSV, matrix,
                                maximum(rowStart, rowStart2), minimum(rowEnd, rowEnd2),
                                maximum(colStart, colStart2), minimum(colEnd, colEnd2) )
             ) \else (
                  empty
             )
       )
       \heuristics (simplify_ENLARGING)
   };

   elementOfMatrixRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k,l;


        \assumes (wellFormedMatrix(matrix, heapSV)==>)
        \find (elementOf(obj, f, matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, f),
                 \notFreeIn(l, matrix, obj, rowStart, rowEnd, heapSV),
                 \hasElementarySort(matrix, ElementSort))

        \replacewith(
                       (obj = matrix & \exists k; (f = arr(k) & k >= rowStart & k<rowEnd)) |
                       ( (\exists l; ( obj = ElementSort::select(heapSV, matrix, arr(l)) & l>=rowStart & l<rowEnd)) &
                         (\exists k; (f = arr(k) & k >= colStart & k<colEnd )) )
                    )

        \heuristics(simplify_ENLARGING)
   };

      elementOfMatrixRangeEQ {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object obj;
           \schemaVar \term Field f;
           \schemaVar \variables int k,l;
           \schemaVar \term LocSet EQ;


           \assumes (wellFormedMatrix(matrix, heapSV), matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd) = EQ ==>)
           \find (elementOf(obj, f, EQ))
           \sameUpdateLevel
           \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, f),
                    \notFreeIn(l, matrix, obj, rowStart, rowEnd, heapSV),
                    \hasElementarySort(matrix, ElementSort))

           \replacewith(
                          (obj = matrix & \exists k; (f = arr(k) & k >= rowStart & k<rowEnd)) |
                          ( (\exists l; ( obj = ElementSort::select(heapSV, matrix, arr(l)) & l>=rowStart & l<rowEnd)) &
                            (\exists k; (f = arr(k) & k >= colStart & k<colEnd )) )
                       )

           \heuristics(simplify_ENLARGING)
      };


      matrixRangeSetMinusMatrixRange {
      	\schemaVar \term Object a,b;
      	\schemaVar \term int lRowA, hRowA, lColA, hColA;
      	\schemaVar \term int lRowB, hRowB, lColB, hColB;
      	\schemaVar \term Heap heapSV;

        \assumes(wellFormedMatrix(a, heapSV), wellFormedMatrix(b, heapSV) ==>)

      	\find(setMinus(matrixRange(heapSV, a,lRowA, hRowA, lColA, hColA), matrixRange(heapSV, b,lRowB, hRowB, lColB, hColB)))

      	\replacewith(\if (a != b | hRowA < lRowB | hRowB < lRowA | hColA < lColB | hColB < lColA) \then (matrixRange(heapSV, a,lRowA, hRowA, lColA, hColA))
                     \else (\if(lRowA<lRowB)
                            \then(\if(hRowA<hRowB)
                                  \then(\if(lColB<lColA)
                                        \then(\if(hColB<hColA)
                                              \then(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB+1,hRowA,hColB+1,hColA)))
                                              \else(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA)))
                                        \else(\if(hColB<hColA)
                                              \then(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowA,lColA,lColB-1)),matrixRange(heapSV, a,lRowB,hRowA,hColB+1,hColA)))
                                              \else(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowA,lColA,lColB-1)))))
                                  \else(\if(lColB<lColA)
                                        \then(\if(hColB<hColA)
                                              \then(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,hColB+1,hColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                              \else(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))
                                        \else(\if(hColB<hColA)
                                              \then(union(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,lColA,lColB-1)),matrixRange(heapSV, a,lRowB,hRowB,hColB+1,lColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                              \else(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,lColA,hColB-1)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))))
                            \else(\if(hRowA<hRowB)
                                      \then(\if(lColB<lColA)
                                            \then(\if(hColB<hColA)
                                                  \then(matrixRange(heapSV, a,lRowA,hRowA,hColB+1,hColA))
                                                  \else(empty))
                                            \else(\if(hColB<hColA)
                                                  \then(union(matrixRange(heapSV, a,lRowA,hRowA,lColA,lColB-1),matrixRange(heapSV, a,lRowA,hRowA,hColB+1,hColA)))
                                                  \else(matrixRange(heapSV, a,lRowA,hRowA,lColA,hColB-1))))
                                      \else(\if(lColB<lColA)
                                          \then(\if(hColB<hColA)
                                                \then(union(matrixRange(heapSV, a,lRowA,hRowB,hColB+1,hColA),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                                \else(matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                          \else(\if(hColB<hColA)
                                                \then(union(union(matrixRange(heapSV, a,lRowA,hRowB,lColA,hColB-1),matrixRange(heapSV, a,lRowA,hRowB,hColB+1,lColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                                \else(union(matrixRange(heapSV, a,lRowA,hRowB,lColA,lColB-1),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))))))
      		\heuristics(locset_expand_setMinus)
        };

}
