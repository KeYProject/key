\rules(programRules:Java) {
   //axioms - wellFormedMatrix
   wellFormedMatrixDef {
        \schemaVar \term Object matrix;
        \schemaVar \term Heap heapSV;
        \schemaVar \variables int row1, row2;
        \schemaVar \variables Object matrix2;

        \find (wellFormedMatrix(matrix, heapSV) ==>)
        \varcond(\notFreeIn(matrix2, matrix, heapSV), \notFreeIn(row1, heapSV, matrix),
                 \notFreeIn(row2, heapSV, matrix),
                 \hasElementarySort(matrix, ElementSort))
        \add(
            matrix != null
            &
            (\forall row1; ElementSort::select(heapSV, matrix, arr(row1)) != null)
            &
            (\forall row1; matrix != ElementSort::select(heapSV, matrix, arr(row1)))
            &
            (\forall row1; \forall row2;
               (row1 != row2 -> ElementSort::select(heapSV, matrix, arr(row1)) != ElementSort::select(heapSV, matrix, arr(row2))))
            &
             (\forall matrix2; ( matrix != matrix2 ->
               \forall row1; \forall row2;
                 ( any::select(heapSV, matrix, arr(row1)) != any::select(heapSV, matrix2, arr(row2)))) )
            & (\forall row1;\forall row2;
                 length(ElementSort::select(heapSV, matrix, arr(row1))) = length(ElementSort::select(heapSV, matrix, arr(row2))))
        ==>)
        \heuristics(simplify_ENLARGING, noEqApp)
   };



   wellFormedMatrixDismissStoreOfPrimitiveType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    \varcond(\not\isReference(\typeof(value))) // value is of primitive type e.g. int, boolean, etc.
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreOfPrimitiveTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;
    \schemaVar \term Heap EQ;

    \assumes(store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \varcond(\not\isReference(\typeof(value))) // value is of primitive type e.g. int, boolean, etc.
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };


   wellFormedMatrixDismissStoreOfNonArrayType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(value))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreOfNonArrayTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV, EQ;


    \assumes (store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(value))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreForNonArrayType {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV;

    \find (wellFormedMatrix(matrix, store(heapSV, obj, field, value)))
    // obj is not an array, we must exclude ArraySort explicitly as there might be an array lurking behind this type
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(obj))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissStoreForNonArrayTypeEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Field field;
    \schemaVar \term G value;
    \schemaVar \term Heap heapSV,EQ;

    \assumes(store(heapSV, obj, field, value) = EQ ==>)
    \find (wellFormedMatrix(matrix, EQ))
    // obj is not an array, we must exclude ArraySort explicitly as there might be an array lurking behind this type
    \sameUpdateLevel
    \varcond(\strict\sub(\typeof(obj),ArraySort), \not\isArray(obj))
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissCreated {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Heap heapSV;

    \assumes(==> matrix = obj)
    \find(wellFormedMatrix(matrix, create(heapSV, obj)))
    \sameUpdateLevel
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixDismissCreatedEQ {
    \schemaVar \term ArraySort matrix, obj;
    \schemaVar \term Heap heapSV;
    \schemaVar \term Heap EQ;

    \assumes(create(heapSV, obj) = EQ ==> matrix = obj)
    \find(wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \replacewith(wellFormedMatrix(matrix, heapSV))
    \heuristics(simplify)
   };

   wellFormedMatrixAnon {
    \schemaVar \term ArraySort matrix;
    \schemaVar \term LocSet ls;
    \schemaVar \term Heap h1,h2;

    \find(wellFormedMatrix(matrix, anon(h1, ls, h2)))
    \sameUpdateLevel
    \replacewith(\if (intersect(ls, arrayRange(matrix, 0, length(matrix))) = empty)
                 \then (wellFormedMatrix(matrix, h1))
                 \else (wellFormedMatrix(matrix, anon(h1, ls, h2)))
                 )
    \heuristics(simplifyMatrixAnonHeap) // <--noEqApp?
   };

   wellFormedMatrixAnonEQ {
    \schemaVar \term ArraySort matrix;
    \schemaVar \term LocSet ls;
    \schemaVar \term Heap h1,h2;
    \schemaVar \term Heap EQ;

    \assumes(anon(h1, ls, h2) = EQ ==>)
    \find(wellFormedMatrix(matrix, EQ))
    \sameUpdateLevel
    \replacewith( \if (intersect(ls, arrayRange(matrix, 0, length(matrix))) = empty) // <= must be matrixRange
                  \then (wellFormedMatrix(matrix, h1))
                  \else (wellFormedMatrix(matrix, EQ))
                 )
    \heuristics(simplifyMatrixAnonHeap) // <--noEqApp?
   };


   wellFormedMatrixUnaffected {
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Heap successorHeap;
        \schemaVar \term Heap heapSV;

        \assumes(wellFormedMatrix(matrix, heapSV) ==>)
        \find(successorHeap)
        \sameUpdateLevel
        \varcond(\different(heapSV, successorHeap))
        \add (wellFormedMatrix(matrix, successorHeap) ==>);
        \add (==> wellFormedMatrix(matrix, successorHeap))
//        \heuristics(self_app_prevention, beta, noEqApp)
   };


   // axioms

    matrixRangeDef {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \variables int rowIndex;

        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \varcond(\notFreeIn(rowIndex, matrix, heapSV, rowStart, rowEnd, colStart, colEnd),
                                  \hasElementarySort(matrix,ElementSort))
        \replacewith(infiniteUnion{rowIndex;}(\if (rowIndex >= rowStart & rowIndex <= rowEnd)
                                            \then (arrayRange(ElementSort::select(heapSV, matrix, arr(rowIndex)), colStart, colEnd))
                                            \else (empty)))
    };

   // lemmas

   // empty ranges
      matrixRange_emptyBounds {
          \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
          \schemaVar \term Heap heapSV;
          \schemaVar \term ArraySort matrix;

          \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
          \replacewith( \if (rowStart > rowEnd | colStart > colEnd)
                        \then (empty)
                        \else (
                             matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)<<nonEmpty>>
                        )
                      )
          \heuristics(simplify_matrix_range_literal)
     };


/*   // empty ranges
   matrixRange_emptyBounds_noR {
       \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
       \schemaVar \term Heap heapSV;
       \schemaVar \term ArraySort matrix;

       \find (noR(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))==>)
       \replacewith( \if (rowStart > rowEnd | colStart > colEnd)
                     \then (noR(empty))
                     \else (
                          noR(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                     )
                   ==>)
       \heuristics(simplify_matrix_range_literal)
  };

   matrixRange_emptyBounds_noW {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (noW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))==>)
        \replacewith( \if (rowStart > rowEnd | colStart > colEnd)
                      \then (noW(empty))
                      \else (
                           noW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                      )
                    ==>)
        \heuristics(simplify_matrix_range_literal)
   };

   matrixRange_emptyBounds_noRaW {
       \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
       \schemaVar \term Heap heapSV;
       \schemaVar \term ArraySort matrix;

       \find (noRaW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))==>)
       \replacewith( \if (rowStart > rowEnd | colStart > colEnd)
                     \then (noRaW(empty))
                     \else (
                          noRaW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                     )
                   ==>)
       \heuristics(simplify_matrix_range_literal)
  };

  matrixRange_emptyBounds_noWaR {
          \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
          \schemaVar \term Heap heapSV;
          \schemaVar \term ArraySort matrix;

          \find (noWaR(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))==>)
          \replacewith( \if (rowStart > rowEnd | colStart > colEnd)
                        \then (noWaR(empty))
                        \else (
                             noWaR(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                        )
                      ==>)
          \heuristics(simplify_matrix_range_literal)
    };

    matrixRange_emptyBounds_noWaW {
         \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
         \schemaVar \term Heap heapSV;
         \schemaVar \term ArraySort matrix;

         \find (noWaW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))==>)
         \replacewith( \if (rowStart > rowEnd | colStart > colEnd)
                       \then (noWaW(empty))
                       \else (
                            noWaW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                       )
                     ==>)
         \heuristics(simplify_matrix_range_literal)
    };

  matrixRange_emptyBounds_2_noR {
       \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
       \schemaVar \term Heap heapSV;
       \schemaVar \term ArraySort matrix;

       \find (==> noR(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
       \replacewith(==> \if (rowStart > rowEnd | colStart > colEnd)
                     \then (noR(empty))
                     \else (
                          noR(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                     )
                   )
       \heuristics(simplify_matrix_range_literal_2)
  };

  matrixRange_emptyBounds_2_noW {
     \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
     \schemaVar \term Heap heapSV;
     \schemaVar \term ArraySort matrix;

     \find (==> noW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
     \replacewith(==> \if (rowStart > rowEnd | colStart > colEnd)
                   \then (noW(empty))
                   \else (
                        noW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                   )
                 )
     \heuristics(simplify_matrix_range_literal_2)
  };

  matrixRange_emptyBounds_2_noRaW {
     \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
     \schemaVar \term Heap heapSV;
     \schemaVar \term ArraySort matrix;

     \find (==> noRaW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
     \replacewith(==> \if (rowStart > rowEnd | colStart > colEnd)
                   \then (noRaW(empty))
                   \else (
                        noRaW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                   )
                 )
     \heuristics(simplify_matrix_range_literal_2)
  };

  matrixRange_emptyBounds_2_noWaR {
     \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
     \schemaVar \term Heap heapSV;
     \schemaVar \term ArraySort matrix;

     \find (==> noWaR(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
     \replacewith(==> \if (rowStart > rowEnd | colStart > colEnd)
                   \then (noWaR(empty))
                   \else (
                        noWaR(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                   )
                 )
     \heuristics(simplify_matrix_range_literal_2)
  };

  matrixRange_emptyBounds_2_noWaW {
     \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
     \schemaVar \term Heap heapSV;
     \schemaVar \term ArraySort matrix;

     \find (==> noWaW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
     \replacewith(==> \if (rowStart > rowEnd | colStart > colEnd)
                   \then (noWaW(empty))
                   \else (
                        noWaW(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
                   )
                 )
     \heuristics(simplify_matrix_range_literal_2)
  };
*/

   matrixRangeEmptyColumns {
           \schemaVar \term int rowStart, rowEnd, colStart;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \find (matrixRange(heapSV, matrix,
                              rowStart, rowEnd,
                              colStart, -1 + colStart))
           \replacewith(empty)
           \heuristics(simplify)
   };

   matrixRangeEmptyColumns2a {
              \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
              \schemaVar \term Heap heapSV;
              \schemaVar \term ArraySort matrix;
              \assumes(colEnd <= -1 + colStart ==>)
              \find (matrixRange(heapSV, matrix,
                                 rowStart, rowEnd,
                                 colStart, colEnd))
              \sameUpdateLevel
              \replacewith(empty)
              \heuristics(simplify)
      };


   matrixRangeEmptyColumns3 {
              \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
              \schemaVar \term Heap heapSV;
              \schemaVar \term ArraySort matrix;
              \assumes(colStart > colEnd ==>)
              \find (matrixRange(heapSV, matrix,
                                 rowStart, rowEnd,
                                 colStart, colEnd))
              \sameUpdateLevel
              \replacewith(empty)
              \heuristics(simplify)
      };

      matrixRangeEmptyColumns3a {
                    \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
                    \schemaVar \term Heap heapSV;
                    \schemaVar \term ArraySort matrix;
                    \assumes(colStart >= 1 + colEnd ==>)
                    \find (matrixRange(heapSV, matrix,
                                       rowStart, rowEnd,
                                       colStart, colEnd))
                    \sameUpdateLevel
                    \replacewith(empty)
                    \heuristics(simplify)
            };


   matrixRangeSingleRow {
        \schemaVar \term int rowStart, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, rowStart, colStart, colEnd))
        \varcond(\hasElementarySort(matrix, ElementSort))
        \replacewith(arrayRange(ElementSort::select(heapSV, matrix, arr(rowStart)), colStart, colEnd))
        //\heuristics (lateSimplification)
   };

   matrixRangeEmptyRow {
        \schemaVar \term int rowStart, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \find (matrixRange(heapSV, matrix, rowStart, -1 + rowStart, colStart, colEnd))
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRangeEmptyRow2 {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \assumes (rowEnd < rowStart ==>)
        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRangeEmptyRow2a {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \assumes (rowEnd <= -1 + rowStart ==>)
        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRangeEmptyRow3a {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;

        \assumes (rowStart >= 1 + rowEnd ==>)
        \find (matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \replacewith(empty)
        \heuristics (simplify)
   };

   matrixRangeDismissUnrelatedStore {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \term any value;

        \find(matrixRange(store(heapSV, obj, f, value), matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \varcond(\disjointModuloNull(\typeof(obj), ArraySort))
        \replacewith(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \heuristics(simplify)
   };

   matrixRangeDismissUnrelatedStoreEQ {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV, EQ;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \term any value;

        \assumes( store(heapSV, obj, f, value) = EQ ==> )
        \find(matrixRange(EQ, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \varcond(\disjointModuloNull(\typeof(obj), ArraySort))
        \replacewith(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd))
        \heuristics(simplify)
   };

   pullOutMatrixRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap h1, h2;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term LocSet ls;
        \schemaVar \skolemTerm LocSet matrixRangeDescription;
        
        \find( matrixRange(anon(h1, ls, h2), matrix, rowStart, rowEnd, colStart, colEnd) )
        \sameUpdateLevel
        
        \replacewith(matrixRangeDescription)
        \add( matrixRange(anon(h1, ls, h2), matrix, rowStart, rowEnd, colStart, colEnd) = matrixRangeDescription ==> )
  //      \heuristics(pull_out_matrixRange)
   };

   pullOutMatrixRangeEQ {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap EQ, h1, h2;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term LocSet ls;
        \schemaVar \skolemTerm LocSet matrixRangeDescription;

        \assumes ( anon(h1, ls, h2) = EQ ==> )
        \find( matrixRange(EQ, matrix, rowStart, rowEnd, colStart, colEnd) )
        \sameUpdateLevel
        
        \replacewith(matrixRangeDescription)
        \add( matrixRange(EQ, matrix, rowStart, rowEnd, colStart, colEnd) = matrixRangeDescription ==> )
  //      \heuristics(pull_out_matrixRange)
   };

    makeReinsertSimplifiedMatrixRange {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
           \schemaVar \term Heap heapSV, simpleHeap;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term LocSet ls;
           \schemaVar \term LocSet matrixRangeDescription;

           \assumes(heapSV = simpleHeap  ==>)
           \find(matrixRange(simpleHeap, matrix, rowStart, rowEnd, colStart, colEnd) =
                        matrixRangeDescription ==>)

            \replacewith(==>)
            \addrules ( reinsertSimplifiedMatrixRange {
                \find (matrixRangeDescription)
                \replacewith (matrixRange(simpleHeap, matrix, rowStart, rowEnd, colStart, colEnd))
                \heuristics ( simplify )
               }
            )
     //       \heuristics(apply_matrix_eq_reverse)
      };

   matrixRangeDismissUnrelatedAnonHeap { // TODO: here and at other places talking about anon(...) the commented out parts need to be included
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap h1, h2;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term LocSet ls;

        \find(matrixRange(anon(h1, ls, h2), matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \replacewith(\if (intersect(ls, arrayRange(matrix, rowStart, rowEnd))=empty)
                     \then (matrixRange(h1, matrix, rowStart, rowEnd, colStart, colEnd))
                     \else (matrixRange(anon(h1, ls, h2), matrix, rowStart, rowEnd, colStart, colEnd))
                     )
       \heuristics(simplifyMatrixAnonHeap, noEqApp)// simplifyAnonHeapMatrixRange
   };

   matrixRangeDismissUnrelatedAnonHeapEQ {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap EQ, h1, h2;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term LocSet ls;

        \assumes( anon(h1, ls, h2) = EQ ==> )
        \find(matrixRange(EQ, matrix, rowStart, rowEnd, colStart, colEnd))
        \sameUpdateLevel
        \replacewith(\if (intersect(ls, arrayRange(matrix, rowStart, rowEnd))=empty)
                     \then (matrixRange(h1, matrix, rowStart, rowEnd, colStart, colEnd))
                     \else (matrixRange(EQ, matrix, rowStart, rowEnd, colStart, colEnd))
                     )
        \heuristics(simplifyMatrixAnonHeap, noEqApp) //simplifyAnonHeapMatrixRange
   };


   matrixRangeNegativeRowEnd {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term numbers a;

        \find(matrixRange(heapSV, matrix, rowStart, Z(neglit(a)), colStart, colEnd))
        \sameUpdateLevel
        \replacewith(empty)
        \add(rowStart > Z(neglit(a)) ==>);
        \add(rowStart <= Z(neglit(a)) ==>)
      //  \heuristics(beta)
   };

   matrixRangeNegativeColEnd {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term numbers a;

        \find(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, Z(neglit(a))))
        \sameUpdateLevel
        \replacewith(empty)
        \add(colStart > Z(neglit(a)) ==>);
        \add(colStart <= Z(neglit(a)) ==>)
     //   \heuristics(beta)
   };

   // intersections
   matrixRange_intersectionSingleton {
      \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
      \schemaVar \term Heap heapSV;
      \schemaVar \term ArraySort matrix;
      \schemaVar \term Object obj;
      \schemaVar \term Field f;
      \schemaVar \variables int j, k,l;

      \assumes(wellFormedMatrix(matrix, heapSV) ==>)
      \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  singleton(obj, f)
                  ))
      \sameUpdateLevel
      \varcond(\notFreeIn(j, rowStart, rowEnd, f),
               \notFreeIn(k, rowStart, rowEnd, heapSV, matrix, obj),
               \notFreeIn(l, colStart, colEnd, f),
               \hasElementarySort(matrix, ElementSort))
      \replacewith(
                \if ( \exists k; ( k>=rowStart & k<=rowEnd & ElementSort::select(heapSV, matrix, arr(k)) = obj ) ) \then (
                    \if ( \exists l; (l>=colStart & l<=colEnd & f = arr(l) ) )
                    \then (singleton(obj, f))
                    \else (empty)
                ) \else (
                    empty
                )
        )
        \heuristics (simplify_ENLARGING)
   };

   matrixRange_intersectionSingletonKnownRowAndCol {
      \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIndex, colIdx;
      \schemaVar \term Heap heapSV;
      \schemaVar \term ArraySort matrix;
      \schemaVar \term Object obj;

      \assumes(wellFormedMatrix(matrix, heapSV),
               ElementSort::select(heapSV, matrix, arr(rowIndex)) = obj ==>)
      \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  singleton(obj, arr(colIdx))
                  ))
      \sameUpdateLevel
      \varcond(\hasElementarySort(matrix, ElementSort))
      \replacewith(
                \if ( rowIndex >= rowStart & rowIndex <= rowEnd &
                      colIdx >= colStart & colIdx <= colEnd)
                \then ( singleton(obj, arr(colIdx)) )
                \else ( empty )
        )
        \heuristics (simplify_enlarging)
   };

   matrixRange_intersectionSingletonConcrete {
      \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIndex;
      \schemaVar \term Heap heapSV;
      \schemaVar \term ArraySort matrix;

      \assumes(wellFormedMatrix(matrix, heapSV) ==>)
      \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  singleton(matrix, arr(rowIndex))
             ) )
      \sameUpdateLevel
      \replacewith( empty )
      \heuristics (simplify)
   };

   matrixRange_intersectionArrayRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term int start, end;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k;

        // rule assumes that the array 'matrix' in matrix[][] is not contained in 'matrix[]'
        \assumes(wellFormedMatrix(matrix, heapSV) ==>)
        \find (intersect(
                    matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                    arrayRange(obj, start, end)
                    ))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, heapSV, matrix, obj),
                 \hasElementarySort(matrix, ElementSort) )
        \replacewith(
                  \if ( \exists k; ( k>=rowStart & k<=rowEnd & ElementSort::select(heapSV, matrix, arr(k)) = obj ) )
                  \then (
                      arrayRange(obj, maximum(colStart, start), minimum(colEnd, end))
                  ) \else (
                      empty
                  )
          )
          \heuristics (simplify_ENLARGING)
     };

   matrixRange_intersectionArrayRangeKnownRowEQ {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIndex;
           \schemaVar \term int start, end;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object obj;

           \assumes(wellFormedMatrix(matrix, heapSV),
                    ElementSort::select(heapSV, matrix, arr(rowIndex)) = obj ==>)
           \find (intersect(
                       matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                       arrayRange(obj, start, end)
                  ))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort) )
           \replacewith(
                     \if ( rowIndex >= rowStart & rowIndex <= rowEnd )
                     \then (
                         arrayRange(obj, maximum(colStart, start), minimum(colEnd, end))
                     ) \else (
                         empty
                     )
                 )
           \heuristics (simplify_enlarging)
   };

   matrixRange_intersectionArrayRangeKnownRow {
              \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIndex;
              \schemaVar \term int start, end;
              \schemaVar \term Heap heapSV;
              \schemaVar \term ArraySort matrix;
              \schemaVar \term Object obj;

              \assumes(wellFormedMatrix(matrix, heapSV) ==>)
              \find (intersect(
                          matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                          arrayRange(ElementSort::select(heapSV, matrix, arr(rowIndex)), start, end)
                     ))
              \sameUpdateLevel
              \varcond(\hasElementarySort(matrix, ElementSort) )
              \replacewith(
                        \if ( rowIndex >= rowStart & rowIndex <= rowEnd )
                        \then (
                            arrayRange(ElementSort::select(heapSV, matrix, arr(rowIndex)),
                                       maximum(colStart, start), minimum(colEnd, end))
                        ) \else (
                            empty
                        )
                    )
              \heuristics (simplify_enlarging)
      };

   matrixRange_intersectionArrayRangeConcrete {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd, rowIndex;
           \schemaVar \term int start, end;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object obj;

           \assumes(wellFormedMatrix(matrix, heapSV) ==>)
           \find (intersect(
                       matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                       arrayRange(matrix, start, end)
                  ))
           \sameUpdateLevel
           \replacewith( empty )
           \heuristics (simplify)
   };

   matrixRange_intersectionMatrixRange {
       \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
       \schemaVar \term int rowStart2, rowEnd2, colStart2, colEnd2;
       \schemaVar \term Heap heapSV;
       \schemaVar \term ArraySort matrix, matrix2;
       \schemaVar \term Field f;
       \schemaVar \variables int k,l;

       \assumes(wellFormedMatrix(matrix, heapSV), wellFormedMatrix(matrix2, heapSV) ==>)
       \find (intersect(
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                  matrixRange(heapSV, matrix2, rowStart2, rowEnd2, colStart2, colEnd2)
             ))
       \sameUpdateLevel
       \varcond(\notFreeIn(k, rowStart, rowEnd, f),
                \notFreeIn(l, colStart, colEnd, f))
       \replacewith(
             \if (matrix = matrix2) \then (
                    matrixRange(heapSV, matrix,
                                maximum(rowStart, rowStart2), minimum(rowEnd, rowEnd2),
                                maximum(colStart, colStart2), minimum(colEnd, colEnd2) )
             ) \else (
                  empty
             )
       )
       \heuristics (simplify_enlarging)
   };

   elementOfMatrixRange {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k,l;

        \assumes (wellFormedMatrix(matrix, heapSV)==>)
        \find (elementOf(obj, f, matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, f),
                 \notFreeIn(l, matrix, obj, rowStart, rowEnd, heapSV),
                 \hasElementarySort(matrix, ElementSort))

        \replacewith(
                      (\exists l; ( obj = ElementSort::select(heapSV, matrix, arr(l)) & l>=rowStart & l<=rowEnd)) &
                      (\exists k; (f = arr(k) & k >= colStart & k <= colEnd ))
                    )

        \heuristics(simplify_ENLARGING)
   };

   elementOfMatrixRangeEQ {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k,l;
        \schemaVar \term LocSet EQ;


        \assumes (wellFormedMatrix(matrix, heapSV),
                  matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd) = EQ ==>)
        \find (elementOf(obj, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(k, rowStart, rowEnd, colStart, colEnd, f),
                 \notFreeIn(l, matrix, obj, rowStart, rowEnd, heapSV),
                 \hasElementarySort(matrix, ElementSort))

        \replacewith( (\exists l; ( obj = ElementSort::select(heapSV, matrix, arr(l)) & l>=rowStart & l<=rowEnd)) &
                      (\exists k; (f = arr(k) & k >= colStart & k<=colEnd ) )
                    )

        \heuristics(simplify_ENLARGING)
   };

   elementOfMatrixRangeConcrete {
        \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
        \schemaVar \term Heap heapSV;
        \schemaVar \term ArraySort matrix;
        \schemaVar \term Object obj;
        \schemaVar \term Field f;
        \schemaVar \variables int k,l;


        \assumes (wellFormedMatrix(matrix, heapSV)==>)
        \find (elementOf(obj, f, matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)))
        \sameUpdateLevel
        \varcond(\hasElementarySort(matrix, ElementSort),
                 \disjointModuloNull(\typeof(obj), ElementSort))

        \replacewith( false )

        \heuristics(concrete)
   };

   matrixRangeSetMinusSingletonSimple1 {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object row;
           \schemaVar \term Field f;

           \assumes(wellFormedMatrix(matrix, heapSV) ==>)
           \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                          singleton(row,f)))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort))
           \replacewith(
              \if (ElementSort::instance(row) = FALSE) \then (
                 matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
              ) \else (
                 setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                                          singleton(row,f))
              )
           )
           \heuristics(simplify,checkArrayElementSort)
   };

   matrixRangeSetMinusSingleton {
           \schemaVar \term int rowStart, rowEnd, colStart, colEnd, colIndex;
           \schemaVar \skolemTerm int rowIndex;
           \schemaVar \term Heap heapSV;
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object o;
           \schemaVar \variable int k;

           \assumes(wellFormedMatrix(matrix, heapSV) ==>)
           \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                          singleton(o, arr(colIndex))))
           \sameUpdateLevel
           \varcond(\notFreeIn(k, rowStart, rowEnd, heapSV, matrix, o),
                    \hasElementarySort(matrix, ElementSort))
           \replacewith(
              \if (o = matrix | colIndex < colStart | colIndex > colEnd)
              \then (
                 matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
              ) \else (
                 \if (\exists k; (k>=rowStart & k<=rowEnd & o = ElementSort::select(heapSV, matrix, arr(k))))
                 \then (
                    union(union(union(matrixRange(heapSV, matrix, rowStart, rowIndex-1, colStart, colEnd),
                                      matrixRange(heapSV, matrix, rowIndex+1, rowEnd, colStart, colEnd)),
                                            matrixRange(heapSV, matrix, rowIndex, rowIndex, colStart, colIndex-1)),
                                            matrixRange(heapSV, matrix, rowIndex, rowIndex, colIndex+1, colEnd))
                 ) \else (
                    matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                 )
              )
           )
           \add((\exists k; (k>=rowStart & k<=rowEnd & o = ElementSort::select(heapSV, matrix, arr(k))))
                -> (rowIndex>=rowStart & rowIndex<=rowEnd & o = ElementSort::select(heapSV, matrix, arr(rowIndex))) ==>)
          //\heuristics(locset_expand_setMinus_low_priority)
      };

      matrixRangeSetMinusSingletonKnownRowIndexEQ {
          \schemaVar \term int rowStart, rowEnd, colStart, colEnd, colIndex;
          \schemaVar \term Heap heapSV;
          \schemaVar \term ArraySort matrix;
          \schemaVar \term Object o;
          \schemaVar \term int rowIndex;

          \assumes(wellFormedMatrix(matrix, heapSV), ElementSort::select(heapSV, matrix, arr(rowIndex)) = o ==>)
          \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                               singleton(o,arr(colIndex))))
          \sameUpdateLevel
          \varcond(\hasElementarySort(matrix, ElementSort))
          \replacewith(
                   \if (o = matrix | colIndex < colStart | colIndex > colEnd)
                   \then (
                      matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                   ) \else (
                      \if (rowIndex >= rowStart & rowIndex <= rowEnd)
                      \then (
                         union(union(union(matrixRange(heapSV, matrix, rowStart, rowIndex-1, colStart, colEnd),
                                               matrixRange(heapSV, matrix, rowIndex+1, rowEnd, colStart, colEnd)),
                                                 matrixRange(heapSV, matrix, rowIndex, rowIndex,  colStart, colIndex-1)),
                                                     matrixRange(heapSV, matrix, rowIndex, rowIndex, colIndex+1, colEnd))
                      ) \else (
                         matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
                      )
                   )
                )
          \heuristics(locsetExpandSetMinusMatrix)
      };

   matrixRangeSetMinusSingletonKnownRowIndex {
       \schemaVar \term int rowStart, rowEnd, colStart, colEnd, colIndex;
       \schemaVar \term Heap heapSV;
       \schemaVar \term ArraySort matrix;
       \schemaVar \term int rowIndex;

       \assumes(wellFormedMatrix(matrix, heapSV) ==>)
       \find(setMinus(matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd),
                      singleton(ElementSort::select(heapSV, matrix, arr(rowIndex)),arr(colIndex))))
       \sameUpdateLevel
       \varcond(\hasElementarySort(matrix, ElementSort))
       \replacewith(
          \if (ElementSort::select(heapSV, matrix, arr(rowIndex)) = matrix | colIndex < colStart | colIndex > colEnd)
          \then (
             matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
          ) \else (
             \if (rowIndex >=rowStart & rowIndex<=rowEnd)
             \then (
                union(union(union(matrixRange(heapSV, matrix, rowStart, rowIndex-1, colStart, colEnd),
                                      matrixRange(heapSV, matrix, rowIndex+1, rowEnd, colStart, colEnd)),
                                        matrixRange(heapSV, matrix, rowIndex, rowIndex, colStart, colIndex-1)),
                                            matrixRange(heapSV, matrix, rowIndex, rowIndex, colIndex+1, colEnd))
             ) \else (
                matrixRange(heapSV, matrix, rowStart, rowEnd, colStart, colEnd)
             )
          )
       )
       \heuristics(locsetExpandSetMinusMatrix)
   };

   matrixRangeSetMinusArrayRange {
       \schemaVar \term ArraySort matrix;
       \schemaVar \term int lRowA, hRowA, lColA, hColA, rowIndex;
       \schemaVar \term int lColB, hColB;
       \schemaVar \term Heap heapSV;

       \assumes(wellFormedMatrix(matrix, heapSV) ==>)

       \find(setMinus(matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA),
                      arrayRange(ElementSort::select(heapSV, matrix, arr(rowIndex)), lColB, hColB)))
       \sameUpdateLevel
       \varcond(\hasElementarySort(matrix, ElementSort))
       \replacewith(\if (ElementSort::instance(ElementSort::select(heapSV, matrix, arr(rowIndex))) = FALSE |
                         lColB > hColA | hColB < lColA |
                         !(rowIndex >=lRowA & rowIndex <= hRowA))
                    \then ( matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA) )
                    \else (
                       union(matrixRange(heapSV, matrix,
                                         lRowA, rowIndex - 1,
                                         lColA, hColA),
                       union(matrixRange(heapSV, matrix,
                                   	   rowIndex, rowIndex,
                                   	   lColA, lColB - 1),
                       union(matrixRange(heapSV, matrix,
                                         rowIndex, rowIndex,
                                         hColB + 1, hColA),
                             matrixRange(heapSV, matrix,
                                   	  rowIndex + 1, hRowA,
                                   	  lColA, hColA)
                    ))))
       )
       \heuristics(simplify_ENLARGING)
    };

       matrixRangeSetMinusArrayRangeEQ {
           \schemaVar \term ArraySort matrix;
           \schemaVar \term Object b;
           \schemaVar \term int lRowA, hRowA, lColA, hColA, rowIndex;
           \schemaVar \term int lColB, hColB;
           \schemaVar \term Heap heapSV;

           \assumes(wellFormedMatrix(matrix, heapSV), ElementSort::select(heapSV, matrix, arr(rowIndex)) = b ==>)

           \find(setMinus(matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA),
                          arrayRange(b, lColB, hColB)))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort))
           \replacewith(\if (ElementSort::instance(b) = FALSE |
                             lColB > hColA | hColB < lColA |
                             !(rowIndex >=lRowA & rowIndex <= hRowA))
                        \then ( matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA) )
                        \else (
                           union(matrixRange(heapSV, matrix,
                                             lRowA, rowIndex - 1,
                                             lColA, hColA),
                           union(matrixRange(heapSV, matrix,
                                       	   rowIndex, rowIndex,
                                       	   lColA, lColB - 1),
                           union(matrixRange(heapSV, matrix,
                                             rowIndex, rowIndex,
                                             hColB + 1, hColA),
                                 matrixRange(heapSV, matrix,
                                       	  rowIndex + 1, hRowA,
                                       	  lColA, hColA)
                           ))))
           )
           \heuristics(simplify_ENLARGING)
        };

   matrixRangeSetMinusArrayRangeSimplify {
       \schemaVar \term ArraySort matrix;
       \schemaVar \term Object row;
       \schemaVar \term int lRowA, hRowA, lColA, hColA;
       \schemaVar \term int lColB, hColB;
       \schemaVar \term Heap heapSV;

       \assumes(wellFormedMatrix(matrix, heapSV) ==>)

       \find(setMinus(matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA),
                      arrayRange(row, lColB, hColB)))
       \sameUpdateLevel
       \varcond(\hasElementarySort(matrix, ElementSort))
       \replacewith(
            \if (ElementSort::instance(row) = FALSE) \then (
              matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA)
            ) \else (
              setMinus(matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA),
                                  arrayRange(row, lColB, hColB))
            )
       )
       \heuristics(simplify, checkArrayElementSort)
       // not simplify_enlarging because check prevents automatic application
   };

   matrixRangeSetMinusArrayRangeSimplifyFirstRow {
       \schemaVar \term ArraySort matrix;
       \schemaVar \term int rowIndex, hRowA, lColA, hColA;
       \schemaVar \term int lColB, hColB;
       \schemaVar \term Heap heapSV;

       \assumes(wellFormedMatrix(matrix, heapSV) ==>)

       \find(setMinus(matrixRange(heapSV, matrix, rowIndex, hRowA, lColA, hColA),
                      arrayRange(ElementSort::select(heapSV, matrix, arr(rowIndex)), lColB, hColB)))
       \sameUpdateLevel
       \varcond(\hasElementarySort(matrix, ElementSort))
       \replacewith(
             \if (lColB <= lColA & hColA <= hColB)
             \then (matrixRange(heapSV, matrix, rowIndex + 1, hRowA,  lColA, hColA))
             \else (
                 union(matrixRange(heapSV, matrix, rowIndex + 1, hRowA, lColA, hColA),
                       union(matrixRange(heapSV, matrix, rowIndex, rowIndex, lColA, lColB - 1),
                             matrixRange(heapSV, matrix, rowIndex, rowIndex, hColB + 1, hColA)))
             )
       )
       \heuristics(simplify_enlarging)
   };

  matrixRangeSetMinusArrayRangeSimplifyFirstRowEQ {
       \schemaVar \term ArraySort matrix;
       \schemaVar \term Object EQ;
       \schemaVar \term int rowIndex, hRowA, lColA, hColA;
       \schemaVar \term int lColB, hColB;
       \schemaVar \term Heap heapSV;

       \assumes(wellFormedMatrix(matrix, heapSV), ElementSort::select(heapSV, matrix, arr(rowIndex)) = EQ ==>)

       \find(setMinus(matrixRange(heapSV, matrix, rowIndex, hRowA, lColA, hColA),
                      arrayRange(EQ, lColB, hColB)))
       \sameUpdateLevel
       \varcond(\hasElementarySort(matrix, ElementSort))
       \replacewith(
             \if (lColB <= lColA & hColA <= hColB)
             \then (matrixRange(heapSV, matrix, rowIndex + 1, hRowA,  lColA, hColA))
             \else (
                 union(matrixRange(heapSV, matrix, rowIndex + 1, hRowA, lColA, hColA),
                       union(matrixRange(heapSV, matrix, rowIndex, rowIndex, lColA, lColB - 1),
                             matrixRange(heapSV, matrix, rowIndex, rowIndex, hColB + 1, hColA)))
             )
       )
       \heuristics(simplify_enlarging)
   };


   matrixRangeSetMinusArrayRangeSimplifyLastRow {
       \schemaVar \term ArraySort matrix;
       \schemaVar \term int lRowA, rowIndex, lColA, hColA;
       \schemaVar \term int lColB, hColB;
       \schemaVar \term Heap heapSV;

       \assumes(wellFormedMatrix(matrix, heapSV) ==>)

       \find(setMinus(matrixRange(heapSV, matrix, lRowA, rowIndex, lColA, hColA),
                      arrayRange(ElementSort::select(heapSV, matrix, arr(rowIndex)), lColB, hColB)))
       \sameUpdateLevel
       \varcond(\hasElementarySort(matrix, ElementSort))
       \replacewith(
             \if (lColB <= lColA & hColA <= hColB)
             \then (matrixRange(heapSV, matrix, lRowA, rowIndex - 1, lColA, hColA))
             \else (
                 union(matrixRange(heapSV, matrix, lRowA, rowIndex - 1, lColA, hColA),
                       union(matrixRange(heapSV, matrix, rowIndex, rowIndex, lColA, lColB - 1),
                             matrixRange(heapSV, matrix, rowIndex, rowIndex, hColB + 1, hColA)))
             )
       )
       \heuristics(simplify_enlarging)
   };

   matrixRangeSetMinusArrayRangeSimplifyLastRowEQ {
       \schemaVar \term ArraySort matrix;
       \schemaVar \term Object EQ;
       \schemaVar \term int lRowA, rowIndex, lColA, hColA;
       \schemaVar \term int lColB, hColB;
       \schemaVar \term Heap heapSV;

       \assumes(wellFormedMatrix(matrix, heapSV),ElementSort::select(heapSV, matrix, arr(rowIndex)) = EQ ==>)

       \find(setMinus(matrixRange(heapSV, matrix, lRowA, rowIndex, lColA, hColA),
                      arrayRange(EQ, lColB, hColB)))
       \sameUpdateLevel
       \varcond(\hasElementarySort(matrix, ElementSort))
       \replacewith(
             \if (lColB <= lColA & hColA <= hColB)
             \then (matrixRange(heapSV, matrix, lRowA, rowIndex - 1, lColA, hColA))
             \else (
                 union(matrixRange(heapSV, matrix, lRowA, rowIndex - 1, lColA, hColA),
                       union(matrixRange(heapSV, matrix, rowIndex, rowIndex, lColA, lColB - 1),
                             matrixRange(heapSV, matrix, rowIndex, rowIndex, hColB + 1, hColA)))
             )
       )
       \heuristics(simplify_enlarging)
   };


   arrayRangeSetMinusMatrixRange {
          \schemaVar \term ArraySort matrix;
          \schemaVar \term Object b;
          \schemaVar \term int lRowA, hRowA, lColA, hColA;
          \schemaVar \term int lColB, hColB;
          \schemaVar \term Heap heapSV;
          \schemaVar \variable int rowIndex;

          \assumes(wellFormedMatrix(matrix, heapSV) ==>)

          \find(setMinus(arrayRange(b, lColB, hColB),
                         matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA)))
          \sameUpdateLevel
          \varcond(\hasElementarySort(matrix, ElementSort), \notFreeIn(rowIndex, lRowA, hRowA, b, matrix, heapSV))
          \replacewith(\if (ElementSort::instance(b) = FALSE |
                            lColB > hColA | hColB < lColA |
                            !\exists rowIndex; (rowIndex >=lRowA & rowIndex <= hRowA &
                                                b = ElementSort::select(heapSV, matrix, arr(rowIndex))))
                       \then ( arrayRange(b, lColB, hColB) )
                       \else (
                          union (
                           arrayRange(b, lColB, lColA - 1),
                           arrayRange(b, hColA + 1, hColB)
                          )
                       )
          )
          \heuristics(simplify_ENLARGING)
   };

   arrayRangeSetMinusMatrixRange2 {
         \schemaVar \term ArraySort matrix;
         \schemaVar \term Object row;
         \schemaVar \term int lRowA, hRowA, lColA, hColA, rowIndex;
         \schemaVar \term int lColB, hColB;
         \schemaVar \term Heap heapSV;

         \assumes(wellFormedMatrix(matrix, heapSV)==>)

         \find(setMinus(arrayRange(row, lColB, hColB),
                        matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA) ))
         \sameUpdateLevel
         \varcond(\hasElementarySort(matrix, ElementSort))
         \replacewith( \if (ElementSort::instance(row) = FALSE)
                       \then ( arrayRange(row, lColB, hColB) )
                       \else ( setMinus(arrayRange(row, lColB, hColB),
                                        matrixRange(heapSV, matrix, lRowA, hRowA, lColA, hColA) ))
                     )
         \heuristics(simplify, checkArrayElementSort)
   };

   matrixRangeSetMinusMatrixRangeGeneral {
       \schemaVar \term Object a,b;
       \schemaVar \term int lRowA, hRowA, lColA, hColA;
       \schemaVar \term int lRowB, hRowB, lColB, hColB;
       \schemaVar \term Heap heapSV;

       \assumes(wellFormedMatrix(a, heapSV) ==>)

       \find(setMinus(matrixRange(heapSV, a, lRowA, hRowA, lColA, hColA),
                      matrixRange(heapSV, b, lRowB, hRowB, lColB, hColB)))
       \sameUpdateLevel
       \replacewith(\if (a != b | hRowB < lRowA | lRowB > hRowA |
                         lColB > hColA | hColB < lColA )
                    \then ( matrixRange(heapSV, a, lRowA, hRowA, lColA, hColA) )
                    \else (
                       union(matrixRange(heapSV, a,
                                         lRowA, lRowB - 1,
                                         lColA, hColA),
                       union(matrixRange(heapSV, a,
                                   	   lRowB, hRowB,
                                   	   lColA, lColB - 1),
                       union(matrixRange(heapSV, a,
                                         lRowB, hRowB,
                                         hColB + 1, hColA),
                             matrixRange(heapSV, a,
                                   	  hRowB + 1, hRowA,
                                   	  lColA, hColA)
                       ))))
       )
       \heuristics(simplify_ENLARGING)
   };

  matrixRangeSetMinusMatrixRangeSpecialCase1 {
      \schemaVar \term Object a;
      \schemaVar \term int y, x, lRowA, lColA, hColA;
      \schemaVar \term Heap heapSV;

      \assumes(wellFormedMatrix(a, heapSV) ==>)

      \find(setMinus(matrixRange(heapSV, a, lRowA, x, lColA, hColA),
                     matrixRange(heapSV, a, lRowA, y, lColA, hColA)))
      \sameUpdateLevel
      \replacewith(\if (x <= y )
                   \then (empty)
                   \else ( matrixRange(heapSV, a, y+1, x, lColA, hColA)))
      \heuristics(simplify)
  };

   matrixRangeSetMinusMatrixRangeSpecialCase2 {
      \schemaVar \term Object a;
      \schemaVar \term int y, x, hRowA, lColA, hColA;
      \schemaVar \term Heap heapSV;

      \assumes(wellFormedMatrix(a, heapSV) ==>)

      \find(setMinus(matrixRange(heapSV, a, x, hRowA, lColA, hColA),
                     matrixRange(heapSV, a, y, hRowA, lColA, hColA)))
      \sameUpdateLevel
      \replacewith(\if (x >= y)
                   \then (empty)
                   \else (matrixRange(heapSV, a, x, y-1, lColA, hColA)))
      \heuristics(simplify)
  };

  matrixRangeSetMinusMatrixRangeSpecialCase3 {
        \schemaVar \term Object a;
        \schemaVar \term int x, y, lRowA, hRowA, lColA;
        \schemaVar \term Heap heapSV;

        \assumes(wellFormedMatrix(a, heapSV) ==>)

        \find(setMinus(matrixRange(heapSV, a, lRowA, hRowA, lColA, x),
                       matrixRange(heapSV, a, lRowA, hRowA, lColA, y)))
        \sameUpdateLevel
        \replacewith(\if (x <= y)
                     \then (empty)
                     \else ( matrixRange(heapSV, a, lRowA, hRowA, y+1,x)))
        \heuristics(simplify)
  };

  matrixRangeSetMinusMatrixRangeSpecialCase4 {
        \schemaVar \term Object a;
        \schemaVar \term int x, y, lRowA, hRowA, hColA;
        \schemaVar \term Heap heapSV;

        \assumes(wellFormedMatrix(a, heapSV) ==>)

        \find(setMinus(matrixRange(heapSV, a, lRowA, hRowA, x, hColA),
                       matrixRange(heapSV, a, lRowA, hRowA, y, hColA)))
        \sameUpdateLevel
        \replacewith(\if (x >= y)
                     \then (empty)
                     \else ( matrixRange(heapSV, a, lRowA, hRowA, x, y-1)))
        \heuristics(simplify)
  };

  matrixRangeSetMinusMatrixRangeSpecialCase5 {
          \schemaVar \term Object a;
          \schemaVar \term int lRow1, hRow1, lCol1, hCol1, lRow2, hRow2, lCol2, hCol2;
          \schemaVar \term Heap heapSV;

          \assumes(wellFormedMatrix(a, heapSV) ==>)

          \find(setMinus(matrixRange(heapSV, a, lRow1, hRow1, lCol1, hCol1),
                         matrixRange(heapSV, a, lRow2, hRow2, lCol2, hCol2)))
          \sameUpdateLevel
          \replacewith(\if ( lRow2 <= lRow1 & hRow2 >= hRow1 & lCol2 <= lCol1 & hCol2 >= hCol1 )
                       \then (empty)
                       \else ( setMinus(matrixRange(heapSV, a, lRow1, hRow1, lCol1, hCol1),
                                        matrixRange(heapSV, a, lRow2, hRow2, lCol2, hCol2))) )
          \heuristics(coveredMatrix)
    };


   matrixRangeSetMinusMatrixRange {
   	   \schemaVar \term Object a,b;
   	   \schemaVar \term int lRowA, hRowA, lColA, hColA;
   	   \schemaVar \term int lRowB, hRowB, lColB, hColB;
   	   \schemaVar \term Heap heapSV;
       
       \assumes(wellFormedMatrix(a, heapSV), wellFormedMatrix(b, heapSV) ==>)
       
   	   \find(setMinus(matrixRange(heapSV, a,lRowA, hRowA, lColA, hColA), matrixRange(heapSV, b,lRowB, hRowB, lColB, hColB)))
       
   	   \replacewith(\if (a != b | hRowA < lRowB | hRowB < lRowA | hColA < lColB | hColB < lColA) \then
   	                (matrixRange(heapSV, a,lRowA, hRowA, lColA, hColA))
                     \else (\if(lRowA<lRowB)
                            \then(\if(hRowA<hRowB)
                                  \then(\if(lColB<lColA)
                                        \then(\if(hColB<hColA)
                                              \then(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB+1,hRowA,hColB+1,hColA)))
                                              \else(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA)))
                                        \else(\if(hColB<hColA)
                                              \then(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowA,lColA,lColB-1)),matrixRange(heapSV, a,lRowB,hRowA,hColB+1,hColA)))
                                              \else(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowA,lColA,lColB-1)))))
                                  \else(\if(lColB<lColA)
                                        \then(\if(hColB<hColA)
                                              \then(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,hColB+1,hColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                              \else(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))
                                        \else(\if(hColB<hColA)
                                              \then(union(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,lColA,lColB-1)),matrixRange(heapSV, a,lRowB,hRowB,hColB+1,lColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                              \else(union(union(matrixRange(heapSV, a,lRowA,lRowB-1,lColA,hColA),matrixRange(heapSV, a,lRowB,hRowB,lColA,hColB-1)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))))
                            \else(\if(hRowA<hRowB)
                                      \then(\if(lColB<lColA)
                                            \then(\if(hColB<hColA)
                                                  \then(matrixRange(heapSV, a,lRowA,hRowA,hColB+1,hColA))
                                                  \else(empty))
                                            \else(\if(hColB<hColA)
                                                  \then(union(matrixRange(heapSV, a,lRowA,hRowA,lColA,lColB-1),matrixRange(heapSV, a,lRowA,hRowA,hColB+1,hColA)))
                                                  \else(matrixRange(heapSV, a,lRowA,hRowA,lColA,hColB-1))))
                                      \else(\if(lColB<lColA)
                                          \then(\if(hColB<hColA)
                                                \then(union(matrixRange(heapSV, a,lRowA,hRowB,hColB+1,hColA),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                                \else(matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                          \else(\if(hColB<hColA)
                                                \then(union(union(matrixRange(heapSV, a,lRowA,hRowB,lColA,hColB-1),matrixRange(heapSV, a,lRowA,hRowB,hColB+1,lColA)),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA)))
                                                \else(union(matrixRange(heapSV, a,lRowA,hRowB,lColA,lColB-1),matrixRange(heapSV, a,hRowB+1,hRowA,lColA,hColA))))))))
   	   	//\heuristics(locset_expand_setMinus_low_priority)
   };

    matrixRangeSubSetMatrixRange {
   	   \schemaVar \term Object a;
   	   \schemaVar \term int lRow1, hRow1, lCol1, hCol1;
   	   \schemaVar \term int lRow2, hRow2, lCol2, hCol2;

   	   \schemaVar \term Heap heapSV;

       \find (subset(matrixRange(heapSV, a, lRow1, hRow1, lCol1, hCol1),
                     matrixRange(heapSV, a, lRow2, hRow2, lCol2, hCol2)))
       \replacewith(
           lRow2 <= lRow1 & hRow2 >= hRow1 & lCol2 <= lCol1 & hCol2 >= hCol1
       )
       \heuristics(simplify)
    };

    matrixRangeSubSetArrayRange {
       	   \schemaVar \term ArraySort matrix;
       	   \schemaVar \term Object row;
       	   \schemaVar \term int hRow1, hRow2, lCol1, hCol1;
       	   \schemaVar \term int lCol2, hCol2;

       	   \schemaVar \term Heap heapSV;

           \find (subset(matrixRange(heapSV, matrix, hRow1, hRow2, lCol1, hCol1),
                         arrayRange(row, lCol2, hCol2)))
           \replacewith(
               hRow1 = hRow2 & lCol2 <= lCol1 & hCol1 <= hCol2 &
               row = any::select(heapSV, matrix, arr(hRow1))
           )
           \heuristics(simplify)
        };

    matrixRangeSubSetArrayRangeKnownRowIdx1 {
       	   \schemaVar \term ArraySort matrix;
       	   \schemaVar \term int lRow1, hRow1, lCol1, hCol1;
       	   \schemaVar \term int lCol2, hCol2;
       	   \schemaVar \term Object row;
       	   \schemaVar \term int rowIdx;

       	   \schemaVar \term Heap heapSV;

           \find (subset(arrayRange(ElementSort::select(heapSV, matrix, arr(rowIdx)), lCol2, hCol2),
                         matrixRange(heapSV, matrix, lRow1, hRow1, lCol1, hCol1)))
           \varcond(\hasElementarySort(matrix, ElementSort))
           \replacewith(
               lCol1 <= lCol2 & hCol2 <= hCol1 & rowIdx >= lRow1 & rowIdx <= hRow1
           )
           \heuristics(simplify)
        };

    matrixRangeSubSetArrayRangeKnownRowIdx1EQ {
           \schemaVar \term ArraySort matrix;
           \schemaVar \term int lRow1, hRow1, lCol1, hCol1;
           \schemaVar \term int lCol2, hCol2;
           \schemaVar \term Object row;
           \schemaVar \term int rowIdx;
           \schemaVar \term Object EQ;

           \schemaVar \term Heap heapSV;

           \assumes(ElementSort::select(heapSV, matrix, arr(rowIdx)) = EQ ==>)
           \find (subset(arrayRange(EQ, lCol2, hCol2),
                         matrixRange(heapSV, matrix, lRow1, hRow1, lCol1, hCol1)))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort))
           \replacewith(
               lCol1 <= lCol2 & hCol2 <= hCol1 & rowIdx >= lRow1 & rowIdx <= hRow1
           )
           \heuristics(simplify)
    };

    matrixRangeSubSetSingletonKnownRowIdx {
           \schemaVar \term ArraySort matrix;
           \schemaVar \term int lRow1, hRow1, lCol1, hCol1;
           \schemaVar \term int rowIdx, colIdx;
           \schemaVar \term Object EQ;

           \schemaVar \term Heap heapSV;

           \find (subset(matrixRange(heapSV, matrix, lRow1, hRow1, lCol1, hCol1),
                         singleton(ElementSort::select(heapSV, matrix, arr(rowIdx)),
                         arr(colIdx))))
           \varcond(\hasElementarySort(matrix, ElementSort))
           \replacewith(
               lCol1 = hCol1 & colIdx = hCol1 &
               lRow1 = hRow1 & rowIdx = hRow1
           )
           \heuristics(simplify)
    };

    matrixRangeSubSetSingletonKnownRowIdxEQ {
           \schemaVar \term ArraySort matrix;
           \schemaVar \term int lRow1, hRow1, lCol1, hCol1;
           \schemaVar \term Object EQ;
           \schemaVar \term int rowIdx, colIdx;

           \schemaVar \term Heap heapSV;

           \assumes(ElementSort::select(heapSV, matrix, arr(rowIdx)) = EQ ==>)
           \find (subset(matrixRange(heapSV, matrix, lRow1, hRow1, lCol1, hCol1),
                         singleton(EQ, arr(colIdx))))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort))
           \replacewith(
               lCol1 = hCol1 & colIdx = hCol1 &
               lRow1 = hRow1 & rowIdx = hRow1
           )
           \heuristics(simplify)
    };

    singletonSubSetMatrixRangeKnownRowIdx {
           \schemaVar \term ArraySort matrix;
           \schemaVar \term int lRow1, hRow1, lCol1, hCol1;
           \schemaVar \term int rowIdx, colIdx;
           \schemaVar \term Object EQ;

           \schemaVar \term Heap heapSV;

           \find (subset(singleton(ElementSort::select(heapSV, matrix, arr(rowIdx)),arr(colIdx)),
                         matrixRange(heapSV, matrix, lRow1, hRow1, lCol1, hCol1)))
           \varcond(\hasElementarySort(matrix, ElementSort))
           \replacewith(
               lCol1 <= colIdx & colIdx <= hCol1 &
               lRow1 <= rowIdx & rowIdx <= hRow1
           )
           \heuristics(simplify)
    };

    matrixRangeSubSetSingletonKnownRowIdxEQ {
           \schemaVar \term ArraySort matrix;
           \schemaVar \term int lRow1, hRow1, lCol1, hCol1;
           \schemaVar \term int lCol2, hCol2;
           \schemaVar \term Object EQ;
           \schemaVar \term int rowIdx, colIdx;

           \schemaVar \term Heap heapSV;

           \assumes(ElementSort::select(heapSV, matrix, arr(rowIdx)) = EQ ==>)
           \find (subset(singleton(EQ, arr(colIdx)),
                         matrixRange(heapSV, matrix, lRow1, hRow1, lCol1, hCol1)))
           \sameUpdateLevel
           \varcond(\hasElementarySort(matrix, ElementSort))
           \replacewith(
               lCol1 <= colIdx & colIdx <= hCol1 &
               lRow1 <= rowIdx & rowIdx <= hRow1
           )
           \heuristics(simplify)
    };
}
