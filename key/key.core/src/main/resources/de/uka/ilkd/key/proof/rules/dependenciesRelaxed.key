\sorts {
   \generic U;
}

\schemaVariables{
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
}

//======================================================================================================================
// 												General Rules
//======================================================================================================================

\rules {

// to help with proving the loop invariant

  /* locSetAssSameRightDiffLeft{
        \schemaVar \term LocSet loc1, loc2, loc;

        \assumes(loc1 = loc ==>)
        \find(loc2 = loc ==>)
        \add(loc1 = loc2 ==>)

        \heuristics(simplify_ENLARGING)
    };*/


// unfold boundaries
	unfoldBounds {
		\schemaVar \term numbers a,b;
		\schemaVar \term int x;

		\assumes(x <= Z(b) ==>)
		\find(x >= Z(a) ==> )

		\replacewith( x=Z(a) ==>);

		\replacewith( x>=Z(a) + 1 ==>)

		\heuristics(dep_pred_unroll_fixed_bounds)

	};

	parallelUpdateAssociative {
	    \schemaVar \update u1, u2, u3;

	    \find (u1 || (u2 || u3))
	    \replacewith(u1 || u2 || u3)

	    \heuristics(simplify)

	};
}

//======================================================================================================================
//												Data Dependence Rules
//======================================================================================================================


\rules(programRules:Java, dependencies:on) {
  // Unwinding rules
   loopUnwind    {
            \schemaVar \program Statement #s;
            \schemaVar \program Expression #e;
            \schemaVar \formula post;
            \schemaVar \program Label #innerLabel, #outerLabel;


            \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
             \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
                 \replacewith ({timestamp:=timestamp + 1}{\event(unique, empty, timestamp)}\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel,
                                       while(#e) #s); ...}\endmodality(post))
             \heuristics(loop_expand)
          };
}



\rules(programRules:Java, runtimeExceptions:ban, dependencies: on) {

//======================================================================================================================
//													Assignment Rules
//======================================================================================================================

	assignment  {
		\schemaVar \program Variable #loc;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
		\replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_read_attribute {
		\schemaVar \program Variable #v0, #v, #a;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
		\varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		\event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		//{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v=null))
		;
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_read_attribute_this {
		\schemaVar \program Variable #v0, #v, #a;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
		\varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		\replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		\event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		//{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	/* assignment_read_length {
	\schemaVar \program Variable #v0, #v;
	\schemaVar \formula post;

	\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
	\varcond(\not\isThisReference(#v))
	"Normal Execution (#v != null)":
	\replacewith(==> {#v0 := length(#v)}

	\modality{#allmodal}{.. ...}\endmodality(post))
	//\add (==>(#v=null))
	;
	"Null Reference (#v = null)":
	\replacewith(==> false)
	\add (#v=null ==>)
	\heuristics(simplify_prog, simplify_prog_subset)
	};*/


	assignment_write_attribute {

		\schemaVar \program Variable #v, #a;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
		\varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		\event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		//{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		//\add (==>(#v=null))
		;

		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment"
	};

	assignment_write_attribute_this {

		\schemaVar \program Variable #v, #a;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
		\varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		\replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		\event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		//{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))

		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentThis"
	};

//======================================================================================================================
//												Array Assignment Rules
//======================================================================================================================

	assignment_read_length {
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program ArrayLength #length;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {#v0 := length(#v)}
		//To Be Fixed. We need the LocSet here.
		/*{\event(read,singleton(length(#v)),timestamp)}
		{timestamp:=timestamp + 1}
		{\event(write,singleton(#v0),timestamp)}
		{timestamp:=timestamp + 1}*/
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v=null))
		;
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

	assignment_array_read_EventUpdate{
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
		\varcond(\hasElementarySort(#v0, G))
		"Normal Execution (#v0 != null)":
		\replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}
		{\event(read,singleton(#v0,arr(#se)),timestamp)}
		//{timestamp:=timestamp + 1}
		\modality{#allmodal}{.. ...}\endmodality(post))
		//\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
		;
		"Null Reference (#v0 = null)":
		\replacewith(==> false)
		\add (#v0=null ==>);
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
		\replacewith(==> false)
		\add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)

		\heuristics(simplify_prog, simplify_prog_subset)
	};

	//\rules(programRules:Java, runtimeExceptions:allow, dependencies:off) {
	//assignment_to_primitive_array_component {
	//\schemaVar \modalOperator { diamond, box } #normal;
	//\find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	//\varcond(\not \isReferenceArray(#v))
	//"Normal Execution (#v != null)":
	//\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
	//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
	//(permissions:on) {
	//"Write Permission to #v[#se]":
	//\replacewith(\modality{#normal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality(post))
	//\add(==> writePermission(Permission::select(permissions, #v, arr(#se))))
	//};
	//"Null Reference (#v = null)":
	//\replacewith(\modality{#normal}{..
	//throw new java.lang.NullPointerException();
	//...}\endmodality(post))
	//\add (#v=null ==>);
	//"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
	//\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
	//\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	//\heuristics(simplify_prog, simplify_prog_subset)
	//};
	//}

	assignment_to_primitive_array_component_EventUpdate {
		\schemaVar \program Variable #v;
		\schemaVar \program SimpleExpression #se,#se0;
		\schemaVar \formula post;

		\schemaVar \modalOperator { diamond, box } #normal;
		\find (==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
		\varcond(\not \isReferenceArray(#v))
		"Normal Execution (#v != null)":
		\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)}
		{\event(write,singleton(#v,arr(#se)),timestamp)}
		//{timestamp:=timestamp + 1}
		\modality{#normal}{.. ...}\endmodality(post))
		//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
		;
		(permissions:on) {
		"Write Permission to #v[#se]":
		\replacewith(==> writePermission(Permission::select(permissions, #v, arr(#se))))
		};
		"Null Reference (#v = null)":
		\replacewith(==> false)
		\add (#v=null ==>);
		"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		\replacewith(==> false)
		\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
		\heuristics(simplify_prog, simplify_prog_subset)
	};

//======================================================================================================================
//														Axioms
//======================================================================================================================

	noRaWOnEmptySet{

		\find(noRaW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaROnEmptySet{

		\find(noWaR(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaWOnEmptySet{

		\find(noWaW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWOnEmptySet{

		\find(noW(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	noROnEmptySet{

		\find(noR(empty))
		\replacewith(true)

		\heuristics(concrete)
	};

	rPredOnEmptySet{//New
		\schemaVar \term int id;

		\find(rPred(empty,id))
		\replacewith(false)

		\heuristics(concrete)
	};

	wPredOnEmptySet{//New
		\schemaVar \term int id;

		\find(wPred(empty,id))
		\replacewith(false)

		\heuristics(concrete)
	};

	noRAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noRAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noRaWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noRaWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaRAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWaRAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};

	noWaWAtHistoryOnEmptySet{
		\schemaVar \term int id;

		\find(noWaWAtHistory(empty,id))
		\replacewith(true)

		\heuristics(concrete)
	};
/*
    noRAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noRAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noRaWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noRaWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWaRAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWaRAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };
    noWaWAtHistoryPositiveID{//NEW
        \schemaVar \term int id;
        \schemaVar \term LocSet loc;

        \find(noWaWAtHistory(loc,id))
        \add(id>=0==>)

        \heuristics(concrete)
    };*/
//======================================================================================================================
//	Update, Event Update, Inverse Event Update, Anon Update, and Inverse Anon Update  apply on each other
//======================================================================================================================
//-----------------------------------Apply UPDATE on
	applyUpdateOnEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term int ts;

	 	\find({u}(\event(rw, loc, ts)))

	 	\replacewith(\event({u}rw, {u}loc, {u}ts))

	 	\heuristics(update_apply_on_update)
	};

	applyUpdateOnInverseEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term int ts;

	 	\find({u}(\invEvUp(rw, loc, ts)))

	 	\replacewith(\invEvUp({u}rw, {u}loc, {u}ts))

	 	\heuristics(update_apply_on_update)
	};


    applyUpdateOnAnonEv {
        \schemaVar \update u;
        \schemaVar \term int counter;

        \find({u}\anonEvUp(counter))

        \replacewith(\anonEvUp({u}counter))

        \heuristics(update_apply_on_update)
    };

    applyUpdateOnInverseAnonEvent {
        \schemaVar \update u;
        \schemaVar \term int counter;

        \find({u}\invAnonEvUp(counter))

        \replacewith(\invAnonEvUp({u}counter))

        \heuristics(update_apply_on_update)
    };
//-----------------------------------Apply EVENT on
/*	applyEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term EventMarker rw;
        \schemaVar \term LocSet loc;
        \schemaVar \term int ts;

        \find({\event(rw, loc, ts)}(pv := t))

        \replacewith((pv := {\event(rw, loc, ts)}t))

        \heuristics(update_apply_on_update)
    };

    applyUpdateParallelToEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}(pv := t))

		\replacewith((pv := {u || \event(rw, loc, ts)}t))

		\heuristics(update_apply_on_update)//userTaclets1)
	};

	applyEventOnEvent {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term EventMarker rw1,rw2;
        \schemaVar \term int ts1,ts2;

        \find({\event(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))

        \replacewith(\event({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))

        \heuristics(update_apply_on_update)
    };

    applyEventOnInverseEvent {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term EventMarker rw1,rw2;
        \schemaVar \term int ts1,ts2;

        \find({\event(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))

        \replacewith(\invEvUp({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))

        \heuristics(update_apply_on_update)
    };

    applyEventOnInverseAnonEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\event(rw, loc, ts)}(\invAnonEvUp(counter)))

        \replacewith(\invAnonEvUp({\event(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

    applyEventOnAnonEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\event(rw, loc, ts)}(\anonEvUp(counter)))

        \replacewith(\anonEvUp({\event(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply INVERSE EVENT on
	applyInverseEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}(pv := t))

		\replacewith((pv := {\invEvUp(rw, loc, label)}t))

		\heuristics(update_apply_on_update)
	};

	applyUpdateParallelToInvEvUpOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \update u, invEvent;

		\find({u || invEvent}(pv := t))
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith((pv := {u || invEvent}t))

		\heuristics(update_apply_on_update)//userTaclets1)
	};

    applyInvEvUpParallelToUpdateOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \update u, invEvent;

        \find({invEvent || u}(pv := t))
        \varcond(\onlyInverseEventUpdates(invEvent))

        \replacewith((pv := {invEvent || u}t))

        \heuristics(update_apply_on_update)//userTaclets1)
    };

	applyInverseEventOnEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;

	 	\find({\invEvUp(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))

	 	\replacewith(\event({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))

	 	\heuristics(update_apply_on_update)
	};

	applyInverseEventOnInverseEvent {
	 	\schemaVar \term LocSet loc1,loc2;
	 	\schemaVar \term EventMarker rw1,rw2;
	 	\schemaVar \term int ts1,ts2;

	 	\find({\invEvUp(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))

	 	\replacewith(\invEvUp({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))

	 	\heuristics(update_apply_on_update)
	};

    applyInverseEventOnAnonEv {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\invEvUp(rw, loc, ts)}(\anonEvUp(counter)))

        \replacewith(\anonEvUp({\invEvUp(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

    applyInverseEventOnInvAnonEv {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\invEvUp(rw, loc, ts)}(\invAnonEvUp(counter)))

        \replacewith(\invAnonEvUp({\invEvUp(rw, loc, ts)}counter))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply ANON EVENT on

    applyAnonEventOnEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\anonEvUp(counter)}(\event(rw, loc, ts)))

        \replacewith(\event({\anonEvUp(counter)}rw, {\anonEvUp(counter)}loc, {\anonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };

    applyAnonEvOnInverseEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts, counter;

        \find({\anonEvUp(counter)}(\invEvUp(rw, loc, ts)))

        \replacewith(\invEvUp({\anonEvUp(counter)}rw, {\anonEvUp(counter)}loc, {\anonEvUp(counter)}ts ))

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnAnonEvent {
        \schemaVar \term int counter1, counter2;

        \find({\anonEvUp(counter1)}(\anonEvUp(counter2)))

        \replacewith(\anonEvUp({\anonEvUp(counter1)}counter2 ))

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnInvAnonEvent {//Replaced by two rules below to avoid to many branches
        \schemaVar \term int counter1, counter2;

        \find({\anonEvUp(counter1)}(\invAnonEvUp(counter2)))

        \replacewith(skip)
        \add(==>counter1=counter2);

        \replacewith(\invAnonEvUp({\anonEvUp(counter1)}counter2 + counter1))
        \add(==>counter1!=counter2)

        \heuristics(update_apply_on_update)
    };


    applyUpdateParallelToAnonEventOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({u||\anonEvUp(counter)}(pv := t))

        \replacewith(pv := {u||\anonEvUp(counter)}t)

        \heuristics(update_apply_on_update)
    };

    applyAnonEventParallelToUpdateOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({\anonEvUp(counter)||u}(pv := t))

        \replacewith(pv := {\anonEvUp(counter)||u}t)

        \heuristics(update_apply_on_update)
    };

    applyAnonEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}(pv := t))

        \replacewith((pv := {\anonEvUp(counter)}t))

        \heuristics(update_apply_on_update)
    };

	//-----------------------------------Apply INVERSE ANON EVENT on

    applyInverseAnonEventOnElementary {
        \schemaVar \program Variable pv;
        \schemaVar \term any t;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}(pv := t))

        \replacewith((pv := {\invAnonEvUp(counter)}t))

        \heuristics(update_apply_on_update)
    };

	applyInverseAnonEventOnEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\invAnonEvUp(counter)}(\event(rw, loc, ts)))

        \replacewith(\event({\invAnonEvUp(counter)}rw, {\invAnonEvUp(counter)}loc, {\invAnonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };

	applyInverseAnonEventOnInverseEvent {
        \schemaVar \term LocSet loc;
        \schemaVar \term EventMarker rw;
        \schemaVar \term int ts,counter;

        \find({\invAnonEvUp(counter)}(\invEvUp(rw, loc, ts)))

        \replacewith(\invEvUp({\invAnonEvUp(counter)}rw, {\invAnonEvUp(counter)}loc, {\invAnonEvUp(counter)}ts))

        \heuristics(update_apply_on_update)
    };


    applyInvAnonEventOnAnonEventSameCounter {
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}(\anonEvUp(counter)))

        \replacewith(skip)

        \heuristics(update_apply_on_update)
    };



    applyInverseAnonEventOnAnonEvent {
        \schemaVar \term int counter1, counter2;

        \find({\invAnonEvUp(counter1)}(\anonEvUp(counter2)))

        \replacewith(\invAnonEvUp({\anonEvUp(counter1)}counter2))

        \heuristics(update_apply_on_update)
    };

    applyUpdateParallelToInverseAnonEventOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({u||\invAnonEvUp(counter)}(pv := t))

        \replacewith(pv := {u||\invAnonEvUp(counter)}t)

        \heuristics(update_apply_on_update)
    };

    applyInverseAnonEventParallelToUpdateOnElementary{
        \schemaVar \update u;
        \schemaVar \term int counter;
        \schemaVar \program Variable pv;
        \schemaVar \term any t;

        \find({\invAnonEvUp(counter)||u}(pv := t))

        \replacewith(pv := {\invAnonEvUp(counter)||u}t)

        \heuristics(update_apply_on_update)
    };
*/
//======================================================================================================================
//					Event, Inverse Event, Anon Event, and Inverse Anon Event Update Elimination Rules
//======================================================================================================================
	//---------------------------------------------------> Events:

	/*elimUpdateOnRigidTerm1 {
	    \schemaVar \term[rigid] any t;
		\schemaVar \update u;

		\find({u}t)

		\replacewith(t)

		\heuristics(update_elim)
	};

	elimEventOnRigidTerm2 {
		\schemaVar \term any t, result;
		\schemaVar \update u;

		\find({u}t)
		\varcond(\applyEventUpdateOnRigid(u, t, result))

		\replacewith(result)

		\heuristics(update_elim)
	};

	elimEventOnRigidFormula1 {
	    \schemaVar \formula[rigid] phi;
		\schemaVar \update u;

		\find({u}phi)

		\replacewith(phi)

		\heuristics(update_elim)
	};

	elimEventOnRigidFormula2 {
		\schemaVar \formula phi, result;
		\schemaVar \update u;

		\find({u}phi)
		\varcond(\applyEventUpdateOnRigid(u, phi, result))

		\replacewith(result)

		\heuristics(update_elim)
	};*/


	elimEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({\event(rw, loc, ts)}pv)

		\replacewith(pv)

		\heuristics(update_elim)
	};

	elimEventOnSkip {
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({\event(rw, loc, ts)}skip)

		\replacewith(skip)

		\heuristics(update_elim)
	};

	applyUpdateParallelToEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}pv)

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	};

	applyUpdateParallelToEventOnSkip {
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(rw, loc, ts)}skip)

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	};
	//---------------------------------------------------> Inverse Events:
	/*elimInverseEventOnRigidTerm1 {
		\schemaVar \term[rigid] any t;
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)} t)

		\replacewith(t)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidTerm2 {
		\schemaVar \term any t, result;
		\schemaVar \update u;

		\find({u}t)
		\varcond(\applyInverseEventUpdateOnRigid(u, t, result))

		\replacewith(result)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidFormula1 {
		\schemaVar \formula[rigid] phi;
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}phi)

		\replacewith(phi)

		\heuristics(update_elim)
	};

	elimInverseEventOnRigidFormula2 {
		\schemaVar \formula phi, result;
		\schemaVar \update u;

		\find({u}phi)
		\varcond(\applyInverseEventUpdateOnRigid(u, phi, result))

		\replacewith(result)

		\heuristics(update_elim)
	};*/

	elimInverseEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}pv)

		\replacewith(pv)

		\heuristics(update_elim)
	};

	elimInverseEventOnSkip {
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label)}skip)

		\replacewith(skip)

		\heuristics(update_elim)
	};

	applyUpdateParallelToInvEvUpOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \update u, invEvent;

		\find({u || invEvent}pv)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	};

	 applyInvEvUpParallelToUpdateOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \update u, invEvent;

		\find({invEvent || u}pv)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith({u}pv)

		\heuristics(update_apply)//userTaclets1)
	 };

	 applyUpdateParallelToInvEvUpOnSkip {
		\schemaVar \update u, invEvent;

		\find({u || invEvent}skip)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	 };

	applyInvEvUpParallelToUpdateOnSkip {
		\schemaVar \update u, invEvent;

		\find({invEvent || u}skip)
		\varcond(\onlyInverseEventUpdates(invEvent))

		\replacewith(skip)

		\heuristics(update_elim)//userTaclets1)
	};

//---------------------------------------------------> AnonEvents:

 /*   elimAnonEventOnRigidTerm1 {
        \schemaVar \term[rigid] any t;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} t)

        \replacewith(t)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidTerm2 {
        \schemaVar \term any t, result;
        \schemaVar \update anonEv;

        \find({anonEv}t)
        \varcond(\applyAnonEventUpdateOnRigid(anonEv, t, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidFormula1 {
        \schemaVar \formula[rigid] phi;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}phi)

        \replacewith(phi)

        \heuristics(update_elim)
    };

    elimAnonEventOnRigidFormula2 {
        \schemaVar \formula phi, result;
        \schemaVar \update anonEv;

        \find({anonEv}phi)
        \varcond(\applyAnonEventUpdateOnRigid(anonEv, phi, result))

        \replacewith(result)

        \heuristics(update_elim)
    };*/

    elimAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}pv)

        \replacewith(pv)

        \heuristics(update_elim)
    };

    elimAnonEventOnSkip {
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };

    applyUpdateParallelToAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)}pv)

        \replacewith({u}pv)

        \heuristics(update_apply)
    };

    applyUpdateParallelToAnonEventOnSkip {
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };
//---------------------------------------------------> InverseAnonEvents:

   /*elimInverseAnonEventOnRigidTerm1 {
       \schemaVar \term[rigid] any t;
       \schemaVar \term int counter;

       \find({\invAnonEvUp(counter)} t)

       \replacewith(t)

       \heuristics(update_elim)
   };

    elimInvAnonEventOnRigidTerm2 {
        \schemaVar \term any t, result;
        \schemaVar \update invAnonEv;

        \find({invAnonEv}t)
        \varcond(\applyInverseAnonEventUpdateOnRigid(invAnonEv, t, result))

        \replacewith(result)

        \heuristics(update_elim)
    };

    elimInverseAnonEventOnRigidFormula1 {
        \schemaVar \formula[rigid] phi;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}phi)

        \replacewith(phi)

        \heuristics(update_elim)
     };
  elimInvAnonEventOnRigidFormula2 {
        \schemaVar \formula phi, result;
        \schemaVar \update invAnonEv;

        \find({invAnonEv}phi)
        \varcond(\applyInverseAnonEventUpdateOnRigid(invAnonEv, phi, result))

        \replacewith(result)

        \heuristics(update_elim)
    };*/

    elimUpdateOnRigidTerm {

        \schemaVar \update u;
        \schemaVar \term[rigid] any t;

        \find({u}t)
        \replacewith(t)
        \heuristics(update_elim)

    };

    elimUpdateOnRigidFormula {

            \schemaVar \update u;
            \schemaVar \formula[rigid] phi;

            \find({u}phi)
            \replacewith(phi)
            \heuristics(update_elim)

        };

    elimInvAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}pv)

        \replacewith(pv)

        \heuristics(update_elim)
    };

    elimInvAnonEventOnSkip {
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)
    };

    applyUpdateParallelToInvAnonEventOnPV {
        \schemaVar \program Variable pv;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)}pv)

        \replacewith({u}pv)

        \heuristics(update_apply)
    };

    applyUpdateParallelToInvAnonEventOnSkip {
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)}skip)

        \replacewith(skip)

        \heuristics(update_elim)//userTaclets1)
    };
//======================================================================================================================
//													Splitting Rules
//======================================================================================================================
	//---------------------------------------------------> Dependence Predicates:
	splitNoRaW {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noRaW(union(loc1,loc2)))
	    \replacewith(noRaW(loc1) & noRaW(loc2))

	    \heuristics(simplify)
	};

	splitNoWaR {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noWaR(union(loc1,loc2)))
	    \replacewith(noWaR(loc1) & noWaR(loc2))

	    \heuristics(simplify)
	};

	splitNoWaW {
	    \schemaVar \term LocSet loc1, loc2;

	    \find(noWaW(union(loc1,loc2)))
	    \replacewith(noWaW(loc1) & noWaW(loc2))

	    \heuristics(simplify)
	};

	splitNoR {
		\schemaVar \term LocSet loc1, loc2;

	    \find(noR(union(loc1,loc2)))
	    \replacewith(noR(loc1) & noR(loc2))

	    \heuristics(simplify)
	};

	splitNoW {
		\schemaVar \term LocSet loc1, loc2;

		\find(noW(union(loc1,loc2)))
		\replacewith(noW(loc1) & noW(loc2))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> Dependence Predicates with EQ:
	splitNoRaWEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRaW(EQ)) \sameUpdateLevel
	    \replacewith(noRaW(loc1) & noRaW(loc2))

	    \heuristics(simplify)
	};

	splitNoWaREQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaR(EQ)) \sameUpdateLevel
	    \replacewith(noWaR(loc1) & noWaR(loc2))

	    \heuristics(simplify)
	};

	splitNoWaWEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaW(EQ)) \sameUpdateLevel
	    \replacewith(noWaW(loc1) & noWaW(loc2))

	    \heuristics(simplify)
	};

	splitNoREQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noR(EQ)) \sameUpdateLevel
	    \replacewith(noR(loc1) & noR(loc2))

	    \heuristics(simplify)
	};

	splitNoWEQ {
		\schemaVar \term LocSet EQ, loc1, loc2;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noW(EQ)) \sameUpdateLevel
	    \replacewith(noW(loc1) & noW(loc2))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> History Predicates:
	splitNoRaWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noRaWAtHistory(union(loc1,loc2), label))
	    \replacewith(noRaWAtHistory(loc1, label) & noRaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaRAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWaRAtHistory(union(loc1,loc2), label))
	    \replacewith(noWaRAtHistory(loc1, label) & noWaRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWaWAtHistory(union(loc1,loc2), label))
	    \replacewith(noWaWAtHistory(loc1, label) & noWaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoRAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noRAtHistory(union(loc1,loc2), label))
	    \replacewith(noRAtHistory(loc1, label) & noRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWAtHistory {
	    \schemaVar \term LocSet loc1, loc2;
	    \schemaVar \term int label;

	    \find(noWAtHistory(union(loc1,loc2), label))
	    \replacewith(noWAtHistory(loc1, label) & noWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	//---------------------------------------------------> History Predicates with EQ:
	splitNoRaWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRaWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noRaWAtHistory(loc1, label) & noRaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaRAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaRAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWaRAtHistory(loc1, label) & noWaRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWaWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWaWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWaWAtHistory(loc1, label) & noWaWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoRAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noRAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noRAtHistory(loc1, label) & noRAtHistory(loc2, label))

	    \heuristics(simplify)
	};

	splitNoWAtHistoryEQ {
	    \schemaVar \term LocSet EQ, loc1, loc2;
	    \schemaVar \term int label;

	    \assumes (union(loc1,loc2) = EQ ==>)
	    \find(noWAtHistory(EQ, label)) \sameUpdateLevel
	    \replacewith(noWAtHistory(loc1, label) & noWAtHistory(loc2, label))

	    \heuristics(simplify)
	};

//======================================================================================================================
//												Data Dependence Known
//======================================================================================================================
	//---------------------------------------------------> Data Dependence Predicates:
	// To Prove
	noRKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noR(loc1) ==> )
		\find(==> noR(loc2))
		\replacewith(==> noR(setMinus(loc2,loc1)), subset(loc2,loc1))
		\heuristics(dep_pred_known,noEqApp)
	};

	//--------------------------------------------
	// These rules (and similar ones for other predicates) were causing Loops:

	// noRKnownForSupersetOrSubsetDef{
	//	\schemaVar \term LocSet loc1, loc2;
	//
	//	\assumes(noR(loc1) ==> )
	//	\find(==> noR(loc2))
	//
	//	\replacewith(==>noR(setMinus(loc2,loc1)))
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations_def)
	//	};
	// noRKnownForSupersetOrSubset2{
	//	\schemaVar \term LocSet loc1, loc2;
	//
	//	\assumes(noR(loc1) ==> )
	//	\find(==> noR(loc2))
	//
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations)
	//	};
	//----------------------------------------------

	noWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noW(loc1) ==> )
		\find(==> noW(loc2))
		\replacewith(==> subset(loc2,loc1), noW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};

	noRaWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noRaW(loc1) ==> )
		\find(==> noRaW(loc2))

		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)//_3)
	};

	noWaRKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noWaR(loc1) ==> )
		\find(==> noWaR(loc2))

		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)//_3
	};

	noWaWKnownForSupersetOrSubset{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noWaW(loc1) ==> )
		\find(==> noWaW(loc2))

		\replacewith(==> subset(loc2,loc1), noWaW(setMinus(loc2,loc1)))
		\heuristics(dep_pred_known,noEqApp)
	};

	// To Prove
	noRKnownForSupersetOrSubsetOfNoRaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noR(loc1) ==> )
		\find(==>noRaW(loc2))

		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(saturate_dep_locset_relations_def)
	};

	//Old Version:

	//noReadKnownForSupersetOrSubsetOfNoRaW2{
	//	\schemaVar \term LocSet loc1, loc2;
	//
	//	\assumes(noR(loc1) ==> )
	//	\find(==>noRaW(loc2))
	//
	//	\add(==> subset(loc2,loc1))
	//	\heuristics(saturate_dep_locset_relations)
	//};

	noWKnownForSupersetOrSubsetOfNoRaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noW(loc1) ==> )
		\find(==>noRaW(loc2))

		\replacewith(==> subset(loc2,loc1), noRaW(setMinus(loc2,loc1)))
		\heuristics(saturate_dep_locset_relations_def)
	};

	noWKnownForSupersetOrSubsetOfNoWaR{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noW(loc1) ==> )
		\find(==>noWaR(loc2))

		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)))
		\heuristics(saturate_dep_locset_relations_def)
	};

	noRKnownForSupersetOrSubsetOfNoWaR{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noR(loc1) ==> )
		\find(==>noWaR(loc2))

		\replacewith(==> subset(loc2,loc1), noWaR(setMinus(loc2,loc1)) )
		\heuristics(saturate_dep_locset_relations_def)
	};

	noWKnownForSupersetOrSubsetOfNoWaW{// add -> replace
		\schemaVar \term LocSet loc1, loc2;

		\assumes(noW(loc1) ==> )
		\find(==>noWaW(loc2))

		\replacewith(==> subset(loc2,loc1), noWaW(setMinus(loc2,loc1)))
		\heuristics(saturate_dep_locset_relations_def)
	};

	//---------------------------------------------------> History Data Dependence Predicates:
	noRAtHistoryOnBothSides{
		\schemaVar \term int id1, id2;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \update u;

		\assumes(noRAtHistory(loc1,id1)==>)
		\find(==>noRAtHistory(loc2,id2))
		\varcond(\different(id1,id2))
		\replacewith(==>\if(id1 <= id2 ) \then(noRAtHistory(setMinus(loc2,loc1),id2)) \else(noRAtHistory(loc2,id2)))

		\heuristics(dep_pred_known,noEqApp)
	};

	// To Prove
	noRAndNoRAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noR(loc1)==>)
		 \find(==>noRAtHistory(loc2,id2))
		 \replacewith(==>noRAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};

	noWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWAtHistory(loc1,id1)==>)
		 \find(==> noWAtHistory(loc2,id2))
		 \varcond(\different(id1,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWAtHistory(setMinus(loc2,loc1),id2)) \else(noWAtHistory(loc2,id2)))

		 \heuristics(dep_pred_known,noEqApp)
	};

	noWAndNoWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noW(loc1)==>)
		 \find(==>noWAtHistory(loc2,id2))
		 \replacewith(==>noWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};

	noRaWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noRaWAtHistory(loc1,id1)==>)
		 \find(==>noRaWAtHistory(loc2,id2))
		 \varcond(\different(id1,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noRaWAtHistory(setMinus(loc2,loc1),id2)) \else(noRaWAtHistory(loc2,id2)))

		 \heuristics(dep_pred_known,noEqApp)
	};

	noRaWAndNoRaWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noRaW(loc1)==>)
		 \find(==>noRaWAtHistory(loc2,id2))
		 \replacewith(==>noRaWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};

	noWaRAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWaRAtHistory(loc1,id1)==>)
		 \find(==>noWaRAtHistory(loc2,id2))
		 \varcond(\different(id1,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWaRAtHistory(setMinus(loc2,loc1),id2)) \else(noWaRAtHistory(loc2,id2)))

		 \heuristics(dep_pred_known,noEqApp)
	};

	noWaRAndNoWaRAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWaR(loc1)==>)
		 \find(==>noWaRAtHistory(loc2,id2))
		 \replacewith(==>noWaRAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};

	noWaWAtHistoryOnBothSides{
		 \schemaVar \term int id1, id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWaWAtHistory(loc1,id1)==>)
		 \find(==>noWaWAtHistory(loc2,id2))
		 \varcond(\different(id1,id2))
		 \replacewith(==>\if(id1 <= id2 ) \then(noWaWAtHistory(setMinus(loc2,loc1),id2)) \else(noWaWAtHistory(loc2,id2)))


		 \heuristics(dep_pred_known,noEqApp)
	};

	noWaWAndNoWaWAtHistory{
		 \schemaVar \term int id2;
		 \schemaVar \term LocSet loc1, loc2;

		 \assumes(noWaW(loc1)==>)
		 \find(==>noWaWAtHistory(loc2,id2))
		 \replacewith(==>noWaWAtHistory(setMinus(loc2,loc1),id2))
		 \add(!intersect(loc1,loc2)=empty==>);

		 \add(intersect(loc1,loc2)=empty==>)

		 \heuristics(dep_pred_known)
	};


//======================================================================================================================
//							Update and Event Update Application on Data Dependence Predicates
//======================================================================================================================
	//---------------------------------------------------> Eliminate State Updates:
	elimStateUpdatesBeforeNoRaW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noRaW(tr))
		\replacewith({u}noRaW(tr))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaR{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noWaR(tr))
		\replacewith({u}noWaR(tr))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noWaW(tr))
		\replacewith({u}noWaW(tr))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoR{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noR(tr))
		\replacewith({u}noR(tr))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoW{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;

		\find({pv:=t || u} noW(tr))
		\replacewith({u}noW(tr))
		\heuristics(update_elim)
	};

	//---------------------------------------------------> {event} Data Dependence Predicates:
	// To Prove
	writeEventBeforeNoRaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(write, loc1, ts)} noRaW(loc2))

		\replacewith(noRaW({\event(write, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	// To Prove
	readEventBeforeNoRaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find({\event(read, loc1, ts)} noRaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

		\replacewith(noRaW(tempVar))
		\add(tempVar = {\event(read, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );

		\replacewith(noW(intersect(loc1, tempVar)) & noRaW(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(read, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoWaR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find({\event(write, loc1, ts)} noWaR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

		\replacewith(noWaR(tempVar))
		\add(tempVar = {\event(write, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );

		\replacewith(noR(intersect(loc1, tempVar)) & noWaR(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(write, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoWaR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(read, loc1, ts)} noWaR(loc2))

		\replacewith( noWaR({\event(read, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoWaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find({\event(write, loc1, ts)} noWaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

		\replacewith(noWaW(tempVar))
		\add(tempVar = {\event(write, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );

		\replacewith(noW(intersect(loc1, tempVar)) & noWaW(setMinus(tempVar,loc1)))
		\add(tempVar = {\event(write, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoWaW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(read, loc1, ts)} noWaW(loc2))

		\replacewith( noWaW({\event(read, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	writeEventBeforeNoW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find(==> {\event(write, loc1, ts)} noW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

	    \replacewith(==> noW(tempVar))
	    \add(tempVar = {\event(write, loc1, ts)}loc2,
	    	intersect(loc1, tempVar) = empty ==> );

	    \replacewith(==> false)
	    \add(tempVar = {\event(write, loc1, ts)}loc2,
	    	!(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	readEventBeforeNoW {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(read, loc1, ts)} noW(loc2))

		\replacewith( noW({\event(read, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	// To Prove
	writeEventBeforeNoR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;

		\find({\event(write, loc1, ts)} noR(loc2))

		\replacewith(noR({\event(write, loc1, ts)}loc2))

		\heuristics(update_apply)//userTaclets1)
	};

	// To Prove
	readEventBeforeNoR {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

		\find(==> {\event(read, loc1, ts)} noR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(loc2)))

	    \replacewith(==> noR(tempVar))
	    \add(tempVar = {\event(read, loc1, ts)}loc2,
	    	intersect(loc1, tempVar) = empty ==> );

	    \replacewith(==> false)
	    \add(tempVar = {\event(read, loc1, ts)}loc2,
	    	!(intersect(loc1, tempVar) = empty) ==> )

		\heuristics(update_apply)//userTaclets1)
	};

	//---------------------------------------------------> {u || event} Data Dependence Predicates:
	updateParallelToReadEventOnNoRaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noRaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noRaW(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2,
	          intersect(loc1, tempVar) = empty ==> );

	    \replacewith(==> ({u}noW(intersect(tempVar, loc1))) & {u}noRaW(setMinus(tempVar, loc1)))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2,
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToWriteEventOnNoRaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noRaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noRaW(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> ) //REMEMBER TODO check for others to take u and apply it on tempvar

	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToWriteEventOnNoWaR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noWaR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noWaR(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	     	intersect(tempVar, loc1) = empty ==> );

	     \replacewith(==> ({u}noR(intersect(tempVar, loc1))) & {u}noWaR(setMinus(tempVar, loc1)))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	     	!(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};
	updateParallelToReadEventOnNoWaR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noWaR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noWaR(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==>)
	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToWriteEventOnNoWaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noWaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noWaW(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	     	intersect(tempVar, loc1) = empty ==> );

	     \replacewith(==> {u}noW(intersect(tempVar, loc1)) & {u}noWaW(setMinus(tempVar, loc1)))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	     	!(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};

	updateParallelToReadEventOnNoWaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noWaW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noWaW(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==> )
	     \heuristics(update_apply)//userTaclets1)
	 };

	updateParallelToReadEventOnNoR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))
	     \replacewith(==> {u}noR(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2,
	          intersect(loc1, tempVar) = empty ==> );

	     \replacewith(==> false)
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2,
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
	};

 	updateParallelToWriteEventOnNoR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noR(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noR(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> )

	     \heuristics(update_apply)//userTaclets1)
 	};

 	updateParallelToWriteEventOnNoW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(write, loc1, ts)} noW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))
	     \replacewith(==> {u}noW(tempVar))
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	          intersect(loc1, tempVar) = empty ==> );

	     \replacewith(==> false)
	     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
	          !(intersect(tempVar, loc1) = empty) ==> )
	     \heuristics(update_apply)//userTaclets1)
 	};

 	updateParallelToReadEventOnNoW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int ts;
		\schemaVar \skolemTerm LocSet tempVar;

	 	\find(==> {u || \event(read, loc1, ts)} noW(loc2))
	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
	             \new(tempVar, \dependingOn(loc1)),
	             \new(tempVar, \dependingOn(ts)),
	             \new(tempVar, \dependingOn(loc2)))

	     \replacewith(==> {u}noW(tempVar))
	     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==> )

	     \heuristics(update_apply)//userTaclets1)
 	};

 	//---------------------------------------------------> {u} Data Dependence Predicates:
 	/*simplifyNONEventUpdateNoR {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noR(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noR(loc))

 		\heuristics(update_apply)
 	};

 	simplifyNONEventUpdateNoW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noW(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noW(loc))

 		\heuristics(update_apply)
 	};

 	simplifyNONEventUpdateNoRaW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noRaW(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noRaW(loc))

 		\heuristics(update_apply)
	};

 	simplifyNONEventUpdateNoWaR {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noWaR(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noWaR(loc))

 		\heuristics(update_apply)
 	};

 	simplifyNONEventUpdateNoWaW {
 		\schemaVar \update u1,u2;
 		\schemaVar \term[rigid] LocSet loc;

 		\find({u1||u2}noWaW(loc))

 		\varcond(\noEventUpdate(u1))

 		\replacewith({u2}noWaW(loc))

 		\heuristics(update_apply)
 	};*/

//======================================================================================================================
//										Non-Event and Non-InverseEvent Update Propagation Rules
//======================================================================================================================

	propagateNonEventUpdateONnoRaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noRaW(loc))
		\varcond(\onlyElementary(u))

		\replacewith(noRaW({u}loc))

		\heuristics(update_apply)
	};

	propagateNonEventUpdateONnoWaR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noWaR(loc))

		\varcond(\onlyElementary(u))

		\replacewith(noWaR({u}loc))

		\heuristics(update_apply)
	};

	propagateNonEventUpdateONnoWaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noWaW(loc))

		\varcond(\onlyElementary(u))

		\replacewith(noWaW({u}loc))

		\heuristics(update_apply)
	};

	propagateNonEventUpdateONnoR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noR(loc))

		\varcond(\onlyElementary(u))

		\replacewith(noR({u}loc))

		\heuristics(update_apply)
	};

	propagateNonEventUpdateONnoW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc;

		\find({u}noW(loc))

		\varcond(\onlyElementary(u))

		\replacewith(noW({u}loc))

		\heuristics(update_apply)
	};

//======================================================================================================================
//							Event, Inverse Event, AnonEvent, and Inverse AnonEvent Shifting Rules
//======================================================================================================================
//-----------------------------------------------------------Events
	shiftEventParallelToUpdate {
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	\schemaVar \update u;

	 	\find(\event(rw, loc, ts) || u)

	 	\varcond(\onlyElementary(u))

	 	\replacewith(u || \event(rw, loc, ts))

	 	\heuristics(update_apply)
	};

	shiftEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(\event(rw, loc, ts) || pv:=t)

	 	\replacewith(pv:=t || \event(rw, loc, ts))

	 	\heuristics(update_apply)
	};

	shiftOnlyEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update evUp;

	 	\find(evUp || pv:=t)
	 	\varcond(\onlyEventUpdates(evUp))

	 	\replacewith(pv:=t || evUp)

	 	\heuristics(update_apply)
	};

	shiftEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(u || \event(rw, loc, ts) || pv:=t)

	 	\replacewith(u || pv:=t || \event(rw, loc, ts))

	 	\heuristics(update_apply)
	 };

	shiftEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find(\event(rw, loc, ts) || pv:=t || u)

		\replacewith(pv:=t || \event(rw, loc, ts) || u)

		\heuristics(update_apply)
	};

	shiftOnlyEventWithUpdateAtFirstPlace {
	 	\schemaVar \update evUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(u || evUp || pv:=t)
	 	\varcond(\onlyEventUpdates(evUp))

	 	\replacewith(u || pv:=t || evUp)

	 	\heuristics(update_apply)
	};

	shiftOnlyEventWithUpdateAtLastPlace {
	 	\schemaVar \update evUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find( pv:=t || evUp || u)
	 	\varcond(\onlyEventUpdates(evUp),\onlyElementary(u))
	 	\replacewith(pv:=t || u || evUp)

	 	\heuristics(update_apply)
	};
//-----------------------------------------------------------Inverse Events
    shiftInvEventParallelToUpdate {
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;
	 	\schemaVar \update u;

	 	\find(\invEvUp(rw, loc, ts) || u)

	 	\varcond(\onlyElementary(u))

	 	\replacewith(u || \invEvUp(rw, loc, ts))

	 	\heuristics(update_apply)
	};

	shiftInvEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(\invEvUp(rw, loc, ts) || pv:=t)

	 	\replacewith(pv:=t || \invEvUp(rw, loc, ts))

	 	\heuristics(update_apply)
	};

	shiftOnlyInvEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update invEvUp;

	 	\find(invEvUp || pv:=t)
	 	\varcond(\onlyInverseEventUpdates(invEvUp))

	 	\replacewith(pv:=t || invEvUp)

	 	\heuristics(update_apply)
	};

	shiftInvEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(u || \invEvUp(rw, loc, ts) || pv:=t)

	 	\replacewith(u || pv:=t || \invEvUp(rw, loc, ts))

	 	\heuristics(update_apply)
	 };

	shiftInvEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term EventMarker rw;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find(\invEvUp(rw, loc, ts) || pv:=t || u)

		\replacewith(pv:=t || \invEvUp(rw, loc, ts) || u)

		\heuristics(update_apply)
	};

	shiftOnlyInvEventWithUpdateAtFirstPlace {
	 	\schemaVar \update invEvUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find(u || invEvUp || pv:=t)
	 	\varcond(\onlyInverseEventUpdates(invEvUp))

	 	\replacewith(u || pv:=t || invEvUp)

	 	\heuristics(update_apply)
	};

	shiftOnlyInvEventWithUpdateAtLastPlace {
	 	\schemaVar \update invEvUp;
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term EventMarker rw;
	 	\schemaVar \term LocSet loc;
	 	\schemaVar \term int ts;

	 	\find( pv:=t || invEvUp || u)
	 	\varcond(\onlyInverseEventUpdates(invEvUp),\onlyElementary(u))

	 	\replacewith(pv:=t || u || invEvUp)

	 	\heuristics(update_apply)
	};

//-----------------------------------------------------------Anon Events
	shiftAnonEventParallelToUpdate {
	 	\schemaVar \term int counter;
	 	\schemaVar \update u;

	 	\find(\anonEvUp(counter) || u)
        \varcond(\onlyElementary(u))

	 	\replacewith(u || \anonEvUp(counter))

	 	\heuristics(update_apply)
	};

	shiftAnonEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term int counter;

	 	\find(\anonEvUp(counter) || pv:=t)

	 	\replacewith(pv:=t || \anonEvUp(counter))

	 	\heuristics(update_apply)
	};

	shiftOnlyAnonEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update anonEvUp;

	 	\find(anonEvUp || pv:=t)
	 	\varcond(\onlyAnonEventUpdates(anonEvUp))

	 	\replacewith(pv:=t || anonEvUp)

	 	\heuristics(update_apply)
	};

	shiftAnonEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term int counter;

	 	\find(u || \anonEvUp(counter) || pv:=t)

	 	\replacewith(u || pv:=t || \anonEvUp(counter))

	 	\heuristics(update_apply)
	 };

	shiftAnonEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term int counter;

		\find(\anonEvUp(counter) || pv:=t || u)

		\replacewith(pv:=t || \anonEvUp(counter) || u)

		\heuristics(update_apply)
	};

	shiftOnlyAnonEventWithUpdateAtFirstPlace {
	 	\schemaVar \update anonEvUp, u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;

	 	\find(u || anonEvUp || pv:=t)
	 	\varcond(\onlyAnonEventUpdates(anonEvUp))

	 	\replacewith(u || pv:=t || anonEvUp)

	 	\heuristics(update_apply)
	};

	shiftOnlyAnonEventWithUpdateAtLastPlace {
	 	\schemaVar \update anonEvUp, u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;

	 	\find( pv:=t || anonEvUp || u)
	 	\varcond(\onlyAnonEventUpdates(anonEvUp),\onlyElementary(u))

	 	\replacewith(pv:=t || u || anonEvUp)

	 	\heuristics(update_apply)
	};
//-----------------------------------------------------------Inverse Anon Events
	shiftInverseAnonEventParallelToUpdate {
	 	\schemaVar \term int counter;
	 	\schemaVar \update u;

	 	\find(\invAnonEvUp(counter) || u)

        \varcond(\onlyElementary(u))

	 	\replacewith(u || \invAnonEvUp(counter))

	 	\heuristics(update_apply)
	};

	shiftInverseAnonEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term int counter;

	 	\find(\invAnonEvUp(counter) || pv:=t)

	 	\replacewith(pv:=t || \invAnonEvUp(counter))

	 	\heuristics(update_apply)
	};

	shiftOnlyInverseAnonEventParallelToElementry {
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \update invAnonEvUp;

	 	\find(invAnonEvUp || pv:=t)
	 	\varcond(\onlyInverseAnonEventUpdates(invAnonEvUp))

	 	\replacewith(pv:=t || invAnonEvUp)

	 	\heuristics(update_apply)
	};

	shiftInverseAnonEventWithUpdateAtFirstPlace {
	 	\schemaVar \update u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;
	 	\schemaVar \term int counter;

	 	\find(u || \invAnonEvUp(counter) || pv:=t)

	 	\replacewith(u || pv:=t || \invAnonEvUp(counter))

	 	\heuristics(update_apply)
	 };

	shiftInverseAnonEventWithUpdateAtLastPlace {
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term int counter;

		\find(\invAnonEvUp(counter) || pv:=t || u)

		\replacewith(pv:=t || \invAnonEvUp(counter) || u)

		\heuristics(update_apply)
	};

	shiftOnlyInverseAnonEventWithUpdateAtFirstPlace {
	 	\schemaVar \update invAnonEvUp, u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;

	 	\find(u || invAnonEvUp || pv:=t)
	 	\varcond(\onlyInverseAnonEventUpdates(invAnonEvUp))

	 	\replacewith(u || pv:=t || invAnonEvUp)

	 	\heuristics(update_apply)
	};

	shiftOnlyInverseAnonEventWithUpdateAtLastPlace {
	 	\schemaVar \update invAnonEvUp, u;
	 	\schemaVar \program Variable pv;
	 	\schemaVar \term any t;

	 	\find( pv:=t || invAnonEvUp || u)
	 	\varcond(\onlyInverseAnonEventUpdates(invAnonEvUp),\onlyElementary(u))

	 	\replacewith(pv:=t || u || invAnonEvUp)

	 	\heuristics(update_apply)
	};
//======================================================================================================================
//						Inverse Event, and Inverse Anon Event Update Application on History Predicates
//======================================================================================================================
	//simplifyNONInverseEventUpdateNoRAtHistory:
	simplifyElementaryOnNoRAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;

		\find({u1}noRAtHistory(loc, id))

		\varcond(\onlyElementary(u1))//, \noElementary(u2))

		\replacewith(noRAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};

    simplifyElementaryOnNoWAtHistory {
        \schemaVar \update u1,u2;
        \schemaVar \term LocSet loc;
        \schemaVar \term int id;

        \find({u1}noWAtHistory(loc, id))

        \varcond(\onlyElementary(u1))//, \noElementary(u2))

        \replacewith(noWAtHistory({u1}loc, {u1}id))

        \heuristics(update_apply)
    };

    simplifyElementaryOnNoRaWAtHistory {
        \schemaVar \update u1,u2;
        \schemaVar \term LocSet loc;
        \schemaVar \term int id;

        \find({u1}noRaWAtHistory(loc, id))

        \varcond(\onlyElementary(u1))//, \noElementary(u2))

        \replacewith(noRaWAtHistory({u1}loc, {u1}id))

        \heuristics(update_apply)
    };

    simplifyElementaryOnNoWaRAtHistory {
        \schemaVar \update u1,u2;
        \schemaVar \term LocSet loc;
        \schemaVar \term int id;

        \find({u1}noWaRAtHistory(loc, id))

        \varcond(\onlyElementary(u1))//, \noElementary(u2))

        \replacewith(noWaRAtHistory({u1}loc, {u1}id))

        \heuristics(update_apply)
    };

    simplifyElementaryOnNoWaWAtHistory {
        \schemaVar \update u1,u2;
        \schemaVar \term LocSet loc;
        \schemaVar \term int id;

        \find({u1}noWaWAtHistory(loc, id))

        \varcond(\onlyElementary(u1))//, \noElementary(u2))

        \replacewith(noWaWAtHistory({u1}loc, {u1}id))

        \heuristics(update_apply)
    };



/*	simplifyNONInverseEventUpdateNoWAtHistory {
	   \schemaVar \update u1,u2;
	   \schemaVar \term LocSet loc;
	   \schemaVar \term int id;

		\find({u1||u2}noWAtHistory(loc, id))

		\varcond(\noEventUpdate(u1))

		\replacewith({u2}noWAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};

	simplifyNONInverseEventUpdateNoRaWAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;

		\find({u1||u2}noRaWAtHistory(loc, id))

		\varcond(\noEventUpdate(u1))

		\replacewith({u2}noRaWAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};

	simplifyNONInverseEventUpdateNoWaRAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;

		\find({u1||u2}noWaRAtHistory(loc, id))

		\varcond(\noEventUpdate(u1))

		\replacewith({u2}noWaRAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};

	simplifyNONInverseEventUpdateNoWaWAtHistory {
		\schemaVar \update u1,u2;
		\schemaVar \term LocSet loc;
		\schemaVar \term int id;

		\find({u1||u2}noWaWAtHistory(loc, id))

		\varcond(\noEventUpdate(u1))

		\replacewith({u2}noWaWAtHistory({u1}loc, {u1}id))

		\heuristics(update_apply)
	};*/

//======================================================================================================================
//										Non-InverseEventUpdate Application on Read and Write Predicates
//======================================================================================================================
	simplifyUpdateOnReadPred {
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({u}rPred(loc, ts))
		\varcond(\noInverseEventUpdate(u), \noInverseAnonEventUpdate(u))

		\replacewith(rPred({u}loc, {u}ts))

		\heuristics(update_apply)
	};

	simplifyUpdateOnWritePred {
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({u}wPred(loc, ts))
		\varcond(\noInverseEventUpdate(u), \noInverseAnonEventUpdate(u))

		\replacewith(wPred({u}loc, {u}ts))

		\heuristics(update_apply)
	};

//======================================================================================================================
//								Read and Write Predicates in Relation to noX and noXAtHitory
//======================================================================================================================
	//---------------------------------------------------> With noX
	//To Prove
	rPredAndNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1;

		\assumes(rPred(loc1,label1) ==>)
		\find(==> noR(loc2))

		\replacewith(==>intersect(loc1,loc2)=empty);
		\add(intersect(loc1,loc2)=empty==>)

		\heuristics(dep_pred_known_3)//,simplify)
	};

	wPredAndNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1;

		\assumes(wPred(loc1,label1) ==>)
		\find(==> noW(loc2))

		\replacewith(==>intersect(loc1,loc2)=empty);

		\add(intersect(loc1,loc2)=empty==>)

		\heuristics(dep_pred_known_3)
	};

	wPredAndNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;

		\assumes(wPred(loc1,label1)==>)
		\find(==> noWaR(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(loc2)))

		\replacewith(==> noWaR(setMinus(loc2,loc1)) & noRAtHistory(tempVar,label1 + 1))
		\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);


		\add(intersect(loc1,loc2)=empty==>)

		\heuristics(dep_pred_known_2)
	};

	//To Prove
	rPredAndNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;

		\assumes(rPred(loc1,label1)==>)
		\find(==> noRaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
		        \new(tempVar, \dependingOn(loc2)))

		\replacewith(==> noRaW(setMinus(loc2,loc1)) & noWAtHistory(tempVar, label1 + 1))

		\add(tempVar = intersect(loc1,loc2), !tempVar=empty ==>);

		\add(intersect(loc1,loc2)=empty==>)

		\heuristics(dep_pred_known_2)
	};

	//--------------SPECIAL TO NOWAW----------------------------
	//To Prove
	wPredAndNoWaWPrecise{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label1,label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(wPred(loc2,label2) ==>  )
		\add( \if (label1 = label2) \then (loc1 = loc2)
		      \else (
		         !intersect(loc1,loc2)=empty -> !noWaW( intersect(loc1,loc2) ) ) ==>)

		\heuristics(no_self_application, dep_pred_known_2)//,simplify)
	};

	wPredAndNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1;
		\schemaVar \variables int label2;
		\schemaVar \variables LocSet loc3;

		\assumes(wPred(loc1,label1)==>)
		\find(==> noWaW(loc2))
		\varcond(\new(tempVar, \dependingOn(loc1)),
	            \new(tempVar, \dependingOn(loc2)), \notFreeIn(label2, label1), \notFreeIn(loc3, label1))

		\replacewith(==> noWaW(setMinus(loc2, loc1)) & noWAtHistory(tempVar, label1 + 1) & (\forall loc3; (\forall label2; (0<=label2 & label2<label1 & !(intersect(tempVar, loc3) = empty) -> !wPred(loc3,label2) ) ) ) )
		\add(tempVar=intersect(loc1,loc2)==>)

		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
	};

	//---------------------------------------------------> With noXAtHistory

	//---------------------------------------------------> A. Same Label --- 1. xPred ==> noXHistory
	// To Prove
	rPredANDNoRHistoryRightSameLabel{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noRAtHistory(loc2,label))

		\replacewith(==> intersect(loc1,loc2)=empty & noRAtHistory(loc2,label + 1))

		\heuristics(dep_pred_known_3,noEqApp)//,simplify)
	};

	// To Prove
	rPredANDnoWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noWAtHistory(loc2,label))
		\replacewith(==> noWAtHistory(loc2,label+1))

		\heuristics(simplify)
	};

	// To Prove
	rPredANDnoRAWHistoryRightSameLabel {// add -> replace
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noWAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(simplify,noEqApp)
	};

	rPredANDNoWARHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(loc2,label+1))

		\heuristics(simplify)
	};

	rPredANDnoWAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\replacewith(==> noWaWAtHistory(loc2,label+1))

		\heuristics(simplify)
	};

	wPredANDNoRHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noRAtHistory(loc2,label))
		\replacewith(==> noRAtHistory(loc2,label+1))

		\heuristics(simplify)
	};

	wPredANDNoWHistoryRightSameLabel{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noWAtHistory(loc2,label))

		\replacewith(==> intersect(loc1,loc2)=empty & noWAtHistory(loc2,label + 1))

		\heuristics(dep_pred_known_3,noEqApp)//,simplify)
	};

	wPredANDNoRAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(loc2,label+1))

		\heuristics(simplify)
	};

	wPredANDnoWARHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\add(==> noWaRAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noRAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(dep_pred_known_2b,noEqApp)
	};

	wPredANDnoWAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\add(==> noWaWAtHistory(setMinus(loc2,loc1),label+1) & (intersect(loc1,loc2) != empty -> noWAtHistory(intersect(loc2,loc1),label+1)))
		\heuristics(dep_pred_known_2b,noEqApp)
	};

	//---------------------------------------------------> A. Same Label --- 2. xPred & noXHistory ==>
	rPredANDnoRAtHistorySameLabel {//necessary?
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(noRAtHistory(loc2,label)==>)
		\add(intersect(loc1,loc2) = empty ==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

//	rPredAndNoRaWAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//
//		\assumes(rPred(loc1,label)==>)
//		\find(noRaWAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//
//		\replacewith( noRaWAtHistory(setMinus(loc2, loc1),label) & noWAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};

	// To Prove
	rPredANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(noRaWAtHistory(loc2,label)==>)
		\add(noWAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

	wPredANDnoWAtHistorySameLabel {// necessary?
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(noWAtHistory(loc2,label)==>)
		\add(intersect(loc1,loc2) = empty ==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

//	wPredAndNoWaRAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//
//		\assumes(wPred(loc1,label)==>)
//		\find(noWaRAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//
//		\replacewith( noWaRAtHistory(setMinus(loc2, loc1),label) & noRAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};

	wPredANDnoWARHistSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(noWaRAtHistory(loc2,label)==>)
		\add(noRAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

//	wPredAndNoWaWAtHistory{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \term int label;
//
//		\assumes(wPred(loc1,label)==>)
//		\find(noWaWAtHistory(loc2,label)==> )
//		\varcond(\new(tempVar, \dependingOn(loc1)),
//	            \new(tempVar, \dependingOn(loc2)))
//
//		\replacewith( noWaWAtHistory(setMinus(loc2, loc1),label) & noWAtHistory(tempVar, label + 1) ==>)
//		\add(tempVar=intersect(loc1,loc2)==>)
//
//		\heuristics(dep_pred_known_2b, noEqApp)//,simplify)
//	};

	wPredANDnoWAWHistSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(noWaWAtHistory(loc2,label)==>)
		\add(noWAtHistory(intersect(loc2,loc1),label+1)==>)
		\heuristics(dep_pred_known_2b,noEqApp)
	};

	//---------------------------------------------------> B. Different Label --- 1. xPred BEFORE noXAtHistory ==>
	// To Prove
	rPredBEFOREnoRaWAtHistory {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find   (noRaWAtHistory(loc2,label2)==>)
		\add(\if(label1=label2+1)
		\then(noWAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noRaWAtHistory(loc2,label2)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};
	//rPredBEFOREnoWaRHistory {// OLD
	//\schemaVar \term LocSet loc1,loc2;
	//\schemaVar \term int label1, label2;
	//
	//\assumes(rPred(loc1,label1) ==>)
	//\find(noWaRAtHistory(loc2,label2)==>)
	//\add(\if(label1=label2+1)
	//\then(noWAtHistory(intersect(loc1,loc2),label1+1))
	//\else(noWaRAtHistory(loc2,label2))==>)
	//\heuristics(dep_pred_known,noEqApp)
	//};
	wPredBEFOREnoWaRHistory {//NEW
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find   (noWaRAtHistory(loc2,label2)==>)
		\add(\if(label1=label2+1)
		\then(noRAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noWaRAtHistory(loc2,label2)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredBEFOREnoWaWHist {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find   (noWaWAtHistory(loc2,label2)==>)
		\add(\if(label1=label2+1)
		\then(noWAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noWaWAtHistory(loc2,label2)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	//---------------------------------------------------> B. Different Label --- 2. xPred AFTER noXAtHistory ==>
	// To Prove
	rPredAFTERnoRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noRAtHistory(setMinus(loc2,loc1),label1))
		\else(noRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	// To Prove
	rPredAFTERnoWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWAtHistory(loc2,label1))
		\else(noWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	rPredAFTERnoRaWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noRaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noRaWAtHistory(setMinus(loc2,loc1),label1))
		\else(noRaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	rPredAFTERnoWaRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWaRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWaRAtHistory(loc2,label1))
		\else(noWaRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	rPredAFTERnoWAWHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWaWAtHistory(loc2,label1))
		\else(noWaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredAFTERnoRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noRAtHistory(loc2,label1))
		\else(noRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredAFTERnoWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWAtHistory(setMinus(loc2,loc1),label1))
		\else(noWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredAFTERnoRaWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noRaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noRaWAtHistory(loc2,label1))
		\else(noRaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredAFTERnoWaRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noWaRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWaRAtHistory(setMinus(loc2,loc1),label1))
		\else(noWaRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredAFTERnoWAWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noWaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWaWAtHistory(setMinus(loc2,loc1),label1))
		\else(noWaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	//---------------------------------------------------> B. Different Label --- 3. xPred BEFORE  ==> noXAtHistory
	// To Prove
	rPredBEFOREnoRAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find   (==> noRAtHistory(loc2,label2))
		\replacewith(==> \if(label1=label2+1) \then(intersect(loc1, loc2) = empty) \else(noRAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};

	// To Prove
	rPredBEFOREnoRaWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find (==> noRaWAtHistory(loc2,label2))
		\replacewith(==>\if(label1=label2+1)
		\then(noRaWAtHistory(setMinus(loc2,loc1), label2) & noWAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noRaWAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredBEFOREnoWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find (==> noWAtHistory(loc2,label2))
		\replacewith(==> \if(label1=label2+1) \then(intersect(loc1, loc2) = empty) \else(noWAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredBEFOREnoWaRAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find (==> noWaRAtHistory(loc2,label2))
		\replacewith(==>\if(label1=label2+1)
		\then(noWaRAtHistory(setMinus(loc2,loc1), label2) & noRAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noWaRAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredBEFOREnoWaWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find   (==> noWaWAtHistory(loc2,label2))
		\replacewith(==>\if(label1=label2+1)
		\then(noWaWAtHistory(setMinus(loc2,loc1), label2) &
		noWAtHistory(intersect(loc1,loc2),  label1+1))
		\else(noWaWAtHistory(loc2,label2)))
		\heuristics(dep_pred_known,noEqApp)
	};


//======================================================================================================================
//											noXAtHistory & noXAtHistory Rules
//======================================================================================================================
	//---------------------------------------------------> Different Labels: like the rule below (commented out), are taken care of with the rules relating xPreds to noXAtHistory Preds
	//noWaHnoWAWHistFull {
	//\schemaVar \term LocSet loc1,loc2;
	//\schemaVar \term int label1,label2;
	//
	//\assumes(noWAtHistory(loc1,label1) ==>)
	//\find(==> noWaWAtHistory(loc2,label2))
	//\replacewith(==> \if(label1<=label2) \then (noWaWAtHistory(setMinus(loc2,loc1),label2+1)) \else (noWaWAtHistory(loc2,label2)))
	//
	//\heuristics(simplify_enlarging,noEqApp)
	//
	//};

	//---------------------------------------------------> Same Label
	noRAtHistoryANDnoRAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noRAtHistory(loc1,label) ==>)
		\find(==> noRAtHistory(loc2,label))
		\replacewith(==> noRAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};

	noRAtHistoryANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noRAtHistory(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};

	noRAtHistoryANDnoWaRAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noRAtHistory(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};

	noWAtHistoryANDnoWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noWAtHistory(loc1,label) ==>)
		\find(==> noWAtHistory(loc2,label))
		\replacewith(==> noWAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};

	noWAtHistoryANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noWAtHistory(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};
	noWAtHistoryANDnoWaRAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noWAtHistory(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};
	noWAtHistoryANDnoWaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noWAtHistory(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\replacewith(==> noWaWAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};

	noRaWAtHistoryANDnoRaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noRaWAtHistory(loc1,label) ==>)
		\find(==> noRaWAtHistory(loc2,label))
		\replacewith(==> noRaWAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};

	noWaRAtHistoryANDnoWaRAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noWaRAtHistory(loc1,label) ==>)
		\find(==> noWaRAtHistory(loc2,label))
		\replacewith(==> noWaRAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};

	noWaWAtHistoryANDnoWaWAtHistorySameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(noWaWAtHistory(loc1,label) ==>)
		\find(==> noWaWAtHistory(loc2,label))
		\replacewith(==> noWaWAtHistory(setMinus(loc2,loc1),label))

		\heuristics(dep_pred_known,noEqApp)
	};

//======================================================================================================================
//										Read and Write Predicates Relation
//======================================================================================================================
    //Relaxed version changes
	wPredrPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(rPred(loc2,label)) \sameUpdateLevel
		\replacewith(false)

	    \heuristics(concrete)
	};

	wPredwPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(wPred(loc1,label) ==>)
		\find(wPred(loc2,label))  \sameUpdateLevel
		\replacewith(loc1=loc2)

	    \heuristics(simplify,no_self_application)
	};


	rPredrPred {
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(rPred(loc2,label))  \sameUpdateLevel
		\replacewith(loc1=loc2)

	    \heuristics(simplify,no_self_application)
	};

	rPredwPred {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(rPred(loc1,label) ==>)
		\find(wPred(loc2,label)) \sameUpdateLevel
		\replacewith(false)

	    \heuristics(concrete)
	};

//======================================================================================================================
//											Update Application on noX At History Predicates
//======================================================================================================================

	elimStateUpdatesBeforeNoRaWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({pv:=t || u} noRaWAtHistory(tr, id))
		\replacewith({u}noRaWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoRaWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({u || pv:=t} noRaWAtHistory(tr, id))
		\replacewith({u}noRaWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaRAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({pv:=t || u} noWaRAtHistory(tr, id))
		\replacewith({u}noWaRAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaRAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({u || pv:=t} noWaRAtHistory(tr, id))
		\replacewith({u}noWaRAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({pv:=t || u} noWaWAtHistory(tr, id))
		\replacewith({u}noWaWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWaWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;

		\find({u || pv:=t} noWaWAtHistory(tr, id))
		\replacewith({u}noWaWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoRAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({pv:=t || u} noRAtHistory(tr, id))
		\replacewith({u}noRAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoRAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		 \schemaVar \term[rigid] int id;

		\find({u || pv:=t} noRAtHistory(tr, id))
		\replacewith({u}noRAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWAtHistory1{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;

		\find({pv:=t || u} noWAtHistory(tr, id))
		\replacewith({u}noWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	elimStateUpdatesBeforeNoWAtHistory2{
		\schemaVar \update u;
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term[rigid] LocSet tr;
		\schemaVar \term[rigid] int id;

		\find({u || pv:=t} noWAtHistory(tr, id))
		\replacewith({u}noWAtHistory(tr, id))
		\heuristics(update_elim)
	};

	/*updateOnNoRAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noRAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noRAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};

	updateOnNoWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noWAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};

	updateOnNoRaWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noRaWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noRaWAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};

	updateOnNoWaRAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noWaRAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noWaRAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};

	updateOnNoWaWAtHistory{
		 \schemaVar \term int id;
		 \schemaVar \term LocSet loc;
		 \schemaVar \update u;

		 \find({u}noWaWAtHistory(loc,id))
		 \varcond(\noInverseEventUpdate(u), \noAnonEventUpdate(u), \noInverseAnonEventUpdate(u))
		 \replacewith(noWaWAtHistory({u}loc,{u}id))

		 \heuristics(update_apply)
	};*/

//======================================================================================================================
//										Data Dependence Simplification rules for heuristics
//======================================================================================================================
 	//---------------------------------------------------> Same location sets
	rPredAndNoROnSameLocations{
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;

		\assumes(rPred(loc, label) ==>)
		\find(noR(loc)) \sameUpdateLevel
		\replacewith(false)
		\heuristics(concrete)
	};
	wPredAndNoWOnSameLocations{
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;

		\assumes(wPred(loc, label) ==>)
		\find(noW(loc)) \sameUpdateLevel
		\replacewith(false)
		\heuristics(concrete)
	};
	//------------------------------------------------------
	noRAndNoRaWOnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noR(loc) ==>)
		\find(noRaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

	noWAndNoRaWOnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noW(loc) ==>)
		\find(noRaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

	noRAndNoWaROnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noR(loc) ==>)
		\find(noWaR(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

	noWAndNoWaROnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noW(loc) ==>)
		\find(noWaR(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

	noWAndNoWaWOnSameLocations{
		\schemaVar \term LocSet loc;

		\assumes(noW(loc) ==>)
		\find(noWaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};

//======================================================================================================================
//											Inverse Event Update Application
//======================================================================================================================
 	//---------------------------------------------------> Nothing Inverse Event Update
	nothingToSkip{
		\schemaVar \term LocSet loc1;
		\schemaVar \term int label;

		\find(\invEvUp(nothing, loc1, label))
		\replacewith(skip)
		\heuristics(update_apply)
	};

	nothingInverseOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noR(loc2))
		\replacewith(noR(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noW(loc2))
		\replacewith(noW(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noRaW(loc2))
		\replacewith(noRaW(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noWaR(loc2))
		\replacewith(noWaR(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}noWaW(loc2))
		\replacewith(noWaW(loc2))
		\heuristics(update_apply)
	};

	nothingInverseLastInParallelOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noR(loc2))
		\replacewith({u}noR(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noW(loc2))
		\replacewith({u}noW(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noRaW(loc2))
		\replacewith({u}noRaW(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noWaR(loc2))
		\replacewith({u}noWaR(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}noWaW(loc2))
		\replacewith({u}noWaW(loc2))
		\heuristics(update_apply)
	};

 	//---------------------------------------------------> {\invEvUp()} NoX
	//Rules here can also happen on the right side. So probably I have to delete the ==>.
	// Now they are part of To Prove rules. But I think they are just rewrite rules.
	readInverseEvUpOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noR(loc2)==>)

		\replacewith(noRAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	  };

	writeInverseEvUpOnNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noR(loc2)==>)

		\replacewith(noRAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	  };

	readInverseEvUpOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noW(loc2)==>)

		\replacewith(noWAtHistory({\invEvUp(read,loc1,label)}loc2, 1)==>)
		\heuristics(update_apply)
	 };

	 writeInverseEvUpOnNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noW(loc2)==>)

		\replacewith(noWAtHistory({\invEvUp(write,loc1,label)}loc2, 1)==>)
		\heuristics(update_apply)
	 };

	readInverseEvUpOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noRaW(loc2)==>)

		\replacewith(noRaWAtHistory({\invEvUp(read,loc1,label)}loc2, 1)==>)

		\heuristics(update_apply)
	 };

	 writeInverseEvUpOnNoRaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noRaW(loc2)==>)

		\replacewith(noRaWAtHistory({\invEvUp(write,loc1,label)}loc2, 1)==>)

		\heuristics(update_apply)
	 };

	readInnverseEvUpOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noWaR(loc2)==>)

		\replacewith(noWaRAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	 };

	 writeInnverseEvUpOnNoWaR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noWaR(loc2)==>)

		\replacewith(noWaRAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	 };

	readInverseEvUpOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(read,loc1,label)} noWaW(loc2)==>)

		\replacewith(noWaWAtHistory({\invEvUp(read,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	 };

	 writeInverseEvUpOnNoWaW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(write,loc1,label)} noWaW(loc2)==>)

		\replacewith(noWaWAtHistory({\invEvUp(write,loc1,label)}loc2,1)==>)

		\heuristics(update_apply)
	 };

	//---------------------------------------------------> { update || \invEvUp} noX
	updateParallelToReadInverseEvUpOnNoR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(read,loc1,label)} noR(loc2))
		/*\varcond(\new(tempVar, \dependingOn(loc1)),
                 \new(tempVar, \dependingOn(loc2)),
                 \new(tempVar, \dependingOn(label)))*/

		\replacewith({u}noRAtHistory({u || \invEvUp(read,loc1,label)}loc2,1))
		//\add(tempVar=intersect(loc1,loc2)==>)

		\heuristics(update_apply)
	 };
	 updateParallelToWriteInverseEvUpOnNoR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(write,loc1,label)} noR(loc2))

		\replacewith({u}noRAtHistory({u || \invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	 };

	updateParallelToReadInverseEvUpOnNoW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(read,loc1,label)} noW(loc2))

		\replacewith({u}noWAtHistory({u || \invEvUp(read,loc1,label)}loc2,1))

		\heuristics(update_apply)
	 };
	updateParallelToWriteInverseEvUpOnNoW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(write,loc1,label)} noW(loc2))

		\replacewith({u}noWAtHistory({u || \invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoRaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(read,loc1,label)} noRaW(loc2))

		\replacewith({u}noRaWAtHistory({u || \invEvUp(read,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoRaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(write,loc1,label)} noRaW(loc2))

		\replacewith({u}noRaWAtHistory({u || \invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	 };

	updateParallelToReadInverseEvUpOnNoWaR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(read,loc1,label)} noWaR(loc2))

		\replacewith({u}noWaRAtHistory({u || \invEvUp(read,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoWaR{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\find({u || \invEvUp(write,loc1,label)} noWaR(loc2))

		\replacewith({u}noWaRAtHistory({u || \invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoWaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({u || \invEvUp(read,loc1,label)} noWaW(loc2))

		\replacewith({u}noWaWAtHistory({u || \invEvUp(read,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoWaW{
		\schemaVar \update u;
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;
		\schemaVar \term EventMarker rw;

		\find({u || \invEvUp(write,loc1,label)} noWaW(loc2))

		\replacewith({u}noWaWAtHistory({u || \invEvUp(write,loc1,label)}loc2,1))

		\heuristics(update_apply)
	};

	//---------------------------------------------------> {\invEvUp()} noXAtHistory
	// To Prove, probably it should be a rewrite rule
	readInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noRAtHistory(loc2, label2)==>)

		\replacewith(noRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	// To Prove, probably it should be a rewrite rule
	writeInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noRAtHistory(loc2, label2)==>)

		\replacewith(noRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noWAtHistory(loc2, label2)==>)

		\replacewith(noWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noWAtHistory(loc2, label2)==>)

		\replacewith(noWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	readInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noRaWAtHistory(loc2, label2)==>)

		\replacewith(noRaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1)	==>)

		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noRaWAtHistory(loc2, label2)==>)

		\replacewith(noRaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1)	==>)

		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noWaRAtHistory(loc2, label2)==>)

		\replacewith(noWaRAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noWaRAtHistory(loc2, label2)==>)

		\replacewith(noWaRAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	readInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(read,loc1,label1)} noWaWAtHistory(loc2, label2)==>)

		\replacewith(noWaWAtHistory({\invEvUp(read,loc1,label1)}loc2, ({\invEvUp(read,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};

	writeInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;

		\find({\invEvUp(write,loc1,label1)} noWaWAtHistory(loc2, label2)==>)

		\replacewith(noWaWAtHistory({\invEvUp(write,loc1,label1)}loc2, ({\invEvUp(write,loc1,label1)}label2) + 1) ==>)

		\heuristics(update_apply)
	};
	//---------------------------------------------------> {u || \invEvUp()} noXAtHistory
	updateParallelToReadInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noRAtHistory(loc2, label2)==>)

		\replacewith({u}noRAtHistory({u || \invEvUp(read,loc1,label1)}loc2, ({u || \invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};
	updateParallelToWriteInverseEvUpOnNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noRAtHistory(loc2, label2)==>)

		\replacewith({u}noRAtHistory({u || \invEvUp(write,loc1,label1)}loc2, ({u || \invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noWAtHistory(loc2, label2)==>)

		\replacewith({u}noWAtHistory({u || \invEvUp(read,loc1,label1)}loc2, ({u || \invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};
	updateParallelToWriteInverseEvUpOnNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noWAtHistory(loc2, label2)==>)

		\replacewith({u}noWAtHistory({u || \invEvUp(write,loc1,label1)}loc2, ({u || \invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noRaWAtHistory(loc2, label2)==>)

		\replacewith({u}noRaWAtHistory({u || \invEvUp(read,loc1,label1)}loc2, ({u || \invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noRaWAtHistory(loc2, label2)==>)

		\replacewith({u}noRaWAtHistory({u || \invEvUp(write,loc1,label1)}loc2, ({u || \invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelReadInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noWaRAtHistory(loc2, label2)==>)

		\replacewith({u}noWaRAtHistory({u || \invEvUp(read,loc1,label1)}loc2, ({u || \invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};
	updateParallelWriteInverseEvUpOnNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noWaRAtHistory(loc2, label2)==>)

		\replacewith({u}noWaRAtHistory({u || \invEvUp(write,loc1,label1)}loc2, ({u || \invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToReadInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(read,loc1,label1)} noWaWAtHistory(loc2, label2)==>)

		\replacewith({u}noWaWAtHistory({u || \invEvUp(read,loc1,label1)}loc2, ({u || \invEvUp(read,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

	updateParallelToWriteInverseEvUpOnNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label1, label2;
		\schemaVar \update u;

		\find({u || \invEvUp(write,loc1,label1)} noWaWAtHistory(loc2, label2)==>)

		\replacewith({u}noWaWAtHistory({u || \invEvUp(write,loc1,label1)}loc2, ({u || \invEvUp(write,loc1,label1)}label2) + 1)  ==>)

		\heuristics(update_apply)
	};

//======================================================================================================================
//										Anonymization and Inverse Anonymization Event Update Application
//======================================================================================================================
//---------------------------------------------------> {\anonEvUp()} noX
 /*   anonEvUpOnNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} noR(loc))

        \replacewith(noRAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    anonEvUpOnNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} noW(loc))

        \replacewith(noWAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    anonEvUpOnNoRaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} noRaW(loc))

        \replacewith(noRaWAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWaR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\anonEvUp(counter)} noWaR(loc))

        \replacewith(noWaRAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noWaW(loc))

        \replacewith(noRAtHistory({\anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {u || \anonEvUp()} noX
    updateParallelToAnonEvUpOnNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noR(loc))

        \replacewith({u}noRAtHistory({u || \anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noW(loc))

        \replacewith({u}noWAtHistory({u || \anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoRaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noRaW(loc))
        \replacewith({u}noRaWAtHistory({u || \anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };


    updateParallelToAnonEvUpOnNoWaR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWaR(loc))

        \replacewith({u}noWaRAtHistory({u || \anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoWaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWaW(loc))

        \replacewith({u}noWaWAtHistory({u || \anonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {\invAnonEvUp()} noX
    inverseAnonEvUpOnNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noR(loc))

        \replacewith(noRAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noW(loc))

        \replacewith(noWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoRaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noRaW(loc))

        \replacewith(noRaWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };


    inverseAnonEvUpOnNoWaR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noWaR(loc))

        \replacewith(noWaRAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoWaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noWaW(loc))

        \replacewith(noWaWAtHistory({\invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {u || \invEvUp()} noX
    updateParallelToInverseAnonEvUpOnNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noR(loc))

        \replacewith({u}noRAtHistory({u || \invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noW(loc))

        \replacewith({u}noWAtHistory({u || \invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoRaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noRaW(loc))

        \replacewith({u}noRaWAtHistory({u || \invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };


    updateParallelToInverseAnonEvUpOnNoWaR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWaR(loc))

        \replacewith({u}noWaRAtHistory({u || \invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoWaW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int counter;
        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWaW(loc))

        \replacewith({u}noWaWAtHistory({u || \invAnonEvUp(counter)}loc, counter))

        \heuristics(update_apply)
    };
*/

//---------------------------------------------------> {\event} noXHistory
    eventOnNoRAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;


        \find({\event(rw, loc1, ts)}noRAtHistory(loc2, id))

        \replacewith(noRAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    eventOnNoWAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;


        \find({\event(rw, loc1, ts)}noWAtHistory(loc2, id))

        \replacewith(noWAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    eventOnNoRaWAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;

        \find({\event(rw, loc1, ts)}noRaWAtHistory(loc2, id))

        \replacewith(noRaWAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    eventOnNoWaRAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;


        \find({\event(rw, loc1, ts)}noWaRAtHistory(loc2, id))

        \replacewith(noWaRAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    eventOnNoWaWAtHistory {
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int id, ts;
        \schemaVar \term EventMarker rw;

        \find({\event(rw, loc1, ts)}noWaWAtHistory(loc2, id))

        \replacewith(noWaWAtHistory({\event(rw, loc1, ts)}loc2, {\event(rw, loc1, ts)}id - 1))

        \heuristics(update_apply)
    };

    //---------------------------------------------------> {u || \event} noXHistory
    /*updateParallelToEventOnNoRAtHistory{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int label, ts;
        \schemaVar \term EventMarker rw;
        \schemaVar \update u;
        \schemaVar \skolemTerm LocSet tempVarLoc;
        \schemaVar \skolemTerm int tempVarLabel;

        \find({u || \event(rw, loc1, ts)} noRAtHistory(loc2, label))
        \varcond(\new(tempVarLoc, \dependingOn(loc1)),
        	     \new(tempVarLoc, \dependingOn(ts)),
        	     \new(tempVarLoc, \dependingOn(loc2)),
        	     \new(tempVarLabel, \dependingOn(loc1)),
                 \new(tempVarLabel, \dependingOn(ts)),
                 \new(tempVarLabel, \dependingOn(label)))

        \replacewith({u}noRAtHistory(tempVarLoc, tempVarLabel - 1))
        \add(tempVarLoc = {u || \event(rw, loc1, ts)}loc2, tempVarLabel = {u || \event(rw, loc1, ts)}label ==> )

        \heuristics(update_apply)
    };

    updateParallelToEventOnNoWAtHistory{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int label, ts;
        \schemaVar \term EventMarker rw;
        \schemaVar \update u;
        \schemaVar \skolemTerm LocSet tempVarLoc;
        \schemaVar \skolemTerm int tempVarLabel;

        \find({u || \event(rw, loc1, ts)} noWAtHistory(loc2, label))
        \varcond(\new(tempVarLoc, \dependingOn(loc1)),
                 \new(tempVarLoc, \dependingOn(ts)),
                 \new(tempVarLoc, \dependingOn(loc2)),
                 \new(tempVarLabel, \dependingOn(loc1)),
                 \new(tempVarLabel, \dependingOn(ts)),
                 \new(tempVarLabel, \dependingOn(label)))

        \replacewith({u}noWAtHistory(tempVarLoc, tempVarLabel - 1))
        \add(tempVarLoc = {u || \event(rw, loc1, ts)}loc2, tempVarLabel = {u || \event(rw, loc1, ts)}label ==> )

        \heuristics(update_apply)
    };*/ //in case they are needed, write new ones
//---------------------------------------------------> {\anonEvUp()} noXHistory
    anonEvUpOnNoRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noRAtHistory(loc, label))

        \replacewith(noRAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noWAtHistory(loc, label))

        \replacewith(noWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))
        \heuristics(update_apply)
    };

    anonEvUpOnNoRaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noRaWAtHistory(loc, label))

        \replacewith(noRaWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWaRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noWaRAtHistory(loc, label))

        \replacewith(noWaRAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    anonEvUpOnNoWaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label, counter;

        \find({\anonEvUp(counter)} noWaWAtHistory(loc, label))

        \replacewith(noWaWAtHistory({\anonEvUp(counter)}loc, ({\anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {u || \anonEvUp()} noXAtHistory
    updateParallelToAnonEvUpOnNoRAtHistory{//Update the rules pdf accordingly

        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter
        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noRAtHistory(loc, label))

        \replacewith({u}noRAtHistory({u || \anonEvUp(counter)}loc, ({u || \anonEvUp(counter)}label)- anonLength(counter)))


        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWAtHistory(loc, label))

        \replacewith({u}noWAtHistory({u || \anonEvUp(counter)}loc, ({u || \anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoRaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noRaWAtHistory(loc, label))

        \replacewith({u}noRaWAtHistory({u || \anonEvUp(counter)}loc, ({u || \anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };


    updateParallelToAnonEvUpOnNoWaRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWaRAtHistory(loc, label))

        \replacewith({u}noWaRAtHistory({u || \anonEvUp(counter)}loc, ({u || \anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };

    updateParallelToAnonEvUpOnNoWaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \anonEvUp(counter)} noWaWAtHistory(loc, label))

        \replacewith({u}noWaWAtHistory({u || \anonEvUp(counter)}loc, ({u || \anonEvUp(counter)}label)- anonLength(counter)))

        \heuristics(update_apply)
    };
//---------------------------------------------------> {\invAnonEvUp()} noXAtHistory
    inverseAnonEvUpOnNoRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noRAtHistory(loc, label))

        \replacewith(noRAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noWAtHistory(loc, label))

        \replacewith(noWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoRaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;

        \find({\invAnonEvUp(counter)} noRaWAtHistory(loc, label))

       \replacewith(noRaWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };


    inverseAnonEvUpOnNoWaRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;


        \find({\invAnonEvUp(counter)} noWaRAtHistory(loc, label))

        \replacewith(noWaRAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    inverseAnonEvUpOnNoWaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term int counter;


        \find({\invAnonEvUp(counter)} noWaWAtHistory(loc, label))

        \replacewith(noWaWAtHistory({\invAnonEvUp(counter)}loc, ({\invAnonEvUp(counter)}label)+anonLength(counter)))

        \heuristics(update_apply)
    };

//---------------------------------------------------> {u || \invEvUp()} noXAtHistory
    updateParallelToInverseAnonEvUpOnNoRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noRAtHistory(loc, label))

        \replacewith({u}noRAtHistory({u || \invAnonEvUp(counter)}loc, ({u || \invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWAtHistory(loc, label))

        \replacewith({u}noWAtHistory({u || \invAnonEvUp(counter)}loc, ({u || \invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoRaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noRaWAtHistory(loc, label))

        \replacewith({u}noRaWAtHistory({u || \invAnonEvUp(counter)}loc, ({u || \invAnonEvUp(counter)}label)+anonLength(counter)))


        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoWaRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWaRAtHistory(loc, label))

         \replacewith({u}noWaRAtHistory({u || \invAnonEvUp(counter)}loc, ({u || \invAnonEvUp(counter)}label)+anonLength(counter)))

        \heuristics(update_apply)
    };

    updateParallelToInverseAnonEvUpOnNoWaWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term[rigid] int label; // also to the others
        \schemaVar \term[rigid] int counter; // maybe later more general use skolemterm to save value of counter

        \schemaVar \update u;

        \find({u || \invAnonEvUp(counter)} noWaWAtHistory(loc, label))

        \replacewith({u}noWaWAtHistory({u || \invAnonEvUp(counter)}loc, ({u || \invAnonEvUp(counter)}label)+anonLength(counter)))

        \heuristics(update_apply)
    };

    anonLengthPositive{//NEW
     \schemaVar \term int counter;
     \schemaVar \variables int x;

     \add(\forall x; anonLength(x)>=0 ==>)

    };

    arrayLengthNotNegative {
        \schemaVar \term int o;

        \find(anonLength(o)) \sameUpdateLevel

        \add(anonLength(o) >= 0 ==>)

        \heuristics(inReachableStateImplication)
    };

    //=======================================================================Rules to deal with infiniteUnion
    /*noRAtHistoryOnLocSetSubtract{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int label;
        \schemaVar \variables LocSet loc;

        \find(noRAtHistory(setMinus(loc1,loc2), label))
        \varcond(\notFreeIn(loc, loc1, loc2, label))

        \replacewith(\forall loc;noRAtHistory(loc, label))
        \add(\forall loc; (subset(loc, loc1) & intersect(loc, loc2) = empty)==>)

        \heuristics(lateSimplification)
    };*/

//======================================================================================================================
//======================================================================================================================
//=========================================Rules only for generating loop invariant=====================================
//=====================================Only activated while generating loop invariant===================================
//=========================================Deactivate for proving loop invariant========================================
//======================================================================================================================
//======================================================================================================================


//======================================================================================================================
//												Converting noX To noXAtHistory
//======================================================================================================================

	// To Prove, probably it should be a rewrite rule
   noRtoNoRH {
	    \schemaVar \term LocSet loc;
		\find(noR(loc))
		\replacewith(noRAtHistory(loc, 0))
		\heuristics(concrete)
    };

	noWtoNoWH {
	    \schemaVar \term LocSet loc;
		\find(noW(loc))
		\replacewith(noWAtHistory(loc, 0))
		\heuristics(concrete)
	};

	noWaWtoNoWaWH {
	    \schemaVar \term LocSet loc;
		\find(noWaW(loc))
		\replacewith(noWaWAtHistory(loc, 0))
		\heuristics(concrete)
	};

	noWaRtoNoWaRH {
	    \schemaVar \term LocSet loc;
		\find(noWaR(loc))
		\replacewith(noWaRAtHistory(loc, 0))
		\heuristics(concrete)
	};

	noRaWtoNoRaWH {
	    \schemaVar \term LocSet loc;
		\find(noRaW(loc))
		\replacewith(noRaWAtHistory(loc, 0))
		\heuristics(concrete)
	};


//======================================================================================================================
//======================================================================================================================
//======================================================================================================================
//==================================================RELAXED CALCULUS====================================================
//======================================================================================================================
//======================================================================================================================
//======================================================================================================================

//======================================================================================================================
//==================================================Lattice Rules====================================================
//======================================================================================================================

//--------------------------------------------------Dep preds and Relaxed Predicates
   noRAndRelaxedNoR{
       \schemaVar \term LocSet loc, ls;

       \assumes(noR(loc) ==>)
       \find(==> relaxedNoR(ls))

       \replacewith(==> subset(ls, loc), relaxedNoR(ls))

       \heuristics(dep_pred_known, noEqApp)
  };

  noWAndRelaxedNoW{
       \schemaVar \term LocSet loc, ls;

       \assumes(noW(loc) ==>)
       \find(==> relaxedNoW(ls))

       \replacewith(==> subset(ls, loc), relaxedNoW(ls))

       \heuristics(dep_pred_known, noEqApp)
  };

   noRaWAndRelaxedNoRaW{
       \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

       \assumes(noRaW(loc) ==>)
       \find(==> relaxedNoRaW(ls, rLs, wLs, futRLs))

       \replacewith(==> subset(ls, loc), relaxedNoRaW(ls, rLs, wLs, futRLs))

       \heuristics(dep_pred_known, noEqApp)
   };

   noWaRAndRelaxedNoWaR{
      \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

      \assumes(noWaR(loc) ==>)
      \find(==> relaxedNoWaR(ls, rLs, wLs, futRLs))

      \replacewith(==> subset(ls, loc), relaxedNoWaR(ls, rLs, wLs, futRLs))

      \heuristics(dep_pred_known, noEqApp)
  };

   noWaWAndRelaxedNoWaW{
      \schemaVar \term LocSet loc, ls, wLs, futRLs;

      \assumes(noWaW(loc) ==>)
      \find(==> relaxedNoWaW(ls, wLs, futRLs))

      \replacewith(==> subset(ls, loc), relaxedNoWaW(ls, wLs, futRLs))

      \heuristics(dep_pred_known, noEqApp)
   };

   noRAndRelaxedNoRaW{
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

        \assumes(noR(loc) ==>)
        \find(==> relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith(==> subset(ls, loc), relaxedNoRaW(ls, rLs, wLs, futRLs))

        \heuristics(dep_pred_known, noEqApp)
   };

   noRAndRelaxedNoWaR{
       \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

       \assumes(noR(loc) ==>)
       \find(==> relaxedNoWaR(ls, rLs, wLs, futRLs))

       \replacewith(==> subset(ls, loc), relaxedNoWaR(ls, rLs, wLs, futRLs))

       \heuristics(dep_pred_known, noEqApp)
  };

  noWAndRelaxedNoRaW{
      \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

      \assumes(noW(loc) ==>)
      \find(==> relaxedNoRaW(ls, rLs, wLs, futRLs))

      \replacewith(==> subset(ls, loc), relaxedNoRaW(ls, rLs, wLs, futRLs))

      \heuristics(dep_pred_known, noEqApp)
 };

  noWAndRelaxedNoWaR{
       \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

       \assumes(noW(loc) ==>)
       \find(==> relaxedNoWaR(ls, rLs, wLs, futRLs))

       \replacewith(==> subset(ls, loc), relaxedNoWaR(ls, rLs, wLs, futRLs))

       \heuristics(dep_pred_known, noEqApp)
  };

  noWAndRelaxedNoWaW{
       \schemaVar \term LocSet loc, ls, wLs, futWLs;

       \assumes(noW(loc) ==>)
       \find(==> relaxedNoWaW(ls, wLs, futWLs))

       \replacewith(==> subset(ls, loc), relaxedNoWaW(ls, wLs, futWLs))

       \heuristics(dep_pred_known, noEqApp)
  };

//--------------------------------------------------Relaxed Predicates and Relaxed Predicates
   relaxedNoRAndRelaxedNoR{
       \schemaVar \term LocSet loc, ls;

       \assumes(relaxedNoR(loc) ==>)
       \find(==> relaxedNoR(ls))

       \replacewith(==> subset(ls, loc), relaxedNoR(ls))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoWAndRelaxedNoW{
       \schemaVar \term LocSet loc, ls;

       \assumes(relaxedNoW(loc) ==>)
       \find(==> relaxedNoW(ls))

       \replacewith(==> subset(ls, loc), relaxedNoW(ls))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoRaWAndRelaxedNoRaW{//Sound?
       \schemaVar \term LocSet loc, ls,rLs1, wLs1, futRLs1, rLs2, wLs2, futRLs2;

       \assumes(relaxedNoRaW(loc, rLs1, wLs1, futRLs1) ==>)
       \find(==> relaxedNoRaW(ls, rLs2, wLs2, futRLs2))

       \replacewith(==> subset(ls, loc), relaxedNoRaW(ls, rLs2, wLs2, futRLs2))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoWaRAndRelaxedNoWaR{//Sound?
       \schemaVar \term LocSet loc, ls,rLs1, wLs1, futRLs1, rLs2, wLs2, futRLs2;

       \assumes(relaxedNoWaR(loc, rLs1, wLs1, futRLs1) ==>)
       \find(==> relaxedNoWaR(ls, rLs2, wLs2, futRLs2))

       \replacewith(==> subset(ls, loc), relaxedNoWaR(ls, rLs2, wLs2, futRLs2))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoWaWAndRelaxedNoWaW{//Sound?
       \schemaVar \term LocSet loc, ls, wLs1, futRLs1, wLs2, futRLs2;

       \assumes(relaxedNoWaW(loc, wLs1, futRLs1) ==>)
       \find(==> relaxedNoWaW(ls, wLs2, futRLs2))

       \replacewith(==> subset(ls, loc), relaxedNoWaW(ls, wLs2, futRLs2))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoRAndRelaxedNoRaW{
       \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

       \assumes(relaxedNoR(loc) ==>)
       \find(==> relaxedNoRaW(ls, rLs, wLs, futRLs))

       \replacewith(==> subset(ls, loc), relaxedNoRaW(ls, rLs, wLs, futRLs))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoRAndRelaxedNoWaR{
       \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

       \assumes(relaxedNoR(loc) ==>)
       \find(==> relaxedNoWaR(ls, rLs, wLs, futRLs))

       \replacewith(==> subset(ls, loc), relaxedNoWaR(ls, rLs, wLs, futRLs))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoWAndRelaxedNoRaW{
       \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

       \assumes(relaxedNoW(loc) ==>)
       \find(==> relaxedNoRaW(ls, rLs, wLs, futRLs))

       \replacewith(==> subset(ls, loc), relaxedNoRaW(ls, rLs, wLs, futRLs))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoWAndRelaxedNoWaR{
       \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;

       \assumes(relaxedNoW(loc) ==>)
       \find(==> relaxedNoWaR(ls, rLs, wLs, futRLs))

       \replacewith(==> subset(ls, loc), relaxedNoWaR(ls, rLs, wLs, futRLs))

       \heuristics(dep_pred_known, noEqApp)
  };

  relaxedNoWAndRelaxedNoWaW{
       \schemaVar \term LocSet loc, ls, wLs, futRLs;

       \assumes(relaxedNoW(loc) ==>)
       \find(==> relaxedNoWaW(ls, wLs, futRLs))

       \replacewith(==> subset(ls, loc), relaxedNoWaW(ls, wLs, futRLs))

       \heuristics(dep_pred_known, noEqApp)
  };

//--------------------------------------------------Relaxed History Predicates
// We can only judge those that are at the  Same Label as we don't know what has happened in the middle (what relaxed xPreds represent).

  	relaxedNoRAtHistoryAndRelaxedNoRAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoRAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoRAtHistory(loc2,label))
  		\replacewith(==> relaxedNoRAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoRAtHistoryAndRelaxedNoRaWAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoRAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoRaWAtHistory(loc2,label))
  		\replacewith(==> relaxedNoRaWAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoRAtHistoryAndRelaxedNoWaRAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoRAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoWaRAtHistory(loc2,label))
  		\replacewith(==> relaxedNoWaRAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoWAtHistoryAndRelaxedNoWAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(noWAtHistory(loc1,label) ==>)
  		\find(==> noWAtHistory(loc2,label))
  		\replacewith(==> noWAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoWAtHistoryAndRelaxedNoRaWAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoWAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoRaWAtHistory(loc2,label))
  		\replacewith(==> relaxedNoRaWAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoWAtHistoryAndRelaxedNoWaRAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoWAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoWaRAtHistory(loc2,label))
  		\replacewith(==> relaxedNoWaRAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoWAtHistoryAndRelaxedNoWaWAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoWAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoWaWAtHistory(loc2,label))
  		\replacewith(==> relaxedNoWaWAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoRaWAtHistoryAndRelaxedNoRaWAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoRaWAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoRaWAtHistory(loc2,label))
  		\replacewith(==> relaxedNoRaWAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoWaRAtHistoryAndRelaxedNoWaRAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoWaRAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoWaRAtHistory(loc2,label))
  		\replacewith(==> relaxedNoWaRAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

  	relaxedNoWaWAtHistoryAndRelaxedNoWaWAtHistorySameLabel {
  		\schemaVar \term LocSet loc1,loc2;
  		\schemaVar \term int label;

  		\assumes(relaxedNoWaWAtHistory(loc1,label) ==>)
  		\find(==> relaxedNoWaWAtHistory(loc2,label))
  		\replacewith(==> relaxedNoWaWAtHistory(setMinus(loc2,loc1),label))

  		\heuristics(dep_pred_known,noEqApp)
  	};

//======================================================================================================================
//========================================Update Application on Relaxed Predicates======================================
//======================================================================================================================

//------------------------------------------------> Normal update application
    updateOnRelaxedNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \update u;

        \find({u}relaxedNoR(loc))
        \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoR({u}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    updateOnRelaxedNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \update u;

        \find({u} relaxedNoW(loc))
        \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoW({u}loc))

        \heuristics(update_apply)//userTaclets1)
    };


    updateOnRelaxedNoRaW{
        \schemaVar \term LocSet loc, rLs, wLs, futRLs;
        \schemaVar \update u;

        \find({u} relaxedNoRaW(loc, rLs, wLs, futRLs))
        \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoRaW({u}loc, {u}rLs, {u}wLs, {u}futRLs))

        \heuristics(update_apply)//userTaclets1)
    };

    updateOnRelaxedNoWaR{
        \schemaVar \term LocSet loc, rLs, wLs, futWLs;
        \schemaVar \update u;

        \find({u} relaxedNoWaR(loc, wLs, rLs, futWLs))
        \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoWaR({u}loc, {u}wLs, {u}rLs, {u}futWLs))

        \heuristics(update_apply)//userTaclets1)
    };

    updateOnRelaxedNoWaW{
        \schemaVar \term LocSet loc, wLs, futWLs;
        \schemaVar \update u;

        \find({u} relaxedNoWaW(loc, wLs, futWLs))
        \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoWaW({u}loc, {u}wLs, {u}futWLs))

        \heuristics(update_apply)//userTaclets1)
    };

//--------------------------------------------------Event Update Application on Relaxed Predicates
//---> Nothing Event Update
	nothingEventUpdateOnRelaxedNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\event(nothing, loc1, label)}relaxedNoR(loc2))
		\replacewith(relaxedNoR({\event(nothing, loc1, label)}loc2))
		\heuristics(update_apply)
	};

	nothingEventUpdateOnRelaxedNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\event(nothing, loc1, label)}relaxedNoW(loc2))
		\replacewith(relaxedNoW({\event(nothing, loc1, label)}loc2))
		\heuristics(update_apply)
	};

	nothingEventUpdateOnRelaxedNoRaW{
		\schemaVar \term LocSet loc1, loc2, rLs, wLs, futRLs;
		\schemaVar \term int label;

		\find({\event(nothing, loc1, label)}relaxedNoRaW(loc2, rLs, wLs, futRLs))
		\replacewith(relaxedNoRaW({\event(nothing, loc1, label)}loc2, {\event(nothing, loc1, label)}rLs, {\event(nothing, loc1, label)}wLs, {\event(nothing, loc1, label)}futRLs))
		\heuristics(update_apply)
	};

	nothingEventUpdateOnRelaxedNoWaR{
		\schemaVar \term LocSet loc1, loc2, rLs, wLs, futWLs;
		\schemaVar \term int label;

		\find({\event(nothing, loc1, label)} relaxedNoWaR(loc2, wLs, rLs, futWLs))
		\replacewith(relaxedNoWaR({\event(nothing, loc1, label)}loc2, {\event(nothing, loc1, label)}wLs, {\event(nothing, loc1, label)}rLs, {\event(nothing, loc1, label)}futWLs))
		\heuristics(update_apply)
	};

	nothingEventUpdateOnRelaxedNoWaW{
		\schemaVar \term LocSet loc1, loc2, wLs, futWLs;
		\schemaVar \term int label;

		\find({\event(nothing, loc1, label)} relaxedNoWaW(loc2, wLs, futWLs))
		\replacewith(relaxedNoWaW({\event(nothing, loc1, label)}loc2,{\event(nothing, loc1, label)} wLs, {\event(nothing, loc1, label)}futWLs))
		\heuristics(update_apply)
	};

//---> Other Event Updates
    readAccessOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \skolemTerm LocSet tempVar;

        \find({\event(read, loc, ts)} relaxedNoR(ls))

		\varcond(\new(tempVar, \dependingOn(loc)),
	            \new(tempVar, \dependingOn(ts)),
	            \new(tempVar, \dependingOn(ls)))

	    \replacewith(relaxedNoR(tempVar))
	    \add(tempVar = {\event(read, loc, ts)}ls,
	    	intersect(loc, tempVar) = empty ==> );

	    \replacewith(false)
	    \add(tempVar = {\event(read, loc, ts)}ls,
	    	!(intersect(loc, tempVar) = empty) ==> )

        \heuristics(update_apply)//userTaclets1)
    };

    writeAccessOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;

        \find({\event(write, loc, ts)} relaxedNoR(ls))

        \replacewith(relaxedNoR({\event(write, loc, ts)} ls))

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;

        \find({\event(unique, loc, ts)} relaxedNoR(ls))

        \replacewith(relaxedNoR({\event(unique, loc, ts)} ls))

        \heuristics(update_apply)//userTaclets1)
    };

    readAccessOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;

        \find({\event(read, loc, ts)} relaxedNoW(ls))

        \replacewith(relaxedNoW({\event(read, loc, ts)} ls))

        \heuristics(update_apply)//userTaclets1)
    };
    writeAccessOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \skolemTerm LocSet tempVar;

        \find({\event(write, loc, ts)} relaxedNoW(ls))

        \varcond(\new(tempVar, \dependingOn(loc)),
                \new(tempVar, \dependingOn(ts)),
                \new(tempVar, \dependingOn(ls)))

        \replacewith( relaxedNoW(tempVar))
        \add(tempVar = {\event(write, loc, ts)}ls,
            intersect(loc, tempVar) = empty ==> );

        \replacewith( false)
        \add(tempVar = {\event(write, loc, ts)}ls,
            !(intersect(loc, tempVar) = empty) ==> )

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;

        \find({\event(unique, loc, ts)} relaxedNoW(ls))

        \replacewith(relaxedNoW({\event(unique, loc, ts)} ls))

        \heuristics(update_apply)//userTaclets1)
    };

    readAccessOnRelaxedNoRaW {
		\schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
		\schemaVar \term int ts;

		\find({\event(read, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

		\replacewith(relaxedNoRaW({\event(read, loc, ts)} ls, union({\event(read, loc, ts)} rLs, loc), {\event(read, loc, ts)} wLs, {\event(read, loc, ts)} futRLs))

		\heuristics(update_apply)//userTaclets1)
	};

    writeAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;

        \find({\event(write, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith(relaxedNoRaW({\event(write, loc, ts)} ls, {\event(write, loc, ts)} rLs, union({\event(write, loc, ts)} wLs, loc), {\event(write, loc, ts)} futRLs))
        //\add(intersect({\event(read, loc, ts)} ls, intersect({\event(read, loc, ts)} wLs, {\event(read, loc, ts)} futRLs)) = empty ==>)

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;

        \find({\event(unique, empty, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith(relaxedNoRaW({\event(unique, empty, ts)}ls, empty, empty, union({\event(unique, empty, ts)}futRLs, rLs)))

        \heuristics(update_apply)//userTaclets1)
    };

    writeAccessOnRelaxedNoWaR {
		\schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
		\schemaVar \term int ts;

		\find({\event(write, loc, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

		\replacewith(relaxedNoWaR({\event(write, loc, ts)} ls, union({\event(write, loc, ts)} wLs, loc), {\event(write, loc, ts)} rLs, {\event(write, loc, ts)} futWLs))

		\heuristics(update_apply)//userTaclets1)
	};

    readAccessOnRelaxedNoWaR {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\event(read, loc, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

        \replacewith(relaxedNoRaW({\event(read, loc, ts)} ls, {\event(read, loc, ts)} wLs, union({\event(read, loc, ts)} rLs, loc), {\event(read, loc, ts)} futWLs))
        //\add(intersect({\event(read, loc, ts)} ls, intersect({\event(read, loc, ts)} wLs, {\event(read, loc, ts)} futRLs)) = empty ==>)

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoWaR {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\event(unique, empty, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

        \replacewith(relaxedNoWaR({\event(unique, empty, ts)}ls, empty, empty, union({\event(unique, empty, ts)}futWLs, wLs)))

        \heuristics(update_apply)//userTaclets1)
    };

    writeAccessOnRelaxedNoWaW {
		\schemaVar \term LocSet loc, ls, wLs, futWLs;
		\schemaVar \term int ts;

		\find({\event(write, loc, ts)} relaxedNoWaW(ls, wLs, futWLs))

		\replacewith(relaxedNoWaW({\event(write, loc, ts)} ls, union({\event(write, loc, ts)} wLs, loc), {\event(write, loc, ts)} futWLs))

		\heuristics(update_apply)//userTaclets1)
	};

    readAccessOnRelaxedNoWaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\event(read, loc, ts)} relaxedNoWaW(ls, wLs, futWLs))

        \replacewith(relaxedNoWaW({\event(read, loc, ts)} ls, {\event(read, loc, ts)} wLs, {\event(read, loc, ts)} futWLs))
        //\add(intersect({\event(read, loc, ts)} ls, intersect({\event(read, loc, ts)} wLs, {\event(read, loc, ts)} futRLs)) = empty ==>)

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoWaW {
        \schemaVar \term LocSet loc, ls, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\event(unique, empty, ts)} relaxedNoWaW(ls, wLs, futWLs))

        \replacewith(relaxedNoWaW({\event(unique, empty, ts)}ls, empty, union({\event(unique, empty, ts)}futWLs, wLs)))

        \heuristics(update_apply)//userTaclets1)
    };

//--------------------------------------------------Update Parallel to Event Update Application on Relaxed Predicates

//---> u || nothing event update
	nothingEventUpdateLastInParallelOnRelaxedNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)} relaxedNoR(loc2))
		\replacewith({u}relaxedNoR({\event(nothing, loc1, label)}loc2))
		\heuristics(update_apply)
	};
	nothingEventUpdateLastInParallelOnRelaxedNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)}relaxedNoW(loc2))
		\replacewith({u}relaxedNoW({\event(nothing, loc1, label)}loc2))
		\heuristics(update_apply)
	};

	nothingEventUpdateLastInParallelOnRelaxedNoRaW{
		\schemaVar \term LocSet loc1, loc2, rLs, wLs, futRLs;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)}relaxedNoRaW(loc2, rLs, wLs, futRLs))
		\replacewith({u}relaxedNoRaW({u || \event(nothing, loc1, label)}loc2, {u || \event(nothing, loc1, label)}rLs, {u || \event(nothing, loc1, label)}wLs, {u || \event(nothing, loc1, label)}futRLs))
		\heuristics(update_apply)
	};
	nothingEventUpdateLastInParallelOnRelaxedNoWaR{
		\schemaVar \term LocSet loc1, loc2, rLs, wLs, futWLs;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)}relaxedNoWaR(loc2, wLs, rLs, futWLs))
		\replacewith({u}relaxedNoWaR({u || \event(nothing, loc1, label)}loc2, {u || \event(nothing, loc1, label)}wLs, {u || \event(nothing, loc1, label)}rLs, {u || \event(nothing, loc1, label)}futWLs))
		\heuristics(update_apply)
	};
	nothingEventUpdateLastInParallelOnRelaxedNoWaW{
		\schemaVar \term LocSet loc1, loc2, wLs, futWLs;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)}relaxedNoWaW(loc2, wLs, futWLs))
		\replacewith({u}relaxedNoWaW({u || \event(nothing, loc1, label)}loc2, {u || \event(nothing, loc1, label)}wLs, {u || \event(nothing, loc1, label)}futWLs))
		\heuristics(update_apply)
	};

//---> u || other event updates
    updateParallelToReadAccessOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \skolemTerm LocSet tempVar;
        \schemaVar \update u;

        \find({u || \event(read, loc, ts)} relaxedNoR(ls))

        \varcond(\new(tempVar, \dependingOn(loc)),
                \new(tempVar, \dependingOn(ts)),
                \new(tempVar, \dependingOn(ls)))

        \replacewith({u} relaxedNoR(tempVar))
        \add(tempVar = {u || \event(read, loc, ts)}ls,
            intersect(loc, tempVar) = empty ==> );

        \replacewith(false)
        \add(tempVar = {u || \event(read, loc, ts)}ls,
            !(intersect(loc, tempVar) = empty) ==> )
        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToWriteAccessOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(write, loc, ts)} relaxedNoR(ls))

        \replacewith({u} relaxedNoR({u || \event(write, loc, ts)} ls))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToUniqueAccessOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(unique, loc, ts)} relaxedNoR(ls))

        \replacewith({u} relaxedNoR({u || \event(unique, loc, ts)} ls))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToReadAccessOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(read, loc, ts)} relaxedNoW(ls))

        \replacewith({u} relaxedNoW({u || \event(read, loc, ts)} ls))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToWriteAccessOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;
        \schemaVar \skolemTerm LocSet tempVar;

        \find({\event(write, loc, ts)} relaxedNoW(ls))

        \varcond(\new(tempVar, \dependingOn(loc)),
                \new(tempVar, \dependingOn(ts)),
                \new(tempVar, \dependingOn(ls)))

        \replacewith({u} relaxedNoW(tempVar))
        \add(tempVar = {u || \event(write, loc, ts)}ls,
            intersect(loc, tempVar) = empty ==> );

        \replacewith(false)
        \add(tempVar = {u || \event(write, loc, ts)}ls,
            !(intersect(loc, tempVar) = empty) ==> )

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToUniqueAccessOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(unique, loc, ts)} relaxedNoW(ls))

        \replacewith({u} relaxedNoW({u || \event(unique, loc, ts)} ls))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToReadAccessOnRelaxedNoRaW {
		\schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(read, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

		\replacewith({u} relaxedNoRaW({u || \event(read, loc, ts)} ls, union({u || \event(read, loc, ts)} rLs, loc), {u || \event(read, loc, ts)} wLs, {u || \event(read, loc, ts)} futRLs))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToWriteAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(write, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith({u} relaxedNoRaW({u || \event(write, loc, ts)} ls, {u || \event(write, loc, ts)} rLs, union({u || \event(write, loc, ts)} wLs, loc), {\event(write, loc, ts)} futRLs))
        //\add(intersect({\event(read, loc, ts)} ls, intersect({\event(read, loc, ts)} wLs, {\event(read, loc, ts)} futRLs)) = empty ==>)

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToMarkerAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(unique, empty, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith({u} relaxedNoRaW({u || \event(unique, empty, ts)}ls, empty, empty, union({u || \event(unique, empty, ts)}futRLs, rLs)))


        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToWriteAccessOnRelaxedNoWaR {
		\schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(write, loc, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

		\replacewith({u} relaxedNoRaW({u || \event(write, loc, ts)} ls, union({u || \event(write, loc, ts)} wLs, loc), {u || \event(write, loc, ts)} rLs, {u || \event(write, loc, ts)} futWLs))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToReadAccessOnRelaxedNoWaR {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(read, loc, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

        \replacewith({u} relaxedNoWaR({u || \event(read, loc, ts)} ls, {u || \event(read, loc, ts)} wLs, union({u || \event(read, loc, ts)} rLs, loc), {u || \event(read, loc, ts)} futWLs))
        //\add(intersect({\event(read, loc, ts)} ls, intersect({\event(read, loc, ts)} wLs, {\event(read, loc, ts)} futRLs)) = empty ==>)

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToMarkerAccessOnRelaxedNoWaR {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(unique, empty, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

        \replacewith({u} relaxedNoWaR({u || \event(unique, empty, ts)}ls, empty, empty, union({u || \event(unique, empty, ts)}futWLs, wLs)))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToWriteAccessOnRelaxedNoWaW {
		\schemaVar \term LocSet loc, ls, wLs, futWLs;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(write, loc, ts)} relaxedNoWaW(ls, wLs, futWLs))

		\replacewith({u} relaxedNoWaW({u || \event(write, loc, ts)} ls, union({u || \event(write, loc, ts)} wLs, loc), {u || \event(write, loc, ts)} futWLs))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToReadAccessOnRelaxedNoWaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(read, loc, ts)} relaxedNoWaW(ls, wLs, futWLs))

        \replacewith({u} relaxedNoWaW({u || \event(read, loc, ts)} ls, {u || \event(read, loc, ts)} wLs, {u || \event(read, loc, ts)} futWLs))
        //\add(intersect({u || \event(read, loc, ts)} ls, intersect({u || \event(read, loc, ts)} wLs, {u || \event(read, loc, ts)} futRLs)) = empty ==>)

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToMarkerAccessOnRelaxedNoWaW {
        \schemaVar \term LocSet loc, ls, wLs, futWLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(unique, empty, ts)} relaxedNoWaW(ls, wLs, futWLs))

        \replacewith({u} relaxedNoWaW({u || \event(unique, empty, ts)}ls, empty, union({u || \event(unique, empty, ts)}futWLs, wLs)))

        \heuristics(update_apply)//userTaclets1)
    };

//--------------------------------------------------Inverse Event Update Application on Relaxed Predicates
//---> Nothing Inverse Event Update
	nothingInverseOnRelaxedNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}relaxedNoR(loc2))
		\replacewith(relaxedNoR(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnRelaxedNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}relaxedNoW(loc2))
		\replacewith(relaxedNoW(loc2))
		\heuristics(update_apply)
	};

	nothingInverseOnRelaxedNoRaW{
		\schemaVar \term LocSet loc1, loc2, rLs, wLs, futRLs;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)}relaxedNoRaW(loc2, rLs, wLs, futRLs))
		\replacewith(relaxedNoRaW({\invEvUp(nothing, loc1, label)}loc2, {\invEvUp(nothing, loc1, label)}rLs, {\invEvUp(nothing, loc1, label)}wLs, {\invEvUp(nothing, loc1, label)}futRLs))
		\heuristics(update_apply)
	};

	nothingInverseOnRelaxedNoWaR{
		\schemaVar \term LocSet loc1, loc2, wLs, rLs, futWLs;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)} relaxedNoWaR(loc2, wLs, rLs, futWLs))
		\replacewith(relaxedNoWaR({\invEvUp(nothing, loc1, label)}loc2, {\invEvUp(nothing, loc1, label)}wLs, {\invEvUp(nothing, loc1, label)}rLs, {\invEvUp(nothing, loc1, label)}futWLs))
		\heuristics(update_apply)
	};

	nothingInverseOnRelaxedNoWaW{
		\schemaVar \term LocSet loc1, loc2, wLs, futWLs;
		\schemaVar \term int label;

		\find({\invEvUp(nothing, loc1, label)} relaxedNoWaW(loc2, wLs, futWLs))
		\replacewith(relaxedNoWaW({\invEvUp(nothing, loc1, label)}loc2, {\invEvUp(nothing, loc1, label)}wLs, {\invEvUp(nothing, loc1, label)}futWLs))
		\heuristics(update_apply)
	};

//---> Other inverse Event Updates
    inverseReadEvUpOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;

        \find({\invEvUp(read, ls, ts)} relaxedNoR(loc))
        \replacewith(relaxedNoR({\invEvUp(read, ls, ts)}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseWriteEvUpOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;

        \find({\invEvUp(write, ls, ts)} relaxedNoR(loc))
        \replacewith(relaxedNoR({\invEvUp(read, ls, ts)}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseUniqueAccessOnRelaxedNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int ts;

        \find({\invEvUp(unique, empty, ts)} relaxedNoR(loc))
        \replacewith(relaxedNoRAtHistory({\invEvUp(unique, empty, ts)}loc, ts - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseReadEvUpOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;

        \find({\invEvUp(read, ls, ts)} relaxedNoW(loc))
        \replacewith(relaxedNoW({\invEvUp(read, ls, ts)}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseWriteEvUpOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;

        \find({\invEvUp(write, ls, ts)} relaxedNoW(loc))
        \replacewith(relaxedNoW({\invEvUp(read, ls, ts)}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseUniqueAccessOnRelaxedNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int ts;

        \find({\invEvUp(unique, empty, ts)} relaxedNoW(loc))
        \replacewith(relaxedNoWAtHistory({\invEvUp(unique, empty, ts)}loc, ts - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseReadAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;

        \find({\invEvUp(read, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith(relaxedNoRaW({\invEvUp(read, loc, ts)} ls, setMinus({\invEvUp(read, loc, ts)} rLs, loc), {\invEvUp(read, loc, ts)} wLs, {\invEvUp(read, loc, ts)} futRLs))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseWriteAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;

        \find({\invEvUp(write, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith(relaxedNoRaW({\invEvUp(write, loc, ts)} ls, {\invEvUp(write, loc, ts)} rLs, setMinus({\invEvUp(write, loc, ts)} wLs, loc), {\invEvUp(write, loc, ts)} futRLs))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseMarkerAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;

        \find({\invEvUp(unique, empty, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith(relaxedNoRaW({\invEvUp(unique, empty, ts)}ls, empty, empty, setMinus({\invEvUp(unique, empty, ts)}futRLs, rLs)))


        \heuristics(update_apply)//userTaclets1)
    };

    inverseWriteAccessOnRelaxedNoWaR {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\invEvUp(write, loc, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

        \replacewith(relaxedNoWaR({\invEvUp(write, loc, ts)} ls, setMinus({\invEvUp(write, loc, ts)} wLs, loc), {\invEvUp(write, loc, ts)} rLs, {\invEvUp(write, loc, ts)} futWLs))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseReadAccessOnRelaxedNoWaR {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\invEvUp(read, loc, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

        \replacewith(relaxedNoWaR({\invEvUp(read, loc, ts)} ls, {\invEvUp(read, loc, ts)} wLs, setMinus({\invEvUp(read, loc, ts)} rLs, loc), {\invEvUp(read, loc, ts)} futWLs))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseMarkerAccessOnRelaxedNoWaR {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\invEvUp(unique, empty, ts)} relaxedNoWaR(ls, wLs, rLs, futWLs))

        \replacewith(relaxedNoWaR({\invEvUp(unique, empty, ts)}ls, empty, empty, setMinus({\invEvUp(unique, empty, ts)}futWLs, wLs)))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseWriteAccessOnRelaxedNoWaW {
        \schemaVar \term LocSet loc, ls, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\invEvUp(write, loc, ts)} relaxedNoWaW(ls, wLs, futWLs))

        \replacewith(relaxedNoWaW({\invEvUp(write, loc, ts)} ls, setMinus({\invEvUp(write, loc, ts)} wLs, loc), {\invEvUp(write, loc, ts)} futWLs))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseReadAccessOnRelaxedNoWaW {
        \schemaVar \term LocSet loc, ls, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\invEvUp(read, loc, ts)} relaxedNoWaW(ls, wLs, futWLs))

        \replacewith(relaxedNoWaW({\invEvUp(read, loc, ts)} ls, {\invEvUp(read, loc, ts)} wLs, {\invEvUp(read, loc, ts)} futWLs))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseMarkerAccessOnRelaxedNoWaW {
        \schemaVar \term LocSet loc, ls, wLs, futWLs;
        \schemaVar \term int ts;

        \find({\invEvUp(unique, empty, ts)} relaxedNoWaW(ls, wLs, futWLs))

        \replacewith(relaxedNoWaW({\invEvUp(unique, empty, ts)}ls, empty, setMinus({\invEvUp(unique, empty, ts)}futWLs, wLs)))

        \heuristics(update_apply)//userTaclets1)
    };

//---------------------------------------------Update Parallel to Inverse Event Update Application on Relaxed Predicates

//---> u || nothing inverse event update

	nothingInverseLastInParallelOnRelaxedNoR{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)} relaxedNoR(loc2))
		\replacewith({u}relaxedNoR(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnRelaxedNoW{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}relaxedNoW(loc2))
		\replacewith({u}relaxedNoW(loc2))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnRelaxedNoRaW{
		\schemaVar \term LocSet loc1, loc2, rLs, wLs, futRLs;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}relaxedNoRaW(loc2, rLs, wLs, futRLs))
		\replacewith({u}relaxedNoRaW({u || \invEvUp(nothing, loc1, label)}loc2, {u || \invEvUp(nothing, loc1, label)}rLs, {u || \invEvUp(nothing, loc1, label)}wLs, {u || \invEvUp(nothing, loc1, label)}futRLs))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnRelaxedNoWaR{
		\schemaVar \term LocSet loc1, loc2, wLs, rLs, futWLs;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}relaxedNoWaR(loc2, wLs, rLs, futWLs))
		\replacewith({u}relaxedNoWaR({u || \invEvUp(nothing, loc1, label)}loc2, {u || \invEvUp(nothing, loc1, label)}wLs, {u || \invEvUp(nothing, loc1, label)}rLs, {u || \invEvUp(nothing, loc1, label)}futWLs))
		\heuristics(update_apply)
	};
	nothingInverseLastInParallelOnRelaxedNoWaW{
		\schemaVar \term LocSet loc1, loc2, wLs, futWLs;
		\schemaVar \term int label;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}relaxedNoWaW(loc2, wLs, futWLs))
		\replacewith({u}relaxedNoWaW({u || \invEvUp(nothing, loc1, label)}loc2, {u || \invEvUp(nothing, loc1, label)}wLs, {u || \invEvUp(nothing, loc1, label)}futWLs))
		\heuristics(update_apply)
	};

//---> u || other inverse event update
    updateParallelToInverseReadEvUpOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \invEvUp(read, ls, ts)} relaxedNoR(loc))
        \replacewith({u} relaxedNoR({u || \invEvUp(read, ls, ts)}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseWriteEvUpOnRelaxedNoR{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \invEvUp(write, ls, ts)} relaxedNoR(loc))
        \replacewith({u} relaxedNoR({u || \invEvUp(read, ls, ts)}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseUniqueAccessOnRelaxedNoR{
        \schemaVar \term LocSet loc;
        \schemaVar \term int ts, label;
        \schemaVar \update u;

        \find({u || \invEvUp(unique, empty, ts)} relaxedNoR(loc))
        \replacewith({u} relaxedNoRAtHistory({u || \invEvUp(unique, empty, ts)}loc, ts - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseReadEvUpOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \invEvUp(read, ls, ts)} relaxedNoW(loc))
        \replacewith({u} relaxedNoW({u || \invEvUp(read, ls, ts)}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseWriteEvUpOnRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \invEvUp(write, ls, ts)} relaxedNoW(loc))
        \replacewith({u} relaxedNoW({u || \invEvUp(read, ls, ts)}loc))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseUniqueAccessOnRelaxedNoW{
        \schemaVar \term LocSet loc;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \invEvUp(unique, empty, ts)} relaxedNoW(loc))
        \replacewith({u}relaxedNoWAtHistory({u || \invEvUp(unique, empty, ts)}loc, ts - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToReadAccessOnRelaxedNoRaW {
		\schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
		\schemaVar \term int ts;
		\schemaVar \update u;

		\find({u || \event(read, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

		\replacewith({u}relaxedNoRaW({u || \event(read, loc, ts)} ls, union({u || \event(read, loc, ts)} rLs, loc), {u || \event(read, loc, ts)} wLs, {u || \event(read, loc, ts)} futRLs))
//        \add(intersect({u || \event(read, loc, ts)} ls, intersect({u || \event(read, loc, ts)} wLs, {u || \event(read, loc, ts)} futRLs)) = empty ==>)

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToWriteAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(write, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith({u} relaxedNoRaW({u || \event(write, loc, ts)} ls, {u || \event(write, loc, ts)} rLs, union({u || \event(write, loc, ts)} wLs, loc), {u || \event(write, loc, ts)} futRLs))
  //      \add(intersect({u || \event(read, loc, ts)} ls, intersect({u || \event(read, loc, ts)} wLs, {u || \event(read, loc, ts)} futRLs)) = empty ==>)

        \heuristics(update_apply)//userTaclets1)
    };

  updateParallelToMarkerAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \event(unique, empty, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith({u} relaxedNoRaW({u || \event(unique, empty, ts)}ls, empty, empty, union({u || \event(unique, empty, ts)}futRLs, rLs)))

        \heuristics(update_apply)//userTaclets1)
  };

  updateParallelToInverseReadAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \invEvUp(read, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith({u}relaxedNoRaW({u || \invEvUp(read, loc, ts)} ls, setMinus({u || \invEvUp(read, loc, ts)} rLs, loc), {u || \invEvUp(read, loc, ts)} wLs, {u || \invEvUp(read, loc, ts)} futRLs))

        \heuristics(update_apply)//userTaclets1)
  };

  updateParallelToInverseWriteAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \invEvUp(write, loc, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith({u}relaxedNoRaW({u || \invEvUp(write, loc, ts)} ls, {u || \invEvUp(write, loc, ts)} rLs, setMinus({u || \invEvUp(write, loc, ts)} wLs, loc), {u || \invEvUp(write, loc, ts)} futRLs))

        \heuristics(update_apply)//userTaclets1)
  };

  updateParallelToInverseMarkerAccessOnRelaxedNoRaW {
        \schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
        \schemaVar \term int ts;
        \schemaVar \update u;

        \find({u || \invEvUp(unique, empty, ts)} relaxedNoRaW(ls, rLs, wLs, futRLs))

        \replacewith({u}relaxedNoRaW({u || \invEvUp(unique, empty, ts)}ls, ls, ls, setMinus({u || \invEvUp(unique, empty, ts)}futRLs, rLs)))

        \heuristics(update_apply)//userTaclets1)
  };

//======================================================================================================================
//================================Update Application on Relaxed HISTORY Predicates======================================
//======================================================================================================================
//--------------------------------------------------Normal Update on Relaxed HISTORY Predicates
    updateOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \update u;

        \find({u}relaxedNoRAtHistory(loc, label))
        \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoRAtHistory({u}loc, {u}label))

        \heuristics(update_apply)//userTaclets1)
    };

    updateOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc;
        \schemaVar \term int label;
        \schemaVar \update u;

        \find({u} relaxedNoWAtHistory(loc, label))
        \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoWAtHistory({u}loc, {u}label))

        \heuristics(update_apply)//userTaclets1)
    };

    updateOnRelaxedNoRaWAtHistory{
        \schemaVar \term LocSet ls;
        \schemaVar \term int label;
        \schemaVar \update u;

        \find({u}relaxedNoRaWAtHistory(ls, label))
       \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoRaWAtHistory({u}ls, {u}label))

        \heuristics(update_apply)//userTaclets1)
    };

    updateOnRelaxedNoWaRAtHistory{
        \schemaVar \term LocSet ls;
        \schemaVar \term int label;
        \schemaVar \update u;

        \find({u}relaxedNoWaRAtHistory(ls, label))
       \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoWaRAtHistory({u}ls, {u}label))

        \heuristics(update_apply)//userTaclets1)
    };

    updateOnRelaxedNoWaWAtHistory{
        \schemaVar \term LocSet ls;
        \schemaVar \term int label;
        \schemaVar \update u;

        \find({u}relaxedNoWaWAtHistory(ls, label))
       \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

        \replacewith(relaxedNoWaWAtHistory({u}ls, {u}label))

        \heuristics(update_apply)//userTaclets1)
    };

//--------------------------------------------------Event Update on Relaxed HISTORY Predicates
//---> Nothing Event Update
	nothingEventUpdateOnRelaxedNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\event(nothing, loc1, label)}relaxedNoRAtHistory(loc2, ts))
		\replacewith(relaxedNoRAtHistory({\event(nothing, loc1, label)}loc2, {\event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	nothingEventUpdateOnRelaxedNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\event(nothing, loc1, label)}relaxedNoWAtHistory(loc2, ts))
		\replacewith(relaxedNoWAtHistory({\event(nothing, loc1, label)}loc2, {\event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	nothingEventUpdateOnRelaxedNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\event(nothing, loc1, label)}relaxedNoRaWAtHistory(loc2, ts))
		\replacewith(relaxedNoRaWAtHistory({\event(nothing, loc1, label)}loc2, {\event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	nothingEventUpdateOnRelaxedNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\event(nothing, loc1, label)} relaxedNoWaRAtHistory(loc2, ts))
		\replacewith(relaxedNoWaRAtHistory({\event(nothing, loc1, label)}loc2, {\event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	nothingEventUpdateOnRelaxedNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\event(nothing, loc1, label)} relaxedNoWaWAtHistory(loc2, ts))
		\replacewith(relaxedNoWaWAtHistory({\event(nothing, loc1, label)}loc2, {\event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

//---> Other Event Updates
    readAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(read, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith(relaxedNoRAtHistory({\event(read, loc, ts)} ls, {\event(read, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };
    writeAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(write, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith(relaxedNoRAtHistory({\event(write, loc, ts)} ls, {\event(write, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(unique, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith(relaxedNoRAtHistory({\event(unique, loc, ts)} ls, {\event(unique, loc, ts)}lb + 1))

        \heuristics(update_apply)//userTaclets1)
    };

    readAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(read, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith(relaxedNoWAtHistory({\event(read, loc, ts)} ls, {\event(read, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };
    writeAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(write, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith(relaxedNoWAtHistory({\event(write, loc, ts)} ls, {\event(write, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(unique, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith(relaxedNoWAtHistory({\event(unique, loc, ts)} ls, {\event(unique, loc, ts)}lb + 1))

        \heuristics(update_apply)//userTaclets1)
    };

    readAccessOnRelaxedNoRaWAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;

		\find({\event(read, loc, ts)} relaxedNoRaWAtHistory(ls,lb))

		\replacewith(relaxedNoRaWAtHistory({\event(read, loc, ts)} ls, {\event(read, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    writeAccessOnRelaxedNoRaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(write, loc, ts)} relaxedNoRaWAtHistory(ls, lb))

        \replacewith(relaxedNoRaWAtHistory({\event(write, loc, ts)} ls, {\event(write, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoRaWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(unique, empty, ts)} relaxedNoRaWAtHistory(ls, lb))

        \replacewith(relaxedNoRaWAtHistory({\event(unique, empty, ts)}ls, {\event(unique, empty, ts)}lb + 1))

        \heuristics(update_apply)//userTaclets1)
    };

    writeAccessOnRelaxedNoWaRAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;

		\find({\event(write, loc, ts)} relaxedNoWaRAtHistory(ls, lb))

		\replacewith(relaxedNoWaRAtHistory({\event(write, loc, ts)} ls, {\event(write, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    readAccessOnRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(read, loc, ts)} relaxedNoWaRAtHistory(ls, lb))

        \replacewith(relaxedNoRaWAtHistory({\event(read, loc, ts)} ls, {\event(read, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(unique, empty, ts)} relaxedNoWaRAtHistory(ls, lb))

        \replacewith(relaxedNoWaRAtHistory({\event(unique, empty, ts)}ls, {\event(unique, empty, ts)} lb + 1))

        \heuristics(update_apply)//userTaclets1)
    };

    writeAccessOnRelaxedNoWaWAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;

		\find({\event(write, loc, ts)} relaxedNoWaWAtHistory(ls, lb))

		\replacewith(relaxedNoWaWAtHistory({\event(write, loc, ts)} ls, {\event(write, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    readAccessOnRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(read, loc, ts)} relaxedNoWaWAtHistory(ls, lb))

        \replacewith(relaxedNoWaWAtHistory({\event(read, loc, ts)} ls, {\event(read, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    markerAccessOnRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\event(unique, empty, ts)} relaxedNoWaWAtHistory(ls, lb))

        \replacewith(relaxedNoWaWAtHistory({\event(unique, empty, ts)}ls, {\event(unique, empty, ts)}lb +1))

        \heuristics(update_apply)//userTaclets1)
    };


//--------------------------------------------------Update Parallel to Event Update on Relaxed HISTORY Predicates
//---> u || Nothing Event Update
	updateParallelToNothingEventUpdateOnRelaxedNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)}relaxedNoRAtHistory(loc2, ts))
		\replacewith({u}relaxedNoRAtHistory({u || \event(nothing, loc1, label)}loc2, {u || \event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	updateParallelToNothingEventUpdateOnRelaxedNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)}relaxedNoWAtHistory(loc2, ts))
		\replacewith({u}relaxedNoWAtHistory({u || \event(nothing, loc1, label)}loc2, {u || \event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	updateParallelToNothingEventUpdateOnRelaxedNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)}relaxedNoRaWAtHistory(loc2, ts))
		\replacewith({u}relaxedNoRaWAtHistory({u || \event(nothing, loc1, label)}loc2, {u || \event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	updateParallelToNothingEventUpdateOnRelaxedNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)} relaxedNoWaRAtHistory(loc2, ts))
		\replacewith({u}relaxedNoWaRAtHistory({u || \event(nothing, loc1, label)}loc2, {u || \event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	updateParallelToNothingEventUpdateOnRelaxedNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \event(nothing, loc1, label)} relaxedNoWaWAtHistory(loc2, ts))
		\replacewith({u}relaxedNoWaWAtHistory({u || \event(nothing, loc1, label)}loc2, {u || \event(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

//---> u || Other Event Updates

    updateParallelToReadAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(read, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith({u} relaxedNoRAtHistory({u || \event(read, loc, ts)} ls, {u || \event(read, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };
    updateParallelToWriteAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(write, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith({u} relaxedNoRAtHistory({u || \event(write, loc, ts)} ls, {u || \event(write, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToMarkerAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(unique, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith({u}relaxedNoRAtHistory({u|| \event(unique, loc, ts)} ls, {u ||\event(unique, loc, ts)}lb + 1))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToReadAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(read, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWAtHistory({u || \event(read, loc, ts)} ls, {u || \event(read, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToWriteAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(write, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWAtHistory({u || \event(write, loc, ts)} ls, {u || \event(write, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToMarkerAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(unique, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith({u}relaxedNoWAtHistory({u|| \event(unique, loc, ts)} ls, {u ||\event(unique, loc, ts)}lb + 1))

        \heuristics(update_apply)//userTaclets1)
    };
    updateParallelToReadAccessOnRelaxedNoRaWAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;
		\schemaVar \update u;

		\find({u || \event(read, loc, ts)} relaxedNoRaWAtHistory(ls,lb))

		\replacewith({u} relaxedNoRaWAtHistory({u || \event(read, loc, ts)} ls, {u || \event(read, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToWriteAccessOnRelaxedNoRaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(write, loc, ts)} relaxedNoRaWAtHistory(ls, lb))

        \replacewith({u} relaxedNoRaWAtHistory({u || \event(write, loc, ts)} ls, {u || \event(write, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToMarkerAccessOnRelaxedNoRaWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(unique, empty, ts)} relaxedNoRaWAtHistory(ls, lb))

        \replacewith({u} relaxedNoRaWAtHistory({u || \event(unique, empty, ts)}ls, {u || \event(unique, empty, ts)}lb + 1))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToWriteAccessOnRelaxedNoWaRAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;
		\schemaVar \update u;

		\find({u || \event(write, loc, ts)} relaxedNoWaRAtHistory(ls, lb))

		\replacewith({u} relaxedNoWaRAtHistory({u || \event(write, loc, ts)} ls, {u || \event(write, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToReadAccessOnRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(read, loc, ts)} relaxedNoWaRAtHistory(ls, lb))

        \replacewith({u} relaxedNoRaWAtHistory({u || \event(read, loc, ts)} ls, {u || \event(read, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToMarkerAccessOnRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(unique, empty, ts)} relaxedNoWaRAtHistory(ls, lb))

        \replacewith({u} relaxedNoWaRAtHistory({u || \event(unique, empty, ts)}ls, {u || \event(unique, empty, ts)} lb + 1))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToWriteAccessOnRelaxedNoWaWAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;
		\schemaVar \update u;

		\find({u || \event(write, loc, ts)} relaxedNoWaWAtHistory(ls, lb))

		\replacewith({u} relaxedNoWaWAtHistory({u || \event(write, loc, ts)} ls, {u || \event(write, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToReadAccessOnRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(read, loc, ts)} relaxedNoWaWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWaWAtHistory({u || \event(read, loc, ts)} ls, {u || \event(read, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToMarkerAccessOnRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \event(unique, empty, ts)} relaxedNoWaWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWaWAtHistory({u || \event(unique, empty, ts)}ls, {u || \event(unique, empty, ts)}lb +1))

        \heuristics(update_apply)//userTaclets1)
    };

//--------------------------------------------------Inverse Event Update on Relaxed HISTORY Predicates
//---> Nothing Inverse Event Update
	inverseNothingEventUpdateOnRelaxedNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\invEvUp(nothing, loc1, label)}relaxedNoRAtHistory(loc2, ts))
		\replacewith(relaxedNoRAtHistory({\invEvUp(nothing, loc1, label)}loc2, {\invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	inverseNothingEventUpdateOnRelaxedNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\invEvUp(nothing, loc1, label)}relaxedNoWAtHistory(loc2, ts))
		\replacewith(relaxedNoWAtHistory({\invEvUp(nothing, loc1, label)}loc2, {\invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	inverseNothingEventUpdateOnRelaxedNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\invEvUp(nothing, loc1, label)}relaxedNoRaWAtHistory(loc2, ts))
		\replacewith(relaxedNoRaWAtHistory({\invEvUp(nothing, loc1, label)}loc2, {\invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	inverseNothingEventUpdateOnRelaxedNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\invEvUp(nothing, loc1, label)} relaxedNoWaRAtHistory(loc2, ts))
		\replacewith(relaxedNoWaRAtHistory({\invEvUp(nothing, loc1, label)}loc2, {\invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	inverseNothingEventUpdateOnRelaxedNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;

		\find({\invEvUp(nothing, loc1, label)} relaxedNoWaWAtHistory(loc2, ts))
		\replacewith(relaxedNoWaWAtHistory({\invEvUp(nothing, loc1, label)}loc2, {\invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

//---> Other Event Updates

    inverseReadAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(read, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith(relaxedNoRAtHistory({\invEvUp(read, loc, ts)} ls, {\invEvUp(read, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };
    inverseWriteAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(write, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith(relaxedNoRAtHistory({\invEvUp(write, loc, ts)} ls, {\invEvUp(write, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseMarkerAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(unique, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith(relaxedNoRAtHistory({\invEvUp(unique, loc, ts)} ls, {\invEvUp(unique, loc, ts)}lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseReadAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(read, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith(relaxedNoWAtHistory({\invEvUp(read, loc, ts)} ls, {\invEvUp(read, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseWriteAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(write, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith(relaxedNoWAtHistory({\invEvUp(write, loc, ts)} ls, {\invEvUp(write, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseMarkerAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(unique, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith(relaxedNoWAtHistory({\invEvUp(unique, loc, ts)} ls, {\invEvUp(unique, loc, ts)}lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseReadAccessOnRelaxedNoRaWAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;

		\find({\invEvUp(read, loc, ts)} relaxedNoRaWAtHistory(ls,lb))

		\replacewith(relaxedNoRaWAtHistory({\invEvUp(read, loc, ts)} ls, {\invEvUp(read, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    inverseWriteAccessOnRelaxedNoRaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(write, loc, ts)} relaxedNoRaWAtHistory(ls, lb))

        \replacewith(relaxedNoRaWAtHistory({\invEvUp(write, loc, ts)} ls, {\invEvUp(write, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseMarkerAccessOnRelaxedNoRaWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(unique, empty, ts)} relaxedNoRaWAtHistory(ls, lb))

        \replacewith(relaxedNoRaWAtHistory({\invEvUp(unique, empty, ts)}ls, {\invEvUp(unique, empty, ts)}lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseWriteAccessOnRelaxedNoWaRAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;

		\find({\invEvUp(write, loc, ts)} relaxedNoWaRAtHistory(ls, lb))

		\replacewith(relaxedNoWaRAtHistory({\invEvUp(write, loc, ts)} ls, {\invEvUp(write, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    inverseReadAccessOnRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(read, loc, ts)} relaxedNoWaRAtHistory(ls, lb))

        \replacewith(relaxedNoRaWAtHistory({\invEvUp(read, loc, ts)} ls, {\invEvUp(read, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseMarkerAccessOnRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(unique, empty, ts)} relaxedNoWaRAtHistory(ls, lb))

        \replacewith(relaxedNoWaRAtHistory({\invEvUp(unique, empty, ts)}ls, {\invEvUp(unique, empty, ts)} lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseWriteAccessOnRelaxedNoWaWAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;

		\find({\invEvUp(write, loc, ts)} relaxedNoWaWAtHistory(ls, lb))

		\replacewith(relaxedNoWaWAtHistory({\invEvUp(write, loc, ts)} ls, {\invEvUp(write, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    inverseReadAccessOnRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(read, loc, ts)} relaxedNoWaWAtHistory(ls, lb))

        \replacewith(relaxedNoWaWAtHistory({\invEvUp(read, loc, ts)} ls, {\invEvUp(read, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    inverseMarkerAccessOnRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;

        \find({\invEvUp(unique, empty, ts)} relaxedNoWaWAtHistory(ls, lb))

        \replacewith(relaxedNoWaWAtHistory({\invEvUp(unique, empty, ts)}ls, {\invEvUp(unique, empty, ts)}lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

//--------------------------------------------------Update Parallel to Inverse Event Update on Relaxed HISTORY Predicates
//---> Nothing Inverse Event Update
	updateParallelToInverseNothingEventUpdateOnRelaxedNoRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}relaxedNoRAtHistory(loc2, ts))
		\replacewith({u} relaxedNoRAtHistory({u || \invEvUp(nothing, loc1, label)}loc2, {u || \invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	updateParallelToInverseNothingEventUpdateOnRelaxedNoWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}relaxedNoWAtHistory(loc2, ts))
		\replacewith({u} relaxedNoWAtHistory({u || \invEvUp(nothing, loc1, label)}loc2, {u || \invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	updateParallelToInverseNothingEventUpdateOnRelaxedNoRaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)}relaxedNoRaWAtHistory(loc2, ts))
		\replacewith({u} relaxedNoRaWAtHistory({u || \invEvUp(nothing, loc1, label)}loc2, {u || \invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	updateParallelToInverseNothingEventUpdateOnRelaxedNoWaRAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)} relaxedNoWaRAtHistory(loc2, ts))
		\replacewith({u} relaxedNoWaRAtHistory({u || \invEvUp(nothing, loc1, label)}loc2, {u || \invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

	updateParallelToInverseNothingEventUpdateOnRelaxedNoWaWAtHistory{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label, ts;
		\schemaVar \update u;

		\find({u || \invEvUp(nothing, loc1, label)} relaxedNoWaWAtHistory(loc2, ts))
		\replacewith({u} relaxedNoWaWAtHistory({u || \invEvUp(nothing, loc1, label)}loc2, {u || \invEvUp(nothing, loc1, label)}ts))
		\heuristics(update_apply)
	};

//---> Other Event Updates

    updateParallelToInverseReadAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(read, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith({u} relaxedNoRAtHistory({u || \invEvUp(read, loc, ts)} ls, {u || \invEvUp(read, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };
    updateParallelToInverseWriteAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(write, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith({u} relaxedNoRAtHistory({u || \invEvUp(write, loc, ts)} ls, {u || \invEvUp(write, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseMarkerAccessOnRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(unique, loc, ts)} relaxedNoRAtHistory(ls, lb))

        \replacewith({u} relaxedNoRAtHistory({u || \invEvUp(unique, loc, ts)} ls, {u || \invEvUp(unique, loc, ts)}lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseReadAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(read, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWAtHistory({u || \invEvUp(read, loc, ts)} ls, {u || \invEvUp(read, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseWriteAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(write, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWAtHistory({u || \invEvUp(write, loc, ts)} ls, {u || \invEvUp(write, loc, ts)}lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseMarkerAccessOnRelaxedNoWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(unique, loc, ts)} relaxedNoWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWAtHistory({u || \invEvUp(unique, loc, ts)} ls, {u || \invEvUp(unique, loc, ts)}lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };
    updateParallelToInverseReadAccessOnRelaxedNoRaWAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;
		\schemaVar \update u;

		\find({u || \invEvUp(read, loc, ts)} relaxedNoRaWAtHistory(ls,lb))

		\replacewith({u} relaxedNoRaWAtHistory({u || \invEvUp(read, loc, ts)} ls, {u || \invEvUp(read, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToInverseWriteAccessOnRelaxedNoRaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(write, loc, ts)} relaxedNoRaWAtHistory(ls, lb))

        \replacewith({u} relaxedNoRaWAtHistory({u || \invEvUp(write, loc, ts)} ls, {u || \invEvUp(write, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseMarkerAccessOnRelaxedNoRaWAtHistory{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(unique, empty, ts)} relaxedNoRaWAtHistory(ls, lb))

        \replacewith({u} relaxedNoRaWAtHistory({u || \invEvUp(unique, empty, ts)}ls, {u || \invEvUp(unique, empty, ts)}lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseWriteAccessOnRelaxedNoWaRAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;
		\schemaVar \update u;

		\find({u || \invEvUp(write, loc, ts)} relaxedNoWaRAtHistory(ls, lb))

		\replacewith(relaxedNoWaRAtHistory({u || \invEvUp(write, loc, ts)} ls, {u || \invEvUp(write, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToInverseReadAccessOnRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(read, loc, ts)} relaxedNoWaRAtHistory(ls, lb))

        \replacewith({u} relaxedNoRaWAtHistory({u || \invEvUp(read, loc, ts)} ls, {u || \invEvUp(read, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseMarkerAccessOnRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(unique, empty, ts)} relaxedNoWaRAtHistory(ls, lb))

        \replacewith({u} relaxedNoWaRAtHistory({u || \invEvUp(unique, empty, ts)}ls, {u || \invEvUp(unique, empty, ts)} lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseWriteAccessOnRelaxedNoWaWAtHistory {
		\schemaVar \term LocSet loc, ls;
		\schemaVar \term int ts, lb;
        \schemaVar \update u;

		\find({u || \invEvUp(write, loc, ts)} relaxedNoWaWAtHistory(ls, lb))

		\replacewith({u} relaxedNoWaWAtHistory({u || \invEvUp(write, loc, ts)} ls, {u || \invEvUp(write, loc, ts)} lb))

		\heuristics(update_apply)//userTaclets1)
	};

    updateParallelToInverseReadAccessOnRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(read, loc, ts)} relaxedNoWaWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWaWAtHistory({u || \invEvUp(read, loc, ts)} ls, {u || \invEvUp(read, loc, ts)} lb))

        \heuristics(update_apply)//userTaclets1)
    };

    updateParallelToInverseMarkerAccessOnRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet loc, ls;
        \schemaVar \term int ts, lb;
        \schemaVar \update u;

        \find({u || \invEvUp(unique, empty, ts)} relaxedNoWaWAtHistory(ls, lb))

        \replacewith({u} relaxedNoWaWAtHistory({u || \invEvUp(unique, empty, ts)}ls, {u || \invEvUp(unique, empty, ts)}lb - 1))

        \heuristics(update_apply)//userTaclets1)
    };

//======================================================================================================================
//========================================Update Application on NORMAL xPred============================================
//======================================================================================================================

//--------------------------------------------------Normal Update on NORMAL xPred
    updateOnRPred {
       \schemaVar \term LocSet loc;
       \schemaVar \term int lb;
       \schemaVar \update u;

       \find({u} rPred(loc, lb))
       \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

       \replacewith(rPred({u}loc, {u}lb))

       \heuristics(update_apply)
   };

   updateOnWPred {
      \schemaVar \term LocSet loc;
      \schemaVar \term int lb;
      \schemaVar \update u;

      \find({u} wPred(loc, lb))
      \varcond(\noEventUpdate(u), \noInverseEventUpdate(u))

      \replacewith(wPred({u}loc, {u}lb))

      \heuristics(update_apply)
  };

//--------------------------------------------------Event Update on NORMAL xPred
    nothingAccessOnRPred {
       \schemaVar \term LocSet loc, loc2;
       \schemaVar \term int ts, lb;

       \find({\event(nothing, loc, ts)} rPred(loc2, lb))

       \replacewith(rPred({\event(nothing, loc, ts)}loc2, {\event(nothing, loc, ts)}lb))

       \heuristics(update_apply)//userTaclets1)
   };

    nothingAccessOnWPred {
       \schemaVar \term LocSet loc, loc2;
       \schemaVar \term int ts, lb;

       \find({\event(nothing, loc, ts)} wPred(loc2, lb))

       \replacewith(rPred({\event(nothing, loc, ts)}loc2, {\event(nothing, loc, ts)}lb))

       \heuristics(update_apply)//userTaclets1)
   };

    readAccessOnRPred {
       \schemaVar \term LocSet loc, loc2;
       \schemaVar \term int ts, lb;

       \find({\event(read, loc, ts)} rPred(loc2, lb))

       \replacewith(rPred({\event(read, loc, ts)}loc2, {\event(read, loc, ts)}lb))


       \heuristics(update_apply)//userTaclets1)
   };

   writeAccessOnRPred {
      \schemaVar \term LocSet loc, loc2;
      \schemaVar \term int ts, lb;

      \find({\event(write, loc, ts)} rPred(loc2, lb))

      \replacewith(rPred({\event(write, loc, ts)}loc2, {\event(write, loc, ts)}lb))


      \heuristics(update_apply)//userTaclets1)
   };

   readAccessOnWPred {
      \schemaVar \term LocSet loc, loc2;
      \schemaVar \term int ts, lb;

      \find({\event(read, loc, ts)} wPred(loc2, lb))

      \replacewith(wPred({\event(read, loc, ts)}loc2, {\event(read, loc, ts)}lb))


      \heuristics(update_apply)//userTaclets1)
  };

  writeAccessOnWPred {
     \schemaVar \term LocSet loc, loc2;
     \schemaVar \term int ts, lb;

     \find({\event(write, loc, ts)} wPred(loc2, lb))

     \replacewith(wPred({\event(write, loc, ts)}loc2, {\event(write, loc, ts)}lb))

     \heuristics(update_apply)//userTaclets1)
  };

  uniqueAccessOnRPred {
     \schemaVar \term LocSet loc, loc2;
     \schemaVar \term int ts, lb;

     \find({\event(unique, loc, ts)} rPred(loc2, lb))

     \replacewith(relaxedRPred({\event(unique, loc, ts)}loc2, ts + 1))

     \heuristics(update_apply)//userTaclets1)
 };

 uniqueAccessOnWPred {
    \schemaVar \term LocSet loc, loc2;
    \schemaVar \term int ts, lb;

    \find({\event(unique, loc, ts)} wPred(loc2, lb))

    \replacewith(relaxedWPred({\event(unique, loc, ts)}loc2, ts + 1))

    \heuristics(update_apply)//userTaclets1)
 };


//--------------------------------------------------Update Parallel to Event Update on NORMAL xPred
    updateParallelToNothingAccessOnRPred {
       \schemaVar \term LocSet loc, loc2;
       \schemaVar \term int ts, lb;
       \schemaVar \update u;

       \find({u || \event(nothing, loc, ts)} rPred(loc2, lb))

       \replacewith({u} rPred({u || \event(nothing, loc, ts)}loc2, {u || \event(nothing, loc, ts)}lb))

       \heuristics(update_apply)//userTaclets1)
   };

    updateParallelToNothingAccessOnWPred {
       \schemaVar \term LocSet loc, loc2;
       \schemaVar \term int ts, lb;
       \schemaVar \update u;

       \find({u || \event(nothing, loc, ts)} wPred(loc2, lb))

       \replacewith({u} rPred({u || \event(nothing, loc, ts)}loc2, {u || \event(nothing, loc, ts)}lb))

       \heuristics(update_apply)//userTaclets1)
   };

    updateParallelToReadAccessOnRPred {
       \schemaVar \term LocSet loc, loc2;
       \schemaVar \term int ts, lb;
       \schemaVar \update u;

       \find({u || \event(read, loc, ts)} rPred(loc2, lb))

       \replacewith({u} rPred({\event(read, loc, ts)}loc2, {u || \event(read, loc, ts)}lb))

       \heuristics(update_apply)//userTaclets1)
   };

   updateParallelToWriteAccessOnRPred {
      \schemaVar \term LocSet loc, loc2;
      \schemaVar \term int ts, lb;
      \schemaVar \update u;

      \find({u || \event(write, loc, ts)} rPred(loc2, lb))

      \replacewith({u} rPred({u || \event(write, loc, ts)}loc2, {u || \event(write, loc, ts)}lb))

      \heuristics(update_apply)//userTaclets1)
   };

   updateParallelToReadAccessOnWPred {
      \schemaVar \term LocSet loc, loc2;
      \schemaVar \term int ts, lb;
      \schemaVar \update u;

      \find({\event(read, loc, ts)} wPred(loc2, lb))

      \replacewith({u} wPred({u || \event(read, loc, ts)}loc2, {u || \event(read, loc, ts)}lb))

      \heuristics(update_apply)//userTaclets1)
  };

  updateParallelToWriteAccessOnWPred {
     \schemaVar \term LocSet loc, loc2;
     \schemaVar \term int ts, lb;
     \schemaVar \update u;

     \find({u || \event(write, loc, ts)} wPred(loc2, lb))

     \replacewith({u} wPred({u || \event(write, loc, ts)}loc2, {u || \event(write, loc, ts)}lb))

     \heuristics(update_apply)//userTaclets1)
  };

  updateParallelToUniqueAccessOnRPred {
     \schemaVar \term LocSet loc, loc2;
     \schemaVar \term int ts, lb;
     \schemaVar \update u;

     \find({u || \event(unique, loc, ts)} rPred(loc2, lb))

     \replacewith({u} relaxedRPred({u || \event(unique, loc, ts)}loc2, ts + 1))

     \heuristics(update_apply)//userTaclets1)
 };

 updateParallelToUniqueAccessOnWPred {
    \schemaVar \term LocSet loc, loc2;
    \schemaVar \term int ts, lb;
    \schemaVar \update u;

    \find({u || \event(unique, loc, ts)} wPred(loc2, lb))

    \replacewith({u} relaxedWPred({u || \event(unique, loc, ts)}loc2, ts + 1))

    \heuristics(update_apply)//userTaclets1)
 };

//--------------------------------------------------Inverse Event Update Application on NORMAL xPred
   inverseReadAccessOnRPred {
       \schemaVar \term LocSet loc, loc2;
       \schemaVar \term int ts, lb;

       \find({\invEvUp(read, loc, ts)} rPred(loc2, lb))

       \replacewith(rPred({\invEvUp(read, loc, ts)}loc2, {\invEvUp(read, loc, ts)}lb))

       \heuristics(update_apply)//userTaclets1)
   };

   inverseWriteAccessOnRPred {
      \schemaVar \term LocSet loc, loc2;
      \schemaVar \term int ts, lb;

      \find({\invEvUp(write, loc, ts)} rPred(loc2, lb))

      \replacewith(rPred({\invEvUp(write, loc, ts)}loc2, {\invEvUp(write, loc, ts)}lb))

      \heuristics(update_apply)//userTaclets1)
   };

   inverseReadAccessOnWPred {
      \schemaVar \term LocSet loc, loc2;
      \schemaVar \term int ts, lb;

      \find({\invEvUp(read, loc, ts)} wPred(loc2, lb))

      \replacewith(wPred({\invEvUp(read, loc, ts)}loc2, {\invEvUp(read, loc, ts)}lb))

      \heuristics(update_apply)//userTaclets1)
  };

  inverseWriteAccessOnWPred {
     \schemaVar \term LocSet loc, loc2;
     \schemaVar \term int ts, lb;

     \find({\invEvUp(write, loc, ts)} wPred(loc2, lb))

     \replacewith(wPred({\invEvUp(write, loc, ts)}loc2, {\invEvUp(write, loc, ts)}lb))

     \heuristics(update_apply)//userTaclets1)
  };

  inverseUniqueAccessOnRPred {
     \schemaVar \term LocSet loc, loc2;
     \schemaVar \term int ts, lb;

     \find({\invEvUp(unique, loc, ts)} rPred(loc2, lb))

     \replacewith(relaxedRPred({\invEvUp(unique, loc, ts)}loc2, ts - 1))

     \heuristics(update_apply)//userTaclets1)
 };

 inverseUniqueAccessOnWPred {
    \schemaVar \term LocSet loc, loc2;
    \schemaVar \term int ts, lb;

    \find({\invEvUp(unique, loc, ts)} wPred(loc2, lb))

    \replacewith(relaxedWPred({\invEvUp(unique, loc, ts)}loc2, ts - 1))

    \heuristics(update_apply)//userTaclets1)
 };

//-------------------------------------------------- Update Parallel To Inverse Event Update Application on xPreds
   updateParallelToInverseReadAccessOnRPred {
       \schemaVar \term LocSet loc, loc2;
       \schemaVar \term int ts, lb;
       \schemaVar \update u;

       \find({u || \invEvUp(read, loc, ts)} rPred(loc2, lb))

       \replacewith({u}rPred({u || \invEvUp(read, loc, ts)}loc2, {u || \invEvUp(read, loc, ts)}lb))

       \heuristics(update_apply)//userTaclets1)
   };

   updateParallelToInverseWriteAccessOnRPred {
      \schemaVar \term LocSet loc, loc2;
      \schemaVar \term int ts, lb;
      \schemaVar \update u;

      \find({u || \invEvUp(write, loc, ts)} rPred(loc2, lb))

      \replacewith({u}rPred({u || \invEvUp(write, loc, ts)}loc2, {u || \invEvUp(write, loc, ts)}lb))

      \heuristics(update_apply)//userTaclets1)
   };

   updateParallelToInverseReadAccessOnWPred {
      \schemaVar \term LocSet loc, loc2;
      \schemaVar \term int ts, lb;
      \schemaVar \update u;

      \find({u || \invEvUp(read, loc, ts)} wPred(loc2, lb))

      \replacewith({u}wPred({u || \invEvUp(read, loc, ts)}loc2, {u || \invEvUp(read, loc, ts)}lb))

      \heuristics(update_apply)//userTaclets1)
  };

  updateParallelToInverseWriteAccessOnWPred {
     \schemaVar \term LocSet loc, loc2;
     \schemaVar \term int ts, lb;
     \schemaVar \update u;

     \find({u || \invEvUp(write, loc, ts)} wPred(loc2, lb))

     \replacewith({u}wPred({u || \invEvUp(write, loc, ts)}loc2, {u || \invEvUp(write, loc, ts)}lb))

     \heuristics(update_apply)//userTaclets1)
  };

  updateParallelToInverseUniqueAccessOnRPred {
     \schemaVar \term LocSet loc, loc2;
     \schemaVar \term int ts, lb;
     \schemaVar \update u;

     \find({u || \invEvUp(unique, loc, ts)} rPred(loc2, lb))

     \replacewith({u}relaxedRPred({u || \invEvUp(unique, loc, ts)}loc2, ts - 1))

     \heuristics(update_apply)//userTaclets1)
 };

 updateParallelToInverseUniqueAccessOnWPred {
    \schemaVar \term LocSet loc, loc2;
    \schemaVar \term int ts, lb;
    \schemaVar \update u;

    \find({u || \invEvUp(unique, loc, ts)} wPred(loc2, lb))

    \replacewith({u}relaxedWPred({u || \invEvUp(unique, loc, ts)}loc2, ts - 1))

    \heuristics(update_apply)//userTaclets1)
 };

//----------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------
  /*  The following two rules can make us fall in a loop
  collectAllRelaxedRPreds{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int ts;


        \assumes(relaxedRPred(loc1, ts) ==> )
        \find(relaxedRPred(loc2, ts)==>)

        \replacewith(relaxedRPred(union(loc1, loc2),ts))

        \heuristics(simplify)
    }

  collectAllRelaxedWPreds{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int ts;


        \assumes(relaxedWPred(loc1, ts) ==> )
        \find(relaxedWPred(loc2, ts)==>)

        \replacewith(relaxedWPred(union(loc1, loc2),ts))

        \heuristics(simplify)
  }*/
//----------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------


//======================================================================================================================
//=================================Update Application on RELAXED xPred==================================================
//======================================================================================================================

 updateOnRelaxedRPred {
      \schemaVar \term LocSet loc;
      \schemaVar \term int lb;
      \schemaVar \update u;

      \find({u} relaxedRPred(loc, lb))

      \replacewith(relaxedRPred({u} loc, {u} lb))

      \heuristics(update_apply)//userTaclets1)
 };

 updateOnRelaxedWPred {
      \schemaVar \term LocSet loc;
      \schemaVar \term int lb;
      \schemaVar \update u;

      \find({u} relaxedWPred(loc, lb))

      \replacewith(relaxedWPred({u} loc, {u} lb))

      \heuristics(update_apply)//userTaclets1)
 };

//======================================================================================================================
//====================================Data Dependence Simplification rules for heuristics===============================
//======================================================================================================================
/* Can't have them the first part. Beacause in the relaxed version we allow xPreds with the same label as the relaxedNoX.
 The second part is already included. */


//======================================================================================================================
//=============================================xPred and Relaxed Predicates=============================================
//======================================================================================================================
   rPredAndRelaxedNoR{
   		\schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
   		\schemaVar \skolemTerm LocSet tempVar;
   		\schemaVar \term int label;

   		\assumes(rPred(loc,label)==>)
   		\find(==> relaxedNoR(ls))
   		\varcond(\new(tempVar, \dependingOn(loc1)),
   		        \new(tempVar, \dependingOn(loc2)))

   		\replacewith(==> false)

   		\add(tempVar = intersect(loc,ls), !tempVar=empty ==>);

   		\add(intersect(loc,ls)=empty==>)

   		\heuristics(dep_pred_known_2)
   };

   wPredAndRelaxedNoW{
        \schemaVar \term LocSet loc, ls;
        \schemaVar \skolemTerm LocSet tempVar;
        \schemaVar \term int label;

        \assumes(wPred(loc,label)==>)
        \find(==> relaxedNoW(ls))
        \varcond(\new(tempVar, \dependingOn(loc1)),
                \new(tempVar, \dependingOn(loc2)))

        \replacewith(==> false)

        \add(tempVar = intersect(loc,ls), !tempVar=empty ==>);

        \add(intersect(loc,ls)=empty==>)

        \heuristics(dep_pred_known_2)
  };

   rPredAndRelaxedNoRaW{
		\schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int label;

		\assumes(rPred(loc,label)==>)
		\find(==> relaxedNoRaW(ls, rLs, wLs, futRLs))
		\varcond(\new(tempVar, \dependingOn(loc1)),
		        \new(tempVar, \dependingOn(loc2)))

		\replacewith(==> relaxedNoRaW(setMinus(ls, loc), rLs, wLs, futRLs) & relaxedNoWAtHistory(tempVar, timestamp - 1))

		\add(tempVar = intersect(loc,ls), !tempVar=empty ==>);

		\add(intersect(loc,ls)=empty==>)

		\heuristics(dep_pred_known_2)
   };

   wPredAndRelaxedNoWaR{
   		\schemaVar \term LocSet loc, ls, rLs, wLs, futRLs;
   		\schemaVar \skolemTerm LocSet tempVar;
   		\schemaVar \term int label;

   		\assumes(wPred(loc,label)==>)
   		\find(==> relaxedNoWaR(ls, rLs, wLs, futRLs))
   		\varcond(\new(tempVar, \dependingOn(loc1)),
   		        \new(tempVar, \dependingOn(loc2)))

   		\replacewith(==> relaxedNoWaR(setMinus(ls, loc), rLs, wLs, futRLs) & relaxedNoRAtHistory(tempVar, timestamp - 1))

   		\add(tempVar = intersect(loc,ls), !tempVar=empty ==>);

   		\add(intersect(loc,ls) = empty==>)

   		\heuristics(dep_pred_known_2)
   };

   wPredAndRelaxedNoWaW{
   		\schemaVar \term LocSet loc, ls, wLs, futRLs;
   		\schemaVar \skolemTerm LocSet tempVar;
   		\schemaVar \term int label;

   		\assumes(wPred(loc,label)==>)
   		\find(==> relaxedNoWaW(ls, wLs, futRLs))
   		\varcond(\new(tempVar, \dependingOn(loc1)),
   		        \new(tempVar, \dependingOn(loc2)))

   		\replacewith(==> relaxedNoWaW(setMinus(ls, loc), wLs, futRLs) & relaxedNoWAtHistory(tempVar, timestamp - 1))

   		\add(tempVar = intersect(loc,ls), !tempVar=empty ==>);

   		\add(intersect(loc,ls) = empty==>)

   		\heuristics(dep_pred_known_2)
   };

//======================================================================================================================
//=============================================Relaxed xPred and Relaxed Predicates=====================================
//======================================================================================================================
/* To write? */

//======================================================================================================================
//=========================================Relaxed noX TO Relaxed History===============================================
//======================================================================================================================

    relaxedNoRToRelaxedNoRAtHistory {
        \schemaVar \term LocSet ls;

        \find(relaxedNoR(ls))
        \replacewith(relaxedNoRAtHistory(ls, timestamp))

        \heuristics(concrete)
    };

    relaxedNoWToRelaxedNoWAtHistory {
        \schemaVar \term LocSet ls;

        \find(relaxedNoW(ls))
        \replacewith(relaxedNoWAtHistory(ls, timestamp))

        \heuristics(concrete)
    };

    relaxedNoRaWToRelaxedNoRaWAtHistory {
        \schemaVar \term LocSet ls, rLs, wLs, futRLs;

        \find(relaxedNoRaW(ls, rLs, wLs, futRLs))
        \replacewith(relaxedNoRaWAtHistory(ls, timestamp))

        \heuristics(concrete)
    };

    relaxedNoWaRToRelaxedNoWaRAtHistory {
        \schemaVar \term LocSet ls, rLs, wLs, futRLs;

        \find(relaxedNoWaR(ls, rLs, wLs, futRLs))
        \replacewith(relaxedNoWaRAtHistory(ls, timestamp))

        \heuristics(concrete)
    };

    relaxedNoWaWToRelaxedNoWaWAtHistory {
        \schemaVar \term LocSet ls, wLs, futRLs;

        \find(relaxedNoWaW(ls, wLs, futRLs))
        \replacewith(relaxedNoWaWAtHistory(ls, timestamp))

        \heuristics(concrete)
    };


//----------------------------------------------------------------------------------------------------------------------
//------------------------------------------Relaxed History Predicates and NORMAL rPred and wPred----------------------
//----------------------------------------------------------------------------------------------------------------------
 /*  rPredAndRelaxedNoRaWAtHistoryAtTimeStamp{
        \schemaVar \term LocSet loc1, loc2;
        \schemaVar \term int label, ts;

        \assumes(rPred(loc1,label) ==>)
        \find(==> relaxedNoRaWAtHistory(loc2,ts))
        \replacewith(==>relaxedNoWAtHistory(intersect(loc2, loc1), ts-2) & relaxedNoRaWAtHistory(setMinus(loc2, loc1), ts-2))
        \add(ts=timestamp+1,intersect(loc2, loc1) != empty ==>);

        \add(ts=timestamp+1,intersect(loc2, loc1) = empty ==>)
        \heuristics(dep_pred_known_2b,noEqApp)
    };*/

//----------------------------------------------------------------------------------------------------------------------
//------------------------------------------Relaxed History Predicates and relaxed rPred and wPred----------------------
//----------------------------------------------------------------------------------------------------------------------

//------------------------------------------A. Same Label
//------------------------------------------
//------------------------------------------


//------------------------------------------1. Same Label both on left (xPred(lb), xAtHistory(lb)==>)
    relaxedRPredAndRelaxedNoRAtHistorySameLabel{
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int label;

        \assumes(relaxedRPred(loc1,label) ==>)
        \find(relaxedNoRAtHistory(loc2,label)==>)
        \add(intersect(loc1,loc2) = empty ==>)
        \heuristics(dep_pred_known_2b,noEqApp)
    };

    relaxedRPredAndRelaxedNoRaWAtHistorySameLabel {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int label;

        \assumes(relaxedRPred(loc1,label) ==>)
        \find(relaxedNoRaWAtHistory(loc2,  label)==>)
        \add(relaxedNoWAtHistory(intersect(loc2,loc1),label - 1)==>)
        \heuristics(dep_pred_known_2b,noEqApp)
    };

    relaxedWPredAndRelaxednoWAtHistorySameLabel{
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int label;

        \assumes(relaxedWPred(loc1,label) ==>)
        \find(relaxedNoWAtHistory(loc2,label)==>)
        \add(intersect(loc1,loc2) = empty ==>)
        \heuristics(dep_pred_known_2b,noEqApp)
    };

    relaxedWPredAndRelaxedNoWaRAtHistorySameLabel {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int label;

        \assumes(relaxedWPred(loc1,label) ==>)
        \find(relaxedNoWaRAtHistory(loc2,  label)==>)
        \add(relaxedNoRAtHistory(intersect(loc2,loc1),label - 1)==>)
        \heuristics(dep_pred_known_2b,noEqApp)
    };

    relaxedWPredAndRelaxedNoWaWAtHistorySameLabel {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int label;

        \assumes(relaxedWPred(loc1,label) ==>)
        \find(relaxedNoWaWAtHistory(loc2,  label)==>)
        \add(relaxedNoWAtHistory(intersect(loc2,loc1),label - 1)==>)
        \heuristics(dep_pred_known_2b,noEqApp)
    };
//------------------------------------------2. Same Label xPred on left (xPred(lb) ==> noXAtHistory(lb))

/* We can't have any of these rules, as we don't have all rPreds accumulated in one.
    relaxedRPredAndRelaxedNoRAtHistoryRightSameLabel{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(relaxedRPred(loc1,label) ==>)
		\find(==> relaxedNoRAtHistory(loc2,label))

		\replacewith(==> intersect(loc1,loc2)=empty & noRAtHistory(loc2,label - 1))//this would only work if we can collect all the read locations in an iteration in one relaxedRPred

		\heuristics(dep_pred_known_3,noEqApp)//,simplify)
	};

   relaxedRPredAndRelaxedNoWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(relaxedRPred(loc1, label) ==>)
		\find(==> relaxedNoWAtHistory(loc2, label))
		\replacewith(==> relaxedNoWAtHistory(loc2, label - 1))

		\heuristics(simplify)
   };

   relaxedRPredAndRelaxedNoRaWAtHistoryRightSameLabel {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int label;

        \assumes(relaxedRPred(loc1,label) ==>)//should be same as rLs
        \find(==> relaxedNoRaWAtHistory(loc2, label))
        \replacewith(==> relaxedNoRaWAtHistory(setMinus(loc2,loc1),label - 1) & (intersect(loc1,loc2) != empty -> relaxedNoWAtHistory(intersect(loc2,loc1),label-1)))
        \heuristics(simplify,noEqApp)
   };

   relaxedRPredAndRelaxedNoWARHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(relaxedRPred(loc1,label) ==>)
		\find(==> relaxedNoWaRAtHistory(loc2,label))
		\replacewith(==> relaxedNoWaRAtHistory(loc2, label - 1))

		\heuristics(simplify)
   };

   relaxedRPredAndRelaxedNoWAWHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(relaxedRPred(loc1,label) ==>)
		\find(==> relaxedNoWaWAtHistory(loc2,label))
		\replacewith(==> relaxedNoWaWAtHistory(loc2,label-1))

		\heuristics(simplify)
   };

   relaxedWPredAndRelaxedNoRHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(relaxedWPred(loc1,label) ==>)
		\find(==> relaxedNoRAtHistory(loc2,label))
		\replacewith(==> relaxedNoRAtHistory(loc2,label-1))

		\heuristics(simplify)
   };

   relaxedWPredAndRelaxedNoWHistoryRightSameLabel{
		\schemaVar \term LocSet loc1, loc2;
		\schemaVar \term int label;

		\assumes(relaxedWPred(loc1,label) ==>)
		\find(==> relaxedNoWAtHistory(loc2,label))

		\replacewith(==> intersect(loc1,loc2)=empty & noWAtHistory(loc2,label - 1))

		\heuristics(dep_pred_known_3,noEqApp)//,simplify)
   };

   relaxedWPredAndRelaxedNoRaWAtHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(relaxedWPred(loc1,label) ==>)
		\find(==> relaxedNoRaWAtHistory(loc2,label))
		\replacewith(==> relaxedNoRaWAtHistory(loc2,label-1))

		\heuristics(simplify)
   };

   relaxedWPredAndRelaxedNoWaRAtHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(relaxedWPred(loc1,label) ==>)
		\find(==> relaxedNoWaRAtHistory(loc2,label))
		\add(==> relaxedNoWaRAtHistory(setMinus(loc2,loc1),label-1) & (intersect(loc1,loc2) != empty -> noRAtHistory(intersect(loc2,loc1),label-1)))
		\heuristics(dep_pred_known_2b,noEqApp)
   };

   relaxedWPredAndRelaxedNoWaWAtHistoryRightSameLabel {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label;

		\assumes(relaxedWPred(loc1,label) ==>)
		\find(==> relaxedNoWaWAtHistory(loc2,label))
		\add(==> relaxedNoWaWAtHistory(setMinus(loc2,loc1),label-1) & (intersect(loc1,loc2) != empty -> relaxedNoWAtHistory(intersect(loc2,loc1),label-1)))
		\heuristics(dep_pred_known_2b,noEqApp)
   };*/

//------------------------------------------Different Label
//------------------------------------------
//------------------------------------------

//------------------------------------------1. xPred then History Pred both on left (xPred(old), xAtHistory(new) ==>)
    relaxedRPredBEFORERelaxedNoRaWAtHistory {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int old, new;

		\assumes(relaxedRPred(loc1, old) ==>)
		\find(relaxedNoRaWAtHistory(loc2, new)==>)
		\add(\if(new = old + 1)
		\then(relaxedNoWAtHistory(intersect(loc1,loc2),  old - 1))
		\else(relaxedNoRaWAtHistory(loc2, new)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};

    relaxedWPredBEFORERelaxedNoWaRAtHistory {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int old, new;

		\assumes(relaxedWPred(loc1, old) ==>)
		\find(relaxedNoWaRAtHistory(loc2, new)==>)
		\add(\if(new = old + 1)
		\then(relaxedNoRAtHistory(intersect(loc1,loc2), old - 1))
		\else(relaxedNoWaRAtHistory(loc2, new)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};

    relaxedWPredBEFORERelaxedNoWaWAtHistory {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int old, new;

		\assumes(relaxedWPred(loc1, old) ==>)
		\find(relaxedNoWaWAtHistory(loc2, new)==>)
		\add(\if(new = old + 1)
		\then(relaxedNoWAtHistory(intersect(loc1,loc2), old - 1))
		\else(relaxedNoWaWAtHistory(loc2, new)) ==>)
		\heuristics(dep_pred_known,noEqApp)
	};

//------------------------------------------2. xPred then History Pred on right (xPred(old) ==> noXAtHistory(new))

	relaxedRPredBEFORERelaxedNoRAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int old, new;

		\assumes(relaxedRPred(loc1,old) ==>)
		\find   (==> relaxedNoRAtHistory(loc2, new))
		\replacewith(==> \if(new = old + 1) \then(intersect(loc1, loc2) = empty) \else(relaxedNoRAtHistory(loc2, new)))
		\heuristics(dep_pred_known,noEqApp)
	};

	relaxedRPredBEFORERelaxedNoRaWAtHistoryRight {
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int old, new;

		\assumes(relaxedRPred(loc1,old) ==>)
		\find (==> relaxedNoRaWAtHistory(loc2, new))
		\replacewith(==>\if(new = old + 1)
		\then(relaxedNoRaWAtHistory(setMinus(loc2,loc1), new) & relaxedNoWAtHistory(intersect(loc1,loc2),  old - 1))
		\else(relaxedNoRaWAtHistory(loc2, new)))
		\heuristics(dep_pred_known,noEqApp)
	};

	relaxedWPredBEFORERelaxedNoWAtHistoryRight {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int old, new;

        \assumes(relaxedWPred(loc1,old) ==>)
        \find   (==> relaxedNoWAtHistory(loc2, new))
        \replacewith(==> \if(new = old + 1) \then(intersect(loc1, loc2) = empty) \else(relaxedNoWAtHistory(loc2, new)))
        \heuristics(dep_pred_known,noEqApp)
    };

    relaxedWPredBEFORERelaxedNoWaRAtHistoryRight {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int old, new;

        \assumes(relaxedWPred(loc1,old) ==>)
        \find   (==> relaxedNoWaRAtHistory(loc2, new))
        \replacewith(==> \if(new = old + 1)
        \then(relaxedNoWaRAtHistory(setMinus(loc2,loc1), new) & relaxedNoRAtHistory(intersect(loc1,loc2),  old - 1))
         \else(relaxedNoWaRAtHistory(loc2, new)))
        \heuristics(dep_pred_known,noEqApp)
    };

    relaxedWPredBEFORERelaxedNoWaWAtHistoryRight {
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int old, new;

        \assumes(relaxedWPred(loc1,old) ==>)
        \find   (==> relaxedNoWaWAtHistory(loc2, new))
        \replacewith(==> \if(new = old + 1)
        \then(relaxedNoWaWAtHistory(setMinus(loc2,loc1), new) & relaxedNoWAtHistory(intersect(loc1,loc2),  old - 1))
        \else(relaxedNoWaWAtHistory(loc2, new)))
        \heuristics(dep_pred_known,noEqApp)
    };

//------------------------------------------History Pred then xPred both on left (noXAtHistory(old), xPred(new) ==>)
    relaxedRPredAFTERRelaxedNoRAtHistory{
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int old, new;

        \assumes(relaxedRPred(loc1, new) ==>)
        \find(relaxedNoRAtHistory(loc2,old)==>)
        \add(\if(new = old + 1)
        \then(relaxedNoRAtHistory(setMinus(loc2,loc1), new))
        \else(relaxedNoRAtHistory(loc2, old))==>)
        \heuristics(dep_pred_known,noEqApp)
    };

/* can't have a rule like this as in the relaxed version many xPreds can have the same label
    rPredAFTERnoWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWAtHistory(loc2,label1))
		\else(noWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};*/


    relaxedRPredAFTERRelaxedNoRaWAtHistory{
        \schemaVar \term LocSet loc1,loc2;
        \schemaVar \term int old, new;

        \assumes(relaxedRPred(loc1, new) ==>)
        \find(relaxedNoRaWAtHistory(loc2,old)==>)
        \add(\if(new = old + 1)
        \then(relaxedNoRaWAtHistory(setMinus(loc2,loc1),new))
        \else(noRaWAtHistory(loc2,old))==>)
        \heuristics(dep_pred_known,noEqApp)
    };

/* can't have a rule like this as in the relaxed version many xPreds can have the same label
    rPredAFTERnoWaRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWaRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWaRAtHistory(loc2,label1))
		\else(noWaRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	rPredAFTERnoWAWHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(rPred(loc1,label1) ==>)
		\find(noWaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noWaWAtHistory(loc2,label1))
		\else(noWaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

	wPredAFTERnoRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noRAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noRAtHistory(loc2,label1))
		\else(noRAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
*/

	relaxedWPredAFTERRelaxedNoWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int old, new;

		\assumes(relaxedWPred(loc1, new) ==>)
		\find(relaxedNoWAtHistory(loc2, old)==>)
		\add(\if(new = old + 1)
		\then(relaxedNoWAtHistory(setMinus(loc2,loc1), new))
		\else(relaxedNoWAtHistory(loc2, old))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

/* can't have a rule like this as in the relaxed version many xPreds can have the same label
	wPredAFTERnoRaWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int label1, label2;

		\assumes(wPred(loc1,label1) ==>)
		\find(noRaWAtHistory(loc2,label2)==>)
		\add(\if(label2=label1+1)
		\then(noRaWAtHistory(loc2,label1))
		\else(noRaWAtHistory(loc2,label2))==>)
		\heuristics(dep_pred_known,noEqApp)
	};
*/
	relaxedWPredAFTERRelaxedNoWaRAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int old, new;

		\assumes(relaxedWPred(loc1, new) ==>)
		\find(relaxedNoWaRAtHistory(loc2, old)==>)
		\add(\if(new = old + 1)
		\then(relaxedNoWaRAtHistory(setMinus(loc2,loc1), new))
		\else(relaxedNoWaRAtHistory(loc2, old))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

    relaxedWPredAFTERRelaxedNoWaWAtHistory{
		\schemaVar \term LocSet loc1,loc2;
		\schemaVar \term int old, new;

		\assumes(relaxedWPred(loc1, new) ==>)
		\find(relaxedNoWaWAtHistory(loc2, old)==>)
		\add(\if(new = old + 1)
		\then(relaxedNoWaWAtHistory(setMinus(loc2,loc1), new))
		\else(relaxedNoWaWAtHistory(loc2, old))==>)
		\heuristics(dep_pred_known,noEqApp)
	};

//------------------------------------------History Pred on right then xPred (xPred(new) ==> xAtHistory(old))
/* This category is useless and also doesn't exist in the original version */
}