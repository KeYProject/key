// This file contains the RULES for location sets.
// Find the DECLARATIONS in file locSet.key

\rules(programRules:Java){

    //--------------------------------------------------------------------------
    //axioms for elementOf
    //--------------------------------------------------------------------------

    elementOfEmpty {
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(elementOf(o, f, empty))

        \replacewith(false)

        \heuristics(concrete)
    };


    elementOfAllLocs {
        \schemaVar \term Object o;
	\schemaVar \term Field f;

        \find(elementOf(o, f, allLocs))

        \replacewith(true)

        \heuristics(concrete)
    };


    elementOfSingleton {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f, f2;

        \find(elementOf(o, f, singleton(o2, f2)))

        \replacewith(o = o2 & f = f2)

        \heuristics(simplify)
    };


    elementOfUnion {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, union(s, s2)))

        \replacewith(elementOf(o, f, s) | elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };


    elementOfIntersect {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, intersect(s, s2)))

        \replacewith(elementOf(o, f, s) & elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };


    elementOfSetMinus {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;

        \find(elementOf(o, f, setMinus(s, s2)))

        \replacewith(elementOf(o, f, s) & !elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };


    elementOfInfiniteUnion {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \variables alpha av;
	\schemaVar \term LocSet s;

        \find(elementOf(o, f, infiniteUnion{av;}(s)))
        \varcond(\notFreeIn(av, o, f))

        \replacewith(\exists av; elementOf(o, f, s))

        \heuristics(simplify)
    };


    elementOfInfiniteUnion2Vars {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \variables alpha av;
	\schemaVar \variables beta bv;
	\schemaVar \term LocSet s;

        \find(elementOf(o, f, infiniteUnion{av, bv;}(s)))
        \varcond(\notFreeIn(av, o, f), \notFreeIn(bv, o, f))

        \replacewith(\exists av; \exists bv; elementOf(o, f, s))

        \heuristics(simplify)
    };


    elementOfAllFields {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;

        \find(elementOf(o, f, allFields(o2)))

        \replacewith(o = o2)

        \heuristics(concrete)
    };


    allFieldsEq {
        \schemaVar \term Object o1, o2;
        \find(allFields(o1) = allFields(o2))
        \replacewith(o1 = o2)
        \heuristics(simplify)
    };

    elementOfAllObjects {
        \schemaVar \term Object o;
	\schemaVar \term Field f, f2;

        \find(elementOf(o, f, allObjects(f2)))

        \replacewith(f = f2)

        \heuristics(concrete)
    };


   // change upper to exclusive (in line with other definitions?)
    elementOfArrayRange {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;
	\schemaVar \term int lower, upper;
	\schemaVar \variables int iv;

        \find(elementOf(o, f, arrayRange(o2, lower, upper)))
        \varcond(\notFreeIn(iv, f, lower, upper))

        \replacewith(o = o2 & \exists iv; (f = arr(iv) & lower <= iv & iv <= upper))

        \heuristics(simplify_enlarging)
    };


   // change upper to exclusive (in line with other definitions?)
    elementOfArrayRangeConcrete {
        \schemaVar \term Object o, o2;
	\schemaVar \term int idx, lower, upper;

        \find(elementOf(o, arr(idx), arrayRange(o2, lower, upper)))

        \replacewith(o = o2 & lower <= idx & idx <= upper)

        \heuristics(simplify)
    };


    elementOfFreshLocs {
        \schemaVar \term Object o;
	\schemaVar \term Field f;
	\schemaVar \term Heap h;

        \find(elementOf(o, f, freshLocs(h)))

        \replacewith( o != null & !boolean::select(h,o,java.lang.Object::<created>)=TRUE)

        \heuristics(concrete)
    };




    //--------------------------------------------------------------------------
    //EQ versions of axioms (these are lemmata)
    //--------------------------------------------------------------------------
    elementOfUnionEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) | elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };


    elementOfIntersectEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) & elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };


    elementOfSetMinusEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, s2) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel

        \replacewith(elementOf(o, f, s) & !elementOf(o, f, s2))

        \heuristics(simplify_enlarging)
    };


    elementOfInfiniteUnionEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \variables alpha av;
	\schemaVar \term LocSet s;
        \schemaVar \term LocSet EQ;

        \assumes(infiniteUnion{av;}(s) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(av, o, f))

        \replacewith(\exists av; elementOf(o, f, s))

        \heuristics(simplify)
    };


    elementOfInfiniteUnion2VarsEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
	\schemaVar \variables alpha av;
	\schemaVar \variables beta bv;
	\schemaVar \term LocSet s;
	\schemaVar \term LocSet EQ;

        \assumes(infiniteUnion{av, bv;}(s) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(av, o, f), \notFreeIn(bv, o, f))

        \replacewith(\exists av; \exists bv; elementOf(o, f, s))

        \heuristics(simplify)
    };


    elementOfArrayRangeEQ {
        \schemaVar \term Object o, o2;
	\schemaVar \term Field f;
	\schemaVar \term int lower, upper;
	\schemaVar \variables int iv;
	\schemaVar \term LocSet EQ;

        \assumes(arrayRange(o2, lower, upper) = EQ ==>)
        \find(elementOf(o, f, EQ))
        \sameUpdateLevel
        \varcond(\notFreeIn(iv, f, lower, upper))

        \replacewith(o = o2 & \exists iv; (f = arr(iv) & lower <= iv & iv <= upper))

        \heuristics(simplify)
    };

    //--------------------------------------------------------------------------
    //axioms for set predicates (reduce to elementOf)
    //--------------------------------------------------------------------------

    equalityToElementOf {
    	\schemaVar \term LocSet s, s2;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;

    	\find(s = s2)
	\varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

    	\replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) <-> elementOf(ov, fv, s2)))

	\heuristics(semantics_blasting)
    };


    // proven with KeY (CS)
    equalityToElementOfRight {
    	\schemaVar \term LocSet s, s2;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;

    	\find(==> s = s2)
	\varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

    	\replacewith(==> \forall ov; \forall fv; (elementOf(ov, fv, s) <-> elementOf(ov, fv, s2)))

        \heuristics(setEqualityBlastingRight)
    };


    emptyEqualsSingleton {
	\schemaVar \term Object o;
	\schemaVar \term Field f;

    	\find(empty = singleton(o, f))

    	\replacewith(false)

        \heuristics(concrete)
    };


    singletonEqualsEmpty {
	\schemaVar \term Object o;
	\schemaVar \term Field f;

    	\find(singleton(o, f) = empty)
	   	\replacewith(false)

        \heuristics(concrete)
    };


    unionWithSingletonEqualsUnionWithSingleton {
        \schemaVar \term LocSet s1, s2;
	\schemaVar \term Object o;
	\schemaVar \term Field f;

        \find(union(s1, singleton(o, f)) = union(s2, singleton(o, f)))

        \replacewith(setMinus(s1, singleton(o, f)) = setMinus(s2, singleton(o, f)))
// TODO: why is this a simplification? (DB)
        \heuristics(simplify)
    };


    unionWithSingletonEqualsUnionWithSingleton_2 {
        \schemaVar \term LocSet s1, s2;
	\schemaVar \term Object o;
	\schemaVar \term Field f;

        \find(union(singleton(o, f), s1) = union(singleton(o, f), s2))

        \replacewith(setMinus(s1, singleton(o, f)) = setMinus(s2, singleton(o, f)))

        \heuristics(simplify)
    };


    subsetToElementOf {
        \schemaVar \term LocSet s, s2;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;

        \find(subset(s, s2))
	\varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

	\replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s) -> elementOf(ov, fv, s2)))
	\heuristics(semantics_blasting)
//        \heuristics(simplify)
    };


    // proven with KeY (CS)
    subsetToElementOfRight {
        \schemaVar \term LocSet s, s2;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;

        \find(==> subset(s, s2))
	\varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

	\replacewith(==> \forall ov; \forall fv; (elementOf(ov, fv, s) -> elementOf(ov, fv, s2)))

        \heuristics(setEqualityBlastingRight)
    };


    // proven with KeY (CS)
    elementOfSubsetImpliesElementOfSuperset {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(s, s2) ==>)

	\find(elementOf(o,f,s) ==>)
	
	\add(elementOf(o,f,s2) ==>)

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    noElementOfSupersetImpliesNoElementOfSubset {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(s, s2) ==>)
	\find(==> elementOf(o,f,s2)) 
	\add(==> elementOf(o,f,s))

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    subsetSingletonLeft {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(subset(singleton(o,f), s))

	\replacewith(elementOf(o,f,s))

        \heuristics(simplify)
    };


    // proven with KeY (CS)
    subsetSingletonLeftEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o,f) = EQ ==>)
        \find(subset(EQ, s))
        \sameUpdateLevel

	\replacewith(elementOf(o,f,s))

        \heuristics(simplify)
    };


    // proven with KeY (CS)
    subsetSingletonRight {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(subset(s, singleton(o,f)))

	\replacewith(s = empty | s = singleton(o,f))

        \heuristics(simplify)
    };


    // proven with KeY (CS)
    subsetSingletonRightEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o,f) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

	\replacewith(s = empty | s = singleton(o,f))

        \heuristics(simplify)
    };


    // proven with KeY (CS)
    subsetUnionLeft {
        \schemaVar \term LocSet s, s2, s3;

        \find(subset(union(s, s2), s3))

	\replacewith(subset(s, s3) & subset(s2, s3))

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    subsetUnionLeftEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(subset(EQ, s3))
        \sameUpdateLevel

	\replacewith(subset(s, s3) & subset(s2, s3))

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    subsetOfUnionWithItSelf1 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, union(s, s2)))

	\replacewith(true)

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    subsetOfUnionWithItSelfEQ1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

	\replacewith(true)

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    subsetOfUnionWithItSelf2 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, union(s2, s)))

	\replacewith(true)

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    subsetOfUnionWithItSelfEQ2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(union(s2, s) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

	\replacewith(true)

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    subsetOfIntersectWithItSelf1 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, intersect(s, s2)))

	\replacewith(subset(s, s2))

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    subsetOfIntersectWithItSelfEQ1 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s, s2) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

	\replacewith(subset(s, s2))

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    subsetOfIntersectWithItSelf2 {
        \schemaVar \term LocSet s, s2;

        \find(subset(s, intersect(s2, s)))

	\replacewith(subset(s, s2))

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    subsetOfIntersectWithItSelfEQ2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term LocSet EQ;

        \assumes(intersect(s2, s) = EQ ==>)
        \find(subset(s, EQ))
        \sameUpdateLevel

	\replacewith(subset(s, s2))

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    allFieldsSubsetOf {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(subset(allFields(o), s) ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

	\replacewith(true)

        \heuristics(concrete)
    };


    // proven with KeY (CS)
    elementOfSubsetOfUnion1 {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \assumes(subset(s, union(s2, s3)),
             ==> elementOf(o, f, s2))
        \find(elementOf(o, f, s))
        \sameUpdateLevel

	\add(elementOf(o, f, s) <-> elementOf(o, f, intersect(s, s3)) ==>)

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    elementOfSubsetOfUnion2 {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \assumes(subset(s, union(s2, s3)),
             ==> elementOf(o, f, s3))
        \find(elementOf(o, f, s))
        \sameUpdateLevel

	\add(elementOf(o, f, s) <-> elementOf(o, f, intersect(s, s2)) ==>)

        \heuristics(simplify_enlarging)
    };


    disjointToElementOf {
        \schemaVar \term LocSet s, s2;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;

        \find(disjoint(s, s2))
	\varcond(\notFreeIn(ov, s, s2), \notFreeIn(fv, s, s2))

        \replacewith(\forall ov; \forall fv; (!elementOf(ov, fv, s) | !elementOf(ov, fv, s2)))
	\heuristics(semantics_blasting)
//        \heuristics(simplify)
    };


    // proven with KeY (CS)
    disjointDefinition {
        \schemaVar \term LocSet s, s2;

        \find(disjoint(s, s2))

	\replacewith(intersect(s, s2) = empty)
	//\heuristics(semantics_blasting)
        \heuristics(simplify)
    };


    // proven with KeY (CS)
    disjointNotInOtherLocset1 {
        \schemaVar \term LocSet s, s2;
	\schemaVar \term Object o;
	\schemaVar \term Field f;

        \assumes(intersect(s, s2) = empty ==>)
        \find(elementOf(o,f,s) ==>)

	\add(==> elementOf(o,f,s2))

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    disjointNotInOtherLocset2 {
        \schemaVar \term LocSet s, s2;
	\schemaVar \term Object o;
	\schemaVar \term Field f;

        \assumes(intersect(s, s2) = empty ==>)
        \find(elementOf(o,f,s2) ==>)

	\add(==> elementOf(o,f,s))

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    disjointAndSubset1 {
        \schemaVar \term LocSet s, s2, s3;

        \assumes(intersect(s2, s3) = empty ==>)
        \find(subset(s, s2) ==>)

	\add(intersect(s, s3) = empty ==>)

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    disjointAndSubset2 {
        \schemaVar \term LocSet s, s2, s3;

        \assumes(intersect(s2, s3) = empty ==>)
        \find(subset(s, s3) ==>)

	\add(intersect(s, s2) = empty ==>)

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    disjointAllFields {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(allFields(o), s) = empty ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

	\replacewith(false)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointAllFields_2 {
        \schemaVar \term Object o, o2;
        \schemaVar \term Field f;

        \find(intersect(allFields(o), allFields(o2)) = empty)

	\replacewith(o != o2)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointAllObjects {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(intersect(allObjects(f), s) = empty ==>)
        \find(elementOf(o, f, s))
        \sameUpdateLevel

	\replacewith(false)

        \heuristics(concrete)
    };

    // proven with KeY (CS)
    disjointInfiniteUnion {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables int iv;

        \find(intersect(infiniteUnion{iv;}(s2), s) = empty)
        \varcond(\notFreeIn(iv, s))

	\replacewith(\forall iv;(intersect(s2, s) = empty))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    disjointInfiniteUnion_2 {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \variables int iv;

        \find(intersect(s, infiniteUnion{iv;}(s2)) = empty)
        \varcond(\notFreeIn(iv, s))

	\replacewith(\forall iv;(intersect(s, s2) = empty))

        \heuristics(simplify)
    };

    // proven with KeY (CS)
    intersectAllFieldsFreshLocs {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(intersect(allFields(o), freshLocs(h)) = empty)
        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)
        \heuristics(simplify)
    };


    // proven with KeY (CS)
    disjointAndSubset_3 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s1, s2) = empty ==>)
        \find(subset(s4, union(s2, s3)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    disjointAndSubset_4 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s1, s2) = empty ==>)
        \find(subset(s4, union(s3, s2)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    disjointAndSubset_5 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s2, s1) = empty ==>)
        \find(subset(s4, union(s2, s3)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    disjointAndSubset_6 {
        \schemaVar \term LocSet s1, s2, s3, s4;

        \assumes(intersect(s2, s1) = empty ==>)
        \find(subset(s4, union(s3, s2)) ==>)
        \add(intersect(s1, s3) = empty -> intersect(s1, s4) = empty ==>)
        \heuristics(simplify_enlarging)
    };


    createdInHeapToElementOf {
    	\schemaVar \term LocSet s;
    	\schemaVar \term Heap h;
	\schemaVar \variables Object ov;
	\schemaVar \variables Field fv;

        \find(createdInHeap(s, h))
	\varcond(\notFreeIn(ov, s, h), \notFreeIn(fv, s, h))

        \replacewith(\forall ov; \forall fv; (elementOf(ov, fv, s)
                                              -> ov = null
                                                 | boolean::select(h, ov, java.lang.Object::<created>) = TRUE))
        \heuristics(classAxiom)
    };



    //--------------------------------------------------------------------------
    //lemmata for empty and allLocs
    //--------------------------------------------------------------------------

    unionWithEmpty {
        \schemaVar \term LocSet s;

        \find(union(empty, s))

        \replacewith(s)

        \heuristics(concrete)
    };


    unionWithAllLocs {
        \schemaVar \term LocSet s;

        \find(union(allLocs, s))

        \replacewith(allLocs)

        \heuristics(concrete)
    };


    intersectWithEmpty {
        \schemaVar \term LocSet s;

        \find(intersect(empty, s))

        \replacewith(empty)

        \heuristics(concrete)
    };

    intersectWithAllLocs {
        \schemaVar \term LocSet s;

        \find(intersect(allLocs, s))

        \replacewith(s)

        \heuristics(concrete)
    };


    // the following set of rules should be the only one needed 
    // for empty elimination as the strategies take care to commute the 
    // the empty set always on the second place
    // the other rules are left for backward proof loading copatibility
 // begin
    unionWithEmptyRight {
        \schemaVar \term LocSet s;

        \find(union(s, empty))

        \replacewith(s)

	\displayname "unionWithEmpty"
        \heuristics(concrete)
    };


    unionWithAllLocsRight {
        \schemaVar \term LocSet s;

        \find(union(s, allLocs))

        \replacewith(allLocs)

	\displayname "unionWithAllLocs"
        \heuristics(concrete)
    };


    intersectWithEmptyRight {
        \schemaVar \term LocSet s;

        \find(intersect(s, empty))

        \replacewith(empty)

	\displayname "intersectWithEmpty"
        \heuristics(concrete)
    };

    intersectWithAllLocsRight {
        \schemaVar \term LocSet s;

        \find(intersect(s, allLocs))

        \replacewith(s)

	\displayname "intersectWithAllLocs"
        
        \heuristics(concrete)
    };

//  end 

    setMinusWithEmpty1 {
        \schemaVar \term LocSet s;

        \find(setMinus(s, empty))

        \replacewith(s)
	
	\displayname "setMinusWithEmpty"
        \heuristics(concrete)
    };


    setMinusWithEmpty2 {
        \schemaVar \term LocSet s;

        \find(setMinus(empty, s))

        \replacewith(empty)

	\displayname "setMinusWithEmpty"
        \heuristics(concrete)
    };


    setMinusWithAllLocs {
        \schemaVar \term LocSet s;

        \find(setMinus(s, allLocs))

        \replacewith(empty)
        
	\displayname "setMinusWithAllLocs"
        \heuristics(concrete)
    };



    //--------------------------------------------------------------------------
    //lemmata for subset
    //--------------------------------------------------------------------------

    subsetWithEmpty {
        \schemaVar \term LocSet s;

        \find(subset(empty, s))

        \replacewith(true)

        \heuristics(concrete)
    };

   subsetOfEmpty {
        \schemaVar \term LocSet s;

        \find(subset(s, empty))

        \replacewith(s = empty)

        \heuristics(concrete)
    };


    subsetWithAllLocs {
        \schemaVar \term LocSet s;

        \find(subset(s, allLocs))

        \replacewith(true)

	\displayname "subsetOfAllLocs" // should be the name, but for backward compatibility only displayname
        \heuristics(concrete)
    };

    subsetWithAllLocs2 {
        \schemaVar \term LocSet s;

        \find(subset(allLocs, s))
        \replacewith(s = allLocs)

	\displayname "subsetWithAllLocs"
        \heuristics(concrete)
    };


    //--------------------------------------------------------------------------
    //lemmata for disjoint
    //--------------------------------------------------------------------------

    disjointWithEmpty {
        \schemaVar \term LocSet s;

        \find(disjoint(empty, s))

        \replacewith(true)

        \heuristics(concrete)
    };

    \lemma
    disjointWithSingleton1 {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \find(intersect(s,singleton(o,f))=empty)
        \replacewith(!elementOf(o,f,s))
        \heuristics(simplify)
        \displayname "disjointWithSingleton"
    };

    \lemma
    disjointWithSingleton2 {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \find(intersect(singleton(o,f),s)=empty)
        \replacewith(!elementOf(o,f,s))
        \heuristics(simplify)
        \displayname "disjointWithSingleton"
    };


    //--------------------------------------------------------------------------
    //lemmata for createdInHeap
    //--------------------------------------------------------------------------

    createdInHeapWithEmpty {
        \schemaVar \term Heap h;

        \find(createdInHeap(empty, h))

        \replacewith(true)

        \heuristics(concrete)
    };


    createdInHeapWithSingleton {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(createdInHeap(singleton(o, f), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };


    createdInHeapWithUnion {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Heap h;

        \find(==> createdInHeap(union(s, s2), h))

        \replacewith(==> createdInHeap(s, h));
        \replacewith(==> createdInHeap(s2, h))

        \heuristics(simplify_enlarging)
    };


    createdInHeapWithSetMinusFreshLocs {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;

        \find(createdInHeap(setMinus(s, freshLocs(h)), h))

        \replacewith(true)

        \heuristics(concrete)
    };


    createdInHeapWithAllFields {
    	\schemaVar \term Object o;
        \schemaVar \term Heap h;

        \find(createdInHeap(allFields(o), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };


    createdInHeapWithArrayRange {
    	\schemaVar \term Object o;
	\schemaVar \term int lower, upper;
        \schemaVar \term Heap h;

        \find(createdInHeap(arrayRange(o, lower, upper), h))

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE | upper < lower)

        \heuristics(simplify_enlarging)
    };


    createdInHeapWithSelect {
    	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term Heap h;

        \find(==> createdInHeap(LocSet::select(h, o, f), h))

        \replacewith(==> wellFormed(h))

        \heuristics(concrete)
    };


    createdInHeapWithObserver {
        \schemaVar \term LocSet obs;
        \schemaVar \term Heap h;

        \find(==> createdInHeap(obs, h))
        \varcond(\isObserver(obs, h))

        \replacewith(==> wellFormed(h))

        \heuristics(concrete)
    };


    //--------------------------------------------------------------------------
    //EQ versions of lemmata for createdInHeap
    //--------------------------------------------------------------------------


    createdInHeapWithSingletonEQ {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(singleton(o, f) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };


    createdInHeapWithUnionEQ {
        \schemaVar \term LocSet s, s2;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(==> createdInHeap(EQ, h))

        \replacewith(==> createdInHeap(s, h));
        \replacewith(==> createdInHeap(s2, h))

        \heuristics(simplify_enlarging)
    };


    createdInHeapWithSetMinusFreshLocsEQ {
        \schemaVar \term LocSet s;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, freshLocs(h)) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(true)

        \heuristics(concrete)
    };


    createdInHeapWithAllFieldsEQ {
    	\schemaVar \term Object o;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(allFields(o) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE)

        \heuristics(simplify_enlarging)
    };


    createdInHeapWithArrayRangeEQ {
    	\schemaVar \term Object o;
	\schemaVar \term int lower, upper;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(arrayRange(o, lower, upper) = EQ ==>)
        \find(createdInHeap(EQ, h))
        \sameUpdateLevel

        \replacewith(o = null | boolean::select(h, o, java.lang.Object::<created>) = TRUE | upper < lower)

        \heuristics(simplify_enlarging)
    };


    createdInHeapWithSelectEQ {
    	\schemaVar \term Object o;
	\schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(LocSet::select(h, o, f) = EQ ==>)
        \find(==> createdInHeap(EQ, h))

        \replacewith(==> wellFormed(h))

        \heuristics(concrete)
    };


    createdInHeapWithObserverEQ {
        \schemaVar \term LocSet obs;
        \schemaVar \term Heap h;
        \schemaVar \term LocSet EQ;

        \assumes(obs = EQ ==>)
        \find(==> createdInHeap(EQ, h))
        \varcond(\isObserver(obs, h))

        \replacewith(==> wellFormed(h))

        \heuristics(concrete)
    };



    //--------------------------------------------------------------------------
    //other lemmata for proving createdness
    //--------------------------------------------------------------------------

    referencedObjectIsCreatedRight {
    	\schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(==> deltaObject::select(h, o, f) = null)
        \find(==> boolean::select(h,
                                  deltaObject::select(h, o, f),
                                  java.lang.Object::<created>) = TRUE)

        \replacewith(==> wellFormed(h))

	\heuristics(concrete)
    };


    referencedObjectIsCreatedRightEQ {
    	\schemaVar \term Heap h;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Object EQ;

        \assumes(deltaObject::select(h, o, f) = EQ ==> EQ = null)
        \find(==> boolean::select(h,
                                  EQ,
                                  java.lang.Object::<created>) = TRUE)

        \replacewith(==> wellFormed(h))

	\heuristics(concrete)
    };





    //--------------------------------------------------------------------------
    //some other lemmata
    //--------------------------------------------------------------------------

    // proven with KeY (CS)
    unionEqualsEmpty {
        \schemaVar \term LocSet s, s2, s3;

        \find(union(s, s2) = empty)

	\replacewith(s = empty & s2 = empty)

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    unionEqualsEmptyEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(EQ = empty)
        \sameUpdateLevel

	\replacewith(s = empty & s2 = empty)

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    setMinusOfUnion {
        \schemaVar \term LocSet s, s2, s3;

        \find(setMinus(union(s, s2), s3))

	\replacewith(union(setMinus(s, s3), setMinus(s2, s3)))

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    setMinusOfUnionEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(union(s, s2) = EQ ==>)
        \find(setMinus(EQ, s3))
        \sameUpdateLevel

	\replacewith(union(setMinus(s, s3), setMinus(s2, s3)))

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    subsetWithSetMinusLeft {
        \schemaVar \term LocSet s, s2, s3;

        \find(subset(setMinus(s, s2), s3))

	\replacewith(subset(s, union(s2, s3)))

        \heuristics(simplify_enlarging)
    };


    // proven with KeY (CS)
    subsetWithSetMinusLeftEQ {
        \schemaVar \term LocSet s, s2, s3;
        \schemaVar \term LocSet EQ;

        \assumes(setMinus(s, s2) = EQ ==>)
        \find(subset(EQ, s3))
        \sameUpdateLevel

	\replacewith(subset(s, union(s2, s3)))

        \heuristics(simplify_enlarging)
    };


    unionWithItself {
        \schemaVar \term LocSet s;

        \find(union(s, s))

        \replacewith(s)

        \heuristics(concrete)
    };


    intersectWithItself {
        \schemaVar \term LocSet s;

        \find(intersect(s, s))

        \replacewith(s)

        \heuristics(concrete)
    };


// one of the two below should be obsolete after completing term ordering (not yet done)
    distributeIntersection {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(s1, union(s2, s3)))

        \replacewith(union(intersect(s1, s2), intersect(s1, s3)))

        \heuristics(simplify_enlarging)
    };


    distributeIntersection_2 {
        \schemaVar \term LocSet s1, s2, s3;

        \find(intersect(union(s2, s3), s1))

        \replacewith(union(intersect(s2, s1), intersect(s3, s1)))

        \heuristics(simplify_enlarging)
    };


    intersectWithSingleton {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \find(intersect(singleton(o, f), s))

        \replacewith(\if(elementOf(o, f, s)) \then(singleton(o, f)) \else(empty))

        \heuristics(simplify_enlarging)
    };


    setMinusItself {
        \schemaVar \term LocSet s;

        \find(setMinus(s, s))

        \replacewith(empty)

        \heuristics(concrete)
    };


    setMinusSingleton {
        \schemaVar \term LocSet s;
        \schemaVar \term Object o;
        \schemaVar \term Field f;

        \assumes(==> elementOf(o, f, s))

        \find(setMinus(s, singleton(o, f)))

        \replacewith(s)

        \heuristics(simplify)
    };


    intersectionSetMinusItself {
        \schemaVar \term LocSet s1, s2;

        \find(intersect(setMinus(s1, s2), s2))

        \replacewith(empty)

        \heuristics(concrete)
    };


    intersectionSetMinusItself_2 {
        \schemaVar \term LocSet s1, s2;

        \find(intersect(s2, setMinus(s1, s2)))

        \replacewith(empty)

        \heuristics(concrete)
    };


    unionIntersectItself {
        \schemaVar \term LocSet s1, s2;

        \find(union(intersect(s1, s2), s1))

        \replacewith(s1)

        \heuristics(simplify)
    };


    unionIntersectItself_2 {
        \schemaVar \term LocSet s1, s2;

        \find(union(intersect(s2, s1), s1))

        \replacewith(s1)

        \heuristics(simplify)
    };


    unionIntersectItself_3 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(s, intersect(s1, s2)), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };


    unionIntersectItself_4 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(s, intersect(s2, s1)), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };


    unionIntersectItself_5 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(intersect(s1, s2), s), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };


    unionIntersectItself_6 {
        \schemaVar \term LocSet s1, s2, s;

        \find(union(union(intersect(s2, s1), s), s1))

        \replacewith(union(s, s1))

        \heuristics(simplify)
    };


    infiniteUnionUnused {
	\schemaVar \variables alpha av;
	\schemaVar \term LocSet s;

        \find(infiniteUnion{av;}(s))
        \varcond(\notFreeIn(av, s))

        \replacewith(s)

        \heuristics(concrete)
    };


    subsetOfItself {
        \schemaVar \term LocSet s;

        \find(subset(s, s))

        \replacewith(true)

        \heuristics(concrete)
    };


// really needed for efficiency?
    elementOfGuardedSet {
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \formula phi;
        \schemaVar \term LocSet s;

        \find(elementOf(o, f, \if(phi)\then(s)\else(empty)))

        \replacewith(phi & elementOf(o, f, s))

        \heuristics(concrete)
    };


    commuteDisjoint {
    	\schemaVar \term LocSet commLeft, commRight;

    	\find(disjoint(commLeft, commRight))
    	\replacewith(disjoint(commRight, commLeft))
    	
    	\heuristics(cnf_setComm)
    };


    commuteUnion {
    	\schemaVar \term LocSet commLeft, commRight;

    	\find(union(commLeft, commRight))

    	\replacewith(union(commRight, commLeft))

        \heuristics(cnf_setComm)
    };


    commuteUnion_2 {
    	\schemaVar \term LocSet commLeft, commRight, s;

    	\find(union(union(s, commLeft), commRight))

    	\replacewith(union(union(s, commRight), commLeft))

        \heuristics(cnf_setComm)
    };


    commuteIntersection {
    	\schemaVar \term LocSet commLeft, commRight;

    	\find(intersect(commLeft, commRight))

    	\replacewith(intersect(commRight, commLeft))

        \heuristics(cnf_setComm)
    };


    commuteIntersection_2 {
    	\schemaVar \term LocSet commLeft, commRight, s;

    	\find(intersect(intersect(s, commLeft), commRight))

    	\replacewith(intersect(intersect(s, commRight), commLeft))

        \heuristics(cnf_setComm)
    };


    associativeLawUnion {
    	\schemaVar \term LocSet s1, s2, s3;

    	\find(union(s1, union(s2, s3)))

    	\replacewith(union(union(s1, s2), s3))

        \heuristics(conjNormalForm)
    };


    associativeLawIntersect {
    	\schemaVar \term LocSet s1, s2, s3;

    	\find(intersect(s1, intersect(s2, s3)))

    	\replacewith(intersect(intersect(s1, s2), s3))

        \heuristics(conjNormalForm)
    };


    //--------------------------------------------------------------------------
    // work-a-round to use \infinite_union in JML set statements
    //--------------------------------------------------------------------------

    definitionAllElementsOfArray {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArray(h, array, singleton(o, f)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array), \notFreeIn(j, o, f))

        \replacewith(infiniteUnion{j;}(\if (0 <= j & j < length(array))
                                       \then(singleton(Object::select(h, array, arr(j)), f))
                                       \else(empty)))
        \heuristics(simplify)
    };

    definitionAllElementsOfArray2 {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArray(h, array, allFields(o)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array))

        \replacewith(infiniteUnion{j;}(\if (0 <= j & j < length(array))
                                       \then(allFields(Object::select(h, array, arr(j))))
                                       \else(empty)))
        \heuristics(simplify)
    };

    definitionAllElementsOfArrayLocsets {
        \schemaVar \term Object array;
        \schemaVar \term Object o;
        \schemaVar \term Field f;
        \schemaVar \term Heap h;
        \schemaVar \variables int j;

        \find(allElementsOfArrayLocsets(h, array, singleton(o, f)))
        \varcond(\notFreeIn(j, h), \notFreeIn(j, array), \notFreeIn(j, o, f))

        \replacewith(infiniteUnion{j;}(\if (0 <= j & j < length(array))
                                       \then(LocSet::select(h, Object::select(h, array, arr(j)), f))
                                       \else(empty)))
        \heuristics(simplify)
    };

}
