// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//


// This file contains quantifier and equality rules which used to be in genericRules.key

\sorts {
  \generic G, S1, S2, H;
}



\schemaVariables {
  \term G e,s,t, e0;
  \term H t1;
  \term S1 t2;
  \skolemTerm G sk ;
  \formula b,c;
  \variables G u, e2 ;

  \term G commEqLeft;
  \term H commEqRight;


  \term[rigid] G sr;
  \term[rigid] H tr;

  \term S1 ind1, ind2, target ;
}


\rules {

  // Gamma rules
  allLeft {
	\find (\forall u; b ==>)
	\add ({\subst u; t}(b) ==>)
	\heuristics(gamma)
  };
  exRight { \find (==> \exists u; b) \add (==> {\subst u; t}(b))
            \heuristics(gamma) };
  allLeftHide { \find (\forall u; b ==>) \replacewith ({\subst u; t}(b) ==>)
		\addrules ( insert_hidden { \add (\forall u; b ==>) } )
                \heuristics(gamma_destructive) };
  exRightHide { \find (==> \exists u; b) \replacewith (==> {\subst u; t}(b))
		\addrules ( insert_hidden { \add (==> \exists u; b) } )
                \heuristics(gamma_destructive)  };

  instAll { \assumes (\forall u; b ==>) \find (t) \add ({\subst u; t}(b) ==>) };
  instEx  { \assumes (==> \exists u; b) \find (t) \add (==> {\subst u; t}(b)) };

  // delta rules
  allRight { \find (==> \forall u; b) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith (==> {\subst u; sk}b) \heuristics (delta) };
  exLeft { \find (\exists u; b ==>) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith ({\subst u; sk}b ==>) \heuristics (delta) };

  // simplification
  all_unused { \find (\forall u; b) \varcond (\notFreeIn(u, b))
		 \replacewith (b)
		 \heuristics (elimQuantifier) };
  ex_unused  { \find (\exists u; b) \varcond (\notFreeIn(u, b))
		 \replacewith (b)
		 \heuristics (elimQuantifier) };

  // abbreviation used for replay of nnf-pos/nnf-neg/quant-intro only
  // can be proven in KeY (requires equiv split; on every branch skolemization + 2 instantiations!)
  distribute_all_equiv {
        //\assumes (==> (\forall u; b) <-> (\forall u; c))
        \find (\forall u; (b <-> c) ==>)
        // The rule is weakening if the original 'find' formula is replaced (-> incompleteness!).
        //\replacewith ((\forall u; b) <-> (\forall u; c) ==>)
        \add ((\forall u; b) <-> (\forall u; c) ==>)
        \heuristics (simplify_enlarging)  // better to assign no heuristics, but needed for macro
  };
  
  /*
  distribute_all_equiv_lr {
        \assumes ((\forall u; b) ==> (\forall u; c))
        \find (\forall u; (b <-> c) ==>)
        \replacewith ((\forall u; b) <-> (\forall u; c) ==>)
        \heuristics (simplify)  // better to assign no heuristics, but needed for macro
  };
  
  distribute_all_equiv_rl {
        \assumes (==> (\forall u; c), (\forall u; b))
        \find (\forall u; (b <-> c) ==>)
        \replacewith ((\forall u; b) <-> (\forall u; c) ==>)
        \heuristics (simplify)  // better to assign no heuristics, but needed for macro
  };
  
  distribute_all_equiv_rr {
        \assumes (==> (\forall u; b), (\forall u; c))
        \find (\forall u; (b <-> c) ==>)
        \replacewith ((\forall u; b) <-> (\forall u; c) ==>)
        \heuristics (simplify)  // better to assign no heuristics, but needed for macro
  };*/

  // equality
  eqClose {
     \find (s = s) \replacewith (true) \heuristics (concrete)
  };


  eqSymm { \find (commEqLeft = commEqRight)
           \replacewith (commEqRight = commEqLeft)
           \heuristics ( order_terms )
  };

  make_insert_eq { \find (sr = tr ==>)
		   \addrules ( insert_eq { \find (sr) \replacewith (tr) } )
		 };

  make_insert_eq_nonrigid { \find (s = t ==>)
	     \addrules ( insert_eq_nonrigid { \find (s) \sameUpdateLevel
                                              \replacewith (t)
                                              \displayname "insert_eq" } )
                    };
  insert_eq_all  { \find (sr = tr ==>)
		     \replacewith (==>)
		     \addrules ( auto_insert_eq { \find (sr)
						 \replacewith (tr)
						 \heuristics (simplify) } ) };

// wary substitutions
  apply_subst { \find ({\subst u; t} target)
                // it is enough to rebuild the same term, as substitutions
                // are automatically applied in this situation
                \replacewith ({\subst u; t} target)
                \heuristics (try_apply_subst) };

  apply_subst_for { \schemaVar \formula phi;
                    \find ({\subst u; t} phi)
                    // it is enough to rebuild the same term, as substitutions
                    // are automatically applied in this situation
                    \replacewith ({\subst u; t} phi)
                    \heuristics (try_apply_subst)
                    \displayname "apply_subst" };

  subst_to_eq { \find ({\subst u; t} target) \sameUpdateLevel
                \varcond (\new(sk, \dependingOn(t)))
                \replacewith ({\subst u; sk} target)
                \add (sk = t ==>)
                \heuristics (simplify) };

  subst_to_eq_for { \schemaVar \formula phi;
                    \find ({\subst u; t} phi) \sameUpdateLevel
                    \varcond (\new(sk, \dependingOn(t)))
                    \replacewith ({\subst u; sk} phi)
                    \add (sk = t ==>)
                    \heuristics (simplify)
                    \displayname "subst_to_eq" };



///////////////////////////////////////////////////////////////////////////////




 applyEq {
	\assumes (s = t1 ==>) \find (s)
	\sameUpdateLevel
	\replacewith ( t1 )
        \heuristics ( apply_equations, apply_select_eq )
	\displayname "applyEq"
 };

 applyEqReverse {
	\assumes (s = t1 ==>) \find (t1)
	\sameUpdateLevel
	\replacewith ( s )
        \heuristics ( apply_auxiliary_eq )
	\displayname "applyEqReverse"
 };

 applyEqRigid {
	\schemaVar \term[rigid] H tr1;

	\assumes (sr = tr1 ==>) \find (sr)
	\replacewith ( tr1)
        \heuristics ( apply_equations )
	\displayname "applyEq"
 };

  pullOut{ \find ( t ) \sameUpdateLevel \varcond ( \new(sk, \dependingOn(t)) )
           \replacewith (sk)
           \add ( t = sk ==>)
	   \heuristics(semantics_blasting)
  };


  \lemma
  eqTermCut {
      \find (t) \sameUpdateLevel
      "Assume #t  = #s": \add( t = s ==>);
      "Assume #t != #s": \add (t != s ==>)
  };

    //--------------------------------------------------------------------------
    //rule for unique function symbols
    //--------------------------------------------------------------------------

    equalUnique {
	\schemaVar \term any f, f2;
	\schemaVar \formula result;

	\find(f = f2)
	\varcond(\equalUnique(f, f2, result))

	\replacewith(result)

	\heuristics(concrete)
    };

}

