/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */
package de.uka.ilkd.key.testgen;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import javax.lang.model.element.Modifier;

import com.squareup.javapoet.*;

import static com.squareup.javapoet.TypeName.*;

/**
 * Creates the RFL.java file, that provides setter and getter methods using the reflection API as
 * well as object creation functions based on the objenesis library.
 *
 * @author mbender
 * @author gladisch
 * @author weigl -- rewrite for javapoet
 */
public class ReflectionClassCreator {
    public static final String NAME_OF_CLASS = "RFL";
    public static final String ARRAY = "_ARRAY_";
    public static final String SET_PREFIX = "_set_";
    public static final String GET_PREFIX = "_get_";

    // Default values for primitive types
    private static final String[] PRIM_TYP_DEF_VAL = { "0", "0", "0", "0", "false", "0", "0" };

    private final HashSet<TypeName> usedObjectSortsStrings;


    public ReflectionClassCreator() {
        usedObjectSortsStrings = new HashSet<>();
    }

    /**
     * Creates the RFL.java file, that provides setter and getter methods using the reflection API
     * as well as object creation functions based on the objenesis library.
     */
    public TypeSpec createClass(boolean staticClass) {
        var sorts = sortsToString();
        var clazz = classDecl(staticClass);
        ghostMapDecls(clazz);
        staticInitializer(true, clazz);
        instanceMethod(clazz);
        instances(sorts, clazz);
        getterAndSetter(sorts, clazz);
        return clazz.build();
    }

    /**
     * Constructors, setter-, getter-methods will be created for the added sorts.
     */
    public void addSort(TypeName s) {
        usedObjectSortsStrings.add(s);
    }

    /**
     * @return String representations for all non primitive types
     */
    private Set<TypeName> sortsToString() {
        final Set<TypeName> result = new HashSet<>();

        for (TypeName sort : usedObjectSortsStrings) {
            if (sort instanceof ArrayTypeName a) {
                sort = a.componentType;
            }

            if (sort instanceof ParameterizedTypeName p) {
                sort = p.rawType;
            }

            if (sort instanceof TypeVariableName
                    || sort instanceof WildcardTypeName
                    || TestgenUtils.PRIMITIVE_TYPES.contains(sort)
                    || sort == VOID) {
                continue;
            }
            result.add(sort);
        }
        return result;
    }

    /**
     * @return Beginning of the RFL class
     */
    private TypeSpec.Builder classDecl(boolean staticClass) {
        var tb = TypeSpec.classBuilder(NAME_OF_CLASS);
        tb.addModifiers(Modifier.PUBLIC);
        if (staticClass)
            tb.addModifiers(Modifier.STATIC);
        tb.addJavadoc(
            """
                    // This file was generated by KeY Version %s (www.key-project.org).
                    /** This class enables the test suite to read and write protected and private
                    * fields of other classes. It can also simulate ghost fields using a hashmap.
                    * Ghostfields are implicit fields that exist in the specification but not in the
                    * actual Java class. Futhermore, this class also enables to create an object of
                    * any class even if it has no default constructor. To create objects the
                    * the objenesis library is required and must be provided when compiling and
                    * executing the test suite.
                    * @see http://docs.oracle.com/javase/tutorial/reflect/member/ctorInstance.html
                    * @see http://code.google.com/p/objenesis
                    * @see http://objenesis.org/
                    * @author gladisch").append(NEW_LINE);
                    * @author mbender").append(NEW_LINE);
                    */""");
        return tb;
    }

    /**
     * Writes a hashmap and a utility method for associating ghost/model fiels with objects.
     *
     * @param clazz a builder to append the necessary declarations
     */
    private void ghostMapDecls(TypeSpec.Builder clazz) {
        clazz.addField(String.class, "NoSuchFieldExceptionText", Modifier.PUBLIC, Modifier.STATIC);
        clazz.addField(Boolean.TYPE, "ghostMapActive", Modifier.PUBLIC, Modifier.STATIC);
        clazz.addField(ParameterizedTypeName.get(HashMap.class, Integer.class, Object.class),
            "ghostModelFields",
            Modifier.PUBLIC, Modifier.STATIC);
        clazz.addMethod(MethodSpec.methodBuilder("getHash")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addParameter(Class.class, "c")
                .addParameter(Object.class, "obj")
                .addParameter(String.class, "attr")
                .addStatement(
                    "return c.hashCode() * (obj!=null?obj.hashCode():1) * attr.hashCode();")
                .build());
    }

    /**
     * The method that allows to create new instances
     */
    private void instanceMethod(TypeSpec.Builder clazz) {
        clazz.addField(ClassName.get("org.objenesis", "Objenesis"), "objenesis");
        var ms = MethodSpec.methodBuilder("newInstance")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(Object.class)
                .addParameter(Class.class, "c")
                .addException(Exception.class)
                .addJavadoc(
                    "The Objenesis library can create instances of classes that have no default constructor.")
                .addStatement("Object res=objenesis.newInstance(c);")
                .beginControlFlow("if (res==null)")
                .addStatement("throw new Exception($S+c);", "Couldn't create instance of class: ")
                .endControlFlow()
                .addStatement("return res;");
        clazz.addMethod(ms.build());
    }

    private void staticInitializer(boolean ghostMapActive, TypeSpec.Builder clazz) {
        clazz.addStaticBlock(
            CodeBlock.builder()
                    .addStatement("objenesis = new org.objenesis.ObjenesisStd();")
                    .add("ghostMapActive = $L;", ghostMapActive)
                    .add("ghostModelFields = new java.util.HashMap<Integer,Object>();")
                    .add("NoSuchFieldExceptionText =")
                    .addStatement(
                        "/*This exception occurs when ghost fields or model fields are used in " +
                            "the code or if mock objects are used that have different fields, than the real objects."
                            +
                            "The tester should extend the handling of such fields in this generated utility class RFL.java.*/;)")
                    .build());
    }

    /**
     * All calls to create objects for the given sorts
     */
    private void instances(final Set<TypeName> sorts, TypeSpec.Builder clazz) {
        for (final TypeName sort : sorts) {
            clazz.addMethod(newRef(sort));
        }
    }

    /**
     * @return The call to create an object of given type
     */
    private MethodSpec newRef(final TypeName sort) {
        if (sort instanceof ArrayTypeName a) {
            return newArrayField(a);
        } else {
            return newInstance(sort);
        }
    }

    /**
     * Takes a string representing a type e.g. "java.lang.Object[]" and returns a new name without
     * "." and "[]", e.g. "java_lang_Object_ARRAY_". It is used to create correct setter and getter
     * method names. This method is also used in Assignment.toString(boolean rfl) to generate the
     * correct method names.
     */
    public static String cleanTypeName(TypeName s) {
        if (s instanceof ArrayTypeName a) {
            return cleanTypeName(a.componentType) + ARRAY;
        }

        if (s instanceof ParameterizedTypeName p) {
            return cleanTypeName(p.rawType);
        }

        return s.toString().replace('.', '_');
    }

    /**
     * @param sort
     * @return The call to create an object of given type
     */
    private MethodSpec newInstance(final TypeName sort) {
        String methodName = cleanTypeName(sort);
        return MethodSpec.methodBuilder(methodName)
                .returns(sort)
                .addException(RuntimeException.class)
                .addStatement("try{ return ($N) newInstance($N.class); } " +
                    "catch (java.lang.Throwable e) { throw new java.lang.RuntimeException(e); }",
                    sort)
                .build();
    }

    /**
     * @param sort
     * @return The call to create an Array of given type
     */
    private MethodSpec newArrayField(final ArrayTypeName sort) {
        String typeName = cleanTypeName(sort);
        return MethodSpec.methodBuilder("new" + typeName)
                .returns(sort)
                .addStatement("return new $N[dim];", sort.componentType)
                .build();
    }

    private boolean isPrimitiveType(TypeName sort) {
        return TestgenUtils.PRIMITIVE_TYPES.contains(sort);
    }

    private void getterAndSetter(final Set<TypeName> sorts, TypeSpec.Builder clazz) {
        for (int i = 0; i < 7; i++) {
            clazz.addMethod(declareSetter(TestgenUtils.PRIMITIVE_TYPES.get(i), true));
            clazz.addMethod(
                declareGetter(TestgenUtils.PRIMITIVE_TYPES.get(i), PRIM_TYP_DEF_VAL[i], true));
        }
        for (final var sort : sorts) {
            clazz.addMethod(declareSetter(sort, false));
            clazz.addMethod(declareGetter(sort, "null", false));
        }
    }

    private MethodSpec declareSetter(final TypeName sort, final boolean prim) {
        var retType = sort;
        var ms = MethodSpec.methodBuilder(SET_PREFIX + cleanTypeName(sort))
                .addParameter(Class.class, "c")
                .addParameter(OBJECT, "obj")
                .addParameter(String.class, "attr")
                .addParameter(retType, "val")
                .beginControlFlow("try")
                .addStatement("$T f = c.getDeclaredField(attr);", java.lang.reflect.Field.class)
                .addStatement("f.setAccessible(true);");

        if (prim) {
            var camelCase =
                Character.toUpperCase(sort.toString().charAt(0)) + sort.toString().substring(1);
            ms.addStatement("f.set" + camelCase + "(obj, val);");
        } else {
            ms.addStatement("f.set(obj, val);");
        }

        ms.nextControlFlow("catch(NoSuchFieldException e)")
                .beginControlFlow("if(ghostMapActive)")
                .addStatement("ghostModelFields.put(getHash(c,obj,attr), val);")
                .nextControlFlow("else")
                .addStatement(
                    "throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);")
                .endControlFlow()
                .nextControlFlow("catch(Exception e)")
                .addStatement("throw new RuntimeException(e);")
                .endControlFlow();
        return ms.build();
    }


    private MethodSpec declareGetter(final TypeName sort, final String def, final boolean prim) {
        var ms = MethodSpec.methodBuilder(GET_PREFIX + cleanTypeName(sort))
                .returns(sort)
                .addParameter(Class.class, "c")
                .addParameter(OBJECT, "obj")
                .addParameter(String.class, "attr")
                .addStatement("rest = $L;", def)
                .beginControlFlow("try")
                .addStatement("$T f = c.getDeclaredField(attr);", java.lang.reflect.Field.class)
                .addStatement("f.setAccessible(true);");

        if (prim) {
            var camelCase =
                Character.toUpperCase(sort.toString().charAt(0)) + sort.toString().substring(1);
            ms.addStatement("return f.get" + camelCase + "(obj);");
        } else {
            ms.addStatement("return ($N) f.get(obj);", sort);
        }

        ms.nextControlFlow("catch($N e)", NoSuchFieldException.class);
        ms.addStatement("ghostModelFields.get(getHash(c,obj,attr));");
        ms.nextControlFlow("catch(Exception e)");
        ms.addStatement("throw new RuntimeException(e);");
        ms.endControlFlow();

        return ms.build();
    }
}
