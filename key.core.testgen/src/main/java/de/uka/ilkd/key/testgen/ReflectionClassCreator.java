/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */
package de.uka.ilkd.key.testgen;

import com.squareup.javapoet.*;
import de.uka.ilkd.key.logic.sort.Sort;

import javax.lang.model.element.Modifier;
import java.util.HashMap;
import java.util.HashSet;

/**
 * Creates the RFL.java file, that provides setter and getter methods using the reflection API as
 * well as object creation functions based on the objenesis library.
 *
 * @author mbender
 * @author gladisch
 * @author weigl -- rewrite for javapoet
 */
public class ReflectionClassCreator {

    public static final String NAME_OF_CLASS = "RFL";

    public static final String ARRAY = "_ARRAY_";
    public static final String SET_PREFIX = "_set_";
    public static final String GET_PREFIX = "_get_";

    // setter and getter methods will be created for these types.
    private static final String[] PRIMITIVE_TYPES =
            {"int", "long", "byte", "char", "boolean", "float", "double"};

    // Default values for primitive types
    private static final String[] PRIM_TYP_DEF_VAL = {"0", "0", "0", "' '", "false", "0", "0"};

    private final HashSet<Sort> usedObjectSorts;
    private final HashSet<String> usedObjectSortsStrings;


    public ReflectionClassCreator() {
        usedObjectSorts = new HashSet<>();
        usedObjectSortsStrings = new HashSet<>();
    }

    /**
     * Creates the RFL.java file, that provides setter and getter methods using the reflection API
     * as well as object creation functions based on the objenesis library.
     */
    public TypeSpec createClass(boolean staticClass) {
        final HashSet<String> sorts = sortsToString();
        var clazz = classDecl(staticClass);
        ghostMapDecls(clazz);
        staticInitializer(true, clazz);
        instanceMethod(clazz);
        instances(sorts, clazz);
        getterAndSetter(sorts, clazz);
        return clazz.build();
    }

    /**
     * Constructors, setter-, getter-methods will be created for the added sorts.
     */
    public void addSort(Sort s) {
        usedObjectSorts.add(s);
    }

    /**
     * Constructors, setter-, getter-methods will be created for the added sorts.
     */
    public void addSort(String s) {
        usedObjectSortsStrings.add(s);
    }

    /**
     * @return String representations for all non primitive types
     */
    private HashSet<String> sortsToString() {
        final HashSet<String> result = new HashSet<>();
        for (final Sort var : usedObjectSorts) {
            String sort = var.toString();
            // We only want Object-Types
            if (!" jbyte jint jlong jfloat jdouble jboolean jchar ".contains(" " + sort + " ")) {
                if (" jbyte[] jint[] jlong[] jfloat[] jdouble[] jboolean[] jchar[] "
                        .contains(" " + sort + " ")) {
                    sort = sort.substring(1);
                }
                if (!isPrimitiveType(sort)) {
                    result.add(sort);
                }
            }
        }
        for (String sort : usedObjectSortsStrings) {
            // We only want Object-Types
            if (!" jbyte jint jlong jfloat jdouble jboolean jchar ".contains(" " + sort + " ")) {
                if (" jbyte[] jint[] jlong[] jfloat[] jdouble[] jboolean[] jchar[] "
                        .contains(" " + sort + " ")) {
                    sort = sort.substring(1);
                }
                if (!isPrimitiveType(sort)) {
                    result.add(sort);
                }
            }
        }
        return result;
    }

    /**
     * @return Beginning of the RFL class
     */
    private TypeSpec.Builder classDecl(boolean staticClass) {
        var tb = TypeSpec.classBuilder(NAME_OF_CLASS);
        tb.addModifiers(Modifier.PUBLIC);
        if (staticClass) tb.addModifiers(Modifier.STATIC);
        tb.addJavadoc("""
                // This file was generated by KeY Version %s (www.key-project.org).
                /** This class enables the test suite to read and write protected and private
                * fields of other classes. It can also simulate ghost fields using a hashmap.
                * Ghostfields are implicit fields that exist in the specification but not in the
                * actual Java class. Futhermore, this class also enables to create an object of
                * any class even if it has no default constructor. To create objects the
                * the objenesis library is required and must be provided when compiling and
                * executing the test suite. * @see http://docs.oracle.com/javase/tutorial/reflect/member/ctorInstance.html
                * @see http://code.google.com/p/objenesis
                * @see http://objenesis.org/
                * @author gladisch").append(NEW_LINE);
                * @author mbender").append(NEW_LINE);
                */""");
        return tb;
    }

    /**
     * Writes a hashmap and a utility method for associating ghost/model fiels with objects.
     *
     * @param clazz a builder to append the necessary declarations
     */
    private void ghostMapDecls(TypeSpec.Builder clazz) {
        clazz.addField(String.class, "NoSuchFieldExceptionText", Modifier.PUBLIC, Modifier.STATIC);
        clazz.addField(Boolean.TYPE, "ghostMapActive", Modifier.PUBLIC, Modifier.STATIC);
        clazz.addField(ParameterizedTypeName.get(HashMap.class, Integer.class, Object.class),
                "ghostModelFields",
                Modifier.PUBLIC, Modifier.STATIC);
        clazz.addMethod(MethodSpec.methodBuilder("getHash")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addParameter(Class.class, "c")
                .addParameter(Object.class, "obj")
                .addParameter(String.class, "attr")
                .addStatement("return c.hashCode() * (obj!=null?obj.hashCode():1) * attr.hashCode();")
                .build());
    }

    /**
     * The method that allows to create new instances
     */
    private void instanceMethod(TypeSpec.Builder clazz) {
        clazz.addField(ClassName.get("org.objenesis", "Objenesis"), "objenesis");
        var ms = MethodSpec.methodBuilder("newInstance")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(Object.class)
                .addParameter(Class.class, "c")
                .addException(Exception.class)
                .addJavadoc("The Objenesis library can create instances of classes that have no default constructor.")
                .addStatement("Object res=objenesis.newInstance(c);")
                .beginControlFlow("if (res==null)")
                .addStatement("throw new Exception($S+c);", "Couldn't create instance of class: ")
                .endControlFlow()
                .addStatement("return res;");
        clazz.addMethod(ms.build());
    }

    private void staticInitializer(boolean ghostMapActive, TypeSpec.Builder clazz) {
        clazz.addStaticBlock(
                CodeBlock.builder()
                        .addStatement("objenesis = new org.objenesis.ObjenesisStd();")
                        .add("ghostMapActive = $L;", ghostMapActive)
                        .add("ghostModelFields = new java.util.HashMap<Integer,Object>();")
                        .add("NoSuchFieldExceptionText =")
                        .addStatement("/*This exception occurs when ghost fields or model fields are used in " +
                                "the code or if mock objects are used that have different fields, than the real objects." +
                                "The tester should extend the handling of such fields in this generated utility class RFL.java.*/;)"
                        ).build()
        );
    }

    /**
     * All calls to create objects for the given sorts
     */
    private void instances(final HashSet<String> sorts, TypeSpec.Builder clazz) {
        //r.append(NEW_LINE).append("  // ---The methods for object creation---").append(NEW_LINE)
        //        .append(NEW_LINE);
        for (final String sort : sorts) {
            clazz.addMethod(newRef(sort));
        }
    }

    /**
     * @return The call to create an object of given type
     */
    private MethodSpec newRef(final String sort) {
        if (sort.indexOf('[') != -1) {
            return newArrayField(sort);
        } else {
            return newInstance(sort);
        }
    }

    /**
     * Takes a string representing a type e.g. "java.lang.Object[]" and returns a new name without
     * "." and "[]", e.g. "java_lang_Object_ARRAY_". It is used to create correct setter and getter
     * method names. This method is also used in Assignment.toString(boolean rfl) to generate the
     * correct method names.
     */
    public static String cleanTypeName(String s) {
        // WARNING: Make sure this fixed string begins with a SPACE and also
        // ends with a SPACE.
        if (" jbyte jint jlong jfloat jdouble jboolean jchar jbyte[] jint[] jlong[] jfloat[] jdouble[] jboolean[] jchar[] "
                .contains(" " + s + " ")) {
            s = s.substring(1);
        }
        while (s.contains(".")) {
            s = s.substring(0, s.indexOf('.')) + "_" + s.substring(s.indexOf('.') + 1);
        }
        while (s.contains("[]")) {
            s = s.substring(0, s.indexOf("[]")) + ARRAY + s.substring(s.indexOf("[]") + 2);
        }
        return s;
    }

    /**
     * @param sort
     * @return The call to create an object of given type
     */
    private MethodSpec newInstance(final String sort) {
        String methodName = cleanTypeName(sort);
        ClassName returnType = ClassName.get("", sort);
        return MethodSpec.methodBuilder(methodName)
                .returns(returnType)
                .addException(RuntimeException.class)
                .addStatement("try{ return ($N) newInstance($N.class); } " +
                                "catch (java.lang.Throwable e) { throw new java.lang.RuntimeException(e); }",
                        returnType)
                .build();
    }

    /**
     * @param sort
     * @return The call to create an Array of given type
     */
    private MethodSpec newArrayField(final String sort) {
        String typeName = cleanTypeName(sort);
        String substring = sort.substring(0, sort.length() - 2);
        return MethodSpec.methodBuilder("new" + typeName)
                .addStatement("return new $N[dim];", substring)
                .build();
    }

    private boolean isPrimitiveType(String sort) {
        for (String s : PRIMITIVE_TYPES) {
            if (s.equals(sort)) {
                return true;
            }
        }
        return false;
    }

    private void getterAndSetter(final HashSet<String> sorts, TypeSpec.Builder clazz) {
        for (int i = 0; i < 7; i++) {
            clazz.addMethod(declareSetter(PRIMITIVE_TYPES[i], true));
            clazz.addMethod(declareGetter(PRIMITIVE_TYPES[i], PRIM_TYP_DEF_VAL[i], true));
        }
        for (final String sort : sorts) {
            clazz.addMethod(declareSetter(sort, false));
            clazz.addMethod(declareGetter(sort, "null", false));
        }
    }

    private MethodSpec declareSetter(final String sort, final boolean prim) {

        var retType = ClassName.get("", sort);
        var ms = MethodSpec.methodBuilder(SET_PREFIX + cleanTypeName(sort))
                .addParameter(Class.class, "c")
                .addParameter(TypeName.OBJECT, "obj")
                .addParameter(String.class, "attr")
                .addParameter(retType, "val")
                .beginControlFlow("try")
                .addStatement("$T f = c.getDeclaredField(attr);", java.lang.reflect.Field.class)
                .addStatement("f.setAccessible(true);");

        if (prim)
            ms.addStatement("f.set" + Character.toUpperCase(sort.charAt(0)) + sort.substring(1)
                    + "(obj, val);");
        else
            ms.addStatement("f.set(obj, val);");

        ms.nextControlFlow("catch(NoSuchFieldException e)")
                .beginControlFlow("if(ghostMapActive)")
                .addStatement("ghostModelFields.put(getHash(c,obj,attr), val);")
                .nextControlFlow("else")
                .addStatement("throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);")
                .endControlFlow()
                .nextControlFlow("catch(Exception e)")
                .addStatement("throw new RuntimeException(e);")
                .endControlFlow();
        return ms.build();
    }

    private String primToWrapClass(String sort) {
        if (sort.equals("int")) {
            return "Integer";
        } else if (sort.equals("char")) {
            return "Character";
        } else {
            return Character.toUpperCase(sort.charAt(0)) + sort.substring(1);
        }
    }

    private MethodSpec declareGetter(final String sort, final String def, final boolean prim) {
        var retType = ClassName.get("", sort);
        var ms = MethodSpec.methodBuilder(GET_PREFIX + cleanTypeName(sort))
                .returns(retType)
                .addParameter(Class.class, "c")
                .addParameter(TypeName.OBJECT, "obj")
                .addParameter(String.class, "attr")
                .addStatement("rest = $L;", def)
                .beginControlFlow("try")
                .addStatement("$T f = c.getDeclaredField(attr);", java.lang.reflect.Field.class)
                .addStatement("f.setAccessible(true);");

        if (prim)
            ms.addStatement("return f.get" + Character.toUpperCase(sort.charAt(0))
                    + sort.substring(1) + "(obj);");
        else
            ms.addStatement("return ($N) f.get(obj);", retType);

        ms.nextControlFlow("catch($N e)", NoSuchFieldException.class);
        ms.addStatement(prim ? primToWrapClass(sort) : sort);
        ms.addStatement("ghostModelFields.get(getHash(c,obj,attr));");
        ms.nextControlFlow("catch(Exception e)");
        ms.addStatement("throw new RuntimeException(e);");
        ms.endControlFlow();

        return ms.build();
    }
}
