<?xml version="1.0" encoding="UTF-8"?>
<start name="&lt;start&gt;" pathCondition="true" pathConditionChanged="false">
   <methodCall name="&lt;call LoopInvariantWithSplittingQuery.main(x)&gt;" pathCondition="true" pathConditionChanged="false">
      <loopInvariant name="invariant: LoopInvariantWithSplittingQuery.magic(x) &gt;= 0;
variant: LoopInvariantWithSplittingQuery.magic(x)
mod: false" pathCondition="true" pathConditionChanged="false" initiallyValid="true">
         <branchCondition name="update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathCondition="update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="true" branchCondition="update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" mergedBranchCondition="false" isBranchConditionComputed="true" additionalBranchLabel="Body Preserves Invariant">
            <branchCondition name="gt(x_0,Z(neglit(1(#))))" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="true" branchCondition="gt(x_0,Z(neglit(1(#))))" mergedBranchCondition="false" isBranchConditionComputed="true">
               <loopCondition name="magic(x) &gt; 0;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" blockOpened="false">
                  <methodCall name="&lt;call LoopInvariantWithSplittingQuery.magic(x_10)&gt;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                     <branchStatement name="if (x_10 &gt;= 0)" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" blockOpened="true">
                        <statement name="return x_10;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                           <methodReturn name="&lt;return of magic&gt;" signature="&lt;return of LoopInvariantWithSplittingQuery.magic(x_10)&gt;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" nameIncludingReturnValue="&lt;return magic_sk_0 as result of magic&gt;" signatureIncludingReturnValue="&lt;return magic_sk_0 as result of LoopInvariantWithSplittingQuery.magic(x_10)&gt;" isReturnValueComputed="true" methodReturnCondition="true">
                              <methodReturnValue name="magic_sk_0" returnValueString="magic_sk_0" hasCondition="false">
                              </methodReturnValue>
                              <statement name="x--;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                                 <termination name="&lt;loop body end&gt;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" terminationKind="LOOP_BODY" branchVerified="true">
                                 </termination>
                              </statement>
                           </methodReturn>
                           <completedBlockEntry path="/0/0/0/0/0/0/0" conditionString="true"/>
                        </statement>
                        <blockCompletionEntry path="/0/0/0/0/0/0/0/0"/>
                     </branchStatement>
                     <methodReturnEntry path="/0/0/0/0/0/0/0/0/0"/>
                  </methodCall>
               </loopCondition>
            </branchCondition>
            <branchCondition name="lt(x_0,Z(0(#)))" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="true" branchCondition="lt(x_0,Z(0(#)))" mergedBranchCondition="false" isBranchConditionComputed="true">
               <loopCondition name="magic(x) &gt; 0;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" blockOpened="false">
                  <methodCall name="&lt;call LoopInvariantWithSplittingQuery.magic(x_13)&gt;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                     <branchStatement name="if (x_13 &gt;= 0)" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" blockOpened="true">
                        <statement name="return -x_13;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                           <methodReturn name="&lt;return of magic&gt;" signature="&lt;return of LoopInvariantWithSplittingQuery.magic(x_13)&gt;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" nameIncludingReturnValue="&lt;return magic_sk_0 as result of magic&gt;" signatureIncludingReturnValue="&lt;return magic_sk_0 as result of LoopInvariantWithSplittingQuery.magic(x_13)&gt;" isReturnValueComputed="true" methodReturnCondition="true">
                              <methodReturnValue name="magic_sk_0" returnValueString="magic_sk_0" hasCondition="false">
                              </methodReturnValue>
                              <statement name="x--;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                                 <termination name="&lt;loop body end&gt;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\] (and(equals(b,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" terminationKind="LOOP_BODY" branchVerified="false">
                                 </termination>
                              </statement>
                           </methodReturn>
                           <completedBlockEntry path="/0/0/0/1/0/0/0" conditionString="true"/>
                        </statement>
                        <blockCompletionEntry path="/0/0/0/1/0/0/0/0"/>
                     </branchStatement>
                     <methodReturnEntry path="/0/0/0/1/0/0/0/0/0"/>
                  </methodCall>
               </loopCondition>
            </branchCondition>
         </branchCondition>
         <branchCondition name="update-application(elem-update(x)(x_0),\&lt;{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\&gt; (and(not(equals(b,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathCondition="update-application(elem-update(x)(x_0),\&lt;{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\&gt; (and(not(equals(b,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="true" branchCondition="update-application(elem-update(x)(x_0),\&lt;{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\&gt; (and(not(equals(b,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" mergedBranchCondition="false" isBranchConditionComputed="true" additionalBranchLabel="Use Case">
            <statement name="return x;" pathCondition="update-application(elem-update(x)(x_0),\&lt;{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\&gt; (and(not(equals(b,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="false">
               <methodReturn name="&lt;return of main&gt;" signature="&lt;return of LoopInvariantWithSplittingQuery.main(x)&gt;" pathCondition="update-application(elem-update(x)(x_0),\&lt;{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\&gt; (and(not(equals(b,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="false" nameIncludingReturnValue="&lt;return Z(0(#)) as result of main&gt;" signatureIncludingReturnValue="&lt;return Z(0(#)) as result of LoopInvariantWithSplittingQuery.main(x)&gt;" isReturnValueComputed="true" methodReturnCondition="update-application(elem-update(x)(x_0),\&lt;{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\&gt; (and(not(equals(b,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))">
                  <methodReturnValue name="Z(0(#))" returnValueString="Z(0(#))" hasCondition="false">
                  </methodReturnValue>
                  <termination name="&lt;end&gt;" pathCondition="update-application(elem-update(x)(x_0),\&lt;{
  method-frame (
    source=main(int)@LoopInvariantWithSplittingQuery
  ) {
    x_1 = magic(x);
    b = x_1 &gt; 0;
  }
}\&gt; (and(not(equals(b,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="false" terminationKind="NORMAL" branchVerified="true">
                  </termination>
               </methodReturn>
            </statement>
         </branchCondition>
      </loopInvariant>
      <methodReturnEntry path="/0/0/1/0/0"/>
   </methodCall>
   <terminationEntry path="/0/0/0/0/0/0/0/0/0/0/0"/>
   <terminationEntry path="/0/0/0/1/0/0/0/0/0/0/0"/>
   <terminationEntry path="/0/0/1/0/0/0"/>
</start>
