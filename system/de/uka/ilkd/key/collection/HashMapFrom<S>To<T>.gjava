#!/bin/sh
# This file is part of KeY - Integrated Deductive Software Design
# Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
#                         Universitaet Koblenz-Landau, Germany
#                         Chalmers University of Technology, Sweden
#
# The KeY system is protected by the GNU General Public License. 
# See LICENSE.TXT for details.
#
#
#
#
#!/bin/sh
pck=$1
outDir=$GENERATED_SRC_PATH`echo $1 | sed 's!\.!/!g;'`
mkdir -p $outDir
outFile=$outDir"/HashMapFrom"$2"To"$3".java"
sed "s/<Pck>/$pck/g;s/<S>/$2/g;s/<T>/$3/g;" <<END_OF_CLASS >$outFile


package <Pck>;

import de.uka.ilkd.key.logic.*;  //because the involved classes may be spread
import de.uka.ilkd.key.rule.*;  //because the involved classes may be spread

/** this class wraps @see{java.util.HashMap} but ensures that all keys
 * are from type <S> and the corresponding values are <T> types
 * The method are a subset of the java.util.HashMap so for a 
 * description see the JDK 1.2 API-Doc
 */
import java.util.HashMap;
import java.util.Iterator;

public class HashMapFrom<S>To<T> implements java.io.Serializable {
    
    /** the wrapped HashMap */
    private HashMap map;

    /** creates an empty HashMap with keys of type <S> and values of
     * type <T>
     */
    public HashMapFrom<S>To<T>() {
	map=new HashMap();
    }

    /** used by clone, handsover a HashMap map */
    private HashMapFrom<S>To<T>(HashMap map) {
	this.map=map;
    }


    /** removes all elements from this mapped */
    public void clear() {
	map.clear();
    }

    /** copies this map but without copying the keys or values */
    public Object clone() {
	return new HashMapFrom<S>To<T>((HashMap)map.clone());
    }

    /** @return true iff key is mapped to one value */
    public boolean containsKey(<S> key) {
	return map.containsKey(key);
    }

    /** @return true iff value is mapped by one ore more keys */
    public boolean containsValue(<T> val) {
	return map.containsValue(val);
    }

    /** @return value of <T> that is mapped to key, null if key has no
    * mapping */
    
    public <T> get(<S> key) {
	return (<T>)map.get(key);
    }

    /** @return true iff map contains no mapping */
    public boolean isEmpty() {
	return map.isEmpty();
    }

    /** @return IteratorOf<S> with all keys */
    public IteratorOf<S> keyIterator() {
	return new HashMapKeyIterator(map);
    }

    /** adds a mappig (key,value) to this map 
     * @return value that was mapped to key before
     */
    public <T> put(<S> key, <T> val) {
	return (<T>)map.put(key,val);
    }

    /** removes mapping for the specified key
     * @return the deleted value 
     */
    public <T> remove(<S> key) {
	return (<T>)map.remove(key);
    }

    /** @return the number of mappings */
    public int size() {
	return map.size();
    }

    /** @return IteratorOf<T> with all values */
    public IteratorOf<T> values() {
	return new HashMapValueIterator(map);
    }

    /** toString*/
    public String toString() {
	return map.toString();
    }

    private static class HashMapValueIterator implements IteratorOf<T>{
	
	private Iterator it;

	private HashMapValueIterator(HashMap map) {
	    it=(map.values()).iterator();
	}

	public boolean hasNext() {
	    return it.hasNext();
	}

	public <T> next() {
	    return (<T>)it.next();
	}

    }

    private static class HashMapKeyIterator implements IteratorOf<S>{
	
	private Iterator it;

	private HashMapKeyIterator(HashMap map) {
	    it=(map.keySet()).iterator();
	}

	public boolean hasNext() {
	    return it.hasNext();
	}

	public <S> next() {
	    return (<S>)it.next();
	}

    }
}

END_OF_CLASS
