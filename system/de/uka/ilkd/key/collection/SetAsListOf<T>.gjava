#!/bin/sh
# This file is part of KeY - Integrated Deductive Software Design
# Copyright (C) 2001-2009 Universitaet Karlsruhe, Germany
#                         Universitaet Koblenz-Landau, Germany
#                         Chalmers University of Technology, Sweden
#
# The KeY system is protected by the GNU General Public License. 
# See LICENSE.TXT for details.
#
#
#
#
#!/bin/sh
pck=$1
outDir=$GENERATED_SRC_PATH`echo $1 | sed 's!\.!/!g;'`
mkdir -p $outDir
outFile=$outDir"/"SetAsListOf$2".java"
sed "s/<Pck>/$pck/g;s/<T>/$2/g;" <<END_OF_CLASS >$outFile

package <Pck>;

/** implementation of a persistent set using the SLListOf<T> implementation
 * with all its implications (means e.g. O(n) for adding an 
 * element and so on. 
 */

public class SetAsListOf<T> implements SetOf<T> {

    /** list containing the elements */
    private ListOf<T> elementList=SLListOf<T>.EMPTY_LIST;
    
    /** the empty set */
    public static final SetAsListOf<T> EMPTY_SET=new NILSet();

    private Integer hashCode = null;

    private SetAsListOf<T>() {
    }

    /** creates new set with one element 
    * @param element of type <T> the new Set contains 
    */
    SetAsListOf<T>(<T> element) {
	elementList=elementList.prepend(element);
    }
    
    /** creates new set containg all elements from the elementList 
    * PRECONDITION: elementList has no duplicates
    * @param elementList ListOf<T> contains all elements of the new Set 
    */
    SetAsListOf<T>(ListOf<T> elementList) {
	this.elementList=elementList;
    }

    /** adds an element 
    * @param element of type <T> that has to be added to this set
    */
    public SetOf<T> add(<T> element) {
	if (elementList.contains(element)) {
	    return this;
	}
	return new SetAsListOf<T>(elementList.prepend(element));
    }

    /** adds an element, barfs if the element is already present
    * @param element of type <T> that has to be added to this set
    * @throws de.uka.ilkd.key.collection.NotUniqueException if the element is already present
    */
    public SetOf<T> addUnique(<T> element) 
	throws de.uka.ilkd.key.collection.NotUniqueException {
	if (elementList.contains(element)) {
	    throw new de.uka.ilkd.key.collection.NotUniqueException(element);
	} else {
	    return new SetAsListOf<T>(elementList.prepend(element));
	}
    }

    /** @return union of this set with set */
    public SetOf<T> union(SetOf<T> set) {
	if (set.isEmpty()) {
	    return this;
	}
	SetOf<T> unified=set;       
	IteratorOf<T> it=elementList.iterator();
	while (it.hasNext()) {
	    unified=unified.add(it.next());
	}
	return unified;
    }
    
    /** @return IteratorOf<T> of the set */
    public IteratorOf<T> iterator() {
	return elementList.iterator();
    }

    /** @return true iff obj in set */
    public boolean contains(<T> obj) {
	return elementList.contains(obj);
    }

    /** @return true iff this set is subset of set s */
    public boolean subset(SetOf<T> s) {
	if (size()>s.size()) {
	    return false;
	} else {
	    IteratorOf<T> it=iterator();
	    while (it.hasNext()) {		
		if (!s.contains(it.next())) {
		    return false;
		}
	    }
	}
	return true;
    }

    /** @return int the cardinality of the set */
    public int size() {
	return elementList.size();
    }    

    /** @return true iff the set is empty */
    public boolean isEmpty() {
	return false;
    }

    public SetOf<T> remove(<T> element) {
	ListOf<T> list = elementList.removeFirst(element);
	return (list.isEmpty()) ? EMPTY_SET : new SetAsListOf<T>(list);
    }


    /** @return true iff the this set is subset of o and vice versa.
     */
    public boolean equals(Object obj) {
	if (obj==this) {
	    return true;
	}
	if (!(obj instanceof SetOf<T>)) {
	    return false;
	}
	SetOf<T> o=(SetOf<T>) obj;
	return (o.subset(this) && this.subset(o));
    }

    /**
     * Convert the set to a Java array (O(n))
     */
    public <T>[] toArray() {
        return elementList.toArray();
    }

    public int hashCode() {
	if ( hashCode == null ) {
	    int h = 0;
	    IteratorOf<T> p = iterator();
	    while ( p.hasNext() ) {
		h += p.next().hashCode();
	    }

	    hashCode = new Integer (h);
	}

	return hashCode.intValue ();
    }


    public String toString() {
	IteratorOf<T> it=this.iterator();
	StringBuffer str=new StringBuffer("{");
	while (it.hasNext()) {
	    str.append(""+it.next());
	    if (it.hasNext()) {
		str.append(",");
	    }
	}	
	str.append("}");
	return str.toString();
    }

    /** represents the empty set for elements of type <T> */
    static class NILSet extends SetAsListOf<T> {
	
	NILSet() {} 

	/** the NIL list is a singleton. Deserialization builds
	 * a new NIL object that has to be replaced by the singleton.
	 */ 
	private Object readResolve() 
           throws java.io.ObjectStreamException {
           return SetAsListOf<T>.EMPTY_SET;
        }


	/** adds an element */
	public SetOf<T> add(<T> element) {
	    return new SetAsListOf<T>(element);
	}

	/** adds an element (which is unique, since the set was empty) */
	public SetOf<T> addUnique(<T> element) {
	    return new SetAsListOf<T>(element);
	}

	/** @return union of this set with set */
	public SetOf<T> union(SetOf<T> set) {
	    return set;
	}

	/** @return true iff obj in set */
	public boolean contains(<T> obj) {
	    return false;
	}
    
	/** @return IteratorOf<T> of the set */
	public IteratorOf<T> iterator() {
	    return (SLListOf<T>.EMPTY_LIST).iterator();
	}

	/** @return true iff this set is subset of set s */
	public boolean subset(SetOf<T> s) {
	    return true;
	}

	/** @return int the cardinality of the set */
	public int size() {
	    return 0;
	}       

	/** @return true iff the set is empty */
	public boolean isEmpty() {
	    return true;
	}

	/** @return true iff the this set is subset of o and vice versa.
	 */
	public boolean equals(Object o) {
	    return o instanceof NILSet;
	}

	public int hashCode() {
	    return 23456;
	}

	public String toString() {
	    return "{}";
	}	
 
    }
    
}
END_OF_CLASS
