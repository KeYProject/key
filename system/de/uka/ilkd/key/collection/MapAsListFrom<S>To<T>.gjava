#!/bin/sh
# This file is part of KeY - Integrated Deductive Software Design
# Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
#                         Universitaet Koblenz-Landau, Germany
#                         Chalmers University of Technology, Sweden
#
# The KeY system is protected by the GNU General Public License. 
# See LICENSE.TXT for details.
#
#
#
#
#!/bin/sh
pck=$1
outDir=$GENERATED_SRC_PATH`echo $1 | sed 's!\.!/!g;'`
mkdir -p $outDir
outFile=$outDir"/MapAsListFrom"$2"To"$3".java"
sed "s/<Pck>/$pck/g;s/<S>/$2/g;s/<T>/$3/g;" <<END_OF_CLASS >$outFile

package <Pck>;

import de.uka.ilkd.key.logic.*;  //because the involved classes may be spread
import de.uka.ilkd.key.proof.*;  //because the involved classes may be spread
import de.uka.ilkd.key.rule.*;  //because the involved classes may be spread
import de.uka.ilkd.key.rule.inst.*;  //because the involved classes may be spread


/**
 * This class implements MapFrom<S>To<T> and provides a
 * persistent Map. It is a simple implementation like lists     
 */
public class MapAsListFrom<S>To<T> implements MapFrom<S>To<T> {
    /** the empty map*/
    public static final NILMap EMPTY_MAP=new NILMap();   
    
    private final MapAsListFrom<S>To<T> parent;

    /** list of pairs (key,value) */
    private final EntryOf<S>And<T> entry;

    private int hashCode = 0;

    /** only for use by NILMap */
    private MapAsListFrom<S>To<T>() {
	entry       = null;
	this.parent = null;
    }
        

    /** creates new map with mapping entry */
    private MapAsListFrom<S>To<T>(EntryOf<S>And<T> entry) {
	if (entry == null) 
	    throw new RuntimeException("Invalid entry");
	this.entry = entry;
	this.parent = EMPTY_MAP;
    }

    /** creates new map with mapping entry and parent map */
    private MapAsListFrom<S>To<T>(EntryOf<S>And<T> entry, 
				  MapAsListFrom<S>To<T> parent) {
	if (entry == null) 
	    throw new RuntimeException("Invalid entry");
	this.entry = entry;
	this.parent = parent;
    }

    
    /**      
     * inserts mapping <key,val> into the map (old map is not modified) 
     * if key exists old entry has to be removed 
     * @param key a <S> to be used as key 
     * @param value a <T> to be stored as value
     * @return a MapFrom<S>To<T> including the <key, value> pair and all
     * other pairs of the current map with keys different from the given
     * key
     */
    public MapFrom<S>To<T> put(<S> key,<T> value) {
	return new MapAsListFrom<S>To<T>(new MapEntry(key,value), 
			     (MapAsListFrom<S>To<T>)this.remove(key));
    }


   
    /** @return value of type <T> that is mapped by key of type<S> */
    public <T> get(<S> key) {
	MapAsListFrom<S>To<T> queue = this;
	while (!queue.isEmpty()) {
	    final EntryOf<S>And<T> e = queue.entry;

	    final <S> entryKey = e.key();
	    if (entryKey == key || entryKey.equals(key)) {
		return e.value();
	    }

	    queue = queue.parent;
	}
	return null;
    }

    /** @return number of entries as int */
    public int size() {
	return 1 + parent.size();
    }

    /** returns true if the map is empty */
    public boolean isEmpty() {
	return false;
    }

    /** @return true iff the map includes key */
    public boolean containsKey(<S> key) {
	MapAsListFrom<S>To<T> queue = this;
	while (!queue.isEmpty()) {
	    final EntryOf<S>And<T> e = queue.entry;
	    final <S> entryKey = e.key();
	    if (entryKey == key || entryKey.equals(key)) {
		return true;
	    }
	    
	    queue = queue.parent;
	}
	return false;
    }

    /** @return true iff the map includes value */
    public boolean containsValue(<T> value) {
	MapAsListFrom<S>To<T> queue = this;
	while (!queue.isEmpty()) {
	    final EntryOf<S>And<T> e = queue.entry;
	    final <T> entryVal = e.value();
	    if (entryVal == value || entryVal.equals(value)) {
		return true;
	    }
	    queue = queue.parent;

	}
	return false;
    }

    private MapFrom<S>To<T> createMap(EntryOf<S>And<T>[] stack,
				      int counter,
				      MapAsListFrom<S>To<T> parent) {
	MapAsListFrom<S>To<T> result = parent;
	for (int i = 0; i<counter; i++) {
	    result = new MapAsListFrom<S>To<T>(stack[i], result);	    
	}
	return result;
    }

    /** 
     * removes mapping (key,...) from map
     * @return the new map (the same if key is not in the map)
     */
    public MapFrom<S>To<T> remove(<S> key) {      
	MapAsListFrom<S>To<T> queue = this;
	final EntryOf<S>And<T>[] stack = new EntryOf<S>And<T>[size()];
	int counter = 0;
	while (!queue.isEmpty()) {
	    final EntryOf<S>And<T> e = queue.entry;

	    final <S> entryKey = e.key();
	    
            if (entryKey == key || entryKey.equals(key)) {
		return createMap(stack, counter, queue.parent);
	    }
	    

	    stack[counter] = e;
	    counter ++;

	    queue = queue.parent;
	}
	return this;
    }

    /** removes all mappings (...,value) from map
     * @return the new map (the same if value is not mapped)
     */
    public MapFrom<S>To<T> removeAll(<T> value) {
	MapAsListFrom<S>To<T> queue = this;
	final EntryOf<S>And<T>[] stack = new EntryOf<S>And<T>[size()];
	int counter = 0;
	while (!queue.isEmpty()) {
	    final EntryOf<S>And<T> e = queue.entry;

	    final <T> entryVal = e.value();
	    
	    if (entryVal != value && !entryVal.equals(value)) {
		stack[counter] = e;
		counter ++;		
	    }

	    queue = queue.parent;

	}
	return counter < stack.length ? 
	    createMap(stack, counter, EMPTY_MAP) : this;
    }

    /** @return iterator for all keys */
    public IteratorOf<S> keyIterator() {
	return new MapKeyIterator(this);
    }

    /** @return iterator for all values */
    public IteratorOf<T> valueIterator() {
	return new MapValueIterator(this);
    }

    /** @return iterator for entries */
    public IteratorOfEntryOf<S>And<T> entryIterator() {
        return new MapEntryIterator(this);
    }

    public String toString() {
	final StringBuffer sb = new StringBuffer("[");
	final IteratorOfEntryOf<S>And<T> it = entryIterator();
	while (it.hasNext()) {
	    sb.append(""+it.next());
	    if (it.hasNext()) {
		sb.append(",");		
	    }
	}
	sb.append("]");
	return sb.toString();
    }

    public boolean equals(Object o) {
	if ( ! ( o instanceof MapFrom<S>To<T> ) ) 
	    return false;
	if (o == this) {
	    return true;
	}

	final MapFrom<S>To<T> o1 = (MapFrom<S>To<T>)o;
	if ( o1.size() != size() ) 
	    return false;

	
	final IteratorOfEntryOf<S>And<T> p = entryIterator();
	while ( p.hasNext() ) {
	    final EntryOf<S>And<T> e = p.next();
	    if ( !e.value().equals(o1.get(e.key())) ) {
		return false;
	    }
	}

	return true;
    }

    public int hashCode() {
	if ( hashCode == 0 ) {	  
	    final IteratorOfEntryOf<S>And<T> p = entryIterator();
	    while ( p.hasNext() ) {
		hashCode += 17*p.next().hashCode();
	    }
	    hashCode = hashCode == 0 ? 1 : hashCode; 
	}
	return hashCode;
    }

    /** the empty map */
    static class NILMap extends MapAsListFrom<S>To<T>{

	private NILMap() {
	}

	public MapFrom<S>To<T> put(<S> key, <T> value) {
	    return new MapAsListFrom<S>To<T>(new MapEntry(key,value));
	}

	public <T> get(<S> key) {
	    return null;
	}

	public boolean isEmpty() {
	    return true;
	}

	public boolean containsKey(<S> key) {
	    return false;
	}

	public boolean containsValue(<S> key) {
	    return false;
	}
	
	public MapFrom<S>To<T> remove(<S> key) {
	    return this;
	}

	public MapFrom<S>To<T> removeAll(<S> key) {
	    return this;
	}

	/** @return iterator for keys */
	public IteratorOf<S> keyIterator() {
	    return (SLListOf<S>.EMPTY_LIST).iterator();
	}

	/** @return iterator for values */
	public IteratorOf<T> valueIterator() {
	    return (SLListOf<T>.EMPTY_LIST).iterator();
	}

	/** @return iterator for entries */
	public IteratorOfEntryOf<S>And<T> entryIterator() {
	    return (SLListOfEntryOf<S>And<T>.EMPTY_LIST).iterator();
	}

	public int size(){
	    return 0;
	}

	public String toString() {
	    return "[(,)]";
	}
    }

    /** inner class for the entries */
    static class MapEntry implements EntryOf<S>And<T> {
	// the key
	private final <S> key;
	// the value
	private final <T> value;

	/** creates a new map entry that contains key and value */ 
	MapEntry(<S> key, <T> value) {
	    this.key   = key;
	    this.value = value;
	} 
	
	/** @return the key stored in this entry */
	public <S> key() {
	    return key;
	}

	/** @return the value stored in this entry */
	public <T> value() {
	    return value;
	}	
	
	/** @return true iff both objects have equal pairs of key and
	 * value 
	 */ 
	public boolean equals(Object obj) {
	    final EntryOf<S>And<T> cmp = (EntryOf<S>And<T>) obj; 
	    final <S> cmpKey = cmp.key(); 
	    final <T> cmpVal = cmp.value(); 
	    return (key == cmpKey && value == cmpVal) || 
		(key.equals(cmpKey) && value.equals(cmpVal));
	}
	
	public int hashCode() {
	    return key.hashCode() * 7 + value.hashCode();
	}

	public String toString() {
	    return key+"->"+value;
	}
    }

    /** iterator for the values */
    static abstract class MapIterator {
	// stores the entry iterator
	private MapAsListFrom<S>To<T> map;
	
	// creates the iterator
	MapIterator(MapAsListFrom<S>To<T> map) {
	    this.map = map;
	}

	/** @return true iff there are more elements */
	public boolean hasNext() {
	    return !map.isEmpty();
	}

	/** @return next value in list */
	public EntryOf<S>And<T> nextEntry() {
	    final MapAsListFrom<S>To<T> oldmap = map;
	    map = oldmap.parent;
	    return oldmap.entry;
	}
	
	/** 
	 * throws an unsupported operation exception as removing elements
	 * is not allowed on immutable maps
	 */
	 public void remove() {
	     throw new UnsupportedOperationException("Removing elements via an iterator" +
	    	" is not supported for immutable maps.");
	 } 
    }

    /** iterator for the values */
    static class MapEntryIterator extends MapIterator 
                                  implements IteratorOfEntryOf<S>And<T> {

	MapEntryIterator(MapAsListFrom<S>To<T> map) {
	    super(map);
	}
    
	/** @return next value in list */
	public EntryOf<S>And<T> next() {
	    return nextEntry();
	}
    }


    static class MapValueIterator extends MapIterator 
	implements IteratorOf<T> {

	MapValueIterator(MapAsListFrom<S>To<T> map) {
	    super(map);
	}
    
	/** @return next value in list */
	public <T> next() {
	    return nextEntry().value();
	}
    }

    static class MapKeyIterator extends MapIterator 
	implements IteratorOf<S> {

	MapKeyIterator(MapAsListFrom<S>To<T> map) {
	    super(map);
	}
    
	/** @return next value in list */
	public <S> next() {
	    return nextEntry().key();
	}
    }
}

