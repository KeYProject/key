#!/bin/sh
# This file is part of KeY - Integrated Deductive Software Design
# Copyright (C) 2001-2009 Universitaet Karlsruhe, Germany
#                         Universitaet Koblenz-Landau, Germany
#                         Chalmers University of Technology, Sweden
#
# The KeY system is protected by the GNU General Public License. 
# See LICENSE.TXT for details.
#
#
pck=$1
outDir=$GENERATED_SRC_PATH`echo $1 | sed 's!\.!/!g;'`
mkdir -p $outDir
outFile=$outDir"/"SLListOf$2".java"
sed "s/<Pck>/$pck/g;s/<T>/$2/g;" <<END_OF_CLASS >$outFile

package <Pck>;

import de.uka.ilkd.key.logic.*;  //because the involved classes may be spread

/** a NON-DESTRUCTIVE single linked list for elements of type <T>. The
 *    costs of the  
 * different operations are O(1) for prepending one element,
 * O(m) for prepending a list with m elements, 
 * O(n) for appending an element to this list(size n)
 * O(n) for appending a list with m elements to this list (size n)
 * head() has O(1)
 * tail has O(1)
 * size has O(1)
 * ATTENTION appending and prepending and element can be realized 
 * with O(1) costs (see Osaka) then having tail and head with
 * amortized O(1). This will be done later (if necessary).
 */

public abstract class SLListOf<T> implements ListOf<T> {
    
    /** the empty list */
    public static final SLListOf<T> EMPTY_LIST=new NIL();

    /**
     * Reverses this list (O(N))
     */
    public ListOf<T> reverse() {
	if ( size () <= 1 )
	    return this;

	ListOf<T> rest = this;
	ListOf<T> rev  = EMPTY_LIST;
	while (!rest.isEmpty()) {
	    rev = rev.prepend(rest.head());
	    rest = rest.tail();
	}
	return rev;
    }


    /**
     * Convert the list to a Java array (O(n))
     */
    public <T>[] toArray() {
	<T>[]     res  = new <T> [ size () ];
	int       i    = 0;
	ListOf<T> rest = this;
	while ( !rest.isEmpty() ) {
	    res[i++] = rest.head ();
	    rest     = rest.tail ();
	}
	return res;
    }


    /** prepends array (O(n))
     * @param array the array of the elements to be prepended
     * @return ListOf<T> the new list  
     */
    public ListOf<T> prepend(<T>[] array) {
	return prepend ( array, array.length );
    }


    /** 
     * prepends the first <code>n</code> elements of an array (O(n))
     * @param array the array of the elements to be prepended
     * @param n an int specifying the number of elements to be prepended 
     * @return ListOf<T> the new list  
     */
    protected ListOf<T> prepend(<T>[] array, int n) {
	ListOf<T> res = this;
	while ( n-- != 0 )
	    res = new Cons(array[n], (SLListOf<T>)res);
	return res;
    }

    /** 
     * first <code>n</code> elements of the list are truncated
     * @param n an int specifying the number of elements to be truncated
     * @return ListOf<T> this list without the first <code>n</code> elements  
     */
    public ListOf<T> take(int n) {
	if ( n < 0 || n > size () )
	    throw new IndexOutOfBoundsException
		( "Unable to take " + n + " elements from list " + this );
	
	ListOf<T> rest = this;

	while ( n-- != 0 )
	    rest = rest.tail ();

	return rest;
    }


    static class Cons extends SLListOf<T>{
	
	/** the first element */
	private final <T> element;
	/** reference to the next element (equiv.to the tail of list) */ 
	private final SLListOf<T> cons;
	/** size of the list */
	private final int size;
	/** caches the hashcode */
	private final int hashCode;
	
	/** new list with only one element
	 * @param element the only element in list
	 */
	Cons(<T> element) {
	    this.element=element;
	    cons=EMPTY_LIST;
	    size=1;
	    hashCode=(element == null ? 0 : element.hashCode()); 
	}
	    
	/** constructs a new list with element as head and cons as tail
	 * @param element a <T> stored in the head element of the list
	 * @param cons tail of the list 
	 */
	Cons(<T> element, SLListOf<T> cons) {
	    this.element=element;
	    this.cons=cons;
	    size=cons.size()+1;
	    hashCode=(element == null ? 0 : element.hashCode()) + 
		31*cons.hashCode(); 
	}

	/** creates a new list with element as head and the
	 * momentan list as tail (O(1))
	 * @param e the <T> to be prepended
	 * @return ListOf<T> the new list  
	 */
	public ListOf<T> prepend(<T> e) {
	    return new Cons(e, this);
	}
	
	/** prepends list (O(n))
	 * @param list the ListOf<T> to be prepended
	 * @return ListOf<T> the new list  
	 */
	public ListOf<T> prepend(ListOf<T> list) {
	    return prepend ( list.toArray () );
	}

	/** appends element at end (non-destructive) (O(n))
	 * @param e the <T> to be prepended
	 * @return ListOf<T> the new list  
	 */
	public ListOf<T> append(<T> e) {
	    return (new Cons(e)).prepend(this);
	}

	/** appends element at end (non-destructive) (O(n))
	 * @param list the ListOf<T> to be appended
	 * @return ListOf<T> the new list  
	 */    
	public ListOf<T> append(ListOf<T> list) {
	    return list.prepend(this);
	}

	/** appends element at end (non-destructive) (O(n))
	 * @param array the array to be appended
	 * @return ListOf<T> the new list  
	 */    
	public ListOf<T> append(<T>[] array) {
	    return EMPTY_LIST.prepend ( array ).prepend ( this );
	}

	/** @return <T> first element in list */
	public <T> head() {
	    return element;
	}
	
	/** @return ListOf<T> tail of the list */
	public ListOf<T> tail() {
	    return cons;
	}
	
	/**
	 * hashcode for collections, implemented same algorithm as
         * java.util.Collections use 	 
	 * @return the hashcode of the list
         */
	public int hashCode() {
	    return hashCode;
	}

	
	/** @return iterator through list */
	public IteratorOf<T> iterator() {
	    return new SLListIterator(this);
	}
	
	/** @return int the number of elements in list */    
	public int size() {
	    return size;
	}

	/** @return boolean true iff. obj in list */
	public boolean contains(<T> obj) {
	    ListOf<T> list = this;
	    <T>       t;
	    while (!list.isEmpty()) {
		t = list.head ();
		if ( t == null ? obj == null : t.equals ( obj ) )
		    return true;
		list = list.tail();
	    }
	    return false;
	}

	/** @return true iff the list is empty */
	public boolean isEmpty() {
	    return false;
	}


	/** removes first occurrences of obj (O(n))
	 * @return new list 
	 */
	public ListOf<T> removeFirst(<T> obj) {
	    <T>[]       res            = new <T> [ size () ];
	    int         i              = 0;
	    SLListOf<T> rest           = this;
	    SLListOf<T> unmodifiedTail = this;
	    <T>         t;
	    while (!rest.isEmpty()) {
		t    = rest.head ();
		rest = (SLListOf<T>)rest.tail();
		if ( !( t == null ? obj == null : t.equals ( obj ) ) )
		    res[i++] = t;
		else {
		    unmodifiedTail = rest;
		    return unmodifiedTail.prepend( res, i );
		}
	    }
	    return this;
	    
	}
	

	/** 
	 * removes all occurrences of obj (O(n))
	 * @return new list 
	 */
	public ListOf<T> removeAll(<T> obj) {
	    <T>[]       res            = new <T> [ size () ];
	    int         i              = 0;
	    SLListOf<T> rest           = this;
	    SLListOf<T> unmodifiedTail = this;
	    <T>         t;

	    while (!rest.isEmpty()) {
		t    = rest.head ();
		rest = (SLListOf<T>)rest.tail();
		if ( !( t == null ? obj == null : t.equals ( obj ) ) )
		    res[i++] = t;
		else
		    unmodifiedTail = rest;
	    }

	    return unmodifiedTail.prepend
		( res, i - unmodifiedTail.size () );
	}


	public boolean equals(Object o) {
	    if ( ! ( o instanceof ListOf<T> ) ) 
		return false;
	    ListOf<T> o1 = (ListOf<T>) o;
	    if ( o1.size() != size() ) 
		return false;
	    IteratorOf<T> p = iterator();
		IteratorOf<T> q = (o1).iterator();
	    while ( p.hasNext() ) {
	        <T> ep = p.next();
	        <T> eq = q.next();
	        if ( ( ep == null && eq != null ) 
		    || ( ep != null && !ep.equals(eq) ) ) 
		  return false;
	    }
	    return true;
        }


	public String toString() {
	    IteratorOf<T> it=this.iterator();
	    StringBuffer str=new StringBuffer("[");
	    while (it.hasNext()) {
		str.append(""+it.next());
		if (it.hasNext()) {
		    str.append(",");
		}
	    }	
	    str.append("]");
	    return str.toString();
	}

	/** iterates through a none destructive list */
	private static class SLListIterator implements IteratorOf<T> {
	
	    /** the list of remaining elements */
	    private ListOf<T> list;
	
	    /** constructs the iterator
	     *@param list the ListOf<T> that has to be iterated 
	     */
	    public SLListIterator(ListOf<T> list) {
		this.list = list;	
	    }
	
	    /** @return next element in list */
	    public <T> next() {
		<T> element = list.head();
		list = list.tail();
		return element;
	    }
	
	    /** @return true iff there are unseen elements in the list
	     */ 
	    public boolean hasNext() {
		return !list.isEmpty();
	    }    

	   /** 
	    * throws an unsupported operation exception as removing elements
	    * is not allowed on immutable lists
	    */
	    public void remove() {
	    	throw new UnsupportedOperationException("Removing elements via an iterator" +
	    	" is not supported for immutable datastructures.");
	    } 
	    
	}


    }


    static class NIL extends SLListOf<T>{

	private static final SLNilListIterator iterator = 
	    new SLNilListIterator();
	
	NIL() {
	}
    
	/** the NIL list is a singleton. Deserialization builds
	 * a new NIL object that has to be replaced by the singleton.
         */ 
        private Object readResolve() 
            throws java.io.ObjectStreamException {
            return SLListOf<T>.EMPTY_LIST;
	}
	
	public int size() {
	    return 0;
	}

	public boolean equals ( Object o ) {
	    return o instanceof NIL;
	}
	
	public int hashCode() {
	    return 0;
	}
	
	public ListOf<T> prepend(<T> element) {
	    return new Cons(element);
	}
	    
	public ListOf<T> prepend(ListOf<T> list) {
	    return list;
	}
	    
	public ListOf<T> append(<T> element) {
	    return new Cons(element);
	}
	    
	public ListOf<T> append(ListOf<T> list) {
	    return list;
	}

	public ListOf<T> append(<T>[] array) {
	    return EMPTY_LIST.prepend ( array );
	}
	    
	public boolean contains(<T> obj) {
	    return false;
	}

	public boolean isEmpty() {
	    return true;
	}
	    
	public IteratorOf<T> iterator() {
	    return iterator;
	}
	    
	public <T> head() {
	    return null;
	}
	    
	public ListOf<T> tail() {
	    return this;
	}

	public ListOf<T> removeAll(<T> obj) {
	    return this;	
	}

	public ListOf<T> removeFirst(<T> obj) {
	    return this;	
	}
	    
	public String toString() {
	    return "[]";
	}

	/** iterates through the a none destructive NIL list */
	private static class SLNilListIterator implements IteratorOf<T> {
	    	
	    /** 
	     * creates the NIL list iterator
	     */
	    public SLNilListIterator() {
	    }
	    
	    /** @return next element in list */
	    public <T> next() {
		return null;
	    }

	    /** 
	     * @return true iff there are unseen elements in the list
	     */ 
	    public boolean hasNext() {
		return false;
	    }
	    
	    /** 
	     * throws an unsupported operation exception as removing elements
	     * is not allowed on immutable lists
	     */
	    public void remove() {
	    	throw new UnsupportedOperationException("Removing elements via an iterator" +
	    	" is not supported for immutable datastructures.");
	    }     
	}
    }
}

    
END_OF_CLASS
