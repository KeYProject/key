// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//

package de.uka.ilkd.key.proof.mgt;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import org.apache.log4j.Logger;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.proof.*;
import de.uka.ilkd.key.proof.init.InitConfig;
import de.uka.ilkd.key.proof.init.ProofOblInput;
import de.uka.ilkd.key.rule.*;

/** The unique environment a proof is performed in. The environment
 * consists of a java model, specifications, and a set of justified
 * rules. Since the starting point of the proofs contained in the
 * environment is equal, there is an InitConfig contained to be used
 * to start proofs of this environment.
 */
public class ProofEnvironment {

    private JavaModel jModel;
    private RuleConfig ruleConfig;
    private RuleJustificationInfo justifInfo = new RuleJustificationInfo();
    private final InitConfig initConfig; 
    private Set<ProofAggregate> proofs = new HashSet<ProofAggregate>(); //of ProofList
    private int number=0;

    private Logger mgtLogger = Logger.getLogger("key.proof.mgt");

    /** constructs a proof environment with the given initial
     * configuration of the proofs contained in the environment.
     */
    public ProofEnvironment(InitConfig initConfig) {
	this.initConfig = initConfig;
    }


    /** retrieves the java model underlying this environment.
     */
    public JavaModel getJavaModel() {
	return jModel;
    }

    public RuleConfig getRuleConfig() {
	return ruleConfig;
    }

    /** sets the java model underlying this environment. Only to be
     * called by the {@link de.uka.ilkd.key.proof.init.ProblemInitializer}.
     */
    public void setJavaModel(JavaModel m) {
	jModel=m;
    }

    public void setRuleConfig(RuleConfig rc) {
	ruleConfig=rc;
    }
        
    public Services getInitialServices() {
        return initConfig.getServices();
    }


    /** returns the object managing the rules in this environement and
     * their justifications. The object is unique to this environment. 
     */
    public RuleJustificationInfo getJustifInfo() {
	return justifInfo;
    }

    /** returns the initial configuration to be used to load proofs in
     * this environment. 
     */
    public InitConfig getInitConfig() {
	return initConfig;
    }

    /** registers a proof loaded with the given {@link 
     * de.uka.ilkd.key.proof.init.ProofOblInput}. The method adds
     * the proof list generated by the input to the suitable contract if one 
     * is found. In all cases the proof is added to the proofs of this 
     * environment and the proofs are marked to belong to this environment.
     */
    public void registerProof(ProofOblInput po, ProofAggregate pl) {
        pl.setProofEnv(this);
        proofs.add(pl);
        if(pl.size() == 1) {
            getInitialServices().getSpecificationRepository()
                                .registerProof(po, pl.getFirstProof());
        }        
    }

    /** registers a rule with the given justification at the
     * justification managing {@link RuleJustification} object of this
     * environment. 
     */
    public void registerRule(Rule r, RuleJustification j) {
	justifInfo.addJustification(r, j);
    }

    public void registerRuleIntroducedAtNode(RuleApp r, 
                                             Node node, 
                                             boolean isAxiom) {
        justifInfo.addJustification(r.rule(), 
                                    new RuleJustificationByAddRules(node, 
                                                                    isAxiom));
    }

    /** registers a set of rules with the given justification at the
     * justification managing {@link RuleJustification} object of this
     * environment. All rules of the set are given the same
     * justification. 
     */
    public void registerRules(SetOfTaclet s, RuleJustification j) {
	IteratorOfTaclet it = s.iterator();
	while (it.hasNext()) {
	    registerRule(it.next(), j);
	}
    }

    /** registers a list of rules with the given justification at the
     * justification managing {@link RuleJustification} object of this
     * environment. All rules of the list are given the same
     * justification. 
     */
    public void registerRules(ListOfBuiltInRule s, RuleJustification j) {
	IteratorOfBuiltInRule it = s.iterator();
	while (it.hasNext()) {
	    Rule r=it.next();
	    registerRule(r, j);
	}
    }

    /** retrieves all proofs registered at this environment 
     */
    public Set<ProofAggregate> getProofs() {
	return proofs;
    }

    public void removeProofList(ProofAggregate pl) {
	proofs.remove(pl);
        if(pl.size() == 1) {
            getInitialServices().getSpecificationRepository()
                                .removeProof(pl.getFirstProof());
        }
    }


    /** returns true iff the java model equals those of the argument
     * proof environment. TODO: extend to available rules and specs.
     */
    public boolean equals(Object cmp) {
 	if (!(cmp instanceof ProofEnvironment)) {
 	    return false;
 	}
 	ProofEnvironment pe = (ProofEnvironment) cmp;
 	return pe.getJavaModel().equals(getJavaModel())&&
	    pe.getRuleConfig().equals(getRuleConfig()) &&
	    pe.getNumber()==(getNumber());
    }

    public int hashCode() {
	int result = 5;
	result = result*17+ getJavaModel().hashCode();
	result = result*17+ getRuleConfig().hashCode();
	result = result*17+ getNumber();
	return result;
    }

    /** returns a short String description of the environment.
     */
    public String description() {
	return "Env. with "+getJavaModel().description()+" #"+getNumber();
    }

    public void updateProofStatus() {
	Set<ProofAggregate> allProofs = getProofs();
	Iterator<ProofAggregate> allProofsIt = allProofs.iterator();
	ProofAggregate  pl = null;
	while (allProofsIt.hasNext()) {
	    pl = allProofsIt.next();
	    pl.updateProofStatus();
	}
    }

    public String getPureDiff(ProofEnvironment pe) {
	CvsRunner cvs = new CvsRunner();
	String diff="";
	if (!getJavaModel().isEmpty()) {
	    try{
		diff = cvs.cvsDiff(getJavaModel().getCVSModule(),
				   pe.getJavaModel().getModelTag(), 
				   getJavaModel().getModelTag());
	    } catch(CvsException cvse) {
		mgtLogger.error("Diffing models in CVS failed: "+cvse);
	    }
	}
	return diff;
    }

    public String getRuleDiff(ProofEnvironment pe) {
	return "Rules: \n    Earlier: " +pe.getRuleConfig().description()
	    +"\n    Now: "+getRuleConfig().description();
    }

    public String getDiffUserInfo(ProofEnvironment pe) {
	String base = "Comparing "+description()+" with "+pe.description()+":\n";
	if (getJavaModel() != JavaModel.NO_MODEL && 
	    !getJavaModel().getModelDir().equals
	    (pe.getJavaModel().getModelDir())) {
	    return base+"No Diff for different model directories: \n"
		+getJavaModel().getModelDir()+" \n and "
		+pe.getJavaModel().getModelDir();
	}
	return base+getPureDiff(pe) +"\n"+ getRuleDiff(pe);
    }

    /** sets a number that distinguishes two proof environments
     * with equal java model and rule config from the user perspective
     */
    public void setNumber(int number) {
	this.number = number;
    }

    /** returns a number that distinguishes two proof environments
     * with equal java model and rule config from the user perspective
     */
    public int getNumber() {
	return number;
    }

    public String toString() {
	return description();
    }    

}
