package de.uka.ilkd.key.rule.metaconstruct;

import org.apache.log4j.Logger;

import de.uka.ilkd.key.java.*;
import de.uka.ilkd.key.java.abstraction.ArrayType;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.abstraction.Type;
import de.uka.ilkd.key.java.declaration.LocalVariableDeclaration;
import de.uka.ilkd.key.java.declaration.VariableSpecification;
import de.uka.ilkd.key.java.reference.ArrayReference;
import de.uka.ilkd.key.java.reference.ReferencePrefix;
import de.uka.ilkd.key.java.reference.TypeRef;
import de.uka.ilkd.key.java.statement.*;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.rule.inst.SVInstantiations;

/**
 * 
 * @author mulbrich
 * 
 */

public class EnhancedForElimination extends ProgramMetaConstruct {

    private Logger logger = Logger.getLogger(EnhancedForElimination.class);

    private Services services;

    public EnhancedForElimination(EnhancedFor forStatement) {
        super("enhancedfor-elim", forStatement);
    }

    /**
     * An enhanced for loop is executed by transforming it into a "normal" for
     * loop.
     * 
     * For an enhanced for "for(type var : exp) stm" the fields of LoopStatement
     * are used as follows:
     * <ul>
     * <li>inits: type var
     * <li>guard: exp
     * <li>updates remains empty
     * <li>body: stm
     * </ul>
     * 
     * Loops over arrays and loops over Iterable-objects are treated
     * separatedly.
     * 
     * <b>The rules which use this meta construct must ensure that exp is a
     * simple expression w/o side effects</b>
     * 
     * @see #makeArrayForLoop(LocalVariableDeclaration, Expression, Statement)
     * @see #makeIterableForLoop(LocalVariableDeclaration, Expression,
     *      Statement)
     * 
     * @see de.uka.ilkd.key.rule.metaconstruct.ProgramMetaConstruct#symbolicExecution(de.uka.ilkd.key.java.ProgramElement,
     *      de.uka.ilkd.key.java.Services,
     *      de.uka.ilkd.key.rule.inst.SVInstantiations)
     */
    @Override
    public ProgramElement symbolicExecution(ProgramElement pe,
            Services services, SVInstantiations svInst) {

        assert pe instanceof EnhancedFor : "Only works on enhanced fors";

        this.services = services;

        EnhancedFor enhancedFor = (EnhancedFor) pe;

        LocalVariableDeclaration lvd = enhancedFor.getVariableDeclaration();
        Expression expression = enhancedFor.getGuardExpression();
        Statement body = enhancedFor.getBody();

        final KeYJavaType expType = services.getTypeConverter().getKeYJavaType(
                (Expression) pe, null);

        assert expType != null : "Type of the expression cannot be determined";

        if (expType instanceof ArrayType) {
            return makeArrayForLoop(lvd, expression, body);
        } else
            return makeIterableForLoop(lvd, expression, body);
    }

    /**
     * Given a for loop statement
     * 
     * <pre>
     *              for ( VariableModifiers[opt] Type Identifier : Expression ) Statement
     * </pre>
     * 
     * return a transformed block which looks like:
     * 
     * <pre>
     *              for (int i = 0; i &lt; Expression.length; i++) {
     *                 VariableModifiers[opt] Type Identifier = Expression[i];
     *                 Statement
     *              }
     * </pre>
     * 
     * It must be ensured by the applying rule that Expression is a simple
     * expression free of side effects.
     * 
     * This transformation is deducted from the JLS Paragraph 14.14.2
     * 
     * @param lvd
     *            the variable declaration
     * @param expression
     *            a simple expression
     * @param body
     *            the original body
     * @return
     */

    private ProgramElement makeArrayForLoop(LocalVariableDeclaration lvd,
            Expression expression, Statement body) {
        // TODO Auto-generated method stub

        ProgramVariable countVar = makeCountVar();

        StatementBlock block;
        // Make the block { ... } which contains exactly 2 statements
        {
            Statement[] statements = new Statement[2];
            statements[0] = makeVariableDeclaration(lvd, expression, countVar);
            statements[1] = body;
            block = new StatementBlock(statements);
        }

        For forInst;
        // make the for
        {
            LoopInit inits = makeLoopInitializer(countVar);
            Guard guard = makeGuard(countVar, expression);
            ForUpdates updates = null; //makeUpdates(countVar);
            forInst = new For(inits, guard, updates, block);
        }

        // VariableModifiers[opt] Type Identifier = Expression[i];
        // LocalVariableDeclaration newlvd = services.getTypeConverter().

        return forInst;
    }

    /*
     * make " __i < Expression.length "
     */
    private Guard makeGuard(ProgramVariable countVar, Expression expression) {
        
        return null;
    }

    /*
     * make "int __i = 0"
     */
    private LoopInit makeLoopInitializer(ProgramVariable countVar) {
        VariableSpecification spec = new VariableSpecification(countVar, null,
                countVar.getKeYJavaType());
        TypeRef integerType = new TypeRef(services.getJavaInfo()
                .getPrimitiveKeYJavaType("int"));
        LocalVariableDeclaration[] inits = { new LocalVariableDeclaration(
                integerType, spec) };
        return new LoopInit(inits);
    }

    /*
     * make the counting variable, which is a new one! (e.g. "__i")
     */
    private ProgramVariable makeCountVar() {
        // TODO make a new variable <-- where to get a new name from ?!?
        KeYJavaType integerType = services.getJavaInfo()
                .getPrimitiveKeYJavaType("int");
        return new ProgramVariable(new ProgramElementName("__i"), integerType);
    }

    /*
     * make VariableModifiers[opt] Type Identifier = Expression[__i];
     */
    private LocalVariableDeclaration makeVariableDeclaration(
            LocalVariableDeclaration lvd, Expression expression,
            ProgramVariable countVar) {

        assert expression instanceof ReferencePrefix : "The expression is not a ReferencePrefix (sure it was a simple expresseion?)";

        // make the expression
        Expression[] indx = { countVar };
        ArrayReference ref = new ArrayReference((ReferencePrefix) expression,
                indx);

        // make the declaration
        IProgramVariable v = lvd.getVariables().getVariableSpecification(0)
                .getProgramVariable();
        Type type = lvd.getVariables().getVariableSpecification(0).getType();
        VariableSpecification vspec = new VariableSpecification(v, ref, type);
        LocalVariableDeclaration newlvd = new LocalVariableDeclaration(lvd
                .getModifiers(), lvd.getTypeReference(), vspec);

        return newlvd;
    }

    private ProgramElement makeIterableForLoop(LocalVariableDeclaration lvd,
            Expression expression, Statement body) {
        throw new UnsupportedOperationException("Not yet implemented!");
    }
}
