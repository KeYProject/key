// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//

// This file is taken from the RECODER library, which is protected by the LGPL,
// and modified.

options {
    JAVA_UNICODE_ESCAPE = true; // costs approx. 7%
    STATIC = true; // if true, the parser may be initialized only once
    OPTIMIZE_TOKEN_MANAGER = true;
//    DEBUG_PARSER = true;
}

PARSER_BEGIN(ProofJavaParser)

package de.uka.ilkd.key.parser.proofjava;

import java.io.*;
import java.util.*;

import recoder.*;
import recoder.list.*;
import recoder.java.*;
import recoder.java.declaration.*;
import recoder.java.declaration.modifier.*;
import recoder.java.expression.*;
import recoder.java.expression.literal.*;
import recoder.java.expression.operator.*;
import recoder.java.reference.*;
import recoder.java.statement.*;
import recoder.io.*;

import de.uka.ilkd.key.java.recoderext.*;

/**
   JavaCC AST generation specification based on the original Java1.1   
   grammar that comes with javacc, and includes the modification of D. Williams
   to accept the Java 1.2 strictfp modifier.
   Several patches have been added to allow semicola after member declarations.
   Augmented with special constructs used in KeY proofs. These are:
   - method-call statement
   - method-body statement
   - implicit fields
 */
public class ProofJavaParser {

    public static final void initialize(Reader r) {
	current = null;
	comments.clear();
	ReInit(r);
    }

    /** the JavaProgramFactory instance that is used to create
	parse results
    */
    private static ProofJavaProgramFactory factory
	= (ProofJavaProgramFactory) ProofJavaProgramFactory.getInstance();

    /** temporary valid variable that is used to return an additional
        argument from parser method VariableDeclaratorId, since such an
        id may have a dimension
    */
    private static int tmpDimension;

    /** current token, follows the next links when necessary */
    private static Token current;

    /** all comments in a global list. */
    private static CommentMutableList comments = new CommentArrayList();


    /** reuseable position object. */
    private static SourceElement.Position position 
	= new SourceElement.Position(0, 0);

    private static void	copyPrefixInfo(SourceElement oldResult,
				       SourceElement newResult) {
	newResult.setRelativePosition(oldResult.getRelativePosition());
	newResult.setStartPosition(oldResult.getStartPosition());
        newResult.setEndPosition(oldResult.getEndPosition());
    }

    /**
       Sets indentation information.
     */
    private static void shiftToken() {
        if (current != token) {
	    if (current != null) {
		while (current.next != token) {
		    current = current.next;
		}
	    }
            Token prev;
            if (token.specialToken != null) {
                prev = token.specialToken;
            } else {
                prev = current;
            }
	    if (prev != null) {
		int col = token.beginColumn - 1;
		int lf = token.beginLine - prev.endLine;
		if (lf <= 0) {
                    col -= prev.endColumn; // - 1;
		    if (col < 0) {
			col = 0;
		    }
		}		
		position.setPosition(lf, col);
	    }
        }
        current = token;
    }
        
        
        
    private static void setPrefixInfo(SourceElement constrResult) {
	position.setPosition(0, 0);
        shiftToken();
	constrResult.setRelativePosition(position);
	position.setPosition(current.beginLine, current.beginColumn);
	constrResult.setStartPosition(position);
    }

    private static void setPostfixInfo(SourceElement constrResult) { 
        shiftToken(); 
        position.setPosition(current.endLine, current.endColumn); 
        constrResult.setEndPosition(position); 
    }
     
    private static void addComment(Comment c, Token tok) {
        Token prev = tok.specialToken;
        if (prev == null) {
            prev = token;
            // in case we are inside a lookahead we skip to the last known
            // non-special token
            while (prev.next != null) {
                prev = prev.next;
            }
        }
	position.setPosition(0, 0);

        int internalIndentation = 0;
        int internalLinefeeds = 0;
        if (prev.image != null) {
	    int col = tok.beginColumn - 1;
	    int lf = tok.beginLine - prev.endLine;
	    if (lf <= 0) {
                col -= prev.endColumn; // - 1;
	    }		
	    position.setPosition(lf, col);
        }
        c.setRelativePosition(position);
        position.setPosition(tok.endLine, tok.endColumn);
        c.setEndPosition(position);
        position.setPosition(tok.beginLine, tok.beginColumn);
        c.setStartPosition(position);
        if (!(c instanceof DocComment)) {
	    boolean hasEmptyLine = c.getRelativePosition().getLine() > 1;
	    c.setPrefixed(hasEmptyLine);
	    if (tok.specialToken != null && !hasEmptyLine) {
		c.setPrefixed(comments.getComment(comments.size() - 1).isPrefixed());
	    }	    
	}
        comments.add(c);
    }
    
    static void addSingleLineComment(Token tok) {
        addComment(factory.createSingleLineComment(tok.image.trim()), tok);
    }

    static void addMultiLineComment(Token tok) {
        addComment(factory.createComment(tok.image), tok);
    }

    static void addDocComment(Token tok) {
        addComment(factory.createDocComment(tok.image), tok);
    }
    
    public static CommentMutableList getComments() {
	return comments;
    }
   
 
    /** checks whether or not the tree construction result is valid.
	Currently this only checks whether or not the result is <tt>null</tt>.
	@param constrResult the result of a factory call
	@exception ParseException if the result is not legal
    */
    private static void checkConstruction(SourceElement constrResult) 
    throws ParseException {
	if (constrResult == null) {
	    throw new ParseException
	       ("An illegal null object was created during tree construction");	
	}


	// insert check code here!!
    }

    private static void checkConstruction(ProgramElementList constrResult) 
    throws ParseException {
	if (constrResult == null) {
	    throw new ParseException
		("An illegal null list was created during tree construction");
	}
	// insert check code here!!
    }


    /** inner class that is only used to return results from
	primary suffix syntax rule
	@author RN
    */
    static class PrimarySuffixReturnValue {
	
	// the following constants represent the various sub rules

	/** indicates that the result is currently undefined */
	static final int UNDEFINED       = -1;
	/** production was <pre>"." "this"</pre> */
	static final int THIS            =  0;	
	/** production was <pre>"." AllocationExpression</pre> */
	static final int ALLOCATION_EXPR =  1;	
	/** production was <pre>"[" Expression "]"</pre> */
	static final int INDEX_EXPR      =  2;	
	/** production was <pre>"." <IDENTIFIER></pre> */
	static final int IDENTIFIER      =  3;	
	/** production was <pre>Arguments</pre> */
	static final int ARGUMENTS       =  4;

	/** indicates the type of the result */
	int                   type = UNDEFINED;
	
	/** valid iff <tt>type</tt> is <tt>ALLOCATION_EXPR</tt> or 
	    <tt>INDEX_EXPR</tt> */
	Expression            expr = null;
	
	/** valid iff <tt>type</tt> is <tt>IDENTIFIER</tt> */
	Identifier            id   = null;
    
	/** valid iff <tt>type</tt> is <tt>ARGUMENTS</tt> */
	ExpressionMutableList args = null;
    }


    /** inner class that is only used to return results from
	primary prefix syntax rule
	@author RN
    */
    static class PrimaryPrefixReturnValue {
    
	// the following constants represent the various sub rules
    
	/** indicates that the result is currently undefined */
	static final int UNDEFINED        = -1;	
	/** production was <pre>Literal</pre> */
	static final int LITERAL          =  0;    
	/** production was <pre>"this"</pre> */
	static final int THIS             =  1;	
	/** production was <pre>"super" "." <IDENTIFIER></pre> */
	static final int SUPER_MEMBER     =  2;	
	/** production was <pre>"(" Expression ")"</pre> */
	static final int PARENTHESIZED_EXPR =  3;    
	/** production was <pre>AllocationExpression</pre> */
	static final int ALLOCATION_EXPR  =  4;    
	/** production was <pre>ResultType "." "class"</pre> */
	static final int CLASS_REF        =  5;	
	/** production was <pre>Name</pre> */
	static final int QUALIFIED_NAME   =  6;
	/** production was <pre>"@(" Expression ")"</pre> */
	static final int PASSIVE_EXPR =  7;    
    
	/** indicates the type of the result */
	int           type    = UNDEFINED;
    
	/** valid iff <tt>type</tt> is <tt>LITERAL</tt> */
	Literal       literal = null;
    
	/** valid iff <tt>type</tt> is <tt>PARENTHESED_EXPR</tt>
	    or <tt>ALLOCATION_EXPR</tt> */
	Expression    expr    = null;
    
	/** valid iff <tt>type</tt> is <tt>CLASS_REF</tt> */
	TypeReference typeref = null;
	
	/** valid iff <tt>type</tt> is <tt>QUALIFIED_NAME</tt> or
	 <tt>SUPER_MEMBER</tt>*/
	UncollatedReferenceQualifier name  = null;

    }

    /** return value containers for primary expression.
	need only be allocated once per parser. */
    static PrimarySuffixReturnValue suffix = new PrimarySuffixReturnValue();
    static PrimaryPrefixReturnValue prefix = new PrimaryPrefixReturnValue();

    
}

PARSER_END(ProofJavaParser)

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n">
  {
      ProofJavaParser.addSingleLineComment(matchedToken);
  } 
  : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" >
  {
      ProofJavaParser.addDocComment(matchedToken);
  }: DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" >  {
      ProofJavaParser.addMultiLineComment(matchedToken);
  }: DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < METHODFRAME: "method-frame" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < STRICTFP: "strictfp" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
	   ( ["n","t","b","r","f","\\","'","\""] 
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* ("#" (<DIGIT>)* )? >
|
  < IMPLICITIDENTIFIER: "<" <LETTER> (<LETTER>|<DIGIT>)* ">" >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < DOUBLECOLON: "::" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < SHARP: "#">
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

CompilationUnit CompilationUnit() :
{
    CompilationUnit result;
    PackageSpecification        ps  = null;
    ImportMutableList           il  = new ImportArrayList();
    Import                      imp;
    TypeDeclarationMutableList  tdl = new TypeDeclarationArrayList();
    TypeDeclaration             td;
}
{
  [ ps = PackageDeclaration() ]
  (
    imp = ImportDeclaration()
    {
      if (imp != null) il.add(imp);
    }
  )*
  (
    td = TypeDeclaration()
    {
      if (td != null) tdl.add(td);
    }
  )*
  <EOF>
  {
    result = factory.createCompilationUnit(ps, il, tdl); 
    checkConstruction(result);
    setPostfixInfo(result);
    setPrefixInfo(result);
    return result;
  }
}

PackageSpecification PackageDeclaration() :
{
    PackageSpecification result;
    UncollatedReferenceQualifier qn;
}
{
  "package" 
      {
	  result = factory.createPackageSpecification();
	  setPrefixInfo(result);
      }
  qn = Name() ";"
  {
    result.setPackageReference(qn.toPackageReference());
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Import ImportDeclaration() :
{
    Import result;
    UncollatedReferenceQualifier qn;
    String hs = null;
    boolean wildcard = false;
}
{
  "import" {
      result = factory.createImport();
      setPrefixInfo(result);
  }
  ( qn = Name() ) [ "." "*" { wildcard = true; } ] ";"
  {
    // "*" will be thrown away immediately since the package name is sufficient
      result.setMultiImport(wildcard);
      if (wildcard) {
	  result.setReference(qn);
      } else {
	  result.setReference(qn.toTypeReference());
      }
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

TypeDeclaration TypeDeclaration() :
{
    TypeDeclaration result = null;
}
{
  (
  LOOKAHEAD( ( "abstract" | "final" | "public" | "strictfp" )* "class" )
    result = ClassDeclaration()
  |
    result = InterfaceDeclaration()
  |
  ";" // ????????????????????????????????????????????????????
  )
  {
    if (result != null) {
	checkConstruction(result);
	setPostfixInfo(result);
    }
    return result;
  }
}


/*
 * Declaration syntax follows.
 */

ClassDeclaration ClassDeclaration() :
{
  ClassDeclaration    result = null;
  ModifierMutableList ml = new ModifierArrayList();
  Modifier            m;
}
{
  ( (
      ( "abstract" { m = factory.createAbstract(); } )
    | ( "final"    { m = factory.createFinal();    } )
    | ( "public"   { m = factory.createPublic();   } )
    | ( "strictfp" { m = factory.createStrictFp(); } )
    )
    { 
	setPrefixInfo(m);
	setPostfixInfo(m);
	ml.add(m); 
    }
  )*
  result = UnmodifiedClassDeclaration()
  {
    result.setModifiers(ml);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

ClassDeclaration UnmodifiedClassDeclaration() :
{
  ClassDeclaration                 result;
  UncollatedReferenceQualifier     qn;
  UncollatedReferenceQualifierList nl;
  MemberDeclarationMutableList     mdl;
  Extends ex;
  Implements im;
}
{
  "class"  {
      result = factory.createClassDeclaration();
      setPrefixInfo(result);
  }
  (<IDENTIFIER>
      {
	  Identifier id = factory.createIdentifier(token.image);
	  setPrefixInfo(id);
	  setPostfixInfo(id);
	  result.setIdentifier(id);
      }
  |
   <IMPLICITIDENTIFIER> 
      { 
	  id = factory.createImplicitIdentifier(token.image);
	  setPrefixInfo(id);
	  setPostfixInfo(id);
	  result.setIdentifier(id);
      }
  )
  [ "extends"
      {
	  ex = factory.createExtends();
	  setPrefixInfo(ex);
      }
      qn = Name()
      {
	  ex.setSupertypes(new TypeReferenceArrayList(qn.toTypeReference()));
	  result.setExtendedTypes(ex);
      }
  ]
  [ "implements"
      {
	  im = factory.createImplements();
	  setPrefixInfo(im);	  
      }
      nl = NameList()
      {
	  TypeReferenceMutableList trl = new TypeReferenceArrayList();
	  for (int i = 0, s = nl.size(); i < s; i++) {
	      TypeReference tr = 
		  nl.getUncollatedReferenceQualifier(i).toTypeReference();
	      trl.add(tr);
	  }
	  im.setSupertypes(trl);
	  result.setImplementedTypes(im);
      }
  ]
  mdl = ClassBody()
  {
    result.setMembers(mdl);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

MemberDeclarationMutableList ClassBody() :
{
  MemberDeclarationMutableList result = new MemberDeclarationArrayList();
  MemberDeclaration md;
}
{
  "{"
  (
    md = ClassBodyDeclaration()
    {
	result.add(md);
    }
  )*
  "}"
  {
    checkConstruction(result);
    return result;
  }
}

ClassDeclaration NestedClassDeclaration() :
{
  ClassDeclaration result;
  ModifierMutableList ml = new ModifierArrayList();
  Modifier m;
}
{
  (
    (
      ( "static"    { m = factory.createStatic(); }    )
    | ( "abstract"  { m = factory.createAbstract(); }  )
    | ( "final"     { m = factory.createFinal(); }     )
    | ( "public"    { m = factory.createPublic(); }    )
    | ( "protected" { m = factory.createProtected(); } )
    | ( "private"   { m = factory.createPrivate(); }   )
    | ( "strictfp"  { m = factory.createStrictFp(); }  )
    )
    {
	setPrefixInfo(m);
	setPostfixInfo(m);
	ml.add(m);
    }
  )*
  result = UnmodifiedClassDeclaration()
  {
    result.setModifiers(ml);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

MemberDeclaration ClassBodyDeclaration() :
{
  MemberDeclaration result;
}
{
(
  LOOKAHEAD(2)
  result = Initializer()
| LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp" )* "class" )
  (result = NestedClassDeclaration() (";")*) // patch
| LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp" )* "interface" )
  (result = NestedInterfaceDeclaration() (";")*) // patch
| LOOKAHEAD( [ "public" | "protected" | "private" ] Name() "(" )
  (result = ConstructorDeclaration()  (";")*) // patch
| LOOKAHEAD( MethodDeclarationLookahead() )
  (result = MethodDeclaration() (";")*) // patch
| (result = FieldDeclaration() (";")*) // patch
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() :
{}
{
  ( "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" | "strictfp" )*
  ResultType() (<IDENTIFIER> | <IMPLICITIDENTIFIER>) "("
}

InterfaceDeclaration InterfaceDeclaration() :
{
  InterfaceDeclaration result;
  ModifierMutableList ml = new ModifierArrayList();
  Modifier m;
}
{
  (
    (
      ( "abstract"  { m = factory.createAbstract(); }  )
    | ( "public"    { m = factory.createPublic(); }    )
    | ( "strictfp"  { m = factory.createStrictFp(); }  )
    )
    {
	setPrefixInfo(m);
	setPostfixInfo(m);
	ml.add(m);
    }
  )*
  result = UnmodifiedInterfaceDeclaration()
  {
    result.setModifiers(ml);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

InterfaceDeclaration NestedInterfaceDeclaration() :
{
  InterfaceDeclaration result;
  ModifierMutableList ml = new ModifierArrayList();
  Modifier m;
}
{
  (
    (
      ( "static"    { m = factory.createStatic(); }    )
    | ( "abstract"  { m = factory.createAbstract(); }  )
    | ( "final"     { m = factory.createFinal(); }     )
    | ( "public"    { m = factory.createPublic(); }    )
    | ( "protected" { m = factory.createProtected(); } )
    | ( "private"   { m = factory.createPrivate(); }   )
    | ( "strictfp"  { m = factory.createStrictFp(); }  )
    )
    {
	setPrefixInfo(m);
	setPostfixInfo(m);
	ml.add(m);
    }
  )*
  result = UnmodifiedInterfaceDeclaration()
  {
    result.setModifiers(ml);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

InterfaceDeclaration UnmodifiedInterfaceDeclaration() :
{
    InterfaceDeclaration             result;
    UncollatedReferenceQualifierList nl;
    MemberDeclarationMutableList     mdl = new MemberDeclarationArrayList();
    MemberDeclaration                md;
    Extends ex;
}
{
  "interface"
  {
      result = factory.createInterfaceDeclaration();
      setPrefixInfo(result);
  }      
  <IDENTIFIER>
  {
      Identifier id = factory.createIdentifier(token.image);
      setPrefixInfo(id);
      setPostfixInfo(id);
      result.setIdentifier(id);
  }
  [ "extends"
      {
	  ex = factory.createExtends();
	  setPrefixInfo(ex);
      }
      nl = NameList()
      {
	  TypeReferenceMutableList trl = new TypeReferenceArrayList();
	  for (int i = 0, s = nl.size(); i < s; i++) {
	      TypeReference tr = 
		  nl.getUncollatedReferenceQualifier(i).toTypeReference();
	      trl.add(tr);
	  }
	  ex.setSupertypes(trl);
	  result.setExtendedTypes(ex);
      }
  ]
  "{"
  (
    md = InterfaceMemberDeclaration()
    {
	mdl.add(md);
    }
  )*
  "}"
  {
    result.setMembers(mdl);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

MemberDeclaration InterfaceMemberDeclaration() :
{
    MemberDeclaration result;
}
{
(
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp" )* "class" )
  (result = NestedClassDeclaration() (";")*) // patch
| LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp" )* "interface" )
  (result = NestedInterfaceDeclaration() (";")*) // patch
| LOOKAHEAD( MethodDeclarationLookahead() )
  (result = MethodDeclaration() (";")*) // patch
| (result = FieldDeclaration() (";")*) // patch
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

FieldDeclaration FieldDeclaration() :
{
    FieldDeclaration result;
    ModifierMutableList ml = new ModifierArrayList();
    Modifier m = null;
    TypeReference tr;
    FieldSpecificationMutableList vl = new FieldSpecificationArrayList();
    VariableSpecification var;
}
{
   (
    (
      ( "public"    { m = factory.createPublic(); }    )
    | ( "protected" { m = factory.createProtected(); } )
    | ( "private"   { m = factory.createPrivate(); }   )
    | ( "static"    { m = factory.createStatic(); }    )
    | ( "final"     { m = factory.createFinal(); }     )
    | ( "transient" { m = factory.createTransient(); } )
    | ( "volatile"  { m = factory.createVolatile(); }  )
    )
    {	
	setPrefixInfo(m);	
	setPostfixInfo(m);
	ml.add(m);
    }
  )*
  (tr = Type())
  {
    result = factory.createFieldDeclaration();
    result.setModifiers(ml);
    result.setTypeReference(tr);
  }
  var = VariableDeclarator(true)
      {
	  vl.add((FieldSpecification)var);
      }
  (
    ","
    var = VariableDeclarator(true)
    {
	  vl.add((FieldSpecification)var);
    }
  )*
  ";"
  {
    result.setFieldSpecifications(vl);
    //    setPrefixInfo(result);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

VariableSpecification VariableDeclarator(boolean isForField) :
{
    Identifier id;
    int dim = 0;
    Expression init = null;
    VariableSpecification result;
}
{
    id = VariableDeclaratorId() { dim = tmpDimension; }
    [ "=" init = VariableInitializer() ]    
    {
    if (isForField) {
	result = factory.createFieldSpecification(id, dim, init);
    } else {
	result = factory.createVariableSpecification(id, dim, init);
    }
    //    setPrefixInfo(result); // only after "=" !!!!!!!!!!!!!!!
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}



Identifier VariableDeclaratorId() :
{
    Identifier result;
}
{
  <IDENTIFIER>
  { result = factory.createIdentifier(token.image);
    setPrefixInfo(result);
    setPostfixInfo(result);
    tmpDimension = 0;
  }
  ( "[" "]" { tmpDimension++; } )*
  {
    checkConstruction(result);
    setPostfixInfo(result);
    //setPrefixInfo(result);
    return result;
  }
}

Expression VariableInitializer() :
{
  Expression result;
}
{
(
  result = ArrayInitializer()
| result = Expression()
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}



ArrayInitializer ArrayInitializer() :
{
    ArrayInitializer result;
    ExpressionMutableList el = new ExpressionArrayList();
    Expression init;
}
{
    "{" {
	result = factory.createArrayInitializer();
	setPrefixInfo(result);
    }
  [ init = VariableInitializer()
    { el.add(init); }
    ( LOOKAHEAD(2) ","
      init = VariableInitializer()
    { el.add(init); }
    )*
  ] [ "," ] "}"
  {
    result.setArguments(el);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

MethodDeclaration MethodDeclaration() :
{
  ModifierMutableList ml = new ModifierArrayList();
  Modifier m = null;
  TypeReference tr;
  UncollatedReferenceQualifierMutableList nl = null;
  Throws th = null;
  StatementBlock body = null;
  MethodDeclaration result;
}
{
  (
    (
      ( "public"       { m = factory.createPublic(); }        )
    | ( "protected"    { m = factory.createProtected(); }     )
    | ( "private"      { m = factory.createPrivate(); }       )
    | ( "static"       { m = factory.createStatic(); }        )
    | ( "final"        { m = factory.createFinal(); }         )
    | ( "abstract"     { m = factory.createAbstract(); }      )
    | ( "native"       { m = factory.createNative(); }        )
    | ( "synchronized" { m = factory.createSynchronized(); }  )
    | ( "strictfp"     { m = factory.createStrictFp(); }      )
    )
    {
	setPrefixInfo(m);
	setPostfixInfo(m);
	ml.add(m);
    }
  )*
  tr = ResultType()
  result = MethodDeclarator(tr)
  [ "throws" {
      th = factory.createThrows();
      setPrefixInfo(th);      
    }
    nl = NameList() ]
  ( body = Block() | ";" )
  {
      if (nl != null) {
	  TypeReferenceMutableList trl = new TypeReferenceArrayList();
	  for (int i = 0, s = nl.size(); i < s; i++) {
              trl.add(nl.getUncollatedReferenceQualifier(i).toTypeReference());
	  }
	  th.setExceptions(trl);
	  //  Throws th = factory.createThrows(trl);
	  result.setThrown(th);
      }
      result.setModifiers(ml);
      result.setBody(body);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

MethodDeclaration MethodDeclarator(TypeReference tr) :
{
    Identifier                      id;
    ParameterDeclarationMutableList pdl;
    MethodDeclaration               result;
}
{
  (<IDENTIFIER> 
  { id = factory.createIdentifier(token.image); setPrefixInfo(id); setPostfixInfo(id);}
  |
   <IMPLICITIDENTIFIER> 
  { id = factory.createImplicitIdentifier(token.image); setPrefixInfo(id); setPostfixInfo(id);}
  )	
  pdl = FormalParameters()
  
  ( "[" "]" 
    { if (tr != null) { tr.setDimensions(tr.getDimensions()+1); } }
  )*

  {
      result = factory.createMethodDeclaration();
      result.setIdentifier(id);
      result.setTypeReference(tr);
      result.setParameters(pdl);
      checkConstruction(result);
      setPostfixInfo(result);
      setPrefixInfo(result); 
      return result;
  }
}

ParameterDeclarationMutableList FormalParameters() :
{
    ParameterDeclaration pd;
    ParameterDeclarationMutableList result = new ParameterDeclarationArrayList();
}
{
  "("
      [       pd = FormalParameter() { result.add(pd); }
        ( "," pd = FormalParameter() { result.add(pd); } )* ]
  ")"
  {
      checkConstruction(result);
      return result;
  }
}

ParameterDeclaration FormalParameter() :
{
    Identifier id;
    int dim;
    TypeReference tr;
    Modifier mod = null;
    VariableSpecification vspec;
    ParameterDeclaration result;
}
{
  [ "final" { mod = factory.createFinal(); setPrefixInfo(mod);  } ]
  (tr = Type())
  id = VariableDeclaratorId() { dim = tmpDimension; }
  {
      result = factory.createParameterDeclaration(tr, id);
      if (mod != null) {
	  ModifierMutableList ml = new ModifierArrayList();
	  ml.add(mod);
	  result.setModifiers(ml);
      }
      vspec = result.getVariables().getVariableSpecification(0); 
      vspec.setDimensions(dim);
      checkConstruction(result);
      setPostfixInfo(result);
      setPrefixInfo(result); 
      return result;
  }
}

ConstructorDeclaration ConstructorDeclaration() :
{
    ConstructorDeclaration          result;
    Modifier                        m = null;
    Identifier                      id;
    ParameterDeclarationMutableList pdl;
    UncollatedReferenceQualifierMutableList nl = null;
    SpecialConstructorReference     scr = null;
    StatementBlock                  body;
    StatementMutableList            stats = new StatementArrayList();
    Statement                       stat;
}
{
  {
     result = factory.createConstructorDeclaration();
     setPrefixInfo(result); 
  }
  [
   (
      ( "public"       { m = factory.createPublic(); }    )
    | ( "protected"    { m = factory.createProtected(); } )
    | ( "private"      { m = factory.createPrivate(); }   )
   )
      {
	  setPrefixInfo(m); 
	  setPostfixInfo(m);
      }
  ]
  <IDENTIFIER> { 
      id = factory.createIdentifier(token.image);
      setPrefixInfo(id); 
      setPostfixInfo(id);
  }
  pdl = FormalParameters()
  [ "throws" nl = NameList() ]
  "{"
  {
      body = factory.createStatementBlock();
      setPrefixInfo(body); 
      body.setBody(stats);
  }
    [ LOOKAHEAD(ExplicitConstructorInvocation())
      scr = ExplicitConstructorInvocation()
      { stats.add(scr); }
    ]
    ( stat = BlockStatement()
      { stats.add(stat); }
    )*
  "}"
  {
      result.setIdentifier(id);
      result.setParameters(pdl);
      if (m != null) {
	  ModifierMutableList ml = new ModifierArrayList(1);
	  ml.add(m);
	  result.setModifiers(ml);
      }
      if (nl != null) {
	  int s = nl.size();
	  TypeReferenceMutableList trl = new TypeReferenceArrayList(s);
	  for (int i = 0; i < s; i++) {
              trl.add(nl.getUncollatedReferenceQualifier(i).toTypeReference());
	  }
	  Throws th = factory.createThrows(trl);
	  setPrefixInfo(th);
	  result.setThrown(th);
      }
      result.setBody(body);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

SpecialConstructorReference ExplicitConstructorInvocation() :
{
    SpecialConstructorReference result;
    ExpressionMutableList args;
    Expression expr = null;
}
{
(
  LOOKAHEAD("this" Arguments() ";")
  "this" 
  {
     result = factory.createThisConstructorReference(); setPrefixInfo(result);
  } 
  args = Arguments() ";"
  { result.setArguments(args); }
|
  [ LOOKAHEAD(2) expr = PrimaryExpression() "." ]
  "super" 
  {
     result = factory.createSuperConstructorReference(); setPrefixInfo(result);
  } 
  args = Arguments() ";"
  { 
    result.setArguments(args);
    ((SuperConstructorReference)result).setReferencePrefix((ReferencePrefix)expr);
   }
)
  {
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

ClassInitializer Initializer() :
{
  ClassInitializer result;
  ModifierMutableList ml = null;
  StatementBlock block;
}
{
  [ "static"
    {
      ml = new ModifierArrayList();
      Static s = factory.createStatic();
      setPrefixInfo(s); 
      setPostfixInfo(s);
      ml.add(s);
    }
  ]
  block = Block()
  {
    result = factory.createClassInitializer(block);
    setPrefixInfo(result);
    if (ml != null) {
      result.setModifiers(ml);
    }
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}


/*
 * Type, name and expression syntax follows.
 */

TypeReference Type() :
{
  TypeReference result;
  UncollatedReferenceQualifier qn;
  int dimension = 0;
}
{
(  result = PrimitiveType()
  | (qn = Name() 
    {
	result = qn.toTypeReference();
    }
    )
)  
  ( "[" "]" { if (dimension == 0) setPrefixInfo(result); dimension++; } )*
  {
      result.setDimensions(dimension);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}


TypeReference PrimitiveType() :
{
    TypeReference result;}
{
  (
    "boolean"
  | "char"
  | "byte"
  | "short"
  | "int"
  | "long"
  | "float"
  | "double"
  )
  {
    Identifier id = factory.createIdentifier(token.image);
    setPrefixInfo(id);
    setPostfixInfo(id);
    result = factory.createTypeReference(id);
    checkConstruction(result);
    setPostfixInfo(result);
    //    setPrefixInfo(result);
    return result;
  }
}

TypeReference ResultType() :
{
  TypeReference result;
}
{
(
  ( "void" { 
    Identifier id = factory.createIdentifier(token.image);
    setPrefixInfo(id);
    setPostfixInfo(id);
    result = factory.createTypeReference(id);
    setPrefixInfo(result);
} )
  | result = Type()
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

UncollatedReferenceQualifier Name() :
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{
  UncollatedReferenceQualifier result;
  Identifier id;
}
{
  (<IDENTIFIER>
  {
    id = factory.createIdentifier(token.image);    
    setPrefixInfo(id);
    setPostfixInfo(id);
    result = factory.createUncollatedReferenceQualifier(id);
  } | 
  <IMPLICITIDENTIFIER>
  {
    id = factory.createImplicitIdentifier(token.image);    
    setPrefixInfo(id);
    setPostfixInfo(id);
    result = factory.createUncollatedReferenceQualifier(id);
  })

  (
    LOOKAHEAD(2) "." { setPrefixInfo(result); }
    ( <IDENTIFIER>
      {
        id = factory.createIdentifier(token.image);
      }
    |
      <IMPLICITIDENTIFIER>
      {
        id = factory.createImplicitIdentifier(token.image);
      }
    )
    {
      setPrefixInfo(id);
      setPostfixInfo(id);
      result = factory.createUncollatedReferenceQualifier(result, id);
    }
  )*
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

UncollatedReferenceQualifierMutableList NameList() :
{
  UncollatedReferenceQualifierMutableList result = 
      new UncollatedReferenceQualifierArrayList(2);
  UncollatedReferenceQualifier qn;
}
{
  qn = Name()
  {
    result.add(qn);
  }
  ( "," qn = Name()
    {
      result.add(qn);
    }
  )*
  {
    checkConstruction(result);
/*    setPostfixInfo(result);*/
    return result;
  }
}

/*
 * Expression syntax follows.
 */
Expression Expression() :
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{
    Expression result;
    Expression expr;
    Assignment op;
    ExpressionMutableList leftRight = new ExpressionArrayList(2);
}
{
  (result = ConditionalExpression()
  [
    op   = AssignmentOperator()
    expr = Expression()
    {
	leftRight.add(result);
	leftRight.add(expr);
	op.setArguments(leftRight);
	result = op;
    }
  ]
  {
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  })

}



Assignment AssignmentOperator() :
{
    Assignment result;
}
{
  (   "="    { result = factory.createCopyAssignment(); }
    | "*="   { result = factory.createTimesAssignment(); }
    | "/="   { result = factory.createDivideAssignment(); }
    | "%="   { result = factory.createModuloAssignment(); }
    | "+="   { result = factory.createPlusAssignment(); }
    | "-="   { result = factory.createMinusAssignment(); }
    | "<<="  { result = factory.createShiftLeftAssignment(); }
    | ">>="  { result = factory.createShiftRightAssignment(); }
    | ">>>=" { result = factory.createUnsignedShiftRightAssignment(); }
    | "&="   { result = factory.createBinaryAndAssignment(); }
    | "^="   { result = factory.createBinaryXOrAssignment(); }
    | "|="   { result = factory.createBinaryOrAssignment(); }
  )
  {
    checkConstruction(result);
    setPostfixInfo(result);
    setPrefixInfo(result);
    return result;
  }
}

Expression ConditionalExpression() :
{
    Expression result;
    Expression expr1;
    Expression expr2;
    Operator op;
}
{
  result = ConditionalOrExpression()
  [ "?" { op = factory.createConditional(); setPrefixInfo(op); }
    expr1 = Expression()
    ":" expr2 = ConditionalExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(3);
	args.add(result);
	args.add(expr1);
	args.add(expr2);
	op.setArguments(args);
	result = op;
    }
  ]
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression ConditionalOrExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{
  result = ConditionalAndExpression()
  ( "||" { op = factory.createLogicalOr(); setPrefixInfo(op); }
    expr = ConditionalAndExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	op.setArguments(args);
	result = op;
    }
  )*
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression ConditionalAndExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{
  result = InclusiveOrExpression()
  ( "&&" { op = factory.createLogicalAnd(); setPrefixInfo(op); }
    expr = InclusiveOrExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	op.setArguments(args);
	result = op;
    }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression InclusiveOrExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{
  result = ExclusiveOrExpression()
  ( "|" { op = factory.createBinaryOr(); setPrefixInfo(op); }
    expr = ExclusiveOrExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	op.setArguments(args);
	result = op;
    }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression ExclusiveOrExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{
  result = AndExpression()
  ( "^" { op = factory.createBinaryXOr(); setPrefixInfo(op); }
      expr = AndExpression()
      {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	op.setArguments(args);
	result = op;
      }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression AndExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{ 
  result = EqualityExpression()
  ( "&" { op = factory.createBinaryAnd(); setPrefixInfo(op); }
    expr = EqualityExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	op.setArguments(args);
	result = op;
    }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression EqualityExpression() :
{
    Expression result;
    Expression expr;
    Operator cmp;
}
{ 
  result = InstanceOfExpression()
  ( (   "==" { cmp = factory.createEquals(); setPrefixInfo(cmp); }
      | "!=" { cmp = factory.createNotEquals(); setPrefixInfo(cmp); }
    )
    expr = InstanceOfExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	cmp.setArguments(args);
	result = cmp;
    }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression InstanceOfExpression() :
{
    Expression result;
    TypeReference tr;
}
{
  result = RelationalExpression()
  [ "instanceof" (tr = Type()) 
    {
	result = factory.createInstanceof(result, tr);
	setPrefixInfo(result);
    }
  ]
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression RelationalExpression() :
{
    Expression result;
    Operator cmp;
    Expression expr;
}
{
  result = ShiftExpression()
  ( (   "<"  { cmp = factory.createLessThan(); setPrefixInfo(cmp); }
      | ">"  { cmp = factory.createGreaterThan(); setPrefixInfo(cmp); }
      | "<=" { cmp = factory.createLessOrEquals(); setPrefixInfo(cmp); }
      | ">=" { cmp = factory.createGreaterOrEquals(); setPrefixInfo(cmp); }
    )
    expr = ShiftExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	cmp.setArguments(args);
	result = cmp;
    }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

Expression ShiftExpression() :
{
    Expression result;
    Operator shift;
    Expression expr;
}
{
  result = AdditiveExpression()
  ( (   "<<"  { shift = factory.createShiftLeft(); setPrefixInfo(shift); }
      | ">>"  { shift = factory.createShiftRight(); setPrefixInfo(shift); }
      | ">>>" { shift = factory.createUnsignedShiftRight(); setPrefixInfo(shift); }
    )
    expr = AdditiveExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	shift.setArguments(args);
	result = shift;
    }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

Expression AdditiveExpression() :
{
    Expression result;
    Operator add;
    Expression expr;
}
{
  result = MultiplicativeExpression()
    ( ( "+" { add = factory.createPlus(); setPrefixInfo(add); }
      | "-" { add = factory.createMinus(); setPrefixInfo(add); }
    )
    expr = MultiplicativeExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	add.setArguments(args);
	result = add;
    }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression MultiplicativeExpression() :
{
    Expression result = null;
    Operator mult = null;
    Expression expr;
}
{
  result = UnaryExpression()
  ( (   "*" { mult = factory.createTimes();  setPrefixInfo(mult); }
      | "/" { mult = factory.createDivide(); setPrefixInfo(mult); }
      | "%" { mult = factory.createModulo(); setPrefixInfo(mult); }
    )
    expr = UnaryExpression()
    {
	ExpressionMutableList args = new ExpressionArrayList(2);
	args.add(result);
	args.add(expr);
	mult.setArguments(args);
	result = mult;
    }
  )*
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

Expression UnaryExpression() :
{
    Expression result;
    Expression expr;
    boolean negative = false;
}
{
(
  ( "+" { result = factory.createPositive(); setPrefixInfo(result); } 
  | "-" { result = factory.createNegative(); setPrefixInfo(result); } )
  expr = UnaryExpression()
  {
      ((Operator)result).setArguments(new ExpressionArrayList(expr));
  }
|
  result = PreIncrementExpression()
|
  result = PreDecrementExpression()
|
  result = UnaryExpressionNotPlusMinus()
)
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

PreIncrement PreIncrementExpression() :
{
    PreIncrement result;
    Expression expr;
}
{
  "++"
  {
      result = factory.createPreIncrement();
      setPrefixInfo(result);
  } 
  expr = PrimaryExpression()
  {
      result.setArguments(new ExpressionArrayList(expr));
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

PreDecrement PreDecrementExpression() :
{
    PreDecrement result;
    Expression expr;
}
{
  "--" 
  {
      result = factory.createPreDecrement();
      setPrefixInfo(result);
  }
  expr = PrimaryExpression()
  { 
      result.setArguments(new ExpressionArrayList(expr));
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

Expression UnaryExpressionNotPlusMinus() :
{
    Expression result;
    Expression expr;
    boolean    not = false;
}
{
(
  (   "~" { result = factory.createBinaryNot();  setPrefixInfo(result); }
    | "!" { result = factory.createLogicalNot(); setPrefixInfo(result); }
  )
  expr = UnaryExpression()
  {
      ((Operator)result).setArguments(new ExpressionArrayList(expr));
  }
  
|
  LOOKAHEAD( CastLookahead() )
  result = CastExpression()
|
  result = PostfixExpression()
)
    { 
	checkConstruction(result);
	setPostfixInfo(result);
	return result;
    }

}

// This production is to determine lookahead only. The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead() :
{}
{ LOOKAHEAD("(" PrimitiveType() ("[" "]")* ")")
  "(" PrimitiveType() ("[" "]")* ")"
  //  LOOKAHEAD(2)
  //  "(" PrimitiveType()
|
  LOOKAHEAD("(" Name() "[")
  "(" Name() "[" "]"
|
  "(" Name() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )
}

Expression PostfixExpression() :
{
    Expression result;
}
{
  result = PrimaryExpression()
  [   "++" 
    { 
	result = factory.createPostIncrement(result); 
	setPrefixInfo(result);
    }
    | "--" 
    { 
	result = factory.createPostDecrement(result); 
	setPrefixInfo(result);
    }
  ]
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

TypeCast CastExpression() :
{
    TypeCast result = null;
    TypeReference tr;
    Expression expr = null;
}
{
  {
    result = factory.createTypeCast();
  }
( LOOKAHEAD("(" PrimitiveType() )
  "(" { setPrefixInfo(result); } (tr = Type()) ")"
  expr = UnaryExpression()
| "(" { setPrefixInfo(result); } tr = Type() ")"
  expr = UnaryExpressionNotPlusMinus() 
)
  {
      result.setTypeReference(tr);
      result.setArguments(new ExpressionArrayList(expr));
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}


Expression PrimaryExpression() :
{
    Expression result = null;
    ReferencePrefix tmpResult = null;
}
{
    prefix = PrimaryPrefix()
    {	
      // create initial AST construct from prefix only
      switch (prefix.type) {
      case PrimaryPrefixReturnValue.LITERAL:
	  if (prefix.literal instanceof StringLiteral) {
	      tmpResult = (StringLiteral)prefix.literal;
	  }
          else 
          {
	      result = prefix.literal;
	      checkConstruction(result);
	      setPostfixInfo(result);
	      return result;
	      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	  }
	  break;
      case PrimaryPrefixReturnValue.THIS:
	  tmpResult = factory.createThisReference();
	  setPrefixInfo(tmpResult);
	  setPostfixInfo(tmpResult);
	  break;
      case PrimaryPrefixReturnValue.SUPER_MEMBER:
          tmpResult = prefix.name;
	  break;
      case PrimaryPrefixReturnValue.PARENTHESIZED_EXPR:
          tmpResult = (ParenthesizedExpression)prefix.expr;
	  break;
      case PrimaryPrefixReturnValue.ALLOCATION_EXPR:
	  tmpResult = (ReferencePrefix)prefix.expr;
	  break;
      case PrimaryPrefixReturnValue.CLASS_REF:
	  tmpResult = factory.createMetaClassReference(prefix.typeref);
          setPrefixInfo(tmpResult);
	  setPostfixInfo(tmpResult);
	  break;
      case PrimaryPrefixReturnValue.QUALIFIED_NAME:
	  tmpResult = prefix.name;
	  break;
      case PrimaryPrefixReturnValue.PASSIVE_EXPR:
	  tmpResult = (PassiveExpression)prefix.expr;
	  break;
      default:
	  throw new ParseException("Unknown prefix");
      }
    }
  ( LOOKAHEAD(2) suffix = PrimarySuffix()
    {      
      switch (suffix.type) {
      case PrimarySuffixReturnValue.THIS:
          // the prefix MUST be a type expression!!!!!
	  // we currently only create UncollatedReferenceQualifiers
          if (tmpResult instanceof TypeReference) {
	      tmpResult = 
	         factory.createThisReference((TypeReference)tmpResult);
	      setPrefixInfo(tmpResult);
	      setPostfixInfo(tmpResult);
	  } else if (tmpResult instanceof UncollatedReferenceQualifier) {
	      tmpResult =
	         factory.createThisReference(((UncollatedReferenceQualifier)tmpResult).toTypeReference());
	      setPrefixInfo(tmpResult);
	      setPostfixInfo(tmpResult);
	  } else {
	      throw new ParseException("No type as prefix of `this'");
	  }
	  break;
      case PrimarySuffixReturnValue.ALLOCATION_EXPR:
	  if (suffix.expr instanceof New) {
	      ((New)suffix.expr).setReferencePrefix(tmpResult);
	      tmpResult = (New)suffix.expr;
	  } else {
	      throw new ParseException("Allocation without new?");
	  }
	  break;
      case PrimarySuffixReturnValue.INDEX_EXPR:
          if (tmpResult instanceof UncollatedReferenceQualifier ||
	      tmpResult instanceof MethodReference ||
	      tmpResult instanceof ParenthesizedExpression ||
	      //tmpResult instanceof ThisReference || // this[i] in array initialization
	      tmpResult instanceof VariableReference) {
		  // Now we know that this is an array reference
	      ExpressionMutableList indicees = new ExpressionArrayList(1);
	      indicees.add(suffix.expr);
	      tmpResult = 
	          factory.createArrayReference(tmpResult, indicees);
	      setPrefixInfo(tmpResult);
	      setPostfixInfo(tmpResult);
	  } else if (tmpResult instanceof ArrayReference) {
	      // we need to add another access dimension
	      ((ArrayReference)tmpResult).getDimensionExpressions().add(suffix.expr);
	  } else {
	      throw new ParseException("Bad index context - " +
				       tmpResult.getClass().getName() + "?!");
	      /*
		e.g. StringLiteral, TypeReference, NewArray
		(would have to be in parentheses), SuperReference, ...
	      */
	  }
          break;
      case PrimarySuffixReturnValue.IDENTIFIER:
          tmpResult = factory.createUncollatedReferenceQualifier(tmpResult, suffix.id);
          setPrefixInfo(tmpResult);
	  setPostfixInfo(tmpResult);
          break;
      case PrimarySuffixReturnValue.ARGUMENTS:
          // method call -determine the kind of method
          if (tmpResult instanceof UncollatedReferenceQualifier) {
	      // this is a normal method call
	      tmpResult = factory.createMethodReference
	      (((UncollatedReferenceQualifier)tmpResult).getReferencePrefix(),
	       ((UncollatedReferenceQualifier)tmpResult).getIdentifier(),
	       suffix.args);
              setPrefixInfo(tmpResult);
	      setPostfixInfo(tmpResult);
	  } else {
	      throw new ParseException("Arguments without method name?");
	  }
          break;
      default:
          throw new ParseException("Unknown primary suffix type");
      }
    }
  )*
  {     
      if (tmpResult instanceof UncollatedReferenceQualifier) {
	  result = (UncollatedReferenceQualifier)tmpResult;
      } else {
	  result = (Expression)tmpResult;
      }
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

PrimaryPrefixReturnValue PrimaryPrefix() :
{
    // reuses global prefix field
    Literal                      lit;
    Expression                   expr;
    TypeReference                tr;
    UncollatedReferenceQualifier qn;
    SuperReference               supRef = null;
    ParenthesizedExpression      parExpr = null;
    Identifier                   id = null;
    int                          dimension = 0;   
}
{
(
  lit = Literal()
  {
      prefix.type    = PrimaryPrefixReturnValue.LITERAL;
      prefix.literal = lit;
  }
|
  "this"
  {
      prefix.type = PrimaryPrefixReturnValue.THIS;
  }
|
  "super" {
      supRef = factory.createSuperReference();
      setPrefixInfo(supRef);
      setPostfixInfo(supRef);
  }
  "."
  (
    <IDENTIFIER>
    {
      id   = factory.createIdentifier(token.image);
    }
  |
    <IMPLICITIDENTIFIER>
    {
      id   = factory.createImplicitIdentifier(token.image);
    }
  )
  {
    setPrefixInfo(id);
    setPostfixInfo(id);
    prefix.name =
      factory.createUncollatedReferenceQualifier(supRef, id);
    prefix.type = PrimaryPrefixReturnValue.SUPER_MEMBER;
  }
|
  "("
  { 
  parExpr = factory.createParenthesizedExpression();
    setPrefixInfo(parExpr);
  }
  expr = Expression()
  ")"
  {
  	setPostfixInfo(parExpr);
      parExpr.setArguments(new ExpressionArrayList(expr));
      prefix.expr = parExpr;
      prefix.type = PrimaryPrefixReturnValue.PARENTHESIZED_EXPR;
  }
|
  "@("
  { parExpr = factory.createPassiveExpression();
    setPrefixInfo(parExpr);
  }
  expr = Expression()
  ")"
  {
       parExpr.setArguments(new ExpressionArrayList(expr));
       prefix.expr = parExpr;
       prefix.type = PrimaryPrefixReturnValue.PASSIVE_EXPR;
  }
|
  expr = AllocationExpression()
  {
      prefix.type = PrimaryPrefixReturnValue.ALLOCATION_EXPR;
      prefix.expr = expr;
  }
|
  LOOKAHEAD( ResultType() "." "class" )
  tr = ResultType() "." "class"
  {
      prefix.type    = PrimaryPrefixReturnValue.CLASS_REF;
      prefix.typeref = tr;
  }
|
  qn = Name() 
  {
	prefix.type = PrimaryPrefixReturnValue.QUALIFIED_NAME;
	prefix.name = qn;
  }
)
  {
      return prefix;
  }
}

PrimarySuffixReturnValue PrimarySuffix() :
{
    // reuses global suffix field
    Expression               expr;
    ExpressionMutableList    args;
    Identifier               id;
    Literal                  lit;
}
{
(
  LOOKAHEAD(2)
  "." "this"
  {
      suffix.type = PrimarySuffixReturnValue.THIS;
  }
|
  LOOKAHEAD(2)
  "." expr = AllocationExpression()
  {
      suffix.type = PrimarySuffixReturnValue.ALLOCATION_EXPR;
      suffix.expr = expr;
  }
|
  "[" expr = Expression() "]"
  {
      suffix.type = PrimarySuffixReturnValue.INDEX_EXPR;
      suffix.expr = expr;
  }
|
  "."
  (
    <IDENTIFIER>
    {
      suffix.id   = factory.createIdentifier(token.image);
    }
  |
    <IMPLICITIDENTIFIER>
    {
      suffix.id   = factory.createImplicitIdentifier(token.image);
    }
  )
  {
      suffix.type = PrimarySuffixReturnValue.IDENTIFIER;
      setPrefixInfo(suffix.id);
      setPostfixInfo(suffix.id);
  }
|
  args = Arguments()
  {
      suffix.type = PrimarySuffixReturnValue.ARGUMENTS;
      suffix.args = args;
  }
)
  {
      return suffix;
  }
}

Literal Literal() :
{
    Literal result;
    Expression e;
}
{
(
  <INTEGER_LITERAL>
  {
      if (token.image.endsWith("L") || token.image.endsWith("l")) {
	  result = factory.createLongLiteral(token.image);
      } else {
	  result = factory.createIntLiteral(token.image);
      }
      setPrefixInfo(result);
  }
| <FLOATING_POINT_LITERAL>
  {
      if (token.image.endsWith("F") || token.image.endsWith("f")) {
	  result = factory.createFloatLiteral(token.image);
      } else {
	  result = factory.createDoubleLiteral(token.image);
      }
      setPrefixInfo(result);
  }
| <CHARACTER_LITERAL>
  {
      result = factory.createCharLiteral(token.image);
      setPrefixInfo(result);
  }
| <STRING_LITERAL>
  {
      result = factory.createStringLiteral(token.image);
      setPrefixInfo(result);
  }
| result = BooleanLiteral()
| result = NullLiteral()

)
  { 
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

BooleanLiteral BooleanLiteral() :
{
    BooleanLiteral result;
}
{
(
  "true" { result = factory.createBooleanLiteral(true); }
|
  "false" { result = factory.createBooleanLiteral(false); }
)
  { 
    setPrefixInfo(result);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

NullLiteral NullLiteral() :
{
    NullLiteral result;
}
{
  "null"
  {
      result = factory.createNullLiteral();
      setPrefixInfo(result);
      return result;
  }
}

ExpressionMutableList Arguments() :
{
    ExpressionMutableList result = null;
}
{
  "(" [ result = ArgumentList() ] ")"
  {
      if (result != null)
      {
	  checkConstruction(result);
	  
	  }
      return result;
  }
}

ExpressionMutableList ArgumentList() :
{
    ExpressionMutableList result = new ExpressionArrayList();
    Expression expr;
}
{
        expr = Expression() { result.add(expr); }
  ( "," expr = Expression() { result.add(expr); } )*
  {
    checkConstruction(result);
    
    return result;
  }
}

TypeOperator AllocationExpression() :
{
    UncollatedReferenceQualifier qn;
    TypeOperator  result;
    TypeReference tr;
    ExpressionMutableList args;
    MemberDeclarationMutableList body = null;
    ClassDeclaration cd = null;
    NewArray na;
}
{
(
  LOOKAHEAD(2)
  ( "new"
    {
	na = factory.createNewArray();
	setPrefixInfo(na);
    }
    tr = PrimitiveType()
    {
	na.setTypeReference(tr);
    }
    result = ArrayDimsAndInits(na)
  )
| (
  "new" 
  {
      result = factory.createNew();
      setPrefixInfo(result);
  }
  qn = Name()
  (
   ( args = Arguments()
     [ 
       {
	   cd = factory.createClassDeclaration();
	   setPrefixInfo(cd);
       }
       body = ClassBody()
       {
	   cd.setMembers(body);
	   setPostfixInfo(cd);
       }
     ]
     {
	 result.setTypeReference(qn.toTypeReference());
	 ((New)result).setArguments(args);
	 if (cd != null) {
	     ((New)result).setClassDeclaration(cd);
	 }
     }
   )
   |
   (
    {	
	na = factory.createNewArray();
	copyPrefixInfo(result, na);
	na.setTypeReference(qn.toTypeReference());
    }
    result = ArrayDimsAndInits(na)
   )
  )
 )
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
NewArray ArrayDimsAndInits(NewArray result) :
{
    int dimensions = 0;
    Expression expr;
    ExpressionMutableList sizes = null;
    ArrayInitializer init = null;
}
{
(
  LOOKAHEAD(2)
  ( ( LOOKAHEAD(2)
      "[" expr = Expression() "]"
      {
	  sizes = (sizes == null) ? new ExpressionArrayList() : sizes;
	  sizes.add(expr);
	  dimensions++;
      }
    )+
    ( LOOKAHEAD(2)
      "[" "]"
      { dimensions++; }
    )*
  )
|
  ( ( "[" "]" 
      { dimensions++; }
    )+
    init = ArrayInitializer()
  )
)
  {
      //      setPrefixInfo(result); 
      result.setDimensions(dimensions);
      if (sizes != null) {
	  result.setArguments(sizes);
      }
      result.setArrayInitializer(init);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

/*
 * Statement syntax follows.
 */
Statement Statement() :
{
  Statement result = null;
  Expression expr;
}
{
(
  LOOKAHEAD(2)
  result = LabeledStatement()
| result = Block()
| result = EmptyStatement()
| LOOKAHEAD(2)
  result = MethodCallStatement()
| LOOKAHEAD(MethodBodyStatement())
  result = MethodBodyStatement()
| LOOKAHEAD(2) expr   = StatementExpression() ";"
  {
      try {
	  result = (ExpressionStatement)expr;
      }
      catch (ClassCastException cce) {
	  // this is a semantical error!!!
	  throw new ParseException("Cannot parse "+current+
	      "\nExpressionStatement expected"+
	      "\n@" +current.beginLine+"/"+current.beginColumn+" in block");
      }
  }
| result = SwitchStatement()
| result = IfStatement()
| result = WhileStatement()
| result = DoStatement()
| result = ForStatement()
| result = BreakStatement()
| result = ContinueStatement()
| result = ReturnStatement()
| result = ThrowStatement()
| result = SynchronizedStatement()
| result = TryStatement()
| result = AssertStatement()
| result = KeYCatchAllStatement()
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Statement KeYCatchAllStatement() :
{
  Statement cat;
  ParameterDeclaration param;
  StatementBlock block;
}
{
  "#catchAll" "(" param = FormalParameter() ")" block = Block()
  { cat = factory.createCatchAllStatement(param, block); 
    return cat;
  }
}

LabeledStatement LabeledStatement() :
{
  LabeledStatement result;
  Identifier id;
  Statement stat;
}
{
  (<IDENTIFIER>
  	{
	      id = factory.createIdentifier(token.image);
	      setPrefixInfo(id);
	      setPostfixInfo(id);
	}
  )
  ":"
  {
      result = factory.createLabeledStatement();
      setPrefixInfo(result);
      result.setIdentifier(id);
  }
  stat = Statement()
  {
    result.setBody(stat);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

MethodCallStatement MethodCallStatement() :
{
  MethodCallStatement result;
  VariableReference resVar = null;
  UncollatedReferenceQualifier qn;
  StatementBlock block;
  ExecutionContext ec;
}
{
  <METHODFRAME>
 (
   "("
   [

     "result->" qn = Name() ","
     {
       resVar = qn.toVariableReference();
     }
   ] 
     ec = ExecutionContext()
   ")"
  )
  ":"
  block = Block()
  {   result = factory.createMethodCallStatement(resVar, ec, block); 
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

MethodBodyStatement MethodBodyStatement() :
{
  TypeReference bodySource;
  Expression tmp;
  VariableReference resVar = null;
  UncollatedReferenceQualifier qn;
  MethodReference methRef;
  MethodBodyStatement result;
}
{


        [LOOKAHEAD(Name() "=")
          qn = Name() "="
          {
            resVar = qn.toVariableReference();
          }
        ] 

  tmp = Expression()
  
  "@" bodySource = Type()
  
  ";"
  
  {
    if (tmp instanceof MethodReference)
    {
        methRef = (MethodReference)tmp;
    }
    else
    {
        throw new ParseException("Expected a method reference.");
    }
    result = factory.createMethodBodyStatement(bodySource, resVar, methRef);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

ExecutionContext ExecutionContext() :
{
  TypeReference classContext;
  Expression runtimeInstance = null;
} 
{

  "source="
  classContext = Type() 
  [ ",this=" runtimeInstance = Expression() ]

  { return new ExecutionContext
	(classContext, 
	(ReferencePrefix)runtimeInstance);
  }
}

StatementBlock Block() :
{
  StatementBlock result;
  StatementMutableList sl = new StatementArrayList();
  Statement stat;
}
{
  "{"
  {
    result = factory.createStatementBlock();
    setPrefixInfo(result);
  }
  ( stat = BlockStatement()
    {
      sl.add(stat);
    }
  )*
  "}"
  {
    result.setBody(sl);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}


StatementBlock StartBlock() :
{
  StatementBlock result;
  StatementMutableList sl = new StatementArrayList();
  Statement stat;
}
{
  "{" (
  {
    result = factory.createStatementBlock();
    setPrefixInfo(result);
  }
  ( stat = BlockStatement()
    {
      sl.add(stat);
    }
  )*
  "}"
  {
    result.setBody(sl);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

  )


}





Statement BlockStatement() :
{
  Statement result;
}
{
 (LOOKAHEAD([ "final" ] Type() <IDENTIFIER>)
  result = LocalVariableDeclaration() ";" 

| result = Statement() 
| result = UnmodifiedClassDeclaration() 
// | result = UnmodifiedInterfaceDeclaration()   removed: not valid!
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

LocalVariableDeclaration LocalVariableDeclaration() :
{
  LocalVariableDeclaration result;
  VariableSpecificationMutableList vl = new VariableSpecificationArrayList(1);
  TypeReference tr;
  VariableSpecification var;
}
{
  {
    result = factory.createLocalVariableDeclaration();
    setPrefixInfo(result);
  }
  [ "final" 
    { 
      Final fi = factory.createFinal(); 
      setPrefixInfo(fi);
      setPostfixInfo(fi);
      result.setModifiers(new ModifierArrayList(fi));
    } 
  ]
  (tr = Type())
  var = VariableDeclarator(false) { vl.add(var); }
  ( "," 
    var = VariableDeclarator(false)  { vl.add(var); }
  )*
  {
      result.setTypeReference(tr);
      result.setVariableSpecifications(vl);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}


EmptyStatement EmptyStatement() :
{
    EmptyStatement result;
}
{
  ";"
  {
    result = factory.createEmptyStatement(); 
    setPrefixInfo(result);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Expression StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{
    Expression result;
    Expression expr;
    Assignment op;
    ExpressionMutableList leftRight;
}
{
(
  result = PreIncrementExpression()
| result = PreDecrementExpression()
| (
    result = PrimaryExpression()
    [
      "++" { 
	  result = factory.createPostIncrement(result); 
	  setPrefixInfo(result);
      }
    | "--" { 
	result = factory.createPostDecrement(result);
	setPrefixInfo(result);
      }
    | ( op = AssignmentOperator()
        expr = Expression()
        {
	  leftRight = new ExpressionArrayList(2);
	  leftRight.add(result);
	  leftRight.add(expr);
	  op.setArguments(leftRight);
	  result = op;
        }
      )
    ]
  )
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Switch SwitchStatement() :
{
  Switch result;
  Expression expr;
  BranchMutableList branches = new BranchArrayList(2);
  Branch branch;
  StatementMutableList stats;
  Statement stat;
}
{
  "switch"
  {
      result = factory.createSwitch();
      setPrefixInfo(result);
   }
   "(" expr = Expression() ")" "{"

    ( branch = SwitchLabel()
      {
        stats = new StatementArrayList();
      }
      ( stat = BlockStatement()
        {
          stats.add(stat);
	}
      )*

      {
        if (branch instanceof Case) {
	  ((Case)branch).setBody(stats);
	} else {
	  ((Default)branch).setBody(stats);
	}
	branches.add(branch);
      }
    )*


  "}"
  {
      result.setExpression(expr);
      result.setBranchList(branches);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

Branch SwitchLabel() :
/*
 * The returned branch is not completely initialized - only the label is set
 */
{
  Branch result;
  Expression expr;
}
{
(
  ( "case"
    {
	result = factory.createCase();
	setPrefixInfo(result);
    }
    expr = Expression()
    ":"
    {
	((Case)result).setExpression(expr);
    }
  )
  |
  ( "default"
    {
	result = factory.createDefault();
	setPrefixInfo(result);
    }
    ":"
  )
)
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Assert AssertStatement() :

{
  Assert result;
  Expression cond = null;
  Expression msg = null;
}
{
   "assert"
   {
       result = factory.createAssert();
       setPrefixInfo(result);
   }
   cond = Expression()
   [
    ":"
    msg = Expression()    
   ]
  ";"
  {
      
      result.setCondition(cond);
      result.setMessage(msg);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}


If IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
  If result;
  Expression cond, e0, e1;
  Then thenStat;
  Else elseStat = null;
  Statement trueStat;
  Statement falseStat = null;
}
{
  "if" 
  {
      result = factory.createIf();
      setPrefixInfo(result);
  }
  "(" cond = Expression() ")" 
  {
      thenStat = factory.createThen();
      setPrefixInfo(thenStat);
  }
  trueStat = Statement()
  {
     thenStat.setBody(trueStat);
  }
  [ LOOKAHEAD(1) "else" 
    {
	elseStat = factory.createElse();
	setPrefixInfo(elseStat);
    }
    falseStat = Statement() 
    {
       elseStat.setBody(falseStat);
    }
  ]
  {
      result.setExpression(cond);
      result.setThen(thenStat);
      if (elseStat != null) {
	  result.setElse(elseStat);
      }
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}


While WhileStatement() :
{
  While result;
  Expression expr;
  Statement stat;
}
{
  "while"
  {
    result = factory.createWhile();
    setPrefixInfo(result);
  }
  "(" expr = Expression() ")" stat = Statement()
  {
    result.setGuard(expr);
    result.setBody(stat);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Do DoStatement() :
{
  Do result;
  Expression expr;
  Statement stat;
}
{
  "do" 
  {
      result = factory.createDo();
      setPrefixInfo(result);
  }
  stat = Statement() "while" "(" expr = Expression() ")" ";"
  {
    result.setGuard(expr);
    result.setBody(stat);    
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

For ForStatement() :
{
    For result;
    LoopInitializerMutableList init = null;
    Expression guard = null;
    ExpressionMutableList update = null;
    Statement body;
}
{
  "for"
  {
      result = factory.createFor();
      setPrefixInfo(result);
  }
   "(" [ init = ForInit() ] ";"
       [ guard = Expression() ] ";"
        [ update = ForUpdate() ] ")"
      body = Statement()
  {
      result.setInitializers(init);
      result.setGuard(guard);
      result.setUpdates(update);
      result.setBody(body);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

LoopInitializerMutableList ForInit() :
{
    LoopInitializerMutableList result = new LoopInitializerArrayList();
    LocalVariableDeclaration varDecl = null;
    ExpressionList exprs = null;
}
{
(
  LOOKAHEAD( [ "final" ] Type() <IDENTIFIER> )
  varDecl = LocalVariableDeclaration()
| exprs   = StatementExpressionList()
)
    {
	if (varDecl != null) {
	    result.add(varDecl);
	} else {
            for (int i =  0, s = exprs.size(); i < s; i += 1)
                result.add((LoopInitializer)exprs.getExpression(i));
	}
	checkConstruction(result);
	
	return result;
    }
}

ExpressionMutableList StatementExpressionList() :
{
    ExpressionMutableList result = new ExpressionArrayList(2);
    Expression expr;
}
{
        expr = StatementExpression() { result.add(expr); }
  ( "," expr = StatementExpression() { result.add(expr); } )*
  {
      checkConstruction(result);
      
      return result;
  }
}

ExpressionMutableList ForUpdate() :
{
    ExpressionMutableList result;
}
{
  result = StatementExpressionList()
  { 
    checkConstruction(result);
    
    return result;
  }
}

Break BreakStatement() :
{
    Identifier id = null;
    Break result;
}
{
  "break" 
  { 
      result = factory.createBreak(); 
      setPrefixInfo(result); 
   }
  [ (<IDENTIFIER> { 
      id = factory.createIdentifier(token.image); 
      setPrefixInfo(id);
      setPostfixInfo(id);
      result.setIdentifier(id);
  } )

  ] ";"
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Continue ContinueStatement() :
{
    Identifier id = null;
    Continue result;
}
{
  "continue" 
  {
      result = factory.createContinue();
      setPrefixInfo(result);     
  }
  [ <IDENTIFIER> 
     {
	 id = factory.createIdentifier(token.image); 
	 setPrefixInfo(id);
	 setPostfixInfo(id);
	 result.setIdentifier(id);
       }
  ] ";"
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
}

Return ReturnStatement() :
{
    Expression expr = null;
    Return result;
}
{
  "return" 
  {
      result = factory.createReturn();
      setPrefixInfo(result);
  }
  [ expr = Expression() 
    { 
	result.setExpression(expr); 
    } 
  ]   
  ";"
  {
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }

}

Throw ThrowStatement() :
{
    Throw result;
    Expression expr;
}
{
  "throw" 
  {
      result = factory.createThrow();      
      setPrefixInfo(result);
  }
      expr = Expression() ";"
  {
      result.setExpression(expr);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

SynchronizedBlock SynchronizedStatement() :
{
    SynchronizedBlock result;
    Expression expr;
    StatementBlock block;
}
{
  "synchronized" 
  {
      result = factory.createSynchronizedBlock();
      setPrefixInfo(result);
  }
  "(" expr = Expression() ")"
  block = Block()
  {
      result.setExpression(expr);
      result.setBody(block);
      checkConstruction(result);
      setPostfixInfo(result);
      return result;
  }
}

Try TryStatement() :
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{
    Try result;
    StatementBlock block;
    ParameterDeclaration param;
    BranchMutableList branches = new BranchArrayList(1);
    Catch cat;
    Finally fin;
}
{
  "try"
      {
        result = factory.createTry();
	setPrefixInfo(result);
      }
  block = Block()
      {
	  result.setBody(block);
      }
  
  (
  ( "catch" 
    {
      cat = factory.createCatch();
      setPrefixInfo(cat);
    }
    "("  param = FormalParameter() ")"  
    block = Block()
    {
	cat.setParameterDeclaration(param);
	cat.setBody(block);
	branches.add(cat);
    }
  )*
  [ "finally" 
     {
	 fin = factory.createFinally();
	 setPrefixInfo(fin);
     }
    block = Block()
      {
	  fin.setBody(block);
	  branches.add(fin);
      }
  ])
  { 
    result.setBranchList(branches);
    checkConstruction(result);
    setPostfixInfo(result);
    return result;
  }
  
}


/**
   For partial parsing ONLY. Allows this()/super() calls, as in
   constructor bodies.
 */
StatementMutableList GeneralizedStatements() :
{
    StatementMutableList            result = new StatementArrayList();
    SpecialConstructorReference     scr = null;
    Statement                       stat = null;
}
{
    [ LOOKAHEAD(ExplicitConstructorInvocation())
      scr = ExplicitConstructorInvocation()
      { result.add(scr); }
    ]
    ( stat = BlockStatement()
      { result.add(stat); }
    )*
  {
      checkConstruction(result);
      
      return result;
  }
}
