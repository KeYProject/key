// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//

// This file is taken from the RECODER library, which is protected by the LGPL,
// and modified.

options {
    JAVA_UNICODE_ESCAPE = true; // costs approx. 7%
    STATIC = true; // if true, the parser may be initialized only once
    
    // From JavaCC 4.0 on OPTIMIZE_TOKEN_MANAGER is no longer supported
    // OPTIMIZE_TOKEN_MANAGER = true;
    
    //    DEBUG_PARSER = true;
}

PARSER_BEGIN(SchemaJavaParser)

package de.uka.ilkd.key.parser.schemajava;

import java.io.*;
import java.util.*;

import recoder.*;
import recoder.list.generic.*;
import recoder.java.*;
import recoder.java.declaration.*;
import recoder.java.declaration.modifier.*;
import recoder.java.expression.*;
import recoder.java.expression.literal.*;
import recoder.java.expression.operator.*;
import recoder.java.reference.*;
import recoder.java.statement.*;
import recoder.io.*;

import recoder.abstraction.TypeArgument.WildcardMode;

import de.uka.ilkd.key.java.recoderext.*;
import de.uka.ilkd.key.logic.op.SchemaVariable;
import de.uka.ilkd.key.logic.op.SortedSchemaVariable;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.logic.sort.ProgramSVSort;

/**
   JavaCC AST generation specification based on the original Java1.1   
   grammar that comes with javacc, and includes the modification of D. Williams
   to accept the Java 1.2 strictfp modifier.
   Several patches have been added to allow semicola after member declarations.
   Augmented with meta constructs and schema variables for use of a schematic 
   Java in Taclets.
 */
public class SchemaJavaParser {

    public static final void initialize(Reader r) {
	current = null;
	comments.clear();
	ReInit(r);
    }

    /** the JavaProgramFactory instance that is used to create
	parse results
    */
    private static SchemaJavaProgramFactory factory
	= (SchemaJavaProgramFactory) SchemaJavaProgramFactory.getInstance();

    static boolean superAllowed = true;
    private static boolean isSuperAllowed() { return superAllowed; }
    private static void setAllowSuper(boolean b) { superAllowed = b; }


    static boolean jdk1_4 = true;
    static boolean jdk1_5 = false;

    public static boolean isAwareOfAssert() {
        return jdk1_4;        
    }

    public static void setAwareOfAssert(boolean yes) {
        jdk1_4 = yes;
        if (yes == false) jdk1_5 = false;
    }
    
    public static boolean isJava5() {
    	return jdk1_5;
    }
    
    public static void setJava5(boolean yes) {
	    jdk1_5 = yes;
    	if (yes)
	    	jdk1_4 = true;
    }
    
    public static void setTabSize(int tabSize) {
    	JavaCharStream.setTabSize(tabSize);
    }
    
    public static int getTabSize() {
    	return JavaCharStream.getTabSize(0); // whatever...
    }
    
    /** temporary valid variable that is used to return an additional
        argument from parser method VariableDeclaratorId, since such an
        id may have a dimension
    */
    private static int tmpDimension;

    /** current token, follows the next links when necessary */
    private static Token current;

    /** all comments in a global list. */
    private static List<Comment> comments = new ArrayList<Comment>();

    /** reuseable position object. */
    private static SourceElement.Position position 
	= new SourceElement.Position(0, 0);

    private static void	copyPrefixInfo(SourceElement oldResult,
				       SourceElement newResult) {
	newResult.setRelativePosition(oldResult.getRelativePosition());
	newResult.setStartPosition(oldResult.getStartPosition());
    }

    /**
       Sets indentation information.
    */
    private static void setPrefixInfo(SourceElement constrResult) {
	position.setPosition(0, 0);
        if (current != token) {
	    if (current != null) {
		while (current.next != token) {
		    current = current.next;
		}
	    }
            Token prev;
            if (token.specialToken != null) {
                prev = token.specialToken;
            } else {
                prev = current;
            }
	    if (prev != null) {
		int col = token.beginColumn - 1;
		int lf = token.beginLine - prev.endLine;
		if (lf <= 0) {
                    col -= prev.endColumn; // - 1;
		    if (col < 0) {
			col = 0;
		    }
		}		
		position.setPosition(lf, col);
	    }
        }
        current = token;
	constrResult.setRelativePosition(position);
	position.setPosition(current.beginLine, current.beginColumn);
	constrResult.setStartPosition(position);
    }

    private static void testLeftHandSide(Expression expr) throws ParseException{
	if (expr instanceof ExpressionSVWrapper) {
	    SortedSchemaVariable sv=(SortedSchemaVariable)(((ExpressionSVWrapper) expr).getSV());
	    if ( !isLeftHandSide(sv.sort()) ) {
		throw new ParseException
		    ("Schema variable "+sv+" should be one of lefthandside"
		     +" or nonsimpleexpression or variable or simple expression.");
	    }
	}

    }

    private static boolean isLeftHandSide(Sort s) {
	return  s == ProgramSVSort.VARIABLE ||
	    s == ProgramSVSort.STATICVARIABLE ||
	    s == ProgramSVSort.IMPLICITVARIABLE ||
	    s == ProgramSVSort.EXPLICITVARIABLE ||
	    s == ProgramSVSort.LEFTHANDSIDE  ||
	    s == ProgramSVSort.SIMPLEEXPRESSION  ||
	    s == ProgramSVSort.NONSIMPLEEXPRESSION;
    }

    private static boolean isLocalVariable(String svName) {
	return  factory.lookupSchemaVariableType(svName, 
						 ProgramSVSort.VARIABLE)
	    || factory.lookupSchemaVariableType(svName, 
						ProgramSVSort.EXPLICITVARIABLE)
	    || factory.lookupSchemaVariableType(svName, 
						ProgramSVSort.IMPLICITVARIABLE);	
    }


    private static void addComment(Comment c, Token tok) {
        Token prev = tok.specialToken;
        if (prev == null) {
            prev = token;
            // in case we are inside a lookahead we skip to the last known
            // non-special token
            while (prev.next != null) {
                prev = prev.next;
            }
        }
	position.setPosition(0, 0);

        int internalIndentation = 0;
        int internalLinefeeds = 0;
        if (prev.image != null) {
	    int col = tok.beginColumn - 1;
	    int lf = tok.beginLine - prev.endLine;
	    if (lf <= 0) {
                col -= prev.endColumn; // - 1;
	    }		
	    position.setPosition(lf, col);
        }
	c.setRelativePosition(position);
        position.setPosition(tok.endLine, tok.endColumn);
        c.setEndPosition(position);
	position.setPosition(tok.beginLine, tok.beginColumn);
	c.setStartPosition(position);
        if (!(c instanceof DocComment)) {
	    boolean hasEmptyLine = c.getRelativePosition().getLine() > 1;
	    c.setPrefixed(hasEmptyLine);
	    if (tok.specialToken != null && !hasEmptyLine) {
		c.setPrefixed(comments.get(comments.size() - 1).isPrefixed());
	    }	    
	}
        comments.add(c);
    }
    
    static void addSingleLineComment(Token tok) {
        addComment(factory.createSingleLineComment(tok.image.trim()), tok);
    }

    static void addMultiLineComment(Token tok) {
        addComment(factory.createComment(tok.image), tok);
    }

    static void addDocComment(Token tok) {
        addComment(factory.createDocComment(tok.image), tok);
    }
    
    public static List<Comment> getComments() {
	return comments;
    }
   
    private static void checkExpressionSVWrapper(ProgramSVSort notOfSort, 
						 ProgramElement exp) throws ParseException{
	if (exp!=null && exp instanceof ExpressionSVWrapper) {
	    SchemaVariable sv=((ExpressionSVWrapper)exp).getSV();
	    if  (((SortedSchemaVariable)sv).sort()==notOfSort) {
		throw new ParseException(sv
					 +": "+notOfSort
					 +" not allowed here");
	    }
	}
    }

    private static void checkLabelSVWrapper(ProgramSVSort notOfSort, 
					    ProgramElement exp) throws ParseException{
	if (exp!=null && exp instanceof LabelSVWrapper) {
	    SchemaVariable sv=((LabelSVWrapper)exp).getSV();
	    if  (((SortedSchemaVariable)sv).sort()==notOfSort) {
		throw new ParseException(sv
					 +": "+notOfSort
					 +" not allowed here");
	    }
	}
    }

 
    /** checks whether or not the tree construction result is valid.
	Currently this only checks whether or not the result is <tt>null</tt>.
	@param constrResult the result of a factory call
	@exception ParseException if the result is not legal
    */
    private static void checkConstruction(SourceElement constrResult) 
	throws ParseException {
	if (constrResult == null) {
	    throw new ParseException
		(constrResult+" An illegal null object was created during tree construction");	
	}

	//check forinit sv is only in forinit:
	if ((constrResult instanceof ExpressionContainer) 
	    && !(constrResult instanceof For)) {
	    ExpressionContainer ec
		=(ExpressionContainer) constrResult;
	    for (int i=0; i<ec.getExpressionCount(); i++) {
		if (ec.getExpressionAt(i) 
		    instanceof ExpressionSVWrapper) {
		    checkExpressionSVWrapper(ProgramSVSort.LOOPINIT, ec.getExpressionAt(i));
		}			
	    }
	}
	if (constrResult instanceof For) {
	    For f=(For)constrResult;		
	    if (f.getUpdates()!=null) for (int i=0; i<f.getUpdates().size(); i++) {
		checkExpressionSVWrapper(ProgramSVSort.LOOPINIT, f.getUpdates().get(i));
	    }
	    checkExpressionSVWrapper(ProgramSVSort.LOOPINIT, f.getGuard());
	    ASTList<LoopInitializer> li=f.getInitializers();
	    if ((li!=null) && (li.size()>0)) {
		if (li.get(0) instanceof ExpressionSVWrapper) {
		    if (li.size()!=1) throw new ParseException("ForInit SV not allowed this way.");	
		} else for (int i=0; i<li.size(); i++) {
		    checkExpressionSVWrapper(ProgramSVSort.LOOPINIT, li.get(i));
		}			
	    }
				
	}

	//check label sv is only in labeled statement:
	if (! (constrResult instanceof LabeledStatement) 
	    && (constrResult instanceof NonTerminalProgramElement)) {

	    NonTerminalProgramElement p=(NonTerminalProgramElement) constrResult;
	    for (int i=0; i<p.getChildCount(); i++) {

		if (p.getChildAt(i) instanceof ExpressionSVWrapper) {
		    checkExpressionSVWrapper(ProgramSVSort.LABEL, p.getChildAt(i));
		}			
	    }
	}



	// insert check code here!!
    }

    private static void checkConstruction(ASTList<? extends ProgramElement> constrResult) 
	throws ParseException {
	if (constrResult == null) {
	    throw new ParseException
		("An illegal null list was created during tree construction");
	}
	// insert check code here!!
    }


    /** inner class that is only used to return results from
	primary suffix syntax rule
	@author RN
    */
    static class PrimarySuffixReturnValue {
	
	// the following constants represent the various sub rules

	/** indicates that the result is currently undefined */
	static final int UNDEFINED       = -1;
	/** production was <pre>"." "this"</pre> */
	static final int THIS            =  0;	
	/** production was <pre>"." AllocationExpression</pre> */
	static final int ALLOCATION_EXPR =  1;	
	/** production was <pre>"[" Expression "]"</pre> */
	static final int INDEX_EXPR      =  2;	
	/** production was <pre>"." <IDENTIFIER></pre> */
	static final int IDENTIFIER      =  3;	
	/** production was <pre>Arguments</pre> */
	static final int ARGUMENTS       =  4;
        /** production was <pre>super</pre> */
        static final int SUPER 			 =  5;
	/** production was <pre>"." #sv</pre> */
	static final int SVIDENTIFIER    =  6;

	/** indicates the type of the result */
	int                   type = UNDEFINED;
	
	/** valid iff <tt>type</tt> is <tt>ALLOCATION_EXPR</tt> or 
	    <tt>INDEX_EXPR</tt> */
	Expression            expr = null;
	
	/** valid iff <tt>type</tt> is <tt>IDENTIFIER</tt> */
	Identifier            id   = null;
    
	/** valid iff <tt>type</tt> is <tt>ARGUMENTS</tt> */
	ASTList<Expression> args = null;
        
        /** valid iff <tt>type</tt> is <tt>IDENTIFIER</tt> and 
         *  it is an explicit generic method invocation
         */
        ASTList<TypeArgumentDeclaration> typeArgs = null;
    }


    /** inner class that is only used to return results from
	primary prefix syntax rule
	@author RN
    */
    static class PrimaryPrefixReturnValue {
    
	// the following constants represent the various sub rules
    
	/** indicates that the result is currently undefined */
	static final int UNDEFINED        = -1;	
	/** production was <pre>Literal</pre> */
	static final int LITERAL          =  0;    
	/** production was <pre>"this"</pre> */
	static final int THIS             =  1;	
	/** production was <pre>"super" "." <IDENTIFIER></pre> */
	static final int SUPER_MEMBERVARIABLE     =  2;	
	/** production was <pre>"(" Expression ")"</pre> */
	static final int PARENTHESIZED_EXPR =  3;    
	/** production was <pre>AllocationExpression</pre> */
	static final int ALLOCATION_EXPR  =  4;    
	/** production was <pre>ResultType "." "class"</pre> */
	static final int CLASS_REF        =  5;	
	/** production was <pre>Name</pre> */
	static final int QUALIFIED_NAME   =  6;
	/** production was <pre>"@(" Expression ")"</pre> */
	static final int PASSIVE_EXPR =  7;    
    
	/** indicates the type of the result */
	int           type    = UNDEFINED;
    
	/** valid iff <tt>type</tt> is <tt>LITERAL</tt> */
	Literal       literal = null;
    
	/** valid iff <tt>type</tt> is <tt>PARENTHESED_EXPR</tt>
	    or <tt>ALLOCATION_EXPR</tt> */
	Expression    expr    = null;
    
	/** valid iff <tt>type</tt> is <tt>CLASS_REF</tt> */
	TypeReference typeref = null;
	
	/** valid iff <tt>type</tt> is <tt>QUALIFIED_NAME</tt> or
	    <tt>SUPER_MEMBERVARIABLE</tt>*/
	UncollatedReferenceQualifier name  = null;

    }

    /** return value containers for primary expression.
	need only be allocated once per parser. */
    static PrimarySuffixReturnValue suffix = new PrimarySuffixReturnValue();
    static PrimaryPrefixReturnValue prefix = new PrimaryPrefixReturnValue();

    
}

PARSER_END(SchemaJavaParser)

/* WHITE SPACE */

SKIP :
{
    " "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
	}

/* COMMENTS */

MORE :
{
    "//" : IN_SINGLE_LINE_COMMENT
	|
	<"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
							 |
							 "/*" : IN_MULTI_LINE_COMMENT
							 }

<IN_SINGLE_LINE_COMMENT>
    SPECIAL_TOKEN :
{
    <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n">
	{
	    SchemaJavaParser.addSingleLineComment(matchedToken);
	} 
	: DEFAULT
	      }

<IN_FORMAL_COMMENT>
    SPECIAL_TOKEN :
{
    <FORMAL_COMMENT: "*/" >
	{
	    SchemaJavaParser.addDocComment(matchedToken);
	}: DEFAULT
	       }

<IN_MULTI_LINE_COMMENT>
    SPECIAL_TOKEN :
{
    <MULTI_LINE_COMMENT: "*/" >  {
	SchemaJavaParser.addMultiLineComment(matchedToken);
    }: DEFAULT
	   }

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
    MORE :
{
    < ~[] >
	  }

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >  {
      if (!SchemaJavaParser.jdk1_4) {
          matchedToken.kind = IDENTIFIER;
      }
  }
| < AT: "@" > {
	  if (!SchemaJavaParser.jdk1_5) {
	  	  // TODO
	  }
  }
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" > {
	  if (!SchemaJavaParser.jdk1_5) {
	  	matchedToken.kind = IDENTIFIER;
	  }
}
		    | < EXTENDS: "extends" >
		    | < FALSE: "false" >
		    | < FINAL: "final" >
		    | < FINALLY: "finally" >
		    | < FLOAT: "float" >
		    | < FOR: "for" >
		    | < GHOST: "ghost" >
		    | < GOTO: "goto" >
		    | < IF: "if" >
		    | < IMPLEMENTS: "implements" >
		    | < IMPORT: "import" >
		    | < INSTANCEOF: "instanceof" >
		    | < INT: "int" >
		    | < INTERFACE: "interface" >
		    | < ISSTATIC: "#isstatic" >
		    | < EVALARGS: "#evaluate-arguments" >
		    | < REPLACEARGS: "#replace" >
		    | < LONG: "long" >
		    | < NATIVE: "native" >
		    | < NEW: "new" >
		    | < NULL: "null" >
		    | < PACKAGE: "package">
		    | < PRIVATE: "private" >
		    | < PROTECTED: "protected" >
		    | < PUBLIC: "public" >
		    | < RETURN: "return" >
		    | < SHORT: "short" >
		    | < STATIC: "static" >
		    | < SUPER: "super" >
		    | < SWITCH: "switch" >
		    | < SYNCHRONIZED: "synchronized" >
		    | < THIS: "this" >
		    | < THROW: "throw" >
		    | < THROWS: "throws" >
		    | < TRANSIENT: "transient" >
		    | < TRUE: "true" >
		    | < TRY: "try" >
		    | < VOID: "void" >
		    | < VOLATILE: "volatile" >
		    | < WHILE: "while" >
	//		| < VARARGDENOTER: "..." >  see CONTEXTEND
		    | < STRICTFP: "strictfp" >
		    | < CONTEXTSTART: ".." >
		    | < CONTEXTEND: "..." >
		    | < TYPEOF: "#typeof" >
		    | < SWITCHTOIF: "#switch-to-if" >
		    | < UNPACK: "#unpack" >
		    | < SET: "#set" >
		    }

/* LITERALS */

TOKEN :
{
    < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
	     | <HEX_LITERAL> (["l","L"])?
	     | <OCTAL_LITERAL> (["l","L"])?
	     >
	     |
	     < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
	     |
	     < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
	     |
	     < #OCTAL_LITERAL: "0" (["0"-"7"])* >
	     |
	     < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
	     | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
	     | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
	     | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
	     >
	     |
	     < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
	     |
	     < CHARACTER_LITERAL:
	"'"
	     (   (~["'","\\","\n","\r"])
		 | ("\\"
		    ( ["n","t","b","r","f","\\","'","\""] 
		      | ["0"-"7"] ( ["0"-"7"] )?
		      | ["0"-"3"] ["0"-"7"] ["0"-"7"]
		      )
		    )
		 )
	     "'"
	     >
	     |
	     < STRING_LITERAL:
	"\""
	     (   (~["\"","\\","\n","\r"])
		 | ("\\"
		    ( ["n","t","b","r","f","\\","'","\""]
		      | ["0"-"7"] ( ["0"-"7"] )?
		      | ["0"-"3"] ["0"-"7"] ["0"-"7"]
		      )
		    )
		 )*
	     "\""
	     >
	     }

/* IDENTIFIERS */

TOKEN :
{
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
	[
	 "\u0024",
	 "\u0041"-"\u005a",
	 "\u005f",
	 "\u0061"-"\u007a",
	 "\u00c0"-"\u00d6",
	 "\u00d8"-"\u00f6",
	 "\u00f8"-"\u00ff",
	 "\u0100"-"\u1fff",
	 "\u3040"-"\u318f",
	 "\u3300"-"\u337f",
	 "\u3400"-"\u3d2d",
	 "\u4e00"-"\u9fff",
	 "\uf900"-"\ufaff"
	]
		       >
		       |
		       < #DIGIT:
	[
	 "\u0030"-"\u0039",
	 "\u0660"-"\u0669",
	 "\u06f0"-"\u06f9",
	 "\u0966"-"\u096f",
	 "\u09e6"-"\u09ef",
	 "\u0a66"-"\u0a6f",
	 "\u0ae6"-"\u0aef",
	 "\u0b66"-"\u0b6f",
	 "\u0be7"-"\u0bef",
	 "\u0c66"-"\u0c6f",
	 "\u0ce6"-"\u0cef",
	 "\u0d66"-"\u0d6f",
	 "\u0e50"-"\u0e59",
	 "\u0ed0"-"\u0ed9",
	 "\u1040"-"\u1049"
	]
		       >
		       | < SVIDENTIFIER:  <SHARP> <LETTER> (<LETTER>|<DIGIT>)* >
		       }

/* SEPARATORS */

TOKEN :
{
    < LPAREN: "(" >
		  | < RPAREN: ")" >
		  | < LBRACE: "{" >
		  | < RBRACE: "}" >
		  | < LBRACKET: "[" >
		  | < RBRACKET: "]" >
		  | < SEMICOLON: ";" >
		  | < COMMA: "," >
		  | < DOT: "." >
		  }

/* OPERATORS */

TOKEN :
{
    < ASSIGN: "=" >
//| < GT: ">" >
		  | < LT: "<" >
		  | < BANG: "!" >
		  | < TILDE: "~" >
		  | < HOOK: "?" >
		  | < COLON: ":" >
		  | < EQ: "==" >
		  | < LE: "<=" >
		  | < GE: ">=" >
		  | < NE: "!=" >
		  | < SC_OR: "||" >
		  | < SC_AND: "&&" >
		  | < INCR: "++" >
		  | < DECR: "--" >
		  | < PLUS: "+" >
		  | < MINUS: "-" >
		  | < STAR: "*" >
		  | < SLASH: "/" >
		  | < BIT_AND: "&" >
		  | < BIT_OR: "|" >
		  | < XOR: "^" >
		  | < REM: "%" >
		  | < LSHIFT: "<<" >
		  | < PLUSASSIGN: "+=" >
		  | < MINUSASSIGN: "-=" >
		  | < STARASSIGN: "*=" >
		  | < SLASHASSIGN: "/=" >
		  | < ANDASSIGN: "&=" >
		  | < ORASSIGN: "|=" >
		  | < XORASSIGN: "^=" >
		  | < REMASSIGN: "%=" >
		  | < LSHIFTASSIGN: "<<=" >
		  | < RSIGNEDSHIFTASSIGN: ">>=" >
		  | < RUNSIGNEDSHIFTASSIGN: ">>>=" >
		  | < SHARP: "#">
		  }
		  
TOKEN : 
{
  < IMPLICITIDENTIFIER : "<" <LETTER> (<LETTER>|<DIGIT>)* ">" >
  {
  	matchedToken.kind = LT;
  	((Token.RealKindToken)matchedToken).realKind = IMPLICITIDENTIFIER;
  	input_stream.backup(matchedToken.image.length() - 1);
  	matchedToken.image = "<";
  }
}



/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
  {
     matchedToken.kind = GT;
     ((Token.RealKindToken)matchedToken).realKind = RUNSIGNEDSHIFT;
     input_stream.backup(2);
     matchedToken.image = ">";
  }
| < RSIGNEDSHIFT: ">>" >
  {
     matchedToken.kind = GT;
     ((Token.RealKindToken)matchedToken).realKind = RSIGNEDSHIFT;
     input_stream.backup(1);
     matchedToken.image = ">";
  }
| < GT: ">" >
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

CompilationUnit CompilationUnit() :
{
    CompilationUnit result;
    PackageSpecification        ps  = null;
    ASTList<Import>           il  = new ASTArrayList<Import>();
    Import                      imp;
    ASTList<TypeDeclaration>  tdl = new ASTArrayList<TypeDeclaration>();
    TypeDeclaration             td;
}
{
	// This is a quick "fix" - TypeDeclaration and PackageDeclaration unfortunately 
	// can both start with an unlimited number of annotations. However, usually only one file
	// per package contains package annotations, so this is not a performance issue.
    (
      LOOKAHEAD(PackageDeclaration())
	  ps = PackageDeclaration()
	(
	 imp = ImportDeclaration()
	    { il.add(imp); }
	  )*
	  (
	    td = TypeDeclaration()
	    {
	      if (td != null) tdl.add(td);
	    }
	 )*
    |
	  (
	    imp = ImportDeclaration()
	    { il.add(imp); }
	  )*
	(
	 td = TypeDeclaration()
	    {
		if (td != null) tdl.add(td);
	    }
	 )*
	)
	<EOF>
	{
	    result = factory.createCompilationUnit(ps, il, tdl); 
	    checkConstruction(result);
	    setPrefixInfo(result);
	    return result;
	}
}

PackageSpecification PackageDeclaration() :
{
    PackageSpecification result;
    UncollatedReferenceQualifier qn;
    ASTList<AnnotationUseSpecification> annotations = new ASTArrayList<AnnotationUseSpecification>();
    AnnotationUseSpecification annot;
}
{
  (annot = AnnotationUse() {
  	annotations.add(annot);
  } )*
  { 
  	annotations.trimToSize();
  }
    "package" 
	{
	    result = factory.createPackageSpecification();
	    setPrefixInfo(result);
          result.setAnnotations(annotations);
	}
    qn = Name() ";"
    {
	result.setPackageReference(qn.toPackageReference());
	checkConstruction(result);
	return result;
    }
}

Import ImportDeclaration() :
{
    Import result;
    UncollatedReferenceQualifier qn;
    String hs = null;
    boolean wildcard = false;
    boolean isStatic = false;
}
{
    "import" {
	result = factory.createImport();
	setPrefixInfo(result);
    }
  ["static" { isStatic = true; }] 
    ( qn = Name() ) [ "." "*" { wildcard = true; } ] ";"
	{
	    // "*" will be thrown away immediately since the package name is sufficient
	    result.setMultiImport(wildcard);
      if (isStatic) {
      	result.setStaticImport(true);
	    if (wildcard) {
	     	result.setReference(qn.toTypeReference());
     	} else {
     		result.setStaticIdentifier(qn.getIdentifier());
     		UncollatedReferenceQualifier urq = (UncollatedReferenceQualifier)qn.getReferencePrefix();
     		urq.setReferenceSuffix(null);
     		result.setReference(urq.toTypeReference());
     	}
      }
      else if (wildcard) {
		result.setReference(qn);
	    } else {
		result.setReference(qn.toTypeReference());
	    }
	    checkConstruction(result);
	    return result;
	}
}

TypeDeclaration TypeDeclaration() :
{
    TypeDeclaration result = null;
}
{
    (
      LOOKAHEAD( ( "abstract" | "final" | "public" | "strictfp" | AnnotationUse() )* "class" )
     result = ClassDeclaration()
     |
      LOOKAHEAD( ( "abstract" | "public" | "strictfp" | AnnotationUse() )* "interface" )
     result = InterfaceDeclaration()
     |
      LOOKAHEAD( ("public" | "strictfp" | "protected" | "private" | "static" | AnnotationUse() )* "enum")
      result = EnumDeclaration()
    |
      LOOKAHEAD( ("strictfp" | "public" | "protected" | "private" | "static" | "abstract" | AnnotationUse() )* "@" "interface")
      result = AnnotationTypeDeclaration()
    |
      ";"
     )
	{
    if (result != null) { // may be removed as soon as Recoder fully understands Java5
		checkConstruction(result);
	    }
	    return result;
	}
}


/*
 * Declaration syntax follows.
 */
 
AnnotationDeclaration AnnotationTypeDeclaration() :
{
	ASTList<MemberDeclaration> members = new ASTArrayList<MemberDeclaration>();
	MethodDeclaration md;
	FieldDeclaration fd;
	TypeDeclaration td;
	ASTList<DeclarationSpecifier> declSpecs = new ASTArrayList<DeclarationSpecifier>(), methodDs;
	DeclarationSpecifier ds;
	Identifier name, methodName;
	TypeReference methodRes;
	Expression methodDefExpr;
	AnnotationDeclaration result = new AnnotationDeclaration();
}
{
	(LOOKAHEAD(2)(
	    "strictfp" { ds = factory.createStrictFp(); }
	  | "public" { ds = factory.createPublic(); }
	  | "protected" { ds = factory.createProtected(); }
	  | "private" { ds = factory.createPrivate(); }
	  | "static" { ds = factory.createStatic(); }
	  | "abstract" { ds = factory.createAbstract(); }
	  | ds = AnnotationUse() 
	 ) { declSpecs.add(ds); }
	)*
	"@" { setPrefixInfo(result); } 
	"interface" <IDENTIFIER> { name = factory.createIdentifier(token.image); }
	// here begins AnnotationTypeBody (JLS)
	"{"
		// AnnotationTypeElementDeclarations (JLS)
		(
			// this is a restricted method declaration:
			LOOKAHEAD( (AnnotationUse() | "public" | "abstract")* Type() <IDENTIFIER>)
			{ methodDs = new ASTArrayList<DeclarationSpecifier>(); }
			  (( ds = AnnotationUse() 
			    | "public" { ds = factory.createPublic(); }
			    | "abstract" { ds = factory.createAbstract(); }
			   ) { methodDs.add(ds); }
			  )* 
			  methodRes = Type() 
			  <IDENTIFIER> { methodName = factory.createIdentifier(token.image); }
			  "(" ")" 
			  { methodDefExpr = null; }
			  ["default" methodDefExpr = ElementValue()]
			{ 
				md = factory.createAnnotationPropertyDeclaration(methodDs, methodRes, methodName, methodDefExpr);
				members.add(md);
			}
		  |
		    // ConstantDeclaration
		    /*LOOKAHEAD( (AnnotationUse() | "public" | "static" | "final")* Type() VariableDeclarator(true))
		    (AnnotationUse() | "public" | "static" | "final")* Type() VariableDeclarator(true) ( "," VariableDeclarator(true))* ";"*/
		    LOOKAHEAD(FieldDeclaration())
		    fd = FieldDeclaration() { members.add(fd); }
		  |
		    LOOKAHEAD( NestedClassDeclaration() )
		    td = NestedClassDeclaration() { members.add(td); }
		  |
		    LOOKAHEAD( EnumDeclaration())
		    td = EnumDeclaration() { members.add(td); }
		  |
		    LOOKAHEAD( NestedInterfaceDeclaration() )
		    td = NestedInterfaceDeclaration() { members.add(td); }
		  | 
		    LOOKAHEAD( AnnotationTypeDeclaration() )
		    td = AnnotationTypeDeclaration() { members.add(td); }
		  |
		    ";"
		)*
	"}"
	
	{ 
		result.setDeclarationSpecifiers(declSpecs);
		result.setIdentifier(name);
		result.setMembers(members);
		
		return result;
	}
}

 
EnumDeclaration EnumDeclaration() :
{
	DeclarationSpecifier ds;
	ASTList<DeclarationSpecifier> declSpecs = new ASTArrayList<DeclarationSpecifier>();
	EnumDeclaration result;
	ASTList<MemberDeclaration> members = new ASTArrayList<MemberDeclaration>();
	MemberDeclaration md;
	Implements im;
	ASTList<UncollatedReferenceQualifier> nl;
	EnumConstantDeclaration constant;
}
{

	(LOOKAHEAD(2)(
	    "strictfp" { ds = factory.createStrictFp(); }
	  | "public" { ds = factory.createPublic(); }
	  | "protected" { ds = factory.createProtected(); }
	  | "private" { ds = factory.createPrivate(); }
	  | "static" { ds = factory.createStatic(); }
	  | ds = AnnotationUse() 
	 )	{ 
	 		setPrefixInfo(ds);
	 		
	 		declSpecs.add(ds); 
		}
	)*
	"enum" 
	{
		result = new EnumDeclaration();
		setPrefixInfo(result);
		if (declSpecs.size() != 0)
			result.setDeclarationSpecifiers(declSpecs);
	}
	
	<IDENTIFIER>
    {
          Identifier id = factory.createIdentifier(token.image);
          setPrefixInfo(id);
          
          result.setIdentifier(id);
    }

	[ "implements"
	  {
          im = factory.createImplements();
          setPrefixInfo(im);          
      }
      nl = TypedNameList()
      {
          ASTList<TypeReference> trl = new ASTArrayList<TypeReference>();
          for (int i = 0, s = nl.size(); i < s; i++) {
              TypeReference tr = 
                  nl.get(i).toTypeReference();
              trl.add(tr);
          }
          im.setSupertypes(trl);
          result.setImplementedTypes(im);
      }
	] 
	"{" // begin of "EnumBody"
	  [ constant = EnumConstant() { 
	 		members.add(constant);
	  	}
	  	( LOOKAHEAD(2) "," constant = EnumConstant() { members.add(constant); } )* 
	  ] 
	  [","] 
	  [";" 
	      (md = ClassBodyDeclaration()
			 {
		        members.add(md);
			 }
		   )*
	  ] 
	"}"
	{ 
	 	result.setMembers(members);
	 	
		return result;
	}
}

EnumConstantDeclaration EnumConstant() :
{
	AnnotationUseSpecification annot;
	ASTArrayList<DeclarationSpecifier> annotations = null;
	Identifier id;
	ASTList<Expression> args = null;
	ClassDeclaration cd = null;	
	ASTList<MemberDeclaration> body = null;
	EnumConstantSpecification spec;
	EnumConstructorReference ref = null;
	EnumConstantDeclaration result = new EnumConstantDeclaration();
}
{
	{ setPrefixInfo(result); }
	( 
		{ if (annotations == null) annotations = new ASTArrayList<DeclarationSpecifier>(); }
		annot = AnnotationUse() 
		{ annotations.add(annot); }
	)* 
	
	<IDENTIFIER> { 
		id = factory.createIdentifier(token.image); 
		setPrefixInfo(id);
		
	}
	[
		args = Arguments() 
	] 
    [ 
       {
           cd = factory.createClassDeclaration();
           setPrefixInfo(cd);
       }
       body = ClassBody()
       {
           cd.setMembers(body);
           
       }
    ]	
	{
		ref = new EnumConstructorReference(args, cd);
		setPrefixInfo(ref);  // TODO this maybe too late ?!
		
		spec = new EnumConstantSpecification(id, ref);
		setPrefixInfo(spec); // TODO this maybe too late ?!
		
		
		result.setEnumConstantSpecification(spec);
		result.setDeclarationSpecifiers(annotations);
		return result;
	}
}


ClassDeclaration ClassDeclaration() :
{
    ClassDeclaration    result = null;
    ASTList<DeclarationSpecifier> ml = new ASTArrayList<DeclarationSpecifier>();
  DeclarationSpecifier m;
}
{
    ( (
       ( "abstract" { m = factory.createAbstract(); } )
       | ( "final"    { m = factory.createFinal();    } )
       | ( "public"   { m = factory.createPublic();   } )
       | ( "strictfp" { m = factory.createStrictFp(); } )
    | ( m = AnnotationUse() 							  )
       )
    { 
	setPrefixInfo(m);
	ml.add(m); 
    }
      )*
	result = UnmodifiedClassDeclaration()
    {
    result.setDeclarationSpecifiers(ml);
	checkConstruction(result);
	return result;
    }
}

ClassDeclaration UnmodifiedClassDeclaration() :
{
    ClassDeclaration                 result;
    UncollatedReferenceQualifier     qn;
    ASTList<UncollatedReferenceQualifier> nl;
    ASTList<MemberDeclaration>     mdl;
    Extends ex;
    Implements im;
  ASTList<TypeParameterDeclaration> typeParams = null;
}
{
    "class"  {
	result = factory.createClassDeclaration();
	setPrefixInfo(result);
    }
    <IDENTIFIER>
	{
	    Identifier id = factory.createIdentifier(token.image);
	    setPrefixInfo(id);
	    result.setIdentifier(id);
	}
  [ typeParams = TypeParameters() 
  	{
  		result.setTypeParameters(typeParams);
  	}
  ]
    [ "extends"
    {
	ex = factory.createExtends();
	setPrefixInfo(ex);
    }
      qn = TypedName()
	{
          ex.setSupertypes(new ASTArrayList<TypeReference>(1));
          ex.getSupertypes().add(qn.toTypeReference());
	    result.setExtendedTypes(ex);
	}
    ]
	[ "implements"
	    {
		im = factory.createImplements();
		setPrefixInfo(im);	  
	    }
      nl = TypedNameList()
	    {
          ASTList<TypeReference> trl = new ASTArrayList<TypeReference>();
		for (int i = 0, s = nl.size(); i < s; i++) {
		    TypeReference tr = 
                  nl.get(i).toTypeReference();
		    trl.add(tr);
		}
		im.setSupertypes(trl);
		result.setImplementedTypes(im);
	    }
	]
	mdl = ClassBody()
    {
	result.setMembers(mdl);
	checkConstruction(result);
	return result;
    }
}

ASTList<MemberDeclaration> ClassBody() :
{
    ASTList<MemberDeclaration> result = new ASTArrayList<MemberDeclaration>();
    MemberDeclaration md;
}
{
    "{"
	(
	 md = ClassBodyDeclaration()
	    {
		result.add(md);
	    }
	 )*
	"}"
	{
	    checkConstruction(result);
	    return result;
	}
}

ClassDeclaration NestedClassDeclaration() :
{
    ClassDeclaration result;
    ASTList<DeclarationSpecifier> ml = new ASTArrayList<DeclarationSpecifier>();
  DeclarationSpecifier m;
}
{
    (
     (
      ( "static"    { m = factory.createStatic(); }    )
      | ( "abstract"  { m = factory.createAbstract(); }  )
      | ( "final"     { m = factory.createFinal(); }     )
      | ( "public"    { m = factory.createPublic(); }    )
      | ( "protected" { m = factory.createProtected(); } )
      | ( "private"   { m = factory.createPrivate(); }   )
      | ( "strictfp"  { m = factory.createStrictFp(); }  )
    | ( m = AnnotationUse() 						   )
      )
    {
	setPrefixInfo(m);
	ml.add(m);
    }
     )*
	result = UnmodifiedClassDeclaration()
    {
	result.setDeclarationSpecifiers(ml);
	checkConstruction(result);
	return result;
    }
}

MemberDeclaration ClassBodyDeclaration() :
{
    MemberDeclaration result;
}
{
(
  LOOKAHEAD(2)
     (result = Initializer() (";")*) // patch
| LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp" | AnnotationUse() )* "class" )
     (result = NestedClassDeclaration() (";")*) // patch
| LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp" | AnnotationUse() )* "interface" )
     (result = NestedInterfaceDeclaration() (";")*) // patch
| LOOKAHEAD( (AnnotationUse())* [ ("public" | "protected" | "private")  (AnnotationUse())*] [TypeParameters()] <IDENTIFIER> "(" )
     (result = ConstructorDeclaration()  (";")*) // patch
| LOOKAHEAD( MethodDeclarationLookahead() )
     (result = MethodDeclaration() (";")*) // patch
| LOOKAHEAD( EnumDeclaration() )
     (result = EnumDeclaration() (";")*)
| LOOKAHEAD( AnnotationTypeDeclaration() )
     (result = AnnotationTypeDeclaration() (";")*)
| (result = FieldDeclaration() (";")*) // patch
)
	{
	    checkConstruction(result);
	    return result;
	}
}

InterfaceDeclaration InterfaceDeclaration() :
{
    InterfaceDeclaration result;
    ASTList<DeclarationSpecifier> ml = new ASTArrayList<DeclarationSpecifier>();
  DeclarationSpecifier m;
}
{
    (
     (
      ( "abstract"  { m = factory.createAbstract(); }  )
      | ( "public"    { m = factory.createPublic(); }    )
      | ( "strictfp"  { m = factory.createStrictFp(); }  )
    | ( m = AnnotationUse()								   )
      )
    {
	setPrefixInfo(m);
	ml.add(m);
    }
     )*
	result = UnmodifiedInterfaceDeclaration()
    {
	result.setDeclarationSpecifiers(ml);
	checkConstruction(result);
	return result;
    }

}

InterfaceDeclaration NestedInterfaceDeclaration() :
{
    InterfaceDeclaration result;
    ASTList<DeclarationSpecifier> ml = new ASTArrayList<DeclarationSpecifier>();
  DeclarationSpecifier m;
}
{
    (
     (
      ( "static"    { m = factory.createStatic(); }    )
      | ( "abstract"  { m = factory.createAbstract(); }  )
      | ( "final"     { m = factory.createFinal(); }     )
      | ( "public"    { m = factory.createPublic(); }    )
      | ( "protected" { m = factory.createProtected(); } )
      | ( "private"   { m = factory.createPrivate(); }   )
      | ( "strictfp"  { m = factory.createStrictFp(); }  )
    | ( m = AnnotationUse() 						   )
      )
    {
	setPrefixInfo(m);
	ml.add(m);
    }
     )*
	result = UnmodifiedInterfaceDeclaration()
    {
    result.setDeclarationSpecifiers(ml);
	checkConstruction(result);
	return result;
    }
}

InterfaceDeclaration UnmodifiedInterfaceDeclaration() :
{
    InterfaceDeclaration             result;
    ASTList<UncollatedReferenceQualifier> nl;
    ASTList<MemberDeclaration>     mdl = new ASTArrayList<MemberDeclaration>();
    MemberDeclaration                md;
    Extends ex;
    ASTList<TypeParameterDeclaration> typeParams = null;
}
{
    "interface"
	{
	    result = factory.createInterfaceDeclaration();
	    setPrefixInfo(result);
	}      
    <IDENTIFIER>
	{
	    Identifier id = factory.createIdentifier(token.image);
	    setPrefixInfo(id);
	    result.setIdentifier(id);
	}
  [ typeParams = TypeParameters() 
  	{
  		result.setTypeParameters(typeParams);
  	}
  ]
    [ "extends"
    {
	ex = factory.createExtends();
	setPrefixInfo(ex);
    }
      nl = TypedNameList()
	{
	    ASTList<TypeReference> trl = new ASTArrayList<TypeReference>();
	    for (int i = 0, s = nl.size(); i < s; i++) {
		TypeReference tr = 
		    nl.get(i).toTypeReference();
		trl.add(tr);
	    }
	    ex.setSupertypes(trl);
	    result.setExtendedTypes(ex);
	}
    ]
	"{"
	(
	 md = InterfaceMemberDeclaration()
	    {
		mdl.add(md);
	    }
	 )*
	"}"
	{
	    result.setMembers(mdl);
	    checkConstruction(result);
	    return result;
	}
}

MemberDeclaration InterfaceMemberDeclaration() :
{
    MemberDeclaration result;
}
{
    (
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp" | AnnotationUse() )* "class" )
     (result = NestedClassDeclaration() (";")*) // patch
| LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp" | AnnotationUse() )* "interface" )
     (result = NestedInterfaceDeclaration() (";")*) // patch
     | LOOKAHEAD( MethodDeclarationLookahead() )
     (result = MethodDeclaration() (";")*) // patch
| LOOKAHEAD( EnumDeclaration() )
  (result = EnumDeclaration() (";")*)
| LOOKAHEAD( AnnotationTypeDeclaration() )
  (result = AnnotationTypeDeclaration() (";")*)
     | (result = FieldDeclaration() (";")*) // patch
     )
	{
	    checkConstruction(result);
	    return result;
	}
}

FieldDeclaration FieldDeclaration() :
{
    FieldDeclaration result;
    ASTList<DeclarationSpecifier> ml = new ASTArrayList<DeclarationSpecifier>();
    DeclarationSpecifier m = null;
    TypeReference tr;
    ASTList<FieldSpecification> vl = new ASTArrayList<FieldSpecification>();
    VariableSpecification var;
}
{
    (
     (
      ( "public"    { m = factory.createPublic(); }    )
      | ( "protected" { m = factory.createProtected(); } )
      | ( "private"   { m = factory.createPrivate(); }   )
      | ( "static"    { m = factory.createStatic(); }    )
      | ( "final"     { m = factory.createFinal(); }     )
      | ( "transient" { m = factory.createTransient(); } )
      | ( "volatile"  { m = factory.createVolatile(); }  )
    | ( m = AnnotationUse() 						   )
      )
    {	
	setPrefixInfo(m);	
	ml.add(m);
    }
     )*
	(tr = Type() | tr=TypeSV() | tr=TypeMC())
	{
	    result = factory.createFieldDeclaration();
	    result.setDeclarationSpecifiers(ml);
	    result.setTypeReference(tr);
	}
    var = VariableDeclarator(true)
    {
	vl.add((FieldSpecification)var);
    }
    (
     ","
     var = VariableDeclarator(true)
	{
	    vl.add((FieldSpecification)var);
	}
     )*
	";"
	{
	    result.setFieldSpecifications(vl);
	    //    setPrefixInfo(result);
	    checkConstruction(result);
	    return result;
	}
}

VariableSpecification VariableDeclarator(boolean isForField) :
{
    Identifier id;
    int dim = 0;
    Expression init = null;
    VariableSpecification result;
}
{
    id = VariableDeclaratorId() { dim = tmpDimension; }
    [ "=" init = VariableInitializer() ]    
	{
	    if (isForField) {
		result = factory.createFieldSpecification(id, dim, init);
	    } else {
		result = factory.createVariableSpecification(id, dim, init);
	    }
	    //    setPrefixInfo(result); // only after "=" !!!!!!!!!!!!!!!
	    checkConstruction(result);
	    return result;
	}
}



Identifier VariableDeclaratorId() :
{
    Identifier result;
}
{
    <IDENTIFIER>
	{ result = factory.createIdentifier(token.image);
	setPrefixInfo(result);
	tmpDimension = 0;
	}
    ( "[" "]" { tmpDimension++; } )*
	{
	    checkConstruction(result);
	    //setPrefixInfo(result);
	    return result;
	}
}

Expression VariableInitializer() :
{
    Expression result;
}
{
    (
     result = ArrayInitializer()
     | result = Expression()
     )
	{
	    checkConstruction(result);
	    return result;
	}
}


VariableSpecification SVVariableDeclarator(boolean isForField) :
{
    Identifier id;
    int dim = 0;
    Expression init = null;
    VariableSpecification result;
}
{
    ((id = VariableDeclaratorId() { dim = tmpDimension; })
     |(id = VariableSV()  {dim = tmpDimension; }))

	[ "=" (init = VariableInitializer())
	|(init = ExpressionSV())
	]
	{
	    if (isForField) {
		System.err.println("FIELD DECL WITH SV NOT SUPPORTED");
		result=null;
	    } else {
		result = factory.createVariableSpecification(id, dim, init); //!!CHANGE
	    }
	    //    setPrefixInfo(result); // only after "=" !!!!!!!!!!!!!!!
	    checkConstruction(result);
	    return result;
	}
}



ArrayInitializer ArrayInitializer() :
{
    ArrayInitializer result;
    ASTList<Expression> el = new ASTArrayList<Expression>();
    Expression init;
}
{
    "{" {
	result = factory.createArrayInitializer();
	setPrefixInfo(result);
    }
    [ init = VariableInitializer()
	{ el.add(init); }
    ( LOOKAHEAD(2) ","
      init = VariableInitializer()
	{ el.add(init); }
      )*
    ] [ "," ] "}"
	{
	    result.setArguments(el);
	    checkConstruction(result);
	    return result;
	}
}

MethodDeclaration MethodDeclaration() :
{
    ASTList<DeclarationSpecifier> ml = new ASTArrayList<DeclarationSpecifier>();
  DeclarationSpecifier m = null;
    TypeReference tr;
    ASTList<UncollatedReferenceQualifier> nl = null;
    Throws th = null;
    StatementBlock body = null;
    MethodDeclaration result;
  ASTList<TypeParameterDeclaration> typeParams = null;
  SourceElement dummy = null;
}
{
    (
     (
      ( "public"       { m = factory.createPublic(); }        )
      | ( "protected"    { m = factory.createProtected(); }     )
      | ( "private"      { m = factory.createPrivate(); }       )
      | ( "static"       { m = factory.createStatic(); }        )
      | ( "final"        { m = factory.createFinal(); }         )
      | ( "abstract"     { m = factory.createAbstract(); }      )
      | ( "native"       { m = factory.createNative(); }        )
      | ( "synchronized" { m = factory.createSynchronized(); }  )
      | ( "strictfp"     { m = factory.createStrictFp(); }      )
    | ( m = AnnotationUse()									  )
      )
    {
	setPrefixInfo(m);
	ml.add(m);
    }
     )*

  [	 	
  	"<"
  	{
	    if (ml.size() == 0) { // '<' of MethodDeclaration is first element then. Need to store the result somewhere...
	    	dummy = factory.createPublic();
	    	setPrefixInfo(dummy); /* HACK */
	    }
    }
  	typeParams = TypeParametersNoLE()
  ]
	tr = ResultType()
	result = MethodDeclarator(tr)
  {
	  if (dummy != null) {
	  	copyPrefixInfo(dummy, result);
	  	dummy = null;
	  }
  }
	[ "throws" {
	    th = factory.createThrows();
	    setPrefixInfo(th);      
	}
    nl = TypedNameList() ]
	( body = Block() | ";" )
    {
	if (nl != null) {
	    ASTList<TypeReference> trl = new ASTArrayList<TypeReference>();
	    for (int i = 0, s = nl.size(); i < s; i++) {
		trl.add(nl.get(i).toTypeReference());
	    }
	    th.setExceptions(trl);
	    //  Throws th = factory.createThrows(trl);
	    result.setThrown(th);
	}
      result.setTypeParameters(typeParams);
      result.setDeclarationSpecifiers(ml);
	result.setBody(body);
	checkConstruction(result);
	return result;
    }
}


// This production is to determine lookahead only.
void MethodDeclarationLookahead() :
{}
{
  ( "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" | "strictfp" | AnnotationUse() )*
  [TypeParameters()] ResultType() <IDENTIFIER> "("
}

MethodDeclaration MethodDeclarator(TypeReference tr) :
{
    Identifier                      id;
    ASTList<ParameterDeclaration> pdl;
    MethodDeclaration               result;
}
{
    <IDENTIFIER>
	{ id = factory.createIdentifier(token.image); setPrefixInfo(id); }
    pdl = FormalParameters()
  
  ( "[" "]" // array dims are indeed allowed after parameter list (!)
	    { if (tr != null) { tr.setDimensions(tr.getDimensions()+1); } }
	  )*

    {
	result = factory.createMethodDeclaration();
	result.setIdentifier(id);
	result.setTypeReference(tr);
	result.setParameters(pdl);
	checkConstruction(result);
	setPrefixInfo(result); 
	return result;
    }
}

ASTList<ParameterDeclaration> FormalParameters() :
{
    ParameterDeclaration pd;
    ASTList<ParameterDeclaration> result = new ASTArrayList<ParameterDeclaration>();
}
{
    "("
	[       pd = FormalParameter() { result.add(pd); }
        ( "," pd = FormalParameter() { 
        	// check if more params are admissible (no more after a vararg) occurs in FormalParameter()
        	result.add(pd); 
        } )* 
      ]
	")"
	{
	    checkConstruction(result);
	    return result;
	}
}

ParameterDeclaration FormalParameter() :
{
    ParameterDeclaration result;
    TypeReference tr;
    DeclarationSpecifier mod = null;
	Identifier id;
	VariableSpecification vspec;
	int dim;
	ASTList<DeclarationSpecifier> ml = null;
	boolean isVarArg = false;
}
{
  (
  	mod = AnnotationUse()
  	{
       if (ml == null) {
         ml = new ASTArrayList<DeclarationSpecifier>();
       }
       setPrefixInfo(mod);
       
       ml.add(mod);
  	}
  
  )*
  [  "final"  
  	{  
      mod = factory.createFinal(); 
      setPrefixInfo(mod); 
       
      if (ml == null) {
         ml = new ASTArrayList<DeclarationSpecifier>();
      }
      ml.add(mod);
    } 
    (mod = AnnotationUse()
       {
       setPrefixInfo(mod);
       
       ml.add(mod);
       }
    )*
	  
  ]
  
   (
     tr = Type()  [ "..." {isVarArg = true;} ]
     ( id = VariableDeclaratorId() { dim = tmpDimension; } |
       id = VariableSV() { dim = tmpDimension; } ) 
   |
     tr = TypeSV()
       id = VariableSV() { dim = tmpDimension; }
   )   
	{
        result = factory.createParameterDeclaration(tr, id);
        if (ml != null) {
           result.setDeclarationSpecifiers(ml);
        }
        vspec = result.getVariables().get(0); 
        vspec.setDimensions(dim);
        checkConstruction(result);
        setPrefixInfo(result); 
        result.setVarArg(isVarArg);
        return result;
   }
}

ConstructorDeclaration ConstructorDeclaration() :
{
    ConstructorDeclaration          result;
    DeclarationSpecifier            m = null;
    ASTList<DeclarationSpecifier> ml = new ASTArrayList<DeclarationSpecifier>();
    Identifier                      id;
    ASTList<ParameterDeclaration> pdl;
    ASTList<UncollatedReferenceQualifier> nl = null;
    SpecialConstructorReference     scr = null;
    StatementBlock                  body;
    ASTList<Statement>            stats = new ASTArrayList<Statement>();
    Statement                       stat;
}
{
    {
	result = factory.createConstructorDeclaration();
	setPrefixInfo(result); 
    }
  (m = AnnotationUse() { setPrefixInfo(m);  })*
    [
     (
      ( "public"       { m = factory.createPublic(); }    )
      | ( "protected"    { m = factory.createProtected(); } )
      | ( "private"      { m = factory.createPrivate(); }   )
      )
    {
	setPrefixInfo(m); 
      ml.add(m);
    }
  (m = AnnotationUse() { setPrefixInfo(m);  })*
    ]
  [ TypeParameters() ]
	<IDENTIFIER> { 
	    id = factory.createIdentifier(token.image);
	    setPrefixInfo(id); 
	}
    pdl = FormalParameters()

  [ "throws" nl = TypedNameList() ]
	"{"
    {
	body = factory.createStatementBlock();
	setPrefixInfo(body); 
	body.setBody(stats);
    }
  { setAllowSuper(false); }
    [ LOOKAHEAD(ExplicitConstructorInvocation())
    scr = ExplicitConstructorInvocation()
	{ stats.add(scr); }
    ]
  { setAllowSuper(true); }
	( stat = BlockStatement()
	    { stats.add(stat); }
	  )*
	"}"
	{
	    result.setIdentifier(id);
	    result.setParameters(pdl);
      if (!ml.isEmpty())
          result.setDeclarationSpecifiers(ml);
      if (nl != null) {
          int s = nl.size();
		ASTList<TypeReference> trl = new ASTArrayList<TypeReference>(s);
		for (int i = 0; i < s; i++) {
              trl.add(nl.get(i).toTypeReference());
		}
		Throws th = factory.createThrows(trl);
		setPrefixInfo(th);
		result.setThrown(th);
	    }
	    result.setBody(body);
	    checkConstruction(result);
	    return result;
	}
}

SpecialConstructorReference ExplicitConstructorInvocation() :
{
    SpecialConstructorReference result;
    ASTList<Expression> args;
    Expression expr = null;
}
{
    (
     LOOKAHEAD("this" Arguments() ";")
     "this" 
    {
	result = factory.createThisConstructorReference(); setPrefixInfo(result);
    } 
     args = Arguments() ";"
	{ result.setArguments(args); }
     |
     [ LOOKAHEAD(2) expr = PrimaryExpression() "." ]
     "super" 
	{
	    result = factory.createSuperConstructorReference(); setPrefixInfo(result);
	} 
     args = Arguments() ";"
	{ 
	    result.setArguments(args);
	    ((SuperConstructorReference)result).setReferencePrefix((ReferencePrefix)expr);
	}
     )
	{
	    checkConstruction(result);
	    return result;
	}
}

ClassInitializer Initializer() :
{
    ClassInitializer result;
    ASTList<DeclarationSpecifier> ml = null;
    StatementBlock block;
}
{
    [ "static"
    {
	ml = new ASTArrayList<DeclarationSpecifier>();
	Static s = factory.createStatic();
	setPrefixInfo(s); 
	ml.add(s);
    }
    ]
	block = Block()
    {
	result = factory.createClassInitializer(block);
	setPrefixInfo(result);
	if (ml != null) {
      result.setDeclarationSpecifiers(ml);
	}
	checkConstruction(result);
	return result;
    }
}


/*
 * Type, name and expression syntax follows.
 */

TypeReference Type() :
{
    TypeReference result;
    UncollatedReferenceQualifier qn;
    int dimension = 0;
}
{
	(
	LOOKAHEAD(TypedName()) // try to match typed name FIRST
 	  qn = TypedName() 
 	  {
      	result = qn.toTypeReference();
      }
      ( "[" "]" { if (dimension == 0) setPrefixInfo(result); dimension++; } )*
      {
      	result.setDimensions(dimension);
      	
 	  }
 	|
 	  result = RawType() // raw types are also types
  	)
  {
      return result;
  }
}

TypeReference RawType() :
{
  TypeReference result;
  UncollatedReferenceQualifier qn;
  int dimension = 0;
}
{
  ( result = PrimitiveType() // the 1st difference to Type()
  | (qn = Name()  // the 2nd difference to Type()
    {
        result = qn.toTypeReference();
    }
    )

  )
  ( "[" "]" { if (dimension == 0) setPrefixInfo(result); dimension++; } )*
  {
      result.setDimensions(dimension);
      
      return result;
  }
}

TypeSVWrapper TypeSV() :
{
    TypeSVWrapper result;
}
{
    <SVIDENTIFIER>
	{
	    TypeSVWrapper tsvw=factory.getTypeSV(token.image);
	    //      tsvw.setStartPosition(new recoder.java.SourceElement.Position(0,0));
	    return tsvw;
	}
}


ExecutionContext ExecutionContext() :
{
    ExecutionContext ctxt = null;
    TypeSVWrapper tr = null;
    ExpressionSVWrapper instance = null;
}
{
    tr = TypeSV() "(" (instance = ExpressionSV())? ")" 
    {
	return new ExecutionContext(tr, instance);
    } 
} 



ExecCtxtSVWrapper ExecutionContextSV() : {}
{
    <SVIDENTIFIER>
	{
	    return factory.getExecutionContextSV(token.image);	   
	}
}

JumpLabelSVWrapper JumpLabelSV() : {}
{
    <SVIDENTIFIER>
	{
	    return factory.getJumpLabelSV(token.image);	   
	}
}

RKeYMetaConstructType TypeMC() :
{
    RKeYMetaConstructType result;
    Expression e;
}
{
    <TYPEOF> "(" e = Expression() ")"
     { result = factory.createRKeYMetaConstructType();
       ((RKeYMetaConstructType)result).setChild(e);
       ((RKeYMetaConstructType)result).setName("#typeof");
       return result;
     }
}

RKeYMetaConstructExpression IsStaticMC() :
{
    RKeYMetaConstructExpression result;
    Expression e;
}
{
    <ISSTATIC> "(" e = Expression() ")"
     { result = factory.createRKeYMetaConstructExpression();
       ((RKeYMetaConstructExpression)result).setChild(e);
       ((RKeYMetaConstructExpression)result).setName("#isstatic");
       return result;
     } 
}



ProgramVariableSVWrapper VariableSV() :
{
    ProgramVariableSVWrapper result;
}
{
    <SVIDENTIFIER>
	{
	    return factory.getProgramVariableSV(token.image);
	}
}


TypeReference PrimitiveType() :
{
    TypeReference result;
}
{
    (
     "boolean"
     | "char"
     | "byte"
     | "short"
     | "int"
     | "long"
     | "float"
     | "double"
     )
	{
	    Identifier id = factory.createIdentifier(token.image);
	    setPrefixInfo(id);
	    result = factory.createTypeReference(id);
	    checkConstruction(result);
	    //    setPrefixInfo(result);
	    return result;
	}
}

TypeReference ResultType() :
{
    TypeReference result;
}
{
    (
     ( "void" { 
	 Identifier id = factory.createIdentifier(token.image);
	 setPrefixInfo(id);
	 result = factory.createTypeReference(id);
	 setPrefixInfo(result);
     } )
     | result = Type()
     )
	{
	    checkConstruction(result);
	    return result;
	}
}

UncollatedReferenceQualifier Name() :
    /*
     * A lookahead of 2 is required below since "Name" can be followed
     * by a ".*" when used in the context of an "ImportDeclaration".
 */
{
    UncollatedReferenceQualifier result;
    Identifier id;
}
{
    <IDENTIFIER>
	{
	    id = factory.createIdentifier(token.image);    
	    setPrefixInfo(id);
	    result = factory.createUncollatedReferenceQualifier(id);
	}
    ( LOOKAHEAD(2) "." { setPrefixInfo(result); } <IDENTIFIER>
    {
	id = factory.createIdentifier(token.image);
	setPrefixInfo(id);
	result = factory.createUncollatedReferenceQualifier(result, id);
    }
      )*
	{
	    checkConstruction(result);
	    return result;
	}
}

UncollatedReferenceQualifier TypedName() :
/* this is for generics.
 */
{
  UncollatedReferenceQualifier result;
  Identifier id;
  ASTList<TypeArgumentDeclaration> typeArguments = null;
}
{
  <IDENTIFIER>
  {
    id = factory.createIdentifier(token.image);    
    setPrefixInfo(id);
    
  }
  [LOOKAHEAD(2) typeArguments = TypeArguments()]
  {
    result = factory.createUncollatedReferenceQualifier(id);
    result.setTypeArguments(typeArguments);
  }
  (
    LOOKAHEAD(2) "." { setPrefixInfo(result);  } <IDENTIFIER>
    {
      id = factory.createIdentifier(token.image);
      setPrefixInfo(id);
      
      typeArguments = null; // reset!
    }
    [LOOKAHEAD(2) typeArguments = TypeArguments()]
    {
      result = factory.createUncollatedReferenceQualifier(result, id);
      result.setTypeArguments(typeArguments);
    }
  )*
  {
    
    return result;
  }
}
	
ASTList<TypeArgumentDeclaration> TypeArguments() :
{
	ASTList<TypeArgumentDeclaration> args = new ASTArrayList<TypeArgumentDeclaration>();
	TypeArgumentDeclaration ta;
}
{
	"<" ta = TypeArgument() { args.add(ta); } ("," ta = TypeArgument() { args.add(ta); })* ">"
	{ return args; }
}

TypeArgumentDeclaration TypeArgument() :
{
	WildcardMode wm = WildcardMode.None;
	TypeReference t = null;
	TypeArgumentDeclaration result = new TypeArgumentDeclaration();
}
{
  (
	t = Type() 
   { setPrefixInfo(result); }
  |
	"?" { wm = WildcardMode.Any; setPrefixInfo(result); } 
		[  ("extends" { wm = WildcardMode.Extends; } 
		    | "super"  { wm = WildcardMode.Super; }
		   ) 
		 t = Type()
		]
  )
  { 
  	
  	result.setWildcardMode(wm);
  	result.setTypeReference(t);
  	return result;
  }
}

/*
ASTList<UncollatedReferenceQualifier> NameList() :
{
  ASTList<UncollatedReferenceQualifier> result = 
      new ASTArrayList<UncollatedReferenceQualifier>();
    UncollatedReferenceQualifier qn;
}
{
    qn = Name()
    {
	result.add(qn);
    }
    ( "," qn = Name()
	{
	    result.add(qn);
	}
      )*
	{
	    checkConstruction(result);
	    return result;
	}
}
*/

ASTList<UncollatedReferenceQualifier> TypedNameList() :
{
  ASTList<UncollatedReferenceQualifier> result = 
      new ASTArrayList<UncollatedReferenceQualifier>();
  UncollatedReferenceQualifier qn;
}
{
  qn = TypedName()
  {
    result.add(qn);
  }
  ( "," qn = TypedName()
    {
      result.add(qn);
    }
  )*
  {
    return result;
  }
}


/*
 * Expression syntax follows.
 */
Expression Expression() :
    /*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{
    Expression result;
    Expression expr;
    Assignment op;
    ASTList<Expression> leftRight = new ASTArrayList<Expression>(2);
}
{
    (result = ConditionalExpression()
     [
      op   = AssignmentOperator()
      expr = Expression()
	 {
	     leftRight.add(result);
	     leftRight.add(expr);
	     op.setArguments(leftRight);
	     testLeftHandSide(result);
	     result = op;
	 }
     ]
	{
	    checkConstruction(result);
	    return result;
	})

	}

ExpressionSVWrapper ExpressionSV() :
{
    ExpressionSVWrapper result;
}
{
    <SVIDENTIFIER>
	{
	    return factory.getExpressionSV(token.image);
	}
}


CatchSVWrapper CatchSV() :
{
}
{
    <SVIDENTIFIER>
	{
	    return factory.getCatchSV(token.image);
	}
}




Assignment AssignmentOperator() :
{
    Assignment result;
}
{
    (   "="    { result = factory.createCopyAssignment(); }
	| "*="   { result = factory.createTimesAssignment(); }
	| "/="   { result = factory.createDivideAssignment(); }
	| "%="   { result = factory.createModuloAssignment(); }
	| "+="   { result = factory.createPlusAssignment(); }
	| "-="   { result = factory.createMinusAssignment(); }
	| "<<="  { result = factory.createShiftLeftAssignment(); }
	| ">>="  { result = factory.createShiftRightAssignment(); }
	| ">>>=" { result = factory.createUnsignedShiftRightAssignment(); }
	| "&="   { result = factory.createBinaryAndAssignment(); }
	| "^="   { result = factory.createBinaryXOrAssignment(); }
	| "|="   { result = factory.createBinaryOrAssignment(); }
	)
	{
	    checkConstruction(result);
	    setPrefixInfo(result);
	    return result;
	}
}

Expression ConditionalExpression() :
{
    Expression result;
    Expression expr1;
    Expression expr2;
    Operator op;
}
{
    result = ConditionalOrExpression()
	[ "?" { op = factory.createConditional(); setPrefixInfo(op); }
	expr1 = Expression()
	":" expr2 = ConditionalExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(3);
		args.add(result);
		args.add(expr1);
		args.add(expr2);
		op.setArguments(args);
		result = op;
	    }
	]
    {
	checkConstruction(result);
	return result;
    }
}

Expression ConditionalOrExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{
    result = ConditionalAndExpression()
	( "||" { op = factory.createLogicalOr(); setPrefixInfo(op); }
	  expr = ConditionalAndExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		op.setArguments(args);
		result = op;
	    }
	  )*
    {
	checkConstruction(result);
	return result;
    }
}

Expression ConditionalAndExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{
    result = InclusiveOrExpression()
	( "&&" { op = factory.createLogicalAnd(); setPrefixInfo(op); }
	  expr = InclusiveOrExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		op.setArguments(args);
		result = op;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }
}

Expression InclusiveOrExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{
    result = ExclusiveOrExpression()
	( "|" { op = factory.createBinaryOr(); setPrefixInfo(op); }
	  expr = ExclusiveOrExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		op.setArguments(args);
		result = op;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }
}

Expression ExclusiveOrExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{
    result = AndExpression()
	( "^" { op = factory.createBinaryXOr(); setPrefixInfo(op); }
	  expr = AndExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		op.setArguments(args);
		result = op;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }
}

Expression AndExpression() :
{
    Expression result;
    Expression expr;
    Operator op;
}
{ 
    result = EqualityExpression()
	( "&" { op = factory.createBinaryAnd(); setPrefixInfo(op); }
	  expr = EqualityExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		op.setArguments(args);
		result = op;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }
}

Expression EqualityExpression() :
{
    Expression result;
    Expression expr;
    Operator cmp;
}
{ 
    result = InstanceOfExpression()
	( (   "==" { cmp = factory.createEquals(); setPrefixInfo(cmp); }
	      | "!=" { cmp = factory.createNotEquals(); setPrefixInfo(cmp); }
	      )
	  expr = InstanceOfExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		cmp.setArguments(args);
		result = cmp;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }
}

Expression InstanceOfExpression() :
{
    Expression result;
    TypeReference tr;
}
{
    result = RelationalExpression()
	[ "instanceof" (tr = TypeSV() | tr = Type() | tr=TypeMC() ) 
	    {
		result = factory.createInstanceof(result, tr);
		setPrefixInfo(result);
	    }
	]
    { 
	checkConstruction(result);
	return result;
    }
}

Expression RelationalExpression() :
{
    Expression result;
    Operator cmp;
    Expression expr;
}
{
    result = ShiftExpression()
	( (   "<"  { cmp = factory.createLessThan(); setPrefixInfo(cmp); }
	      | ">"  { cmp = factory.createGreaterThan(); setPrefixInfo(cmp); }
	      | "<=" { cmp = factory.createLessOrEquals(); setPrefixInfo(cmp); }
	      | ">=" { cmp = factory.createGreaterOrEquals(); setPrefixInfo(cmp); }
	      )
	  expr = ShiftExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		cmp.setArguments(args);
		result = cmp;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }

}

Expression ShiftExpression() :
{
    Expression result;
    Operator shift;
    Expression expr;
}
{
    result = AdditiveExpression()
	( (   "<<"  { shift = factory.createShiftLeft(); setPrefixInfo(shift); }
//      | ">>"  { shift = factory.createShiftRight(); setPrefixInfo(shift); }
      | RSIGNEDSHIFT()  { shift = factory.createShiftRight(); setPrefixInfo(shift); }
//      | ">>>" { shift = factory.createUnsignedShiftRight(); setPrefixInfo(shift); }
      | RUNSIGNEDSHIFT() { shift = factory.createUnsignedShiftRight(); setPrefixInfo(shift); }
	      )
	  expr = AdditiveExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		shift.setArguments(args);
		result = shift;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }

}

Expression AdditiveExpression() :
{
    Expression result;
    Operator add;
    Expression expr;
}
{
    result = MultiplicativeExpression()
	( ( "+" { add = factory.createPlus(); setPrefixInfo(add); }
	    | "-" { add = factory.createMinus(); setPrefixInfo(add); }
	    )
	  expr = MultiplicativeExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		add.setArguments(args);
		result = add;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }
}

Expression MultiplicativeExpression() :
{
    Expression result = null;
    Operator mult = null;
    Expression expr;
}
{
    result = UnaryExpression()
	( (   "*" { mult = factory.createTimes();  setPrefixInfo(mult); }
	      | "/" { mult = factory.createDivide(); setPrefixInfo(mult); }
	      | "%" { mult = factory.createModulo(); setPrefixInfo(mult); }
	      )
	  expr = UnaryExpression()
	    {
		ASTList<Expression> args = new ASTArrayList<Expression>(2);
		args.add(result);
		args.add(expr);
		mult.setArguments(args);
		result = mult;
	    }
	  )*
    { 
	checkConstruction(result);
	return result;
    }

}

Expression UnaryExpression() :
{
    Expression result;
    Expression expr;
    boolean negative = false;
}
{
    (
     ( "+" { result = factory.createPositive(); setPrefixInfo(result); } 
       | "-" { result = factory.createNegative(); setPrefixInfo(result); } )
     expr = UnaryExpression()
	{
	    ((Operator)result).setArguments(new ASTArrayList<Expression>(expr));
	}
     |
     result = PreIncrementExpression()
     |
     result = PreDecrementExpression()
     |
     result = UnaryExpressionNotPlusMinus()
     | 
     ("#create-object" "(" expr = ExpressionSV()  ")" 
	 {
	     result = factory.createRKeYMetaConstructExpression();
	     ((RKeYMetaConstructExpression)result).setChild(expr);
	     ((RKeYMetaConstructExpression)result).setName("#create-object");
	 }
      )
     | 
     ( "#length-reference" "(" expr = ExpressionSV()  ")" 
	 {
	     result = factory.createRKeYMetaConstructExpression();
	     ((RKeYMetaConstructExpression)result).setChild(expr);
	     ((RKeYMetaConstructExpression)result).setName("#length-reference");
	 }
       )
     )
	{ 
	    checkConstruction(result);
	    return result;
	}

}

PreIncrement PreIncrementExpression() :
{
    PreIncrement result;
    Expression expr;
}
{
    "++"
	{
	    result = factory.createPreIncrement();
	    setPrefixInfo(result);
	} 
    expr = PrimaryExpression()
    {
	result.setArguments(new ASTArrayList<Expression>(expr));
	checkConstruction(result);
	return result;
    }
}

PreDecrement PreDecrementExpression() :
{
    PreDecrement result;
    Expression expr;
}
{
    "--" 
	{
	    result = factory.createPreDecrement();
	    setPrefixInfo(result);
	}
    expr = PrimaryExpression()
    { 
	result.setArguments(new ASTArrayList<Expression>(expr));
	checkConstruction(result);
	return result;
    }
}

Expression UnaryExpressionNotPlusMinus() :
{
    Expression result;
    Expression expr;
    boolean    not = false;
}
{
    (
     (   "~" { result = factory.createBinaryNot();  setPrefixInfo(result); }
	 | "!" { result = factory.createLogicalNot(); setPrefixInfo(result); }
	 )
     expr = UnaryExpression()
	{
	    ((Operator)result).setArguments(new ASTArrayList<Expression>(expr));
	}
  
     |
     LOOKAHEAD( CastLookahead() )
     result = CastExpression()
     |
     result = PostfixExpression()
     )
	{ 
	    checkConstruction(result);
	    return result;
	}

}

// This production is to determine lookahead only. The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead() :
{}
{ LOOKAHEAD("("<TYPEOF> "(" <SVIDENTIFIER> ) ("(" <TYPEOF> "(" <SVIDENTIFIER>)
      | LOOKAHEAD("(" PrimitiveType() ("[" "]")* ")")
      "(" PrimitiveType() ("[" "]")* ")"
      //  LOOKAHEAD(2)
      //  "(" PrimitiveType()
      |
      LOOKAHEAD("(" <SVIDENTIFIER>) "(" <SVIDENTIFIER> ")" Expression()
      |
      LOOKAHEAD("(" <SVIDENTIFIER> "[" "]" ")") "(" <SVIDENTIFIER> "[" "]" ")" Expression()
      |
      LOOKAHEAD("(" TypedName() "[")
      "(" TypedName() "[" "]"
      |
  "(" TypedName() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )
      }

Expression PostfixExpression() :
{
    Expression result;
}
{
    result = PrimaryExpression()
	[   "++" 
	    { 
		result = factory.createPostIncrement(result); 
		setPrefixInfo(result);
	    }
	| "--" 
	    { 
		result = factory.createPostDecrement(result); 
		setPrefixInfo(result);
	    }
	]
    { 
	checkConstruction(result);
	return result;
    }

}

TypeCast CastExpression() :
{
    TypeCast result = null;
    TypeReference tr;
    Expression expr = null;
}
{
    {
	result = factory.createTypeCast();
    }
    ( LOOKAHEAD ("(" <TYPEOF> "(" <SVIDENTIFIER> ")")
      "(" { setPrefixInfo(result); } tr = TypeMC() ")"
      // !!!we do NOT distinguish UnaryExpression and UnaryExpressionNotPlusMinus!!!
      ( expr=UnaryExpression())
      | LOOKAHEAD ("(" <TYPEOF> "(" <SVIDENTIFIER> "["  <SVIDENTIFIER> "]" ")")
      "(" { setPrefixInfo(result); } tr = TypeMC() ")"
      // !!!we do NOT distinguish UnaryExpression and UnaryExpressionNotPlusMinus!!!
      ( expr=UnaryExpression())
      |  LOOKAHEAD("(" PrimitiveType() )
      "(" { setPrefixInfo(result); } (tr = Type()) ")"
      expr = UnaryExpression()
      | LOOKAHEAD("(" <SVIDENTIFIER> ")" UnaryExpression())
      "(" { setPrefixInfo(result); } tr = TypeSV() ")"
      expr = UnaryExpression()
      | LOOKAHEAD("(" <SVIDENTIFIER> "[" "]" ")" Expression())
      "(" { setPrefixInfo(result); } tr = TypeSV() "[" "]" ")"
      expr = UnaryExpression()
      | "(" { setPrefixInfo(result); } tr = Type() ")"
      expr = UnaryExpressionNotPlusMinus() 
      )
	{
	    result.setTypeReference(tr);
	    result.setArguments(new ASTArrayList<Expression>(expr));
	    checkConstruction(result);
	    return result;
	}
}


Expression PrimaryExpression() :
{
    Expression result = null;
    ReferencePrefix tmpResult = null;
}
{   prefix = PrimaryPrefix()
    {	
	// create initial AST construct from prefix only
	switch (prefix.type) {
	    case PrimaryPrefixReturnValue.LITERAL:
	    if (prefix.literal instanceof StringLiteral) {
		tmpResult = (StringLiteral)prefix.literal;
	    }
	    else 
	    if (prefix.literal instanceof ExpressionSVWrapper) {
		tmpResult = (ExpressionSVWrapper)prefix.literal;
	    }
	    else 
	    {
		result = prefix.literal;
		checkConstruction(result);
		return result;
		//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	    }
	    break;
	    case PrimaryPrefixReturnValue.THIS:
	    tmpResult = factory.createThisReference();
	    setPrefixInfo(tmpResult);
	    break;
	    case PrimaryPrefixReturnValue.SUPER_MEMBERVARIABLE:
            tmpResult = prefix.name;
	    break;
	    case PrimaryPrefixReturnValue.PARENTHESIZED_EXPR:
	    tmpResult = (ParenthesizedExpression)prefix.expr;
	    break;
	    case PrimaryPrefixReturnValue.PASSIVE_EXPR:
	    tmpResult = (PassiveExpression)prefix.expr;
	    break;
	    case PrimaryPrefixReturnValue.ALLOCATION_EXPR:
	    tmpResult = (ReferencePrefix)prefix.expr;
	    break;
	    case PrimaryPrefixReturnValue.CLASS_REF:
	    tmpResult = factory.createMetaClassReference(prefix.typeref);
	    setPrefixInfo(tmpResult);
	    break;
	    case PrimaryPrefixReturnValue.QUALIFIED_NAME:
	    tmpResult = prefix.name;
	    break;
	    default:
	    throw new ParseException("Unknown prefix");
	}
    }
( LOOKAHEAD(2) suffix = PrimarySuffix()
    {   Sort s = null; 
	switch (suffix.type) {
	    case PrimarySuffixReturnValue.THIS:
	    // the prefix MUST be a type expression!!!!!
	    // we currently only create UncollatedReferenceQualifiers
	    if (tmpResult instanceof TypeReference) {
		tmpResult = 
		factory.createThisReference((TypeReference)tmpResult);
		setPrefixInfo(tmpResult);
	    } else if (tmpResult instanceof UncollatedReferenceQualifier) {
		tmpResult =
		factory.createThisReference(((UncollatedReferenceQualifier)tmpResult).toTypeReference());
		setPrefixInfo(tmpResult);
	    } else {
		throw new ParseException("No type as prefix of `this'");
	    }
	    break;
      case PrimarySuffixReturnValue.SUPER:
          // the prefix MUST be a type expression!!!!!
          // we currently only create UncollatedReferenceQualifiers
          if (tmpResult instanceof TypeReference) {
              tmpResult = 
                 factory.createSuperReference((TypeReference)tmpResult);
              setPrefixInfo(tmpResult);
              
          } else if (tmpResult instanceof UncollatedReferenceQualifier) {
              tmpResult =
                 factory.createSuperReference(((UncollatedReferenceQualifier)tmpResult).toTypeReference());
              setPrefixInfo(tmpResult);
              
          } else if (tmpResult instanceof ThisReference) {
          	  tmpResult = 
                 factory.createSuperReference((ThisReference)tmpResult);
              setPrefixInfo(tmpResult);
              
          } else {
              throw new ParseException("No type as prefix of `super', was "  + tmpResult.getClass());
          }
          break;      
	    case PrimarySuffixReturnValue.ALLOCATION_EXPR:
	    if (suffix.expr instanceof New) {
		((New)suffix.expr).setReferencePrefix(tmpResult);
		tmpResult = (New)suffix.expr;
	    } else {
		throw new ParseException("Allocation without new?");
	    }
	    break;
	    case PrimarySuffixReturnValue.INDEX_EXPR:
	    if (tmpResult instanceof SVWrapper) {
		s = ((SortedSchemaVariable)((SVWrapper)tmpResult).getSV()).sort();
	    }
	    if (tmpResult instanceof UncollatedReferenceQualifier ||
		tmpResult instanceof MethodReference ||
		tmpResult instanceof ParenthesizedExpression ||
		tmpResult instanceof VariableReference ||	      
		tmpResult instanceof ThisReference ||
		(tmpResult instanceof SVWrapper &&
		 ( s == ProgramSVSort.EXPRESSION || isLeftHandSide(s)))) {
		      // Now we know that this is an array reference
		      ASTList<Expression> indicees = new ASTArrayList<Expression>(1);
		      indicees.add(suffix.expr);
		      tmpResult = 
		      factory.createArrayReference(tmpResult, indicees);
		      setPrefixInfo(tmpResult);		   	  
		  } else if (tmpResult instanceof ArrayReference) {
		      // we need to add another access dimension
		      ((ArrayReference)tmpResult).getDimensionExpressions().add(suffix.expr);
		  } else {
		      throw new ParseException("Bad index context - " +
					       tmpResult.getClass().getName() + "?!");
		      /*
			e.g. StringLiteral, TypeReference, NewArray
			(would have to be in parentheses), SuperReference, ...
		      */
		  }
	    break;
	    case PrimarySuffixReturnValue.IDENTIFIER:
	    if (tmpResult instanceof SVWrapper) {
		s = ((SortedSchemaVariable)((SVWrapper)tmpResult).getSV()).sort();
	    }
	    if ("length".equals(suffix.id.getText()) && isLeftHandSide(s)) {
		    result = new ArrayLengthReference(tmpResult);
		    checkConstruction(result);
		    setPrefixInfo(result);
		    return result;
		} else {
		    tmpResult = factory.createUncollatedReferenceQualifier(tmpResult, suffix.id);
          ((UncollatedReferenceQualifier)tmpResult).setTypeArguments(suffix.typeArgs);
          suffix.typeArgs = null;
		    setPrefixInfo(tmpResult);
		}
	    break;
	    case PrimarySuffixReturnValue.ARGUMENTS:
	    // method call -determine the kind of method
	    if (tmpResult instanceof UncollatedReferenceQualifier) {
		// this is a normal method call
		tmpResult = factory.createMethodReference
		    (((UncollatedReferenceQualifier)tmpResult).getReferencePrefix(),
		     ((UncollatedReferenceQualifier)tmpResult).getIdentifier(),
               suffix.args, ((UncollatedReferenceQualifier)tmpResult).getTypeArguments());
              
		setPrefixInfo(tmpResult);
	    } else if (tmpResult instanceof MethodReference &&
		       ((MethodReference)tmpResult).getIdentifier()
		       instanceof ProgramVariableSVWrapper) {
			   // this is a method call with svidentifier
			   tmpResult = factory.createMethodReference
			   (((MethodReference)tmpResult).getReferencePrefix(),
			    ((MethodReference)tmpResult).getIdentifier(), suffix.args);
		       } else if (ProgramSVSort.METHODNAME.
		       		getClass().isInstance(((SortedSchemaVariable)
				   ((SVWrapper)tmpResult).getSV()).sort())) {
				       // this is a method call with svidentifier
				       tmpResult = factory.createMethodReference
				       (null, new LabelSVWrapper(((SVWrapper)tmpResult).getSV()), suffix.args);
				   } else {
				       throw new ParseException("Arguments without method name?");
				   }
	    break;
	    case PrimarySuffixReturnValue.SVIDENTIFIER:
	    ProgramVariableSVWrapper pv = (ProgramVariableSVWrapper) suffix.id;
	    s = ((SortedSchemaVariable)pv.getSV()).sort();
	    if (ProgramSVSort.METHODNAME.getClass().isInstance(s)) {
		tmpResult = new MethodReference(tmpResult,pv);
	    } else if (s != ProgramSVSort.NONSIMPLEEXPRESSION &&
		       (isLeftHandSide(s) || s == ProgramSVSort.ARRAYLENGTH)) {
		result = new FieldReference(tmpResult, pv);          
		checkConstruction(result);
		return result;
	    }
	    break;
	    default:
		throw new ParseException("Unknown primary suffix type");
	}
    }
  )*
    {     
	if (tmpResult instanceof UncollatedReferenceQualifier) {
	    result = (UncollatedReferenceQualifier)tmpResult;
	} else {
	    result = (Expression)tmpResult;
	}
	checkConstruction(result);
	return result;
    }
}


PrimaryPrefixReturnValue PrimaryPrefix() :
{
    // reuses global prefix field
    Literal                      lit;
    Expression                   expr;
    TypeReference                tr;
    UncollatedReferenceQualifier qn;
    SuperReference               supRef = null;
    ParenthesizedExpression      parExpr = null;
    Identifier                   id = null;
}
{
(
//  LOOKAHEAD(NonWildcardTypeArguments() "this" Arguments()) 
//  	NonWildcardTypeArguments() "this" /* Arguments() is a mandatory suffix here!*/
//      { 
//        prefix.type = prefix.THIS; 
//        System.err.println("Ignoring NonWildcardTypeArguments!");
//      }
//|
      "this"
    {
	prefix.type = PrimaryPrefixReturnValue.THIS;      
    }
      | 
      LOOKAHEAD(3) lit = Literal()
	{
	    prefix.type    = PrimaryPrefixReturnValue.LITERAL;
	    prefix.literal = lit;
	}

      |
  //[NonWildcardTypeArguments()]
      "super" {
	  supRef = factory.createSuperReference();
	  setPrefixInfo(supRef);
      }
      "."
       (
	(<IDENTIFIER> 
	{
	    id   = factory.createIdentifier(token.image);
	}
	|
	<SVIDENTIFIER>
	{
	    id = factory.getProgramVariableSV(token.image);
        }
	|
        id = ImplicitIdentifier()
	)
	{
	    setPrefixInfo(id);
	    prefix.name =
		factory.createUncollatedReferenceQualifier(supRef, id);
	    prefix.type = PrimaryPrefixReturnValue.SUPER_MEMBERVARIABLE;
	}
       )
      |
      "("
	{ parExpr = factory.createParenthesizedExpression();
	setPrefixInfo(parExpr);
	}
      expr = Expression()
      ")"
	{
	    parExpr.setArguments(new ASTArrayList<Expression>(expr));
	    prefix.expr = parExpr;
	    prefix.type = PrimaryPrefixReturnValue.PARENTHESIZED_EXPR;
	}
      |
      "@("
	{ parExpr = factory.createPassiveExpression();
	setPrefixInfo(parExpr);
	}
      expr = Expression()
      ")"
	{
	    parExpr.setArguments(new ASTArrayList<Expression>(expr));
	    prefix.expr = parExpr;
	    prefix.type = PrimaryPrefixReturnValue.PASSIVE_EXPR;
	}
      |
      expr = AllocationExpression()
	{
	    prefix.type = PrimaryPrefixReturnValue.ALLOCATION_EXPR;
	    prefix.expr = expr;
	}
      |
      LOOKAHEAD( ResultType() "." "class" )
      tr = ResultType() "." "class"
	{
	    prefix.type    = PrimaryPrefixReturnValue.CLASS_REF;
	    prefix.typeref = tr;
	}
      |
      qn = Name() 
	{
	    prefix.type = PrimaryPrefixReturnValue.QUALIFIED_NAME;
	    prefix.name = qn;
	}
      )
	{
	    return prefix;
	}
}

PrimarySuffixReturnValue PrimarySuffix() :
{
    // reuses global suffix field
    Expression               expr;
    ASTList<Expression>    args;
    Identifier               id;
    ASTList<TypeArgumentDeclaration> typeArgs;
    Literal                  lit;
}
{
    (
     LOOKAHEAD(2)
     "." "this"
    {
	suffix.type = PrimarySuffixReturnValue.THIS;
    }
     |
  LOOKAHEAD(2, {isSuperAllowed()})
  "." "super"
  {
  	  suffix.type = suffix.SUPER;
  }
|
     LOOKAHEAD(2)
     "." expr = AllocationExpression()
	{
	    suffix.type = PrimarySuffixReturnValue.ALLOCATION_EXPR;
	    suffix.expr = expr;
	}
     |
     LOOKAHEAD(2)
     "." <SVIDENTIFIER> 
	{
	    suffix.type = PrimarySuffixReturnValue.SVIDENTIFIER;
	    suffix.id = factory.getProgramVariableSV(token.image);
	    setPrefixInfo(suffix.id);
	}
     |
  LOOKAHEAD(3) // explicit Generic method invocation
  "." 
  	  suffix.typeArgs = NonWildcardTypeArguments() <IDENTIFIER>
  {
  	  suffix.type = suffix.IDENTIFIER;
  	  suffix.id = factory.createIdentifier(token.image);
  	  setPrefixInfo(suffix.id);
  	  
  }
|  "[" expr = Expression() "]"
	{
	    suffix.type = PrimarySuffixReturnValue.INDEX_EXPR;
	    suffix.expr = expr;
	}
     |
     "."( 
	  ( <IDENTIFIER>
 	    {
		suffix.id   = factory.createIdentifier(token.image);
	    }
      |
        suffix.id = ImplicitIdentifier()
     )
	 {
	     suffix.type = PrimarySuffixReturnValue.IDENTIFIER;
	     setPrefixInfo(suffix.id);
	 }
	)
     |
     args = Arguments()
	{
	    suffix.type = PrimarySuffixReturnValue.ARGUMENTS;
	    suffix.args = args;
	}
     )
	{
	    return suffix;
	}
}

Literal Literal() :
{
    Literal result;
    Expression e;
}
{
    (
     <INTEGER_LITERAL>
    {
	if (token.image.endsWith("L") || token.image.endsWith("l")) {
	    result = factory.createLongLiteral(token.image);
	} else {
	    result = factory.createIntLiteral(token.image);
	}
	setPrefixInfo(result);
    }
     | <FLOATING_POINT_LITERAL>
    {
	if (token.image.endsWith("F") || token.image.endsWith("f")) {
	    result = factory.createFloatLiteral(token.image);
	} else {
	    result = factory.createDoubleLiteral(token.image);
	}
	setPrefixInfo(result);
    }
     | <CHARACTER_LITERAL>
    {
	result = factory.createCharLiteral(token.image);
	setPrefixInfo(result);
    }
     | <STRING_LITERAL>
    {
	result = factory.createStringLiteral(token.image);
	setPrefixInfo(result);
    }
     | <SVIDENTIFIER>
    {
	result = factory.getExpressionSV(token.image);
    }
     | result = BooleanLiteral()
     | result = NullLiteral()
     | result = IsStaticMC()
     | 
     ("#static-evaluate"  "(" e = InstanceOfExpression() ")")
	{  result = factory.createRKeYMetaConstructExpression();
	   ((RKeYMetaConstructExpression)result).setChild((Operator)e);
	   ((RKeYMetaConstructExpression)result).setName("#static-evaluate");         
	}
     )
	{ 
	    checkConstruction(result);
	    return result;
	}

}

BooleanLiteral BooleanLiteral() :
{
    BooleanLiteral result;
}
{
    (
     "true" { result = factory.createBooleanLiteral(true); }
     |
     "false" { result = factory.createBooleanLiteral(false); }
     )
	{ 
	    setPrefixInfo(result);
	    checkConstruction(result);
	    return result;
	}
}

NullLiteral NullLiteral() :
{
    NullLiteral result;
}
{
    "null"
	{
	    result = factory.createNullLiteral();
	    setPrefixInfo(result);
	    return result;
	}
}

ASTList<Expression> Arguments() :
{
    ASTList<Expression> result = null;
}
{
    "(" [ result = ArgumentList() ] ")"
	{
	    if (result != null)
	    checkConstruction(result);
	    return result;
	}
}

ASTList<Expression> ArgumentList() :
{
    ASTList<Expression> result = new ASTArrayList<Expression>();
    Expression expr;
}
{
    expr = Expression() { result.add(expr); }
    ( "," expr = Expression() { result.add(expr); } )*
	{
	    checkConstruction(result);
	    return result;
	}
}

TypeOperator AllocationExpression() :
{
    UncollatedReferenceQualifier qn = null;
    TypeOperator  result;
    TypeReference tr = null;
    ASTList<Expression> args;
    ASTList<MemberDeclaration> body = null;
    ClassDeclaration cd = null;
    NewArray na;
    ASTList<TypeArgumentDeclaration> typeArgs;
}
{
    (
     LOOKAHEAD(2)
     ( "new"
     {
	 na = factory.createNewArray();
	 setPrefixInfo(na);
     }
       (tr = PrimitiveType()  | tr = TypeMC())
     {
	 na.setTypeReference(tr);
     }
       result = ArrayDimsAndInits(na)
       )
     | (
	"new" 
     {
	 result = factory.createNew();
	 setPrefixInfo(result);
     }
	(qn = TypedName() | tr = TypeSV())
  [typeArgs = NonWildcardTypeArguments() { qn.setTypeArguments(typeArgs); } ]
	(
	 ( args = Arguments()
	   [ 
	       {
		   cd = factory.createClassDeclaration();
		   setPrefixInfo(cd);
	       }
		   body = ClassBody()
	       {
		   cd.setMembers(body);
	       }
	   ]
	     {
		 if (qn != null) tr = qn.toTypeReference();
		 result.setTypeReference(tr);
		 ((New)result).setArguments(args);
		 if (cd != null) {
		     ((New)result).setClassDeclaration(cd);
		 }
	     }
	   )
	 |
	 (
	 {	
	     na = factory.createNewArray();
	     copyPrefixInfo(result, na);
             if (qn != null) tr = qn.toTypeReference();
	     na.setTypeReference(tr);
	 }
	 result = ArrayDimsAndInits(na)
	 )
	 )
	)
     )
	{
	    checkConstruction(result);
	    return result;
	}
}

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
NewArray ArrayDimsAndInits(NewArray result) :
{
    int dimensions = 0;
    Expression expr;
    ASTList<Expression> sizes = null;
    ArrayInitializer init = null;
}
{
    (
     LOOKAHEAD(2)
     ( ( LOOKAHEAD(2)
	 "[" expr = Expression() "]"
	 {
	     sizes = (sizes == null) ? new ASTArrayList<Expression>() : sizes;
	     sizes.add(expr);
	     dimensions++;
	 }
	 )+
       ( LOOKAHEAD(2)
	 "[" "]"
       { dimensions++; }
	 )*
       )
     |
     ( ( "[" "]" 
     { dimensions++; }
	 )+
       init = ArrayInitializer()
       )
     )
	{
	    //      setPrefixInfo(result); 
	    result.setDimensions(dimensions);
	    if (sizes != null) {
		result.setArguments(sizes);
	    }
	    result.setArrayInitializer(init);
	    checkConstruction(result);
	    return result;
	}
}

/*
 * Statement syntax follows.
 */
Statement Statement() :
{
    Statement result = null;
    Expression expr;
}
{
    (
     LOOKAHEAD(2)
     result = LabeledStatement()
     | LOOKAHEAD(2)
     result = RMethodCallStatement()
     | LOOKAHEAD( <SVIDENTIFIER> ("." <SVIDENTIFIER>)* ["[" "]"] "(" [<SVIDENTIFIER>] ")" "::" )
        result = RMethodBodyStatement() ";"
     | LOOKAHEAD( Type() "(" [<SVIDENTIFIER>] ")" "::" )
        result = RMethodBodyStatement() ";"
     | result = Block()
     | result = EmptyStatement()
     | LOOKAHEAD(2) expr   = StatementExpression() ";"
	{
	    try {
		result = (ExpressionStatement)expr;
	    }
	    catch (ClassCastException cce) {
		// this is a semantical error!!!
		ParseException e =  new ParseException("ExpressionStatement expected");
	    }
	}
     | result = SwitchStatement()
     | result = IfStatement()
     | result = WhileStatement()
     | result = KeYMetaConstructStatement()
     | result = DoStatement()
     | result = ForStatement()
     | result = BreakStatement()
     | result = ContinueStatement()
     | result = ReturnStatement()
     | result = ThrowStatement()
     | result = SynchronizedStatement()
     | result = TryStatement()
     | result = AssertStatement()
     | result = StatementSV() 
     )
	{ 
	    checkConstruction(result);
	    return result;
	}
}

StatementSVWrapper StatementSV() :
{
    StatementSVWrapper result;
}
{
    <SVIDENTIFIER>
	{  
	    return factory.getStatementSV(token.image);
	}
}

LabeledStatement LabeledStatement() :
{
    LabeledStatement result;
    Identifier id;
    Statement stat;
}
{
    ((<IDENTIFIER>
    {
	id = factory.createIdentifier(token.image);
	setPrefixInfo(id);
    }
      )
     |
     (
      <SVIDENTIFIER>
     {
	 id = factory.getLabelSV(token.image);
	 setPrefixInfo(id);
     }

      ))	
	":"
	{
	    result = factory.createLabeledStatement();
	    setPrefixInfo(result);
	    result.setIdentifier(id);
	}
    stat = Statement()
    {
	result.setBody(stat);
	checkConstruction(result);
	return result;
    }
}

RMethodCallStatement RMethodCallStatement() :
{
    RMethodCallStatement result;
    ProgramVariableSVWrapper res = null;
    ExecutionContext exec = null;
    StatementBlock block;
}
{
    "method-frame"  "("
	(LOOKAHEAD(2) res = VariableSV() "," )? 
	(LOOKAHEAD(2) exec = ExecutionContext() | 
	 exec = ExecutionContextSV()) ")"  	
	":"
	block = Block()   
    {   
	result = factory.createRMethodCallStatement(res, exec, block);
	checkConstruction(result);
	return result;
    }
}

RMethodBodyStatement RMethodBodyStatement() :
{
  RMethodBodyStatement result;
  
  TypeReference bodySource;
  Expression tmp;
  ProgramVariableSVWrapper resVar = null;
  MethodReference methRef;  
}
{
  (bodySource = Type() | bodySource = TypeSV())
  ( 
    "("
        [ resVar = VariableSV() ] 
    ")" 
  ) 
  "::"
  
  tmp = Expression()
  
  {
    if (tmp instanceof MethodReference)
    {
        methRef = (MethodReference)tmp;
    }
    else
    {
        throw new ParseException("Expected a method reference.");
    }
    result = factory.createRMethodBodyStatement(bodySource, resVar, methRef);
    checkConstruction(result);
    return result;
  }
}


StatementBlock Block() :
{
    StatementBlock result;
    ASTList<Statement> sl = new ASTArrayList<Statement>();
    Statement stat;
}
{
    "{"
	{
	    result = factory.createStatementBlock();
	    setPrefixInfo(result);
	}
    ( stat = BlockStatement()
	{
	    sl.add(stat);
	}
      )*
	"}"
	{
	    result.setBody(sl);
	    checkConstruction(result);
	    return result;
	}
}


StatementBlock StartBlock() :
{
    StatementBlock result = null;
    ASTList<Statement> sl = new ASTArrayList<Statement>();
    Statement stat;
    ExecCtxtSVWrapper ec = null;
    TypeSVWrapper tr = null;
    ExpressionSVWrapper sv = null;
}
{ 
   "{" (   LOOKAHEAD(2)
           ( <DOT> ( LOOKAHEAD(2) 
		     tr = TypeSV() "(" (sv = ExpressionSV())? ")" |  
	             ec = ExecutionContextSV() ))? 
            <CONTEXTSTART> 
            {
              if (tr == null) {
                 result = factory.createContextStatementBlock(ec);
	      } else { 
                 result = factory.createContextStatementBlock(tr, sv);
	      }
              setPrefixInfo(result);
            }        
           (stat = BlockStatement() { sl.add(stat); } )*
           <CONTEXTEND>       
       | 
	  ({
             result = factory.createStatementBlock();
             setPrefixInfo(result);
           }
           ( stat = BlockStatement()
               {
                   sl.add(stat);
               }
           )*)
      )
   "}" {
         result.setBody(sl);
         checkConstruction(result);
         return result;
       }
}




Statement BlockStatement() :
{
    Statement result;
}
{    
    (LOOKAHEAD((AnnotationUse())* [ "final" ]<TYPEOF> "(" <SVIDENTIFIER> ")")
     result = SVLocalVariableDeclaration() ";"
     |  LOOKAHEAD((AnnotationUse())* [ "final" | "ghost" ] <SVIDENTIFIER> <SVIDENTIFIER> ";" ,
	 {
	     isLocalVariable((getToken(1).kind == FINAL || getToken(1).kind == GHOST ? getToken(3) : getToken(2)).toString())
	 })
     result = SVLocalVariableDeclaration() ";" 
     |  LOOKAHEAD((AnnotationUse())* [ "final" | "ghost" ] <SVIDENTIFIER> <SVIDENTIFIER> "=" <SVIDENTIFIER> ,
	 {
	     isLocalVariable((getToken(1).kind == FINAL || getToken(1).kind == GHOST ? getToken(3) : getToken(2)).toString())
	 })
     result = SVLocalVariableDeclaration() ";" 	
     |  LOOKAHEAD((AnnotationUse())* [ "final" | "ghost" ] Type() <SVIDENTIFIER> ";" ,
	 {
	     isLocalVariable((getToken(1).kind == FINAL || getToken(1).kind == GHOST ? getToken(3) : getToken(2)).toString())
	 })
     result = SVLocalVariableDeclaration() ";" 
     |  LOOKAHEAD((AnnotationUse())* [ "final" | "ghost" ] Type() <SVIDENTIFIER> "=" <SVIDENTIFIER> ,
	 {
	     isLocalVariable((getToken(1).kind == FINAL || getToken(1).kind == GHOST ? getToken(3) : getToken(2)).toString())
	 })
     result = SVLocalVariableDeclaration() ";" 
     |
     LOOKAHEAD((AnnotationUse())* [ "final" ] Type() <IDENTIFIER>)
     result = LocalVariableDeclaration() ";" 

     | result = Statement() 
     | result = UnmodifiedClassDeclaration() 
     // | result = UnmodifiedInterfaceDeclaration()   removed: not valid!
     )
	{
	    checkConstruction(result);
	    return result;
	}
}

LocalVariableDeclaration LocalVariableDeclaration() :
{
    LocalVariableDeclaration result;
    ASTList<VariableSpecification> vl = new ASTArrayList<VariableSpecification>(1);
    TypeReference tr;
    VariableSpecification var;
    ASTArrayList<DeclarationSpecifier> declSpecs = new ASTArrayList<DeclarationSpecifier>();
    AnnotationUseSpecification annot;
}
{
    {
	    result = factory.createLocalVariableDeclaration();
	    setPrefixInfo(result);
    }
    
    (annot = AnnotationUse() { declSpecs.add(annot); })*
    
    [ "final" 
      { 
        Final fi = factory.createFinal(); 
        setPrefixInfo(fi);
        declSpecs.add(fi);
 	  } 
      (annot = AnnotationUse() { declSpecs.add(annot); })*
    ]
    {
      if (declSpecs.size() != 0)
         result.setDeclarationSpecifiers(declSpecs); 
    }
    
    tr = Type()
    
	var = VariableDeclarator(false) { vl.add(var); }
    ( "," 
      var = VariableDeclarator(false)  { vl.add(var); }
      )*
      
	{
	    result.setTypeReference(tr);
	    result.setVariableSpecifications(vl);
	    checkConstruction(result);
	    return result;
	}
}


LocalVariableDeclaration SVLocalVariableDeclaration() :
{
    LocalVariableDeclaration result;
    ASTList<VariableSpecification> vl = new ASTArrayList<VariableSpecification>(1);
    TypeReference tr;
    VariableSpecification var;
}
{
    {
	result = factory.createLocalVariableDeclaration();
	setPrefixInfo(result);
    }
    [ "final" 
    { 
	Final fi = factory.createFinal(); 
	setPrefixInfo(fi);
	result.setDeclarationSpecifiers(new ASTArrayList<DeclarationSpecifier>(fi));
    }
    |
      "ghost"
    {
    	Ghost g = new Ghost();
    	setPrefixInfo(g);
    	result.setDeclarationSpecifiers(new ASTArrayList<DeclarationSpecifier>(g));
    } 
    ]
	(tr = TypeMC() | tr = TypeSV() | tr = Type() ) 
	var = SVVariableDeclarator(false) {vl.add(var);}
    {
	result.setTypeReference(tr);
	result.setVariableSpecifications(vl); 
	checkConstruction(result);

	return result;
    }
}

EmptyStatement EmptyStatement() :
{
    EmptyStatement result;
}
{
    ";"
	{
	    result = factory.createEmptyStatement(); 
	    setPrefixInfo(result);
	    checkConstruction(result);
	    return result;
	}
}

Expression StatementExpression() :
    /*
     * The last expansion of this production accepts more than the legal
     * Java expansions for StatementExpression.  This expansion does not
     * use PostfixExpression for performance reasons.
 */
{
    Expression result;
    Expression expr;
    Assignment op;
    ASTList<Expression> leftRight;
}
{
    (
     result = PreIncrementExpression()
     | result = PreDecrementExpression()
     | (
	result = PrimaryExpression()
	[
	 "++" { 
	     result = factory.createPostIncrement(result); 
	     setPrefixInfo(result);
	 }
	 | "--" { 
	     result = factory.createPostDecrement(result);
	     setPrefixInfo(result);
	 }
	 | ( op = AssignmentOperator()
	     expr = Expression()
	     {
		 leftRight = new ASTArrayList<Expression>(2);
		 leftRight.add(result);
		 leftRight.add(expr);
		 op.setArguments(leftRight);
		 testLeftHandSide(result);
		 result = op;
	     }
	     )
	]
	)
     | (
         "#set"
         result = PrimaryExpression()
         "="
         expr = Expression()
         {
             op = new SetAssignment(result, expr);
             testLeftHandSide(result);
             result = op;             
         }
       )
     )
	{
	    checkConstruction(result);
	    return result;
	}
}

Switch SwitchStatement() :
{
    Switch result;
    Expression expr;
    ASTList<Branch> branches = new ASTArrayList<Branch>(2);
    Branch branch;
    ASTList<Statement> stats;
    Statement stat;
}
{ 
    "switch"
	{ 
	    result = factory.createSwitch();
	    setPrefixInfo(result);
	}
    "(" expr = Expression() ")" "{"

	( branch = SwitchLabel()
	    {
		stats = new ASTArrayList<Statement>();
	    }
	  ( stat = BlockStatement()
	      {
		  stats.add(stat);
	      }
	    )*

	    {
		if (branch instanceof Case) {
		    ((Case)branch).setBody(stats);
		} else {
		    ((Default)branch).setBody(stats);
		}
		branches.add(branch);
	    }
	  )*


	"}"
    {
	result.setExpression(expr);
	result.setBranchList(branches);
	checkConstruction(result);
	return result;
    }
}

Branch SwitchLabel() :
    /*
     * The returned branch is not completely initialized - only the label is set
     */
{
    Branch result;
    Expression expr;
}
{
    (
     ( "case"
     {
	 result = factory.createCase();
	 setPrefixInfo(result);
     }
       expr = Expression()
       ":"
	 {
	     ((Case)result).setExpression(expr);
	 }
       )
     |
     ( "default"
     {
	 result = factory.createDefault();
	 setPrefixInfo(result);
     }
       ":"
       )
     )
	{
	    checkConstruction(result);
	    return result;
	}
}

Assert AssertStatement() :

{
    Assert result;
    Expression cond = null;
    Expression msg = null;
}
{
    "assert"
	{
	    result = factory.createAssert();
	    setPrefixInfo(result);
	}
    cond = Expression()
	[
	 ":"
	 msg = Expression()    
	]
	";"
    {
      
	result.setCondition(cond);
	result.setMessage(msg);
	checkConstruction(result);
	return result;
    }
}


If IfStatement() :
    /*
     * The disambiguating algorithm of JavaCC automatically binds dangling
     * else's to the innermost if statement.  The LOOKAHEAD specification
     * is to tell JavaCC that we know what we are doing.
 */
{
    If result;
    Expression cond, e0, e1;
    Then thenStat;
    Else elseStat = null;
    Statement trueStat;
    Statement falseStat = null;
}
{
    "if" 
	{
	    result = factory.createIf();
	    setPrefixInfo(result);
	}
    "(" cond = Expression() ")" 
    {
	thenStat = factory.createThen();
	setPrefixInfo(thenStat);
    }
    trueStat = Statement()
    {
	thenStat.setBody(trueStat);
    }
    [ LOOKAHEAD(1) "else" 
    {
	elseStat = factory.createElse();
	setPrefixInfo(elseStat);
    }
    falseStat = Statement() 
	{
	    elseStat.setBody(falseStat);
	}
    ]
	{
	    result.setExpression(cond);
	    result.setThen(thenStat);
	    if (elseStat != null) {
		result.setElse(elseStat);
	    }
	    checkConstruction(result);
	    return result;
	}
}

RKeYMetaConstruct KeYMetaConstructStatement() :
{
    RKeYMetaConstruct result;
    LoopStatement loopStat;
    Try tryStat;
    TypeCast typeCast;
    LabeledStatement labStat;
    Statement stat;
    Expression methRef, consRef, activeAccess;
    ProgramVariableSVWrapper sv = null;
    ExecCtxtSVWrapper execsv = null;  
    JumpLabelSVWrapper innerLabel, outerLabel;
}
{ (
   "#unwind-loop" "(" 
   (innerLabel = JumpLabelSV() "," outerLabel = JumpLabelSV() ","
      (  loopStat = WhileStatement()
       | loopStat = ForStatement()
       | loopStat = DoStatement()
      )
    )
   ")" ";"
{
    result = factory.createRKeYMetaConstruct();
    setPrefixInfo(result);
    result.setChild(loopStat);
    result.addSV(innerLabel);
    result.addSV(outerLabel);
    result.setName("#unwind-loop");
    return result;
}
   )
     |
   (
    <UNPACK> "(" 
    ( loopStat=ForStatement() )
   ")" ";"
   {
       result = factory.createRKeYMetaConstruct();
       setPrefixInfo(result);
       result.setChild(loopStat);
       result.setName("#unpack");
       return result;
   }
   )
      | 
(      "#for-to-while" "(" innerLabel = JumpLabelSV() "," outerLabel = JumpLabelSV() "," 
      (   stat = Statement()
      ) ")"
  {
      result = factory.createRKeYMetaConstruct();
      setPrefixInfo(result);
      result.setChild(stat);
      result.addSV(innerLabel);
      result.addSV(outerLabel);
      result.setName("#for-to-while");
      return result; 
  }
)      |
      <SWITCHTOIF> "(" stat = Statement() ")"
  {  
      result = factory.createRKeYMetaConstruct();
      setPrefixInfo(result);
      result.setChild(stat);
      result.setName("#switch-to-if");
      return result;
  }
|
      (
       "#do-break" "("
       labStat=LabeledStatement()
       ")" ";" 
	  {
	      result = factory.createRKeYMetaConstruct();
	      setPrefixInfo(result);
	      result.setChild(labStat);
	      result.setName("#do-break");
	      return result;
	  }
       )
	  |
	  (
	   "#evaluate-arguments" "("	
           methRef = StatementExpression() 	
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)methRef);
		  result.setName("#evaluate-arguments");
		  return result;
	      }
	   )
	  |
	  (
	   "#replace" "(" stat = Statement() "," sv = VariableSV() ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild(stat);
		  result.setSV(sv);
		  result.setName("#replace");
		  return result;
	      }
	   )
	  |
	  (
	   "#method-call" "("	
	   [  LOOKAHEAD(2) sv = VariableSV() ","]
	   [  LOOKAHEAD(2) execsv = ExecutionContextSV() ","]
           methRef = PrimaryExpression() 
	
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)methRef);
		  if (sv != null) {
		      result.setSV(sv);
		  }
		  if (execsv != null) {
		      result.addSV(execsv);
		  }		
		  result.setName("#method-call");
		  return result;
	      }
	  ) 
	  |
	  (
	   "#method-call-contract" "("	
	   [  LOOKAHEAD(2) sv = VariableSV() ","]
	   [  LOOKAHEAD(2) execsv = ExecutionContextSV() ","]
           methRef = PrimaryExpression() 
	
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)methRef);
		  if (sv != null) {
		      result.setSV(sv);
		  }
		  if (execsv != null) {
		      result.addSV(execsv);
		  }		
		  result.setName("#method-call-contract");
		  return result;
	      }
	  ) 
	  |
	  (
	   "#expand-method-body" "(" stat = Statement() ("," sv = VariableSV() )?  ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild(stat);
		  result.setSV(sv);
		  result.setName("#expand-method-body");
		  return result;
	      }
	   ) 
	  |  
	  (
	   "#constructor-call" "("	
	   sv = VariableSV() "," consRef = ExpressionSV() 	
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)consRef);
		  result.setSV(sv);
		  result.setName("#constructor-call");
		  return result;
	      }
	   )
	  |  
	  (
	   "#special-constructor-call" "(" consRef = ExpressionSV() ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)consRef);
		  result.setName("#special-constructor-call");
		  return result;
	      }
	   )
	  |  
	  (
	   "#post-work" "("	
	   	 consRef = ExpressionSV() 	
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)consRef);
		  result.setName("#post-work");
		  return result;
	      }
	   )
	  |  
	  (
	   "#static-initialisation" "("	
	         activeAccess = PrimaryExpression() 
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)activeAccess);
		  result.setName("#static-initialisation");
		  return result;
	      }
	   )
	  |  
	  (
	   "#resolve-multiple-var-decl" "(" stat = Statement() ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild(stat);
		  result.setName("#resolve-multiple-var-decl");
		  return result;
	      }
	   )
	  |  
	  (
	   "#array-post-declaration" "(" stat = Statement() ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild(stat);
		  result.setName("#array-post-declaration");
		  return result;
	      }
	   )
	  |  
	  (
	   "#init-array-creation" "("
	   sv = VariableSV() "," consRef = ExpressionSV() 	
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)consRef);
		  result.setSV(sv);
		  result.setName("#init-array-creation");
		  return result;
	      }
	   )
	  |  
	  (
	   "#init-array-creation-transient" "("
	   sv = VariableSV() "," consRef = ExpressionSV() 	
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)consRef);
		  result.setSV(sv);
		  result.setName("#init-array-creation-transient");
		  return result;
	      }
	   )
	  |  
	  (
	   "#init-array-assignments" "("
	   sv = VariableSV() "," consRef = ExpressionSV() 	
	   ")" ";" 
	      {
		  result = factory.createRKeYMetaConstruct();
		  setPrefixInfo(result);
		  result.setChild((Statement)consRef);
		  result.setSV(sv);
		  result.setName("#init-array-assignments");
		  return result;
	      }
	   )
	   |
	   (
	    "#enhancedfor-elim" "("
	      loopStat=ForStatement()
	    ")" ";"
	    	{
	    	result = factory.createRKeYMetaConstruct();
		  	setPrefixInfo(result);
		 	result.setChild(loopStat);
		 	result.setName("#enhancedfor-elim");
		  	return result;
	     	}
	   )
	  }


While WhileStatement() :
{
    While result;
Expression expr;
Statement stat;
}
{
    "while"
	{
	    result = factory.createWhile();
	    setPrefixInfo(result);
	}
    "(" expr = Expression() ")" stat = Statement()
    {
	result.setGuard(expr);
	result.setBody(stat);
	checkConstruction(result);
	return result;
    }
}

Do DoStatement() :
{
    Do result;
    Expression expr;
    Statement stat;
}
{
    "do" 
	{
	    result = factory.createDo();
	    setPrefixInfo(result);
	}
    stat = Statement() "while" "(" expr = Expression() ")" ";"
    {
	result.setGuard(expr);
	result.setBody(stat);    
	checkConstruction(result);
	return result;
    }
}

LoopStatement ForStatement() :
{
    LoopStatement result;
    ASTList<LoopInitializer> init = null;
    Expression guard = null;
    ASTList<Expression> update = null;
    Statement body;
}
{
    "for"
//  {
//      result = factory.createFor();
//      setPrefixInfo(result);
//  }
	   //"(" 
	   (
  	// old for
  	   LOOKAHEAD( "(" [ForInit()] ";")
	{
	    result = factory.createFor();
	    setPrefixInfo(result);
	}
  	      "("
	   	  [ init = ForInit() ] ";"
       [ guard = Expression() ] ";"
    	  [ update = ForUpdate() ] 
    
    | LOOKAHEAD( "(" ForInit() ":")
    // enhanced for loop / "foreach"
    	{
    		result = factory.createEnhancedFor();
    		setPrefixInfo(result);	
    	}
    	"("
    	init = ForInit()
    	":"
    	guard = Expression()
       )
       // this is common again
  	   ")"
      body = Statement()
  {
      result.setInitializers(init);
      result.setGuard(guard);
      result.setUpdates(update);
      result.setBody(body);
	checkConstruction(result);
      return result;
  }
}

ASTList<LoopInitializer> ForInit() :
{
    ASTList<LoopInitializer> result = new ASTArrayList<LoopInitializer>();
    LocalVariableDeclaration varDecl = null;
    ASTList<Expression> exprs = null;
}
{
(
LOOKAHEAD(<TYPEOF> "(" <SVIDENTIFIER> ")")
  varDecl = SVLocalVariableDeclaration()
|  LOOKAHEAD(<SVIDENTIFIER> <SVIDENTIFIER> ,
	{(factory.lookupSchemaVariableType(getToken(2).toString(), 
	ProgramSVSort.VARIABLE))})
  varDecl = SVLocalVariableDeclaration() 
|  LOOKAHEAD(<SVIDENTIFIER> <SVIDENTIFIER> "=" <SVIDENTIFIER> ,
	{(factory.lookupSchemaVariableType(getToken(2).toString(), 
	ProgramSVSort.VARIABLE))})
  varDecl = SVLocalVariableDeclaration()
|  LOOKAHEAD(Type() <SVIDENTIFIER>,
	{(factory.lookupSchemaVariableType(getToken(2).toString(), 
	ProgramSVSort.VARIABLE))})
  varDecl = SVLocalVariableDeclaration()
|  LOOKAHEAD(Type() <SVIDENTIFIER> "=" <SVIDENTIFIER> ,
	{(factory.lookupSchemaVariableType(getToken(2).toString(), 
	ProgramSVSort.VARIABLE))})
  varDecl = SVLocalVariableDeclaration()
|
     LOOKAHEAD( [ "final" ] Type() <IDENTIFIER> )
     varDecl = LocalVariableDeclaration()
     | exprs   = StatementExpressionList()
     )
	{
	    if (varDecl != null) {
		result.add(varDecl);
	    } else {
		if (exprs.size()==1
		    && exprs.get(0) instanceof ExpressionSVWrapper
		    && ((SortedSchemaVariable)((ExpressionSVWrapper)exprs.get(0)).getSV()).sort()
		    ==ProgramSVSort.LOOPINIT) {
		    result.add((LoopInitializer)exprs.get(0));
		} else {
		    for (int i =  0, s = exprs.size(); i < s; i += 1) {
			result.add((LoopInitializer)exprs.get(i));
		    }
		}
	    }
	    checkConstruction(result);
	    return result;
	}
}

ASTList<Expression> StatementExpressionList() :
{
    ASTList<Expression> result = new ASTArrayList<Expression>(2);
    Expression expr;
}
{
    expr = StatementExpression() { result.add(expr); }
    ( "," expr = StatementExpression() { result.add(expr); } )*
	{
	    checkConstruction(result);
	    return result;
	}
}

ASTList<Expression> ForUpdate() :
{
    ASTList<Expression> result;
}
{
    result = StatementExpressionList()
    { 
	if (result.size()!=1 
	    && result.get(0) instanceof ExpressionSVWrapper
	    && !((ExpressionSVWrapper)result.get(0)).getSV().isListSV()){
		throw new ParseException("SchemaVariable stands for a"
					 +" whole StatementExpressionList");
	    } 


	checkConstruction(result);
	return result;
    }
}

Break BreakStatement() :
{
    Identifier id = null;
    Break result;
}
{
    "break" 
	{ 
	    result = factory.createBreak(); 
	    setPrefixInfo(result); 
	}
    [ (<IDENTIFIER> { 
	id = factory.createIdentifier(token.image); 
	setPrefixInfo(id);
	result.setIdentifier(id);
    } ) | (
	   <SVIDENTIFIER>
    {
	id = factory.getLabelSV(token.image);
	setPrefixInfo(id);
	result.setIdentifier(id);
    }

	   )

    ] ";"
	{
	    checkConstruction(result);
	    return result;
	}
}

Continue ContinueStatement() :
{
    Identifier id = null;
    Continue result;
}
{
    "continue" 
	{
	    result = factory.createContinue();
	    setPrefixInfo(result);     
	}
    [ <IDENTIFIER> 
    {
	id = factory.createIdentifier(token.image); 
	setPrefixInfo(id);
	result.setIdentifier(id);
    }
    ] ";"
	{
	    checkConstruction(result);
	    return result;
	}
}

Return ReturnStatement() :
{
    Expression expr = null;
    Return result;
}
{
    "return" 
	{
	    result = factory.createReturn();
	    setPrefixInfo(result);
	}
    [ expr = Expression() 
	{ 
	    result.setExpression(expr); 
	} 
    ]   
	";"
	{
	    checkConstruction(result);
	    return result;
	}

}

Throw ThrowStatement() :
{
    Throw result;
    Expression expr;
}
{
    "throw" 
	{
	    result = factory.createThrow();      
	    setPrefixInfo(result);
	}
    expr = Expression() ";"
    {
	result.setExpression(expr);
	checkConstruction(result);
	return result;
    }
}

SynchronizedBlock SynchronizedStatement() :
{
    SynchronizedBlock result;
    Expression expr;
    StatementBlock block;
}
{
    "synchronized" 
	{
	    result = factory.createSynchronizedBlock();
	    setPrefixInfo(result);
	}
    "(" expr = Expression() ")"
	block = Block()
    {
	result.setExpression(expr);
	result.setBody(block);
	checkConstruction(result);
	return result;
    }
}

Try TryStatement() :
    /*
     * Semantic check required here to make sure that at least one
     * finally/catch is present.
 */
{
    Try result;
    StatementBlock block;
    ParameterDeclaration param;
    ASTList<Branch> branches = new ASTArrayList<Branch>(1);
    Catch cat;
    Finally fin;
}
{
    "try"
	{
	    result = factory.createTry();
	    setPrefixInfo(result);
	}
    block = Block()
    {
	result.setBody(block);
    }
  
    (( {CatchSVWrapper cfsv;} cfsv=CatchSV() 
	{branches.add(cfsv); } )
     |
     (
      ( "catch" 
	( ( {
	    cat = factory.createCatch();
	    setPrefixInfo(cat);
	}
	    "("  param = FormalParameter() ")"  
	    block = Block()
	    {
		cat.setParameterDeclaration(param);
		cat.setBody(block);
		branches.add(cat);
	    } )
	  |
	  ( {CatchSVWrapper cfsv2;} cfsv2=CatchSV() 
	      {branches.add(cfsv2); } ) )
	)*
      [ "finally" 
      {
	  fin = factory.createFinally();
	  setPrefixInfo(fin);
      }
      block = Block()
	  {
	      fin.setBody(block);
	      branches.add(fin);
	  }
      ]))
	{ 
	    result.setBranchList(branches);
	    checkConstruction(result);
	    return result;
	}
  
}


/**
   For partial parsing ONLY. Allows this()/super() calls, as in
   constructor bodies.
 */
ASTList<Statement> GeneralizedStatements() :
{
    ASTList<Statement>            result = new ASTArrayList<Statement>();
    SpecialConstructorReference     scr = null;
    Statement                       stat = null;
}
{
    [ LOOKAHEAD(ExplicitConstructorInvocation())
    scr = ExplicitConstructorInvocation()
	{ result.add(scr); }
    ]
	( stat = BlockStatement()
	    { result.add(stat); }
	  )*
	{
	    checkConstruction(result);
	    return result;
	}
}

// Java 5 specific 
AnnotationUseSpecification AnnotationUse() :
{
	TypeReference tr;	
	AnnotationUseSpecification result = factory.createAnnotationUseSpecification();
	Expression ev = null;
	ASTList<AnnotationElementValuePair> list = null;
	AnnotationPropertyReference id;
	AnnotationElementValuePair evp;
}
{
	"@"
	 { setPrefixInfo(result); }
	tr = Type()
	[ "(" { list = new ASTArrayList<AnnotationElementValuePair>(); }
	    [
			   LOOKAHEAD(<IDENTIFIER> "=")
				<IDENTIFIER> { 
					id = factory.createAnnotationPropertyReference(token.image); 
					setPrefixInfo(id);
					
				} "=" ev = ElementValue() 
				{ 
					 	evp = new AnnotationElementValuePair(id, ev);
					 	setPrefixInfo(evp);
					 	
						list.add(evp); 				} 
				(
					"," <IDENTIFIER> { 
						id = factory.createAnnotationPropertyReference(token.image); 
						setPrefixInfo(id);
						
					 } "=" ev = ElementValue() 
					 { 
					 	evp = new AnnotationElementValuePair(id, ev);
					 	setPrefixInfo(evp);
					 	
						list.add(evp); 
					} 
				)*
			| 
			   LOOKAHEAD(ElementValue())
			  	ev = ElementValue() { 
			  			evp = new AnnotationElementValuePair(null, ev);
					 	setPrefixInfo(evp);
					 	
						list.add(evp); 
			  	} // Single Element Annotation
		]
	 ")"
	]
	{
		result.setTypeReference(tr);
		if (list != null) {
			result.setElementValuePairs(list);
		}
		
		return result;
	}
}

Expression ElementValue() :
{
	Expression res = null;
	Expression tmp;
	ASTList<Expression> elist;
}
{
	(   res = Expression()
	  | res = AnnotationUse()
	  | "{" tmp = ElementValue() 
	  		{ 
	  			res = new ElementValueArrayInitializer();
	  			setPrefixInfo(res);
	  			elist = new ASTArrayList<Expression>();
	  			elist.add(tmp);
	  		}
	  		(LOOKAHEAD(2) "," tmp = ElementValue()
	  			{ elist.add(tmp); }
	  		)* [","] "}"

		{
			((ElementValueArrayInitializer)res).setElementValues(elist);
		}
	  			
	)
	{ 
		
		return res; 
	}
}

ASTList<TypeArgumentDeclaration> NonWildcardTypeArguments() :
{
	ASTList<UncollatedReferenceQualifier> nl;
	ASTList<TypeArgumentDeclaration> res = new ASTArrayList<TypeArgumentDeclaration>();
	TypeArgumentDeclaration ta;
}
{
	"<" nl = TypedNameList() ">"	
	{
		for (int i = 0; i < nl.size(); i++) {
			ta = new TypeArgumentDeclaration(nl.get(i).toTypeReference());
			res.add(ta);
		}
		return res;
	}
}

// HACK for handling position of methodDeclarations correctly
ASTList<TypeParameterDeclaration> TypeParametersNoLE() :
{
	ASTList<TypeParameterDeclaration> res = new ASTArrayList<TypeParameterDeclaration>();
	TypeParameterDeclaration tp;
}
{
  tp = TypeParameter() { res.add(tp); } ("," tp = TypeParameter() { res.add(tp);})* ">"
  {
  	return res;
  }
}

ASTList<TypeParameterDeclaration> TypeParameters() :
{
	ASTList<TypeParameterDeclaration> res = new ASTArrayList<TypeParameterDeclaration>();
}
{
  "<" res = TypeParametersNoLE()
  { return res; }
}

TypeParameterDeclaration TypeParameter() :
{
	TypeParameterDeclaration res = new TypeParameterDeclaration();
	Identifier id;
	ASTList<TypeReference> bound = null;
}
{
	<IDENTIFIER> { 
		id = factory.createIdentifier(token.image); 
		setPrefixInfo(id);
		
	} ["extends" bound = Bound()]	
	{
		res.setIdentifier(id);
		res.setBound(bound);
		return res;
	}
}

ASTList<TypeReference> Bound() :
{
	TypeReference tr;
	ASTList<TypeReference> res = new ASTArrayList<TypeReference>();
}
{
	tr = Type() {res.add(tr);} ("&" tr = Type() {res.add(tr);})*	
	{ 
		return res;
	}
}

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

void RUNSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                ((Token.RealKindToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
   ">" ">" ">"
  )
}

void RSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                ((Token.RealKindToken)getToken(1)).realKind == RSIGNEDSHIFT} )
  ">" ">"
  )
}

Identifier ImplicitIdentifier():
{
	ImplicitIdentifier id;
}
{
	(LOOKAHEAD({ getToken(1).kind == LT
		       && ((Token.RealKindToken)getToken(1)).realKind == IMPLICITIDENTIFIER} )
	  "<" <IDENTIFIER> { id = factory.createImplicitIdentifier(token.image); } ">"
	        { return id; })
}	