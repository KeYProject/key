// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2009 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//

/* Generated by Together */

package de.uka.ilkd.key.logic;

import java.util.Stack;

import de.uka.ilkd.key.logic.op.*;


/**
 * visitor for <t> execPostOrder </t> of 
 * {@link de.uka.ilkd.key.logic.Term}. Called with that method
 * on a term, the visitor evaluates all contained substitution terms
 * by applying a  
 * suitable substitution. Occuring collisions are adequately handled.
 * REMARK: The current implementation is not very efficient. This
 * seems to be (at the moment) 
 * not so important, because the operation this class implements will
 * rarely occur ! 
 */

public class CollisionDeletingSubstitutionTermApplier extends Visitor {

    /**
     * the stack contains the subterms that will be used in getTerm() in Term
     * in order to build the new term. A boolean value
     * between or under the subterms on the stack indicate that a term using
     * these subterms should build a new term instead of using the old one,
     * because one of its subterms has been built, too.
     */
    private Stack<Object> subStack; //of Term (and Boolean)
    private TermFactory tf=TermFactory.DEFAULT;
    private Boolean newMarker = Boolean.TRUE;

    public CollisionDeletingSubstitutionTermApplier() {
	subStack = new Stack<Object>(); // of Term	
    }

    private Term[] neededSubs(int n) {
	boolean newTerm=false;
	Term[] result=new Term[n];
	for (int i=n-1; i>=0; i--) {
	    Object top=subStack.pop();
	    if (top==newMarker){
		newTerm=true; 
		top=subStack.pop();
	    }
	    result[i]=(Term) top;
	}
	if (newTerm && (subStack.empty() || subStack.peek()!=newMarker)) {
	    subStack.push(newMarker);
	}
	return result;
    }

    public void visit(Term visited) {
	// Sort equality has to be ensured before calling this method
	MapFromLogicVariableToTerm substToApply;
	Term resultTerm;

	if (visited.op()==Op.SUBST) {
	    // get completely processed childs ...
	    Term[] neededsubs=neededSubs(visited.arity());
	    substToApply = MapAsListFromLogicVariableToTerm.EMPTY_MAP;
	    // Replace substVar 'x'  by 'KS(s)' if the
	    // SubstitutionTerm has the form {x s} t 
	    // and leave other variables unchanged ...
	    substToApply =
		substToApply.put((LogicVariable)visited.varsBoundHere(1)
				 .getQuantifiableVariable(0),
				 neededsubs[0]); 
	    IteratorOfEntryOfLogicVariableAndTerm it = 
		substToApply.entryIterator();
	    while (it.hasNext()) {
		EntryOfLogicVariableAndTerm substitution = it.next();
		ClashFreeSubst cfSubst = 
		    new ClashFreeSubst(substitution.key(),
				       substitution.value());
		resultTerm = cfSubst.apply(neededsubs[1]);	    
		//pop result on stack and mark as new ...
		subStack.push(resultTerm);
		if (resultTerm!=neededsubs[1]) {
		    subStack.push(newMarker);	  
		}
	    }  
	} else {	 
	    Term[] neededsubs=neededSubs(visited.arity());
	    final ArrayOfQuantifiableVariable[] boundVars = 
	        new ArrayOfQuantifiableVariable[neededsubs.length];
	    for (int i = 0; i<visited.arity(); i++) {
	        boundVars[i] = visited.varsBoundHere(i);
	    }
	    if (!subStack.empty() && subStack.peek()==newMarker) {
		subStack.pop(); // delete new marker ...		
		subStack.push(tf.createTerm(visited.op(), 
					    neededsubs,
					    boundVars,
					    visited.javaBlock()));
		subStack.push(newMarker); // add new marker ...
		
	    } else {
		subStack.push(visited);
	    }	    	    	    
	}
    }      
    

    
    /**
     * resets (internal) state of the visitor.
     */
    
    public void reset(){
	subStack = new Stack<Object>(); // of Term
    }
    
    /**
     * delivers the new built term
     */
    public Term getTerm() {
	Object result = subStack.pop();
	if (result == newMarker) {
	    result = subStack.pop();
	}
	return((Term)result);
    }
    


}









