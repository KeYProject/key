// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//

/* Generated by Together */

package de.uka.ilkd.key.logic.op;

import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.sort.*;

/**
 * This class represents an equality symbol for a given sort.
 * The system will generate automatically for each sort exactly one 
 * equality symbol. For the special sort Formula the corresponding equality 
 * symbol is the equivalence-junctor {@link Op#EQV}.
 */
public class Equality extends Op {

    private final Sort targetSort;

    /**
     * generates a new equality symbol for the given target sort.
     * Don't call this, but {@link Sort#getEqualitySymbol()}. In case of
     * schemavariables without sort on both sides (e.g. two program SVs)
     * @param name the Name of the operator 
     */
    Equality(Name name) {
	this(name, Sort.ANY);
    }
    
    /**
     * generates a new equality symbol for the given target sort and a 
     * given name.
     * Don't call this, but use {@link Op#EQV} or {@link Op#EQUALS}.
     * @param targetSort - sort for which the equality symbol is generated.
     * @param name - name for the equality symbol
     */
    Equality(Name name, Sort targetSort){
	super(name); 
	this.targetSort = targetSort;
    }

    /** 
     * @return Sort of the term consisting of the given subterms if it would
     * have this operator as top level operator  
     */
    public Sort sort(Term[] term) {
	return Sort.FORMULA;
    }

    /** 
     * returns the sort of the <tt>i</tt>-th argument
     */
    public Sort argSort(int i) {
	return targetSort == Sort.FORMULA ? Sort.FORMULA : Sort.ANY;
    }

    /** @return arity of the Equality as int that is 2*/
    public int arity() {
	return 2;
    }
    
    /**
     * checks if the given term is syntactically valid at its top
     * level assumed the top level operator were this, i.e. if the
     * direct subterms can be subterms of a term with this top level
     * operator, the method returns true. Furthermore, it is checked
     * that no variables are bound for none of the subterms.
     * If a subterm is a schemavariable, the whole term is accepted.
     * @param term the Term to be checked.  
     * @return true iff the given term has
     * subterms that are suitable for this function.
     */
    public boolean validTopLevel(Term term){
	if (term.arity()!=arity()) {
	    return false;
	}
	
	for (int i=0; i<arity(); i++) {
	    Sort sort = term.sub(i).sort();
	    if (term.sub(i).op() instanceof SchemaVariable ||
		sort instanceof ProgramSVSort || 
		sort == AbstractMetaOperator.METASORT) {
		return true;
	    }   
	}
        
	final Sort t0Sort = term.sub(0).sort();
	final Sort t1Sort = term.sub(1).sort();

	if (t0Sort instanceof PrimitiveSort != t1Sort instanceof PrimitiveSort) {
	    return false;
	}	

	if ( targetSort == Sort.FORMULA || t0Sort == Sort.FORMULA || t1Sort == Sort.FORMULA ) { 
	    return t0Sort == Sort.FORMULA && t1Sort == Sort.FORMULA && targetSort == Sort.FORMULA;
	}
	
	return t0Sort.extendsTrans(targetSort) && t1Sort.extendsTrans(targetSort);
    }
    
}

