// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe Germany
//                         Universitaet Koblenz-Landau, Germany
//                         and Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
// This file contains rules that are applicable for every sort (as they
// use \generic sorts).
// The format is the same as for problem files.

\sorts {
  \generic G, S1, S2, H;
}

\schemaVariables {
  \term G e,s,t, e0;  
  \term H t1; 
  \term S1 t2; 
  \skolemTerm G sk ;
  \formula phi,b,c;
  \variables G u, e2 ;

  \term G commEqLeft;
  \term H commEqRight;

  \term[rigid] G sr;
  \term[rigid] H tr;

  \term G ref1, ref2 ;
  \term S1 ind1, ind2, target ;
  \term S2 else, then ;
  \term numbers iz, jz ;

  \term int i;
}

\rules {

  // Gamma rules
  all_left { 
  	\find (\forall u; b ==>) 
  	\add ({\subst u; t}(b) ==>) 
  	\heuristics(gamma) 
  };

  ex_right { \find (==> \exists u; b)
             \add (==> {\subst u; t}(b))
  	     \heuristics(gamma) };
  all_left_hide { \find (\forall u; b ==>) \replacewith ({\subst u; t}(b) ==>)
		    \addrules ( insert_hidden { \add (\forall u; b ==>) } )
                    \heuristics(gamma_destructive) };
  ex_right_hide { \find (==> \exists u; b) \replacewith (==> {\subst u; t}(b))
		    \addrules ( insert_hidden { \add (==> \exists u; b) } )
                    \heuristics(gamma_destructive) };
  inst_all { \assumes (\forall u; b ==>) \find (t) \add ({\subst u; t}(b) ==>)};
  inst_ex  { \assumes (==> \exists u; b) \find (t) \add (==> {\subst u; t}(b))};


  // delta rules
  all_right { \find (==> \forall u; b) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith (==> {\subst u; sk}b) \heuristics (delta) };
  ex_left { \find (\exists u; b ==>) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith ({\subst u; sk}b ==>) \heuristics (delta) };
  
  // simplification
  all_unused { \find (\forall u; b) \varcond (\notFreeIn(u, b)) 
		 \replacewith (b)
		 \heuristics (simplify) };
  ex_unused  { \find (\exists u; b) \varcond (\notFreeIn(u, b))
		 \replacewith (b)
		 \heuristics (simplify) };


  // equality
  close_eq { \find (s = s) \replacewith (true) \heuristics (concrete) };


  commute_eq { \find (commEqLeft = commEqRight)
               \replacewith (commEqRight = commEqLeft)
               \heuristics ( order_terms ) };

  make_insert_eq { \find (sr = tr ==>)
		     \addrules ( insert_eq { \find (sr) \replacewith (tr) } )
		     \noninteractive  };

  make_insert_eq_nonrigid { \find (s = t ==>)
	     \addrules ( insert_eq_nonrigid { \find (s) \sameUpdateLevel
                                              \replacewith (t)
                                              \displayname "insert_eq" } )
                     \noninteractive  };
  insert_eq_all  { \find (sr = tr ==>)
		     \replacewith (==>)
		     \addrules ( auto_insert_eq { \find (sr) 
						 \replacewith (tr)
						 \heuristics (simplify) } ) };

// wary substitutions
  apply_subst { \find ({\subst u; t} target)
                // it is enough to rebuild the same term, as substitutions
                // are automatically applied in this situation
                \replacewith ({\subst u; t} target)
                \heuristics (try_apply_subst) };

  apply_subst_for { \find ({\subst u; t} phi)
                    // it is enough to rebuild the same term, as substitutions
                    // are automatically applied in this situation
                    \replacewith ({\subst u; t} phi)
                    \heuristics (try_apply_subst)
                    \displayname "apply_subst" };

  subst_to_eq { \find ({\subst u; t} target) \sameUpdateLevel
                \varcond (\new(sk, \dependingOn(t)))
                \replacewith ({\subst u; sk} target)
                \add (sk = t ==>)
                \heuristics (simplify) };

  subst_to_eq_for { \find ({\subst u; t} phi) \sameUpdateLevel
                    \varcond (\new(sk, \dependingOn(t)))
                    \replacewith ({\subst u; sk} phi)
                    \add (sk = t ==>)
                    \heuristics (simplify)
                    \displayname "subst_to_eq" };

 apply_eq { 
	\assumes (s = t1 ==>) \find (s) 
	\sameUpdateLevel
	\replacewith ( t1 )
        \heuristics ( apply_equations )
	\displayname "apply equality"
 };

 apply_eq_rigid { 
	\schemaVar \term[rigid] H tr1;

	\assumes (sr = tr1 ==>) \find (sr)
	\replacewith ( tr1)
        \heuristics ( apply_equations )
	\displayname "apply equality"
 };

 pull_out { \find ( t ) \sameUpdateLevel \varcond ( \new(sk, \dependingOn(t)) )
	       \replacewith (sk)
	       \add ( t = sk ==>) 
	       \heuristics (query_normalize)
	  };
}
