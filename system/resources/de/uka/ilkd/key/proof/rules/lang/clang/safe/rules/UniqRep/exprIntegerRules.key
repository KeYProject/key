\schemaVariables {
	\skolemTerm int dummy;

	\modalOperator {diamond, box} #allmodal;
	\formula formula;

	\program ClangVariable #tvar, #tvar1, #tvar2;

	\program ClangIntegerVariable #ivar, #ivar1, #ivar2, #ivar3;
	\program ClangIntegerSimpleExpression #iexp, #iexp1, #iexp2, #iexp3;
	\program ClangIntegerSimpleExpression #isexp, #isexp1, #isexp2, #isexp3;
}

\rules {

	/* Logic */

	/**
	 * Eliminating value assignment with integer not RHS.
	 */
	elimValueAssignment_LHS_NotRHS {
		\find (\modality{#allmodal}.. #ivar = !#isexp1; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(\if (#ClangIntegerToInt(#isexp1) = 0) \then (1) \else (0), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1) ==>);
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1))
		\heuristics(simplify_prog)
	};

	/**
	 * Reducing value assignment with logic and RHS.
 	 * NB! Short-circuit evaluation!
	 */
	reduceValueAssignment_LHS_LogicAndRHS {
		\find (\modality{#allmodal}.. #ivar = #iexp1 && #iexp2; ...\endmodality(formula)) 
		\varcond(\new(#tvar, \typeof(#iexp1)))
		\replacewith ( 
			\modality{#allmodal}.. #tvar = #iexp1; if (!#tvar) #ivar = #tvar; else #ivar = #iexp2 != 0; ...\endmodality(formula))
		\addprogvars(#tvar)
		\heuristics(simplify_prog)
	};		

	/**
	 * Reducing value assignment with logic or RHS.
	 * NB! Short-circuit evaluation!
	 */
	reduceValueAssignment_LHS_LogicOrRHS_L {
		\find (\modality{#allmodal}.. #ivar = #iexp1 || #iexp2; ...\endmodality(formula)) 
		\varcond(\new(#tvar, \typeof(#iexp1)))
		\replacewith ( 
			\modality{#allmodal}.. #tvar = #iexp1; if (#tvar) #ivar = #tvar; else #ivar = #iexp2 != 0; ...\endmodality(formula))
		\addprogvars(#tvar)
		\heuristics(simplify_prog)
	};		

	/* Equality */

	/**
	 * Eliminating value assignment with integer equals RHS.
	 */
	elimValueAssignment_LHS_IntegerEqualsRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 == #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(\if (#ClangIntegerToInt(#isexp1) = #ClangIntegerToInt(#isexp2)) \then (1) \else (0), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2) ==>);				
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer not equals RHS.
	 */
	elimValueAssignment_LHS_IntegerNotEqualsRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 != #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(\if (#ClangIntegerToInt(#isexp1) != #ClangIntegerToInt(#isexp2)) \then (1) \else (0), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2) ==>);	
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2))
		\heuristics(simplify_prog)
	};
	
	/* Relational */

	/**
	 * Eliminating value assignment with integer less RHS.
	 */
	elimValueAssignment_LHS_IntegerLessRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 < #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(\if (#ClangIntegerToInt(#isexp1) < #ClangIntegerToInt(#isexp2)) \then (1) \else (0), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2) ==>);	
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer less or equals RHS.
	 */
	elimValueAssignment_LHS_IntegerLessEqRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 <= #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(\if (#ClangIntegerToInt(#isexp1) <= #ClangIntegerToInt(#isexp2)) \then (1) \else (0), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2) ==>);	
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer greater RHS.
	 */
	elimValueAssignment_LHS_IntegerGreaterRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 > #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(\if (#ClangIntegerToInt(#isexp1) > #ClangIntegerToInt(#isexp2)) \then (1) \else (0), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2) ==>);	
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer greater or equals RHS.
	 */
	elimValueAssignment_LHS_IntegerGreaterEqRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 >= #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(\if (#ClangIntegerToInt(#isexp1) >= #ClangIntegerToInt(#isexp2)) \then (1) \else (0), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2) ==>);
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2))
		\heuristics(simplify_prog)
	};

	/* Arithmetic */

	/**
	 * Eliminating value assignment with integer negative RHS.
	 */
	elimValueAssignment_LHS_IntegerNegativeRHS {
		\find (\modality{#allmodal}.. #ivar = -#isexp1; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(-#ClangIntegerToInt(#isexp1), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2) ==>);
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Result: -#isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(-#ClangIntegerToInt(#isexp1), #ivar))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer positive RHS.
	 */
	elimValueAssignment_LHS_IntegerPositiveRHS {
		\find (\modality{#allmodal}.. #ivar = +#isexp1; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #isexp1 }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1) ==>);
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer plus RHS.
	 */
	elimValueAssignment_LHS_IntegerPlusRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 + #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(#ClangIntegerToInt(#isexp1) + #ClangIntegerToInt(#isexp2), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2), inIntegerRange(#ClangIntegerToInt(#isexp1) + #ClangIntegerToInt(#isexp2), #ivar) ==>);
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2));
		"Valid Result: #isexp1 + #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(#ClangIntegerToInt(#isexp1) + #ClangIntegerToInt(#isexp2), #ivar))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer minus RHS.
	 */
	elimValueAssignment_LHS_IntegerMinusRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 - #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(#ClangIntegerToInt(#isexp1) - #ClangIntegerToInt(#isexp2), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2), inIntegerRange(#ClangIntegerToInt(#isexp1) - #ClangIntegerToInt(#isexp2), #ivar) ==>);
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2));
		"Valid Result: #isexp1 - #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(#ClangIntegerToInt(#isexp1) - #ClangIntegerToInt(#isexp2), #ivar))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer multiply RHS.
	 */
	elimValueAssignment_LHS_IntegerMultiplyRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 * #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(#ClangIntegerToInt(#isexp1) * #ClangIntegerToInt(#isexp2), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2), inIntegerRange(#ClangIntegerToInt(#isexp1) * #ClangIntegerToInt(#isexp2), #ivar) ==>);
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2));
		"Valid Result: #isexp1 * #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(#ClangIntegerToInt(#isexp1) * #ClangIntegerToInt(#isexp2), #ivar))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer divide RHS.
	 */
	elimValueAssignment_LHS_IntegerDivideRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 / #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(clangDiv(#ClangIntegerToInt(#isexp1), #ClangIntegerToInt(#isexp2)), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2), #ClangIntegerToInt(#isexp2) != 0, inIntegerRange(clangDiv(#ClangIntegerToInt(#isexp1), #ClangIntegerToInt(#isexp2)), #ivar) ==>);
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2));
		"Valid Divisor: #isexp2 != 0" : \replacewith(undefinedBehavior(dummy)) \add(==> #ClangIntegerToInt(#isexp2) != 0);
		"Valid Result: #isexp1 / #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(clangDiv(#ClangIntegerToInt(#isexp1), #ClangIntegerToInt(#isexp2)), #ivar))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer quotient RHS.
	 */
	elimValueAssignment_LHS_IntegerQuotientRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp1 % #isexp2; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ClangIntegerFromInt(clangMod(#ClangIntegerToInt(#isexp1), #ClangIntegerToInt(#isexp2)), #ivar)  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#isexp1), isValidVal(#isexp2), #ClangIntegerToInt(#isexp2) != 0, inIntegerRange(clangMod(#ClangIntegerToInt(#isexp1), #ClangIntegerToInt(#isexp2)), #ivar) ==>);			
		"Valid Value: #isexp1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp1));
		"Valid Value: #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp2));
		"Valid Divisor: #isexp2 != 0" : \replacewith(undefinedBehavior(dummy)) \add(==> #ClangIntegerToInt(#isexp2) != 0);
		"Valid Result: #isexp1 / #isexp2" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(clangMod(#ClangIntegerToInt(#isexp1), #ClangIntegerToInt(#isexp2)), #ivar))
		\heuristics(simplify_prog)
	};

	/* Increment/Decrement Prefix/Postfix */
	
	/**
	 * Eliminating value assignment with integer IncrementPrefix RHS.
	 */
	elimValueAssignment_LHS_IntegerIncrementPrefixRHS {
		\find (\modality{#allmodal}.. #ivar = ++#ivar1; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar1 := #ClangIntegerFromInt(#ClangIntegerToInt(#ivar1) + 1, #ivar1) } { #ivar := #ivar1  }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#ivar1), inIntegerRange(#ClangIntegerToInt(#ivar1) + 1, #ivar1) , inIntegerRange(#ClangIntegerToInt(#ivar1) + 1, #ivar) ==>);
		"Valid Value: #ivar1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#ivar1));
		"Valid Result: #ivar1+1" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(#ClangIntegerToInt(#ivar1) + 1, #ivar1) , inIntegerRange(#ClangIntegerToInt(#ivar1) + 1, #ivar))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating value assignment with integer DecrementPrefix RHS.
	 */
	elimValueAssignment_LHS_IntegerDecrementPrefixRHS {
		\find (\modality{#allmodal}.. #ivar = --#ivar1; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar1 := #ClangIntegerFromInt(#ClangIntegerToInt(#ivar1) - 1, #ivar1) } { #ivar := #ivar1 }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#ivar1), inIntegerRange(#ClangIntegerToInt(#ivar1) - 1, #ivar1) , inIntegerRange(#ClangIntegerToInt(#ivar1) - 1, #ivar) ==>);
		"Valid Value: #ivar1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#ivar1));
		"Valid Result: #ivar1-1" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(#ClangIntegerToInt(#ivar1) - 1, #ivar1) , inIntegerRange(#ClangIntegerToInt(#ivar1) - 1, #ivar))
		\heuristics(simplify_prog)
	};	

	/**
	 * Eliminating value assignment with integer IncrementPostfix RHS.
	 *
	 * Works only if:
	 * * Signed types needing promotion fit into "int"
	 * * Unsigned types needing promotion fin into "unsigned int"
	 */
	elimValueAssignment_LHS_IntegerIncrementPostfixRHS {
		\find (\modality{#allmodal}.. #ivar = #ivar1++; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 			
				{ #ivar := #ivar1 } { #ivar1 := #ClangIntegerFromInt(#ClangIntegerToInt(#ivar1) + 1, #ivar1) }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#ivar1) ==> inIntegerRange(#ClangIntegerToInt(#ivar1) + 1, #ivar1));
		"Valid Value: #ivar1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#ivar1));
		"Valid Result: #ivar1+1" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(#ClangIntegerToInt(#ivar1) + 1, #ivar1))
		\heuristics(simplify_prog)
	};
	
	/**
	 * Eliminating value assignment with integer DecrementPostfix RHS.
	 *
	 * Works only if:
	 * * Signed types needing promotion fit into "int"
	 * * Unsigned types needing promotion fin into "unsigned int"
	 */
	elimValueAssignment_LHS_IntegerDecrementPostfixRHS {
		\find (\modality{#allmodal}.. #ivar = #ivar1--; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith (
				{ #ivar := #ivar1 } { #ivar1 := #ClangIntegerFromInt(#ClangIntegerToInt(#ivar1) - 1, #ivar1) }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(isValidVal(#ivar1), inIntegerRange(#ClangIntegerToInt(#ivar1) - 1, #ivar1) ==>);
		"Valid Value: #ivar1" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#ivar1));
		"Valid Result: #ivar1+1" : \replacewith(undefinedBehavior(dummy)) \add(==> inIntegerRange(#ClangIntegerToInt(#ivar1) - 1, #ivar1))
		\heuristics(simplify_prog)
	};		
}