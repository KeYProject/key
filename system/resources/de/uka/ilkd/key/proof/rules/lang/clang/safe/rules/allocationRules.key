\schemaVariables {
	\skolemTerm int dummy;

	\modalOperator {diamond, box} #allmodal;
	\formula formula;

	\program ClangVariable #tvar, #tvar1, #tvar2;

	\program ClangValueType #vtype;
	\program ClangIntegerType #itype;
	\program ClangPointerType #ptype;
	\program ClangScalarType #stype;
	\program ClangObjectType #otype;

	\program ClangMember #member;

	\program ClangIntegerLiteral #ilit;

	\program ClangVariable #var, #var1, #var2, #var3;
	\program ClangValueVariable #vvar, #vvar1, #vvar2, #vvar3;
	\program ClangObjectVariable #ovar, #ovar1, #ovar2, #ovar3;
	\program ClangIntegerVariable #ivar, #ivar1, #ivar2, #ivar3;
	\program ClangPointerVariable #pvar, #pvar1, #pvar2, #pvar3;

	\program ClangValueSimpleExpression #vsexp, #vsexp1, #vsexp2, #vsexp3;
	\program ClangIntegerSimpleExpression #isexp, #isexp1, #isexp2, #isexp3;
	\program ClangPointerSimpleExpression #psexp, #psexp1, #psexp2, #psexp3;

	\program ClangExpression #exp, #exp1, #exp2;
	\program ClangObjectExpression #oexp, #oexp1, #oexp2;
	\program ClangValueExpression #vexp, #vexp1, #vexp2;
	\program ClangIntegerExpression #iexp, #iexp1, #iexp2;
	\program ClangPointerExpression #pexp, #pexp1, #pexp2;
}

\rules {

	/**
	 * Eliminating object variable static declaration.	
	 */
	elimStaticVarDecl_Obj { 
		\find (\modality{#allmodal}.. static #otype #ovar; ...\endmodality(formula)) 
		\replacewith ( 
			{ #ovar := #ClangRepositoryAccess(next, #ovar) } { storage(objBlock(#ovar)) := ST_STATIC } { next := next+1 } 
			\modality{#allmodal}.. ...\endmodality(formula))
		\addprogvars(#ovar)			
		\heuristics(simplify_prog)
	};	

	/**
	 * Eliminating object variable allocation.	
	 */
	elimAllocate { 
		\find (\modality{#allmodal}.. allocate #ovar; ...\endmodality(formula)) 
		\replacewith ( 
			{ #ovar := #ClangRepositoryAccess(next, #ovar) } { storage(objBlock(#ovar)) := ST_AUTOMATIC } { next := next+1 } 
			\modality{#allmodal}.. ...\endmodality(formula))
		\addprogvars(#ovar)
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating object variable destruction.	
	 */
	elimDestroy { 
		\find (\modality{#allmodal}.. destroy #ovar; ...\endmodality(formula)) 
		\sameUpdateLevel		
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 
			{ storage(objBlock(#ovar)) := ST_TRAP } 
			\modality{#allmodal}.. ...\endmodality(formula))
			\add(storage(objBlock(#ovar)) = ST_AUTOMATIC ==>);
		"Valid Destruction: #ovar" : \replacewith(undefinedBehavior(dummy)) \add(==> storage(objBlock(#ovar)) = ST_AUTOMATIC)
		\heuristics(simplify_prog)
	};	

	/**
	 * Eliminating malloc.	
	 */
	elimMalloc { 
		\find (\modality{#allmodal}.. #pvar = malloc(sizeof(#otype)); ...\endmodality(formula)) 
		\sameUpdateLevel		
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 
			{ #pvar := #ClangRepositoryAccess(next, #otype) } { storage(objBlock(#pvar)) := ST_ALLOCATED } { next := next+1 } 
			\modality{#allmodal}.. ...\endmodality(formula));
		"Out Of Memory: " : \replacewith ( 
			{ #pvar := null }
			\modality{#allmodal}.. ...\endmodality(formula))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating calloc.	
	 */
	elimCalloc { 
		\find ( \modality{#allmodal}.. #pvar = calloc(#isexp, sizeof(#otype)); ...\endmodality(formula)) 
		\sameUpdateLevel		
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith (
			{ #pvar := #ClangElemAccess(#ClangArrayRepositoryAccess(next, #ClangIntegerToInt(#isexp), #otype), 0) } 
			{ storage(objBlock(#ClangArrayRepositoryAccess(next, #ClangIntegerToInt(#isexp), #otype))) := ST_ALLOCATED } 
			{ next := next + 1 } 
			\modality{#allmodal}.. ...\endmodality(formula))
			\add(isValidVal(#isexp), #ClangIntegerToInt(#isexp) > 0 & #ClangIntegerToInt(#isexp) <= SIZE_T_MAX ==>);
		"Out Of Memory: " : \replacewith (
			{ #pvar := null }
			\modality{#allmodal}.. ...\endmodality(formula))
			\add(isValidVal(#isexp), #ClangIntegerToInt(#isexp) > 0 & #ClangIntegerToInt(#isexp) <= SIZE_T_MAX ==>);			
		"Valid size: #isexp" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp), #ClangIntegerToInt(#isexp) > 0 & #ClangIntegerToInt(#isexp) <= SIZE_T_MAX)
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating free.	
	 */
	elimFree { 
		\find (\modality{#allmodal}.. #ovar <- free(#psexp); ...\endmodality(formula)) 
		\sameUpdateLevel		
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : \replacewith ( 
				{ storage(objBlock(#psexp)) := ST_TRAP } 
				\modality{#allmodal}.. ...\endmodality(formula)
			)
		\add( #psexp != null, objExistsSaved(#psexp,storage(objBlock(#psexp))), objAliased(rootObj(#psexp), #psexp), storage(objBlock(#psexp)) = ST_ALLOCATED ==> );
		"If is null: #psexp = null" : \replacewith ( \modality{#allmodal}.. ...\endmodality(formula) ) \add( #psexp = null ==> );
		"Valid Destruction: #psexp" : \replacewith(undefinedBehavior(dummy)) \add( #psexp != null ==> objExists(#psexp), objExistsSaved(#psexp,storage(objBlock(#psexp))), storage(objBlock(#psexp)) = ST_ALLOCATED, objAliased(rootObj(#psexp), #psexp))
		\heuristics(simplify_prog)
	};
}