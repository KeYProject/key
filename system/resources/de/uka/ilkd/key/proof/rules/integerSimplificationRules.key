// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


\schemaVariables{

  \term int i,i0,i1,i2,i3,i4,j,j0,j1,t,t1,t2;
  \term[rigid] int ir, i0r;
  \variables int k, j2, c, nv ;
  \skolemTerm int sk, sk2 ;


  \term numbers iz, jz ;
  \formula b, psi, phi, post, inv;

  \term int commLeft, commRight;
  \term int distSummand0, distSummand1, distCoeff;
  \term int invertLeft, invertRight;
  \term int pullOutCommon, pullOutLeft, pullOutRight;
  \term int homoLeft, homoRight;
  \term int addAssocMono, addAssocPoly0, addAssocPoly1;
  \term int mulAssocAtom, mulAssocMono0, mulAssocMono1;
  \term int applyEqDividend, applyEqDivisor;
  \term[rigid] int applyEqDivisorr;
  \term int cpLeft1, cpLeft2, cpRight1, cpRight2;
  \term int esLeft, esRight1, esRight2, esCoeff1, esCoeff2;
  \term int sepPosMono, sepNegMono, sepResidue;
  \term int multLeft, multRight, multFac;
  \term int multFacLeft, multFacRight;
  \term int divX, divXBoundPos, divXBoundNonPos, divXBoundNeg, divXBoundNonNeg;
  \term int divY;
  \term int divProd, divProdBoundPos, divProdBoundNonPos;
  \term int divProdBoundNeg, divProdBoundNonNeg;
  \term int squareFac;
  \term int subsumLeft, subsumRightBigger, subsumRightSmaller,
            subsumCoeffBigger, subsumCoeffSmaller;
  \term int contradLeft, contradRightBigger, contradRightSmaller,
            contradCoeffBigger, contradCoeffSmaller;
  \term int strengthenLeft, strengthenRight;
  \term int splitEqLeft, splitEqRight;
  \term int signCasesLeft;
  \term int elimGcdLeft, elimGcdRight, elimGcd;

  \term int elimGcdLeftDiv, elimGcdRightDiv;
  \term int divNum, divDenom, polyDivCoeff;
  \term int modNumLeft, modNumRight, modDenom;
  \term int newSymLeft, newSymLeftCoeff, newSymRight, newSymDef;
  \skolemTerm int l, quotient;
  \term int applyEqLeft, applyEqRight, applyEqOther;
  \term int tautLeft, tautRightBigger, tautRightSmaller;
  \term int weakenLeft, weakenRightSmaller, weakenRightBigger;
  \term int antiSymmLeft, antiSymmRightSmaller, antiSymmRightBigger;
  \term int aePseudoLeft, aePseudoLeftCoeff, aePseudoRight;
  \term int aePseudoTargetLeft, aePseudoTargetRight, aePseudoTargetFactor;

  // attention strategy depends on this var.name
  \term int castedTerm;

  \variables int uSub, uSub1, uSub2;
  \term int tInt;
}

\rules {

//--------------------------------------------------------------------
// some of these taclets are from Isabelle theory IntArith
//--------------------------------------------------------------------

 //reviewed 04/16/2004, St.S.
  less_iff_diff_less_0  {\find (lt(i0,i1)) \replacewith (lt(sub(i0,i1),0)) };

 //reviewed 04/16/2004, St.S.
  leq_iff_diff_leq_0    {\find (leq(i0,i1)) \replacewith (leq(sub(i0,i1),0))};

 //reviewed 04/16/2004, St.S.
  minus_distribute_1 { \find (neg(add(i,i1))) \replacewith (add(neg(i),neg(i1))) 
	\displayname "minus_distribute"};
 //reviewed 04/16/2004, St.S.
  minus_distribute_2 { \find (neg(sub(i,i1))) \replacewith (add(neg(i),i1)) 
	\displayname "minus_distribute"};

 //reviewed 04/16/2004, St.S.
  left_add_mult_distrib {\find (add( mul(i0,i1), add(mul(i2,i1),i3) ) ) 
                           \replacewith (add(mul(add(i0,i2), i1), i3)) };

 //reviewed 04/16/2004, St.S.
  eq_add_iff1            {\find ( add(mul(i0,i1),i2)=add(mul(i3,i1),i4) ) 
                           \replacewith (add(mul(sub(i0,i3),i1),i2)=i4) };

 //reviewed 04/16/2004, St.S.
  eq_add_iff2            {\find (add(mul(i0,i1),i2)=add(mul(i3,i1),i4)) 
                           \replacewith (i2=add(mul(sub(i3,i0),i1),i4)) };

 //reviewed 04/16/2004, St.S.
  less_add_iff1          {\find (lt(add(mul(i0,i1),i2),add(mul(i3,i1),i4))) 
                           \replacewith (lt(add(mul(sub(i0,i3),i1),i2),i4)) };

 //reviewed 04/16/2004, St.S.
  less_add_iff2          {\find (lt(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
                           \replacewith (lt(i2,add(mul(sub(i3,i0),i1),i4))) };

 //reviewed 04/16/2004, St.S.
  leq_add_iff1           {\find (leq(add(mul(i0,i1),i2),add(mul(i3,i1),i4))) 
                           \replacewith (leq(add(mul(sub(i0,i3),i1),i2),i4)) };

 //reviewed 04/16/2004, St.S.
  leq_add_iff2           {\find (leq(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
                           \replacewith (leq(i2,add(mul(sub(i3,i0),i1),i4))) };

 //reviewed 04/16/2004, St.S.
  leq_diff1_eq           {\find (leq(i0,sub(i1,1))) 
                           \replacewith (lt(i0,i1)) };

 //reviewed 04/16/2004, St.S.
  le1_add1_eq_le         {\find (lt(i0,add(i1,1))) 
                           \replacewith (leq(i0,i1)) };

 //reviewed 04/16/2004, St.S.
  zadd_left_cancel0      {\find (i0=add(i0,i1)) \replacewith (i1=0) };

 //reviewed 04/16/2004, St.S.
  int_diff_minus_eq      {\find (sub(i0,neg(i1))) \replacewith (add(i0,i1)) };

 //reviewed 04/16/2004, St.S.
  mult_pos               {\find (lt(0,i0) & lt(0,i1)) 
                           \replacewith (lt(0,mul(i0,i1))) };

 //reviewed 04/16/2004, St.S.
  mult_neg               {\find (lt(i0,0) & lt(i1,0)) 
                           \replacewith (lt(0,mul(i0,i1))) };

 //reviewed 04/16/2004, St.S.
  mult_pos_neg           {\find (lt(i0,0) & lt(0,i1)) 
                           \replacewith (lt(mul(i0,i1),0)) };

 //reviewed 04/16/2004, St.S.
  zero_less_mult_iff        {\find (lt(0, mul(i0,i1))) 
                           \replacewith (lt(0,i0) & lt(0,i1) | lt(i0,0) & lt(i1,0)) 
                           };

 //reviewed 04/16/2004, St.S.  
  zero_leq_mult_iff         {\find (leq(0,mul(i0,i1))) 
                           \replacewith (leq(0,i0) & leq(0,i1) | leq(i0,0) & leq(i1,0)) 
                           };

 //reviewed 04/16/2004, St.S.
  mult_less_0_iff        {\find (lt(mul(i0,i1),0)) 
                           \replacewith (lt(i0,0) & lt(0,i1) | lt(0,i0) & lt(i1,0)) 
                           };

 //reviewed 04/16/2004, St.S.
  mult_leq_0_iff         {\find ( leq(mul(i0,i1),0) )
                           \replacewith (leq(i0,0) & leq(0,i1) | leq(0,i0) & leq(i1,0)) 
                           };

  //reviewed 04/16/2004, St.S.
  square_nonneg          {\find (leq(0,mul(i0,i0))) \replacewith (true) };

  //reviewed 04/16/2004, St.S.
  mult_eq_self_iff       {\find (i0=mul(i0,i1)) \replacewith (i0=0 | i1=1) 
                           };

  //reviewed 04/16/2004, St.S.
  less_1_mult            {\find (lt(1,i0) & lt(1,i1)) 
                           \replacewith (lt(1,mul(i0,i1))) };

  //reviewed 04/16/2004, St.S.
  pos_mult_eq_1_iff      {\find (lt(0,i0) -> mul(i0,i1)=1 )
                           \replacewith (i0=1 & i1=1) };

  //reviewed 04/16/2004, St.S.
  mult_eq_1_iff          {\find (mul(i0,i1)=1) 
                           \replacewith (i0=1 & i1=1| i0=Z(neglit(1(#))) & i1=Z(neglit(1(#))))
                           };

  //reviewed 04/16/2004, St.S.
  multiply_distribute_1    {\find (mul(add(i0,i1),add(j0,j1))) \replacewith 
                           (add( add(mul(i0,j0),mul(i0,j1)), add(mul(i1,j0),mul(i1,j1)) ))                            
                            \displayname "multiply_distribute"};                           

 //reviewed 04/16/2004, St.S.
 multiply_distribute_2    {\find (mul(add(i0,i1),sub(j0,j1))) \replacewith 
                           (add( sub(mul(i0,j0),mul(i0,j1)), sub(mul(i1,j0),mul(i1,j1)) ))                            
                            \displayname "multiply_distribute"};

 //reviewed 04/16/2004, St.S.
 multiply_distribute_3    {\find (mul(sub(i0,i1),sub(j0,j1))) \replacewith 
                           (add( sub(mul(i0,j0),mul(i0,j1)), sub(mul(i1,j1),mul(i1,j0)) ))                            
                            \displayname "multiply_distribute"};                           

 //reviewed 12/21/2004, St.S.
   mul_distribute_4 {
	\find ( mul(i0, add(i1,i2)) ) \replacewith( add(mul(i0,i1), mul(i0,i2)))
                            \displayname "multiply_distribute"
   };

 //reviewed 12/21/2004, St.S.
   mul_distribute_5 {
	\find ( mul( add(i1,i2), i0) ) \replacewith( add(mul(i0,i1), mul(i0,i2)))
                            \displayname "multiply_distribute"
   };

 //reviewed 12/21/2004, St.S.
   theorem_of_archimedes {
        \assumes (gt(i0,sub(i1,1)) ==>) \find (lt(i0,i1) ==> ) \replacewith (false ==>) 
   };


 //reviewed 04/16/2004, St.S.
  collect_same_terms_1          {\find (add(mul(i,j),mul(i,j))) 
                           \replacewith (mul(2,mul(i,j)))                           
                           \displayname "collect_same_terms"};                           

 //reviewed 04/16/2004, St.S.
  collect_same_terms_2          {\find (add(add(mul(i,j),mul(i0,i1)),add(mul(i,j),mul(j0,j1)))) 
                           \replacewith (add(mul(2,mul(i,j)),add(mul(i0,i1),mul(j0,j1))))                           
                           \displayname "collect_same_terms"};

 //reviewed 04/16/2004, St.S.
  collect_same_terms_3          {\find (add( add(neg(mul(i,j)),mul(i0,i1)), add(neg(mul(i,j)),mul(j0,j1)))) 
                           \replacewith (add(neg(mul(2,mul(i,j))), add(mul(i0,i1), mul(j0,j1))))                           
                           \displayname "collect_same_terms"};

 //reviewed 04/16/2004, St.S.
  addition_associative   {\find ( add(add(i0,i1),add(j0,j1)) ) 
                           \replacewith ( add(add(j0,i1),add(i0,j1)) ) };

 //reviewed 04/16/2004, St.S.
  leq_add_one                {\find (leq(i0,i1)) \replacewith (leq(add(i0,1),add(i1,1)))
			   };

 //reviewed 04/16/2004, St.S.
  less_add_one               {\find (lt(i0,i1)) \replacewith (lt(add(i0,1),add(i1,1)))
			   };

 //reviewed 04/16/2004, St.S.
  geq_add_one                {\find (geq(i0,i1)) \replacewith (geq(add(i0,1),add(i1,1)))
			   };

 //reviewed 04/16/2004, St.S.
  greater_add_one            {\find (gt(i0,i1)) \replacewith (gt(add(i0,1),add(i1,1)))
			   };
 //reviewed 04/16/2004, St.S.
  equal_add_one              {\find (i0=i1) \replacewith (add(i0,1)=add(i1,1))
			   };


 //reviewed 04/16/2004, St.S.
  leq_add                {\find (==> leq(i0,i1)) \varcond(\notFreeIn(j2,i0,i1)) \replacewith (==> \exists j2; leq(add(i0,j2),add(i1,j2)))
			   };

 //reviewed 04/16/2004, St.S.
  less_add               {\find (==> lt(i0,i1)) \varcond(\notFreeIn(j2,i0,i1)) \replacewith (==> \exists j2; lt(add(i0,j2),add(i1,j2)))
			   };

 //reviewed 04/16/2004, St.S.
  geq_add                {\find (==> geq(i0,i1)) \varcond(\notFreeIn(j2,i0,i1)) \replacewith (==> \exists j2; geq(add(i0,j2),add(i1,j2)))
			   };

 //reviewed 04/16/2004, St.S.
  greater_add            {\find (==> gt(i0,i1)) \varcond(\notFreeIn(j2,i0,i1)) \replacewith (==> \exists j2; gt(add(i0,j2),add(i1,j2)))
			   };

 //reviewed 04/16/2004, St.S.
  equal_add              {\find (==> i0=i1) \varcond(\notFreeIn(j2,i0,i1)) \replacewith (==> \exists j2; add(i0,j2)=add(i1,j2))
			   };

 //reviewed 04/16/2004, St.S.  
  leq_diff_1             { \find (leq(i0,add(i0,1))) \replacewith (true)
			   \heuristics (int_arithmetic)};

 //reviewed 04/16/2004, St.S.  
  lt_diff_1              { \find (lt(i0,add(i0,1))) \replacewith (true)
			   \heuristics (int_arithmetic)};

 //reviewed 04/16/2004, St.S.  
  geq_diff_1             { \find (geq(add(i0,1),i0)) \replacewith (true)
			   \heuristics (int_arithmetic)};

 //reviewed 04/16/2004, St.S.  
  gt_diff_1              { \find (gt(add(i0,1),i0)) \replacewith (true)
			   \heuristics (int_arithmetic)};



 //reviewed 04/16/2004, St.S.  
  i_minus_i_is_zero { \find (sub(i,i)) \replacewith (0) };

 //reviewed 04/16/2004, St.S.  
  add_two_inequations_1 { \assumes (lt(i,i0)==>) \find (lt(j,j0)==>) \add (lt(add(i,j),add(i0,j0))==>)};
 //reviewed 04/16/2004, St.S.  
  add_two_inequations_2 { \assumes (leq(i,i0)==>) \find (leq(j,j0)==>) \add (leq(add(i,j),add(i0,j0))==>)};

 //reviewed 04/16/2004, St.S.  
 partition_inequation { \assumes (==>lt(i,i0)) \find (lt(i,i1)==>) \add (==>lt(i1, i0)) };

  //reviewed 04/16/2004, St.S.  
  eq_sides { \find (i=j) \replacewith ( sub(i,j)=0 ) };


  //reviewed 04/15/2004, St.S.
  times_one_1 {\find (mul(i,1)) \replacewith (i)
               \displayname "times_one"};
  //reviewed 04/15/2004, St.S.
  times_one_2 {\find (mul(1,i)) \replacewith (i)
               \displayname "times_one"};
  //reviewed 04/15/2004, St.S.
  times_minus_one_1 {\find (mul(i,-1)) \replacewith (neg(i))
                     \displayname "times_minus_one"};
  //reviewed 04/15/2004, St.S.
  times_minus_one_2 {\find (mul(-1,i)) \replacewith (neg(i))
                     \displayname "times_minus_one"};
  //reviewed 04/15/2004, St.S.
  times_zero_1 {\find (mul(i,0)) 
  		\replacewith (0) 
  		\heuristics (simplify_literals)
                \displayname "times_zero"};
  //reviewed 04/15/2004, St.S.
  times_zero_2 {\find (mul(0,i)) \replacewith (0) \heuristics (simplify_literals)
                \displayname "times_zero"};


  //reviewed 04/15/2004, St.S.
  leq_to_gt { \find (leq(i,j)) \replacewith(!gt(i,j)) };

  //reviewed 04/15/2004, St.S.
  geq_to_lt { \find (geq(i,j)) \replacewith(!lt(i,j)) };

  //reviewed 04/15/2004, St.S.
  leq_to_gt_alt {\find (leq(i,j)) \replacewith(lt(i,j) | i=j) };

  //reviewed 04/15/2004, St.S.
  geq_to_lt_alt {\find (geq(i,j)) \replacewith(gt(i,j) | i=j) };


  //reviewed 04/15/2004, St.S.
  greater { \find (gt(i, i0)) \replacewith (lt(i0, i)) };
 
  //reviewed 04/15/2004, St.S.
  less_is_total_heu { \assumes (==> lt(i, i0), (i = i0), lt(i0, i)) \closegoal };
  //reviewed 04/15/2004, St.S.
  less_is_total { \find (i) \sameUpdateLevel \add (lt(i, i0) ==>); \add ((i = i0) ==>); \add (lt(i0, i) ==>) };
  //reviewed 04/15/2004, St.S.
  less_zero_is_total { \find (i) \sameUpdateLevel \add (lt(i, 0) ==>); \add (i = 0 ==>); \add (lt(0, i) ==>) };

  //reviewed 04/15/2004, St.S.
  less_is_alternative_1 { \assumes (lt(i, i0), lt(i0, i) ==>) \closegoal };
  //reviewed 04/15/2004, St.S.
  less_is_alternative_2 { \assumes (==> lt(i, i0)) \find (==> lt(i0, i)) \add ((i = i0) ==>) };

  //reviewed 04/15/2004, St.S.
  less_trans{ \assumes (lt(i, i0) ==>) \find (lt(i0, i1) ==>) \add (lt(i, i1) ==>)};
  //reviewed 04/15/2004, St.S.
  leq_trans{ \assumes (leq(i, i0) ==>) \find (leq(i0, i1) ==>) \add (leq(i, i1) ==>) };

  //reviewed 04/15/2004, St.S.
  less_neg { \find (lt(i, i0)) \replacewith (!(lt(i0, i+1))) };

  //reviewed 04/15/2004, St.S.
  less_base { \find (lt(i, i)) \replacewith (false) };

  //reviewed 04/15/2004, St.S.
  add_zero_left  { \find (add(0, i)) \replacewith (i) \heuristics (simplify_literals) };
  //reviewed 04/15/2004, St.S.
  add_zero_right { \find (add(i, 0)) \replacewith (i) \heuristics (simplify_literals) };

  //reviewed 04/15/2004, St.S.
  switch_brackets { \find (add(add(i, i0), i1)) \replacewith(add(i, add(i0, i1))) };
  //reviewed 04/15/2004, St.S.
  switch_params { \find (add(i0, i1))  \replacewith(add(i1, i0)) };

  //reviewed 04/15/2004, St.S.
  mul_assoc { \find (mul(mul(i, i0), i1)) \replacewith(mul(i, mul(i0, i1))) };
  //reviewed 04/15/2004, St.S.
  mul_comm  { \find (mul(i0, i1)) \replacewith(mul(i1, i0)) };

  //reviewed 04/15/2004, St.S.
  pull_out_neg_1  { \find (mul(neg(i0), i1)) \replacewith(neg(mul(i0, i1))) \displayname "pull_out_minus" };
  //reviewed 04/15/2004, St.S.
  pull_out_neg_2  { \find (mul(i0, neg(i1))) \replacewith(neg(mul(i0, i1))) \displayname "pull_out_minus"};

  //reviewed 04/15/2004, St.S.
  rotate_params { \find (add(i, add(i0, i1))) \replacewith(add(i0, add(i, i1))) };

  // TODO: review;  added 04/19/05 RB
  add_equations { \assumes (i = i0==>) \find (j = j0 ==>) \add (add(i,j) = add(i0,j0)==>)};
  add_equations_right { \assumes (i = i0==>) \find (==> j = j0) \add (==> add(i,j) = add(i0,j0))};

  sub_equations_left { \assumes (i = i0==>) \find (j = j0 ==>) \add (sub(j,i) = sub(j0,i0)==>)};
  sub_equations_right { \assumes (i = i0==>) \find (==> j = j0) \add (==> sub(j,i) = sub(j0,i0))};

  //reviewed 04/15/2004, St.S.
  add_eq { \find (i0 = i1) \replacewith(add(i, i0) = add(i, i1)) };

  //reviewed 04/15/2004, St.S.
  add_eq_back { 
	\find (add(i1, i) = add(i1, i0)) 
	\replacewith(i = i0)
  };

  // new, not reviewed but proven: see ../proof/rules/proven_rules/add_eq_back_2.proof
  add_eq_back_2 { 
	\find (add(i, i1) = add(i0, i1)) 
	\replacewith(i = i0) 
	\displayname "add_eq_back"
  };

  // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_eq_back_2_fst_comm.proof
  add_eq_back_2_fst_comm { 
	\find (add(i1, i) = add(i0, i1)) 
	\replacewith(i = i0) 
	\displayname "add_eq_back"
  };

  // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_eq_back_3.proof
  add_eq_back_3 { 
	\find (i1 = add(i1, i0)) 
	\replacewith (0 = i0) 
	\displayname "add_eq_back"
  };

  //reviewed 04/15/2004, St.S.
  add_less { \find (lt(i, i0)) \replacewith(lt(add(i1, i), add(i1, i0))) };

  //reviewed 04/15/2004, St.S.
  add_less_back { 
	\find (lt(add(i1, i), add(i1, i0))) 
	\replacewith(lt(i, i0)) 
  };

  //reviewed 04/15/2004, St.S.
  add_less_back_zero_1 { 
	\find (lt(i,add(i,i1))) 
	\replacewith(lt(0,i1)) 
	\displayname "add_less_back"
  };

  // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_less_back_zero_1_comm.proof
  add_less_back_zero_1_comm { 
	\find (lt(i,add(i1,i))) 
	\replacewith(lt(0,i1)) 
	\displayname "add_less_back"
  };

  //reviewed 04/15/2004, St.S.
  add_less_back_zero_2 { 
	\find (lt(add(i,i1),i)) 
	\replacewith(lt(i1,0)) 
	\displayname "add_less_back"
  };

  // new, not reviewed, but proven: see ../proof/rules/proven_rules/add_less_back_zero_2_comm.proof
  add_less_back_zero_2_comm { 
	\find (lt(add(i1,i),i)) 
	\replacewith(lt(i1,0)) 
	\displayname "add_less_back"
  };
 

  //reviewed 04/15/2004, St.S.
  sub { \find (sub(i, i0)) \replacewith (add(i, neg(i0))) };
  //reviewed 04/15/2004, St.S.
  sub_zero_1 { \find (Z(neglit(0(#)))) \replacewith (Z(0(#)))
               \heuristics(simplify_literals) };
  //reviewed 04/15/2004, St.S.
  sub_zero_2 { \find (sub(i,0)) \replacewith (i) };
  //reviewed 04/15/2004, St.S.
  add_sub_elim_left  { \find (add(neg(i), i)) \replacewith (0) };
  //reviewed 04/15/2004, St.S.
  add_sub_elim_right { \find (add(i, neg(i))) \replacewith (0) };
  //reviewed 04/15/2004, St.S.
  add_sub_step { \find (add(neg(i), neg(i0))) \replacewith (neg(add(i, i0))) };
  //reviewed 04/15/2004, St.S.
  sub_sub_elim { \find (neg(neg(i))) \replacewith (i) };
  //reviewed 04/15/2004, St.S.
  less_sub { \find (lt(i, i0)) \replacewith (lt(neg(i0), neg(i))) };

  //reviewed 04/15/2004, St.S.
  less_plus { \find (lt(0, add(i0, i1))) \replacewith(lt(neg(i0),i1)) };

  //reviewed 04/15/2004, St.S.
  close_by_lt_leq { \assumes (lt (i,j) ==>) 
           \find (==> leq(add(i,1), j) )
           \replacewith (==> true) };

  //reviewed 04/15/2004, St.S.
  lt_to_leq_1 {\find (lt(i,j)|i=j) \replacewith (leq(i,j))};

  //reviewed 04/15/2004, St.S.
  lt_to_leq_2 { \assumes (==> lt(i,j)) 
              \find (==> i=j) 
              \replacewith (==> leq(i,j))};

  //reviewed 04/15/2004, St.S.
  lt_to_gt {\find (lt(i,i0)) \replacewith (gt(i0,i))};
  //reviewed 04/15/2004, St.S.
  gt_to_lt {\find (gt(i,i0)) \replacewith (lt(i0,i))};
  //reviewed 04/15/2004, St.S.
  leq_to_geq {\find (leq(i,i0)) \replacewith (geq(i0,i))};
  //reviewed 04/15/2004, St.S.
  geq_to_leq {\find (geq(i,i0)) \replacewith (leq(i0,i))};



// -------------------------------------------------------
// ------------- Rules for integer literals --------------
// -------------------------------------------------------

  //reviewed 04/20/2004, St.S.
  double_unary_minus_literal { \find (Z(neglit(neglit(iz)))) 
	  \replacewith (Z(iz)) 
	  \heuristics (simplify_literals)
	  \displayname "double_unary_minus"};


 //reviewed 04/16/2004, St.S.  
  charLiteral_to_int {\find (C(iz)) \replacewith (Z(iz)) \heuristics (charLiteral_to_intLiteral)};
  
 //reviewed 04/15/2004, St.S.
  add_literals {\find (add(Z(iz),Z(jz)))        
    \replacewith (#add(Z(iz),Z(jz)))
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
  sub_literals {\find (sub(Z(iz),Z(jz)))   
    \replacewith (#sub(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
  mul_literals {\find (mul(Z(iz),Z(jz))) 
    \replacewith (#mul(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
   div_literals {\find (div(Z(iz),Z(jz)))     
    \replacewith (#div(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
   less_literals {\find (lt(Z(iz),Z(jz)))   
    \replacewith (#less(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
   greater_literals {\find (gt(Z(iz),Z(jz)))   
    \replacewith (#greater(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
   leq_literals {\find (leq(Z(iz),Z(jz)))   
    \replacewith (#leq(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
   qeq_literals {\find (geq(Z(iz),Z(jz)))   
    \replacewith (#geq(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
   equal_literals {\find (Z(iz)=Z(jz))  
    \replacewith (#eq(Z(iz),Z(jz)))
    \heuristics (simplify_literals)};

 //reviewed 04/15/2004, St.S.
  neg_literal { \find (neg(Z(iz))) 
    \replacewith (Z(neglit(iz))) 
    \heuristics (simplify_literals)};
}

// ---------------------------------------------------------
// - multiply both sides of an (in)equation with some term -
// ---------------------------------------------------------

\rules(integerSimplificationRules:full){
  multiply_inEq0 { \find ( multLeft <= multRight ==> )
                   \add ( \if (multFac >= 0)
                          \then (multLeft * multFac <= multRight * multFac)
                          \else (multLeft * multFac >= multRight * multFac) ==> ) };

  multiply_inEq1 { \find ( multLeft >= multRight ==> )
                   \add ( \if (multFac >= 0)
                          \then (multLeft * multFac >= multRight * multFac)
                          \else (multLeft * multFac <= multRight * multFac) ==> ) };

  multiply_eq    { \find ( multLeft = multRight ==> )
                   \add ( multLeft * multFac = multRight * multFac ==> ) };

  multiply_2_inEq0 { \assumes ( multFacLeft <= multFacRight ==> )
                     \find ( multLeft <= multRight ==> )
                     \add ( multLeft * multFacLeft >=
                            - multRight * multFacRight
                            + multRight * multFacLeft
                            + multLeft * multFacRight ==> )
                     \heuristics (inEqSimp_nonLin,
                                  inEqSimp_nonLin_multiply) };

  multiply_2_inEq1 { \assumes ( multFacLeft >= multFacRight ==> )
                     \find ( multLeft <= multRight ==> )
                     \add ( multLeft * multFacLeft <=
                            - multRight * multFacRight
                            + multRight * multFacLeft
                            + multLeft * multFacRight ==> )
                     \heuristics (inEqSimp_nonLin,
                                  inEqSimp_nonLin_multiply) };

  multiply_2_inEq2 { \assumes ( multFacLeft <= multFacRight ==> )
                     \find ( multLeft >= multRight ==> )
                     \add ( multLeft * multFacLeft <=
                            - multRight * multFacRight
                            + multRight * multFacLeft
                            + multLeft * multFacRight ==> )
                     \heuristics (inEqSimp_nonLin,
                                  inEqSimp_nonLin_multiply) };

  multiply_2_inEq3 { \assumes ( multFacLeft >= multFacRight ==> )
                     \find ( multLeft >= multRight ==> )
                     \add ( multLeft * multFacLeft >=
                            - multRight * multFacRight
                            + multRight * multFacLeft
                            + multLeft * multFacRight ==> )
                     \heuristics (inEqSimp_nonLin,
                                  inEqSimp_nonLin_multiply) };




  divide_inEq0 { \assumes ( divX >= divXBoundPos ==> )
                 \find ( divProd <= divProdBoundNonNeg ==> )
                 \add ( divProd = divX * divY ->
                        divXBoundPos >= 1 ->
                        divProdBoundNonNeg >= 0 ->
                        divY <= divProdBoundNonNeg / divXBoundPos ==> )
                 \heuristics (inEqSimp_special_nonLin,
                              inEqSimp_nonLin_divide) };

  divide_inEq1 { \assumes ( divX >= divXBoundNonNeg ==> )
                 \find ( divProd <= divProdBoundNeg ==> )
                 \add ( divProd = divX * divY ->
                        divXBoundNonNeg >= 0 ->
                        divProdBoundNeg <= -1 ->
                        divY <= -1 ==> )
                 \heuristics (inEqSimp_special_nonLin,
                              inEqSimp_nonLin_neg) };

  divide_inEq2 { \assumes ( divX >= divXBoundPos ==> )
                 \find ( divProd >= divProdBoundNonPos ==> )
                 \add ( divProd = divX * divY ->
                        divXBoundPos >= 1 ->
                        divProdBoundNonPos <= 0 ->
                        divY >= ( divProdBoundNonPos + divXBoundPos - 1 )
                                / divXBoundPos ==> )
                 \heuristics (inEqSimp_special_nonLin,
                              inEqSimp_nonLin_divide) };

  divide_inEq3 { \assumes ( divX >= divXBoundNonNeg ==> )
                 \find ( divProd >= divProdBoundPos ==> )
                 \add ( divProd = divX * divY ->
                        divXBoundNonNeg >= 0 ->
                        divProdBoundPos >= 1 ->
                        divY >= 1 ==> )
                 \heuristics (inEqSimp_special_nonLin,
                              inEqSimp_nonLin_pos) };

  divide_inEq4 { \assumes ( divX <= divXBoundNeg ==> )
                 \find ( divProd >= divProdBoundNonPos ==> )
                 \add ( divProd = divX * divY ->
                        divXBoundNeg <= -1 ->
                        divProdBoundNonPos <= 0 ->
                        divY <= divProdBoundNonPos / divXBoundNeg ==> )
                 \heuristics (inEqSimp_special_nonLin,
                              inEqSimp_nonLin_divide) };

  divide_inEq5 { \assumes ( divX <= divXBoundNonPos ==> )
                 \find ( divProd >= divProdBoundPos ==> )
                 \add ( divProd = divX * divY ->
                        divXBoundNonPos <= 0 ->
                        divProdBoundPos >= 1 ->
                        divY <= -1 ==> )
                 \heuristics (inEqSimp_special_nonLin,
                              inEqSimp_nonLin_neg) };

  divide_inEq6 { \assumes ( divX <= divXBoundNeg ==> )
                 \find ( divProd <= divProdBoundNonNeg ==> )
                 \add ( divProd = divX * divY ->
                        divXBoundNeg <= -1 ->
                        divProdBoundNonNeg >= 0 ->
                        divY >= divProdBoundNonNeg / divXBoundNeg ==> )
                 \heuristics (inEqSimp_special_nonLin,
                              inEqSimp_nonLin_divide) };

  divide_inEq7 { \assumes ( divX <= divXBoundNonPos ==> )
                 \find ( divProd <= divProdBoundNeg ==> )
                 \add ( divProd = divX * divY ->
                        divXBoundNonPos <= 0 ->
                        divProdBoundNeg <= -1 ->
                        divY >= 1 ==> )
                 \heuristics (inEqSimp_special_nonLin,
                              inEqSimp_nonLin_pos) };

  divide_eq0 { \assumes ( divX >= divXBoundPos ==> )
               \find ( divProd = divProdBoundNonNeg ==> )
               \add ( divProd = divX * divY ->
                      divXBoundPos >= 1 ->
                      divProdBoundNonNeg >= 0 ->
                      divY <= divProdBoundNonNeg / divXBoundPos ==> )
               \heuristics (inEqSimp_special_nonLin,
                            inEqSimp_nonLin_divide) };

  divide_eq1 { \assumes ( divX >= divXBoundNonNeg ==> )
               \find ( divProd = divProdBoundNeg ==> )
               \add ( divProd = divX * divY ->
                      divXBoundNonNeg >= 0 ->
                      divProdBoundNeg <= -1 ->
                      divY <= -1 ==> )
               \heuristics (inEqSimp_special_nonLin,
                            inEqSimp_nonLin_neg) };

  divide_eq2 { \assumes ( divX >= divXBoundPos ==> )
               \find ( divProd = divProdBoundNonPos ==> )
               \add ( divProd = divX * divY ->
                      divXBoundPos >= 1 ->
                      divProdBoundNonPos <= 0 ->
                      divY >= ( divProdBoundNonPos + divXBoundPos - 1 )
                              / divXBoundPos ==> )
               \heuristics (inEqSimp_special_nonLin,
                            inEqSimp_nonLin_divide) };

  divide_eq3 { \assumes ( divX >= divXBoundNonNeg ==> )
               \find ( divProd = divProdBoundPos ==> )
               \add ( divProd = divX * divY ->
                      divXBoundNonNeg >= 0 ->
                      divProdBoundPos >= 1 ->
                      divY >= 1 ==> )
               \heuristics (inEqSimp_special_nonLin,
                            inEqSimp_nonLin_pos) };

  divide_eq4 { \assumes ( divX <= divXBoundNeg ==> )
               \find ( divProd = divProdBoundNonPos ==> )
               \add ( divProd = divX * divY ->
                      divXBoundNeg <= -1 ->
                      divProdBoundNonPos <= 0 ->
                      divY <= divProdBoundNonPos / divXBoundNeg ==> )
               \heuristics (inEqSimp_special_nonLin,
                            inEqSimp_nonLin_divide) };

  divide_eq5 { \assumes ( divX <= divXBoundNonPos ==> )
               \find ( divProd = divProdBoundPos ==> )
               \add ( divProd = divX * divY ->
                      divXBoundNonPos <= 0 ->
                      divProdBoundPos >= 1 ->
                      divY <= -1 ==> )
               \heuristics (inEqSimp_special_nonLin,
                            inEqSimp_nonLin_neg) };

  divide_eq6 { \assumes ( divX <= divXBoundNeg ==> )
               \find ( divProd = divProdBoundNonNeg ==> )
               \add ( divProd = divX * divY ->
                      divXBoundNeg <= -1 ->
                      divProdBoundNonNeg >= 0 ->
                      divY >= divProdBoundNonNeg / divXBoundNeg ==> )
               \heuristics (inEqSimp_special_nonLin,
                            inEqSimp_nonLin_divide) };

  divide_eq7 { \assumes ( divX <= divXBoundNonPos ==> )
               \find ( divProd = divProdBoundNeg ==> )
               \add ( divProd = divX * divY ->
                      divXBoundNonPos <= 0 ->
                      divProdBoundNeg <= -1 ->
                      divY >= 1 ==> )
               \heuristics (inEqSimp_special_nonLin,
                            inEqSimp_nonLin_pos) };
}


// ##########################################################################################################
// ------------- integer induction rules    --------------
// ##########################################################################################################

\rules{
  //reviewed 04/15/2004, St.S.
  int_induction { "Base Case": \add ( ==> {\subst nv; 0}(b) );
                  "Step Case": \add ( ==> \forall nv ; ((geq(nv,0) & b)->{\subst nv; (nv + 1)}b) );
                  "Use Case":  \add ( \forall nv; (geq(nv,0) -> b) ==>) };
}

// -------------------------------------------------------------------------------------
// Automatic induction rules. Ch.G.
// Universal quantification in the succedent
// -------------------------------------------------------------------------------------

\rules(integerSimplificationRules:full){

//basic pattern, 
  auto_int_induction_geqZero { 
      \find (==> \forall uSub; b )    \varcond ( \new(sk, \dependingOn(b)) )
      "Base Case": \replacewith ( ==> {\subst uSub; 0}b );
      "Step Case": \replacewith ( ==> ((geq(sk,0) & {\subst uSub; sk}b)->
                                                    {\subst uSub; sk + 1}b) )
      \displayname "auto_induction"
  };

// -------------------------------------------------------------------------------------
//auto induction for: variable greater or equal to some term
  auto_int_induction_geq_1 { 
      \find (==> \forall uSub; (t<=uSub -> b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}b, true) );
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

  auto_int_induction_geq_2 { 
      \find (==> \forall uSub; (t>uSub | b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

  auto_int_induction_geq_3 { 
      \find (==> \forall uSub; (uSub<t | b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

//auto induction for: variable greater or equal to some term and a second bound psi

  auto_int_induction_geq_5 { 
      \find (==> \forall uSub; ((t>uSub | psi) | b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}(psi|b), true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}(psi|b))->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}(psi|b), true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

  auto_int_induction_geq_6 { 
      \find (==> \forall uSub; ((uSub<t | psi) | b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}(psi|b), true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}(psi|b))->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}(psi|b), true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

// -------------------------------------------------------------------------------------
//auto induction for: variable greater than some term
  auto_int_induction_gt_1 { 
      \find (==> \forall uSub; (t < uSub -> b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}b, true) );
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

  auto_int_induction_gt_2 { 
      \find (==> \forall uSub; (t>=uSub | b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

  auto_int_induction_gt_3 { 
      \find (==> \forall uSub; (uSub<=t | b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

//auto induction for: variable greater than some term and a second bound psi

  auto_int_induction_gt_5 { 
      \find (==> \forall uSub; ((t>=uSub | psi) | b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}(psi|b), true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}(psi|b))->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}(psi|b), true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

  auto_int_induction_gt_6 { 
      \find (==> \forall uSub; ((uSub<=t | psi) | b) )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}(psi|b), true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}(psi|b))->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}(psi|b), true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

// -------------------------------------------------------------------------------------
// Automatic induction rules and lemma generation rule. The inductively proved formula is 
//  used as a lemma for consecutive formulas in a conjunction. Ch.G.
// -------------------------------------------------------------------------------------

//basic pattern
  autoInduct_Lemma { 
      \find (==> (\forall uSub; b) & phi )   \varcond ( \new(sk, \dependingOn(b)) )
      "Base Case": \replacewith ( ==> {\subst uSub; 0}b );
      "Step Case": \replacewith ( ==> ((geq(sk,0) & {\subst uSub; sk}b)->
                                                    {\subst uSub; sk + 1}b) );
      "Use Case": \replacewith ( \forall uSub;  b ==> phi) 
  };

  

//---------------------------------------------------------------------------------------------------------------------------------  
//auto induction for: variable greater or equal to some term
  autoInductGEQ_Lemma_1 { 
      \find (==> (\forall uSub; (t<=uSub -> b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}b, true) );
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; t + (sk + 1)}b, true)) );
      "Use Case": \replacewith ( \forall uSub; (t<=uSub -> b) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

  autoInductGEQ_Lemma_2 { 
      \find (==> (\forall uSub; (t>uSub | b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)) );
      "Use Case": \replacewith ( \forall uSub; (t<=uSub -> b) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

  autoInductGEQ_Lemma_3 { 
      \find (==> (\forall uSub; (uSub<t | b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)) );
      "Use Case": \replacewith ( \forall uSub; (t<=uSub -> b) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

//auto induction for: variable greater or equal to some term and a second bound psi.

  autoInductGEQ_Lemma_5 { 
      \find (==> (\forall uSub; ((t>uSub | psi) | b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}(psi|b), true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}(psi|b))->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi|b), true)) );
      "Use Case": \replacewith ( \forall uSub; (t<=uSub -> (psi|b)) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

  autoInductGEQ_Lemma_6 { 
      \find (==> (\forall uSub; ((uSub<t | psi) | b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}(psi|b), true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}(psi|b))->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi|b), true)) );
      "Use Case": \replacewith ( \forall uSub; (t<=uSub -> (psi|b)) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

//---------------------------------------------------------------------------------------------------------------------------------  
//auto induction for: variable greater than some term
  
  autoInductGT_Lemma_1 { 
      \find (==> (\forall uSub; (t < uSub -> b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}b, true) );
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)) );
      "Use Case": \replacewith ( \forall uSub; (t<uSub -> b) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

  autoInductGT_Lemma_2 { 
      \find (==> (\forall uSub; (t>=uSub | b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)) );
      "Use Case": \replacewith ( \forall uSub; (t<uSub -> b) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

  autoInductGT_Lemma_3 { 
      \find (==> (\forall uSub; (uSub<=t | b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}b, true)) );
      "Use Case": \replacewith ( \forall uSub; (t<uSub -> b) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

//auto induction for: variable greater than some term and a second bound psi.
  
  autoInductGT_Lemma_5 { 
      \find (==> (\forall uSub; ((t>=uSub | psi) | b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}(psi|b), true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}(psi|b))->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi|b), true)) );
      "Use Case": \replacewith ( \forall uSub; (t<uSub -> (psi|b)) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

  autoInductGT_Lemma_6 { 
      \find (==> (\forall uSub; ((uSub<=t | psi) | b)) & phi )   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}(psi|b), true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}(psi|b))->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}(psi|b), true)) );
      "Use Case": \replacewith ( \forall uSub; (t<uSub -> (psi|b)) ==> phi)
      \heuristics(auto_induction_lemma)
      \displayname "auto_induction_lemma"
  };

// -------------------------------------------------------------------------------------
// Automatic induction rules. Ch.G.
// Existential quantification in the antecedent
// -------------------------------------------------------------------------------------

//basic pattern, 
  auto_int_induction_geqZeroLeft { 
      \find ( \exists uSub; b ==>)    \varcond ( \new(sk, \dependingOn(b)) )
      "Base Case": \replacewith ( ==> {\subst uSub; 0}!b );
      "Step Case": \replacewith ( ==> ((geq(sk,0) & {\subst uSub; sk}!b)->
                                                    {\subst uSub; (sk + 1)}!b) )
      \displayname "auto_induction"
  };

//auto induction for: variable greater or equal to some term
  auto_int_induction_geq_Left1 { 
      \find (\exists uSub; (t<=uSub & b) ==>)   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}!b, true) );
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}!b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

  auto_int_induction_geq_Left2 { 
      \find (\exists uSub; (uSub>=t & b) ==>)   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t}!b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,0) &  {\subst uSub; t + sk}!b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

 

//auto induction for: variable greater than some term
  auto_int_induction_gt_Left1 { 
      \find (\exists uSub; (t<uSub & b) ==>)   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}!b, true) );
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}!b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

  auto_int_induction_gt_Left2 { 
      \find (\exists uSub; (uSub>t & b) ==>)   \varcond ( \new(sk, \dependingOn(b)) , \notFreeIn(uSub, t) , \isInductVar(uSub))
      "Base Case": \replacewith ( ==> #ExpandQueries({\subst uSub; t + 1}!b, true));
      "Step Case": \replacewith ( ==> ((geq(sk,1) &  {\subst uSub; t + sk}!b)->
                                                     #ExpandQueries({\subst uSub; (t + (sk + 1))}!b, true)) )
      \heuristics(auto_induction)
      \displayname "auto_induction"
  };

}
  
  
// ##########################################################################################################

// ---------------------------------------------------------
// ------------- split an equation into inequations --------
// ---------------------------------------------------------

\rules{

  splitEquation {
	\find (splitEqLeft = splitEqRight)
	\replacewith (splitEqLeft >= splitEqRight & splitEqLeft <= splitEqRight)
  };

  splitEquationSucc {
	\find (==> splitEqLeft = splitEqRight)
	\replacewith (==> splitEqLeft >= splitEqRight);
	\replacewith (==> splitEqLeft <= splitEqRight)
        \heuristics (inEqSimp_nonLin, inEqSimp_split_eq, notHumanReadable)
  };
}


// ---------------------------------------------------------
// ------------- normalisation of polynomials --------------
// ---------------------------------------------------------

\rules{

  polySimp_elimSub { \find (sub(i, i0)) \replacewith (add(i, mul(i0, -1)))
                     \heuristics(polySimp_expand, polySimp_elimSubNeg)
  };

  polySimp_elimNeg { \find (neg(i)) \replacewith (mul(i, -1))
                     \heuristics(polySimp_expand, polySimp_elimSubNeg)
  };

  polySimp_elimOne {\find (mul(i,1)) \replacewith (i)
                    \heuristics (polySimp_expand, polySimp_elimOneRight)};

  polySimp_elimOneLeft0 {\find (mul(1,i)) \replacewith (i)
                         \heuristics (polySimp_expand, polySimp_elimOneLeft)};

  polySimp_elimOneLeft1 {\find (mul(mul(i0,1),i)) \replacewith (mul(i0,i))
                         \heuristics (polySimp_expand, polySimp_elimOneLeft)};


  polySimp_homoEq  { \find (homoLeft = homoRight)
                     \replacewith (add(homoRight, mul(homoLeft, -1)) = 0)
                     \heuristics(polySimp_expand, polySimp_homo,notHumanReadable )
  };



  polySimp_rightDist { \find ( mul(distCoeff, add(distSummand0, distSummand1)) )
                       \replacewith( add(mul(distCoeff, distSummand0),
                                         mul(distSummand1, distCoeff)))
                       \heuristics(polySimp_expand, polySimp_dist)
  };


  polySimp_addAssoc {
         \find (add(addAssocPoly0, add(addAssocPoly1, addAssocMono)))
         \replacewith(add(add(addAssocPoly0, addAssocPoly1), addAssocMono))
         \heuristics(polySimp_expand, polySimp_addAssoc)
  };

  polySimp_mulAssoc {
         \find (mul(mulAssocMono0, mul(mulAssocMono1, mulAssocAtom)))
         \replacewith(mul(mul(mulAssocMono0, mulAssocMono1), mulAssocAtom))
         \heuristics(polySimp_expand, polySimp_mulAssoc)
  };


  polySimp_addComm0  { \find (add(commLeft, commRight))
                       \replacewith(add(commRight, commLeft))
                       \heuristics(polySimp_expand, polySimp_addOrder)
  };

  polySimp_addComm1  { \find (add(add(i0, commLeft), commRight))
                       \replacewith(add(add(i0, commRight), commLeft))
                       \heuristics(polySimp_expand, polySimp_addOrder)
  };


  polySimp_mulComm0  { \find (mul(commLeft, commRight))
                       \replacewith(mul(commRight, commLeft))
                       \heuristics(polySimp_expand, polySimp_mulOrder)
  };

  polySimp_mulComm1  { \find (mul(mul(i0, commLeft), commRight))
                       \replacewith(mul(mul(i0, commRight), commLeft))
                       \heuristics(polySimp_expand, polySimp_mulOrder)
  };


  polySimp_addLiterals {\find (add(add(i, Z(iz)),Z(jz)))
                        \replacewith (add(i, #add(Z(iz),Z(jz))))
                        \heuristics (simplify_literals)};

  polySimp_mulLiterals {\find (mul(mul(i, Z(iz)),Z(jz)))
                        \replacewith (mul(i, #mul(Z(iz),Z(jz))))
                        \heuristics (simplify_literals)};



  polySimp_pullOutFactor0 {\find (add(mul(pullOutCommon, pullOutLeft),
                                      mul(pullOutCommon, pullOutRight)))
                           \replacewith (mul(pullOutCommon,
                                             add(pullOutLeft, pullOutRight)))
                           \heuristics (polySimp_expand, polySimp_pullOutFactor)};

  polySimp_pullOutFactor1 {\find (add(pullOutCommon,
                                      mul(pullOutCommon, pullOutRight)))
                           \replacewith (mul(pullOutCommon,
                                             add(1, pullOutRight)))
                           \heuristics (polySimp_expand, polySimp_pullOutFactor)};

  polySimp_pullOutFactor2 {\find (add(mul(pullOutCommon, pullOutLeft),
                                      pullOutCommon))
                           \replacewith (mul(pullOutCommon,
                                             add(pullOutLeft, 1)))
                           \heuristics (polySimp_expand, polySimp_pullOutFactor)};

  polySimp_pullOutFactor3 {\find (add(pullOutCommon, pullOutCommon))
                           \replacewith (mul(pullOutCommon, 2))
                           \heuristics (polySimp_expand, polySimp_pullOutFactor)};

  polySimp_pullOutFactor0b {\find (add(add(i0, mul(pullOutCommon, pullOutLeft)),
                                       mul(pullOutCommon, pullOutRight)))
                            \replacewith (add(i0, mul(pullOutCommon,
                                                      add(pullOutLeft, pullOutRight))))
                            \heuristics (polySimp_expand, polySimp_pullOutFactor)};

  polySimp_pullOutFactor1b {\find (add(add(i0, pullOutCommon),
                                       mul(pullOutCommon, pullOutRight)))
                            \replacewith (add(i0, mul(pullOutCommon,
                                                      add(1, pullOutRight))))
                            \heuristics (polySimp_expand, polySimp_pullOutFactor)};

  polySimp_pullOutFactor2b {\find (add(add(i0, mul(pullOutCommon, pullOutLeft)),
                                       pullOutCommon))
                            \replacewith (add(i0, mul(pullOutCommon,
                                                      add(pullOutLeft, 1))))
                            \heuristics (polySimp_expand, polySimp_pullOutFactor)};

  polySimp_pullOutFactor3b {\find (add(add(i0, pullOutCommon), pullOutCommon))
                            \replacewith (add(i0, mul(pullOutCommon, 2)))
                            \heuristics (polySimp_expand, polySimp_pullOutFactor)};



  polySimp_invertEq  { \find ( invertLeft = invertRight )
                       \replacewith ( invertLeft * (-1) = invertRight * (-1) )
                       \heuristics (polySimp_directEquations, polySimp_normalise) };

  polySimp_sepPosMonomial {\find (add(sepResidue, sepPosMono) = 0)
                           \replacewith (sepPosMono = mul(sepResidue, -1))
                           \heuristics (polySimp_directEquations, polySimp_balance, notHumanReadable)};

  polySimp_sepNegMonomial {\find (add(sepResidue, sepNegMono) = 0)
                           \replacewith (mul(sepNegMono, -1) = sepResidue)
                           \heuristics (polySimp_directEquations, polySimp_balance)};


  apply_eq_monomials {
     \assumes ( applyEqDivisor = i0 ==> ) \find ( applyEqDividend ) \sameUpdateLevel
     \replacewith ( #divideMonomials(applyEqDividend, applyEqDivisor) *
                    ( i0 + applyEqDivisor * -1 ) 
                    + applyEqDividend )
     \heuristics ( polySimp_applyEq, apply_equations, notHumanReadable ) };

  apply_eq_monomials_rigid {
     \assumes ( applyEqDivisorr = i0r ==> ) \find ( applyEqDividend )
     \replacewith ( #divideMonomials(applyEqDividend, applyEqDivisorr) *
                    ( i0r + applyEqDivisorr * -1 )
                    + applyEqDividend )
     \heuristics ( polySimp_applyEqRigid, apply_equations, notHumanReadable ) };


  apply_eq_pseudo_eq {
     \assumes ( aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==> )
     \find ( aePseudoTargetLeft = aePseudoTargetRight ) \sameUpdateLevel
     \replacewith ( \if ( aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                          & aePseudoLeftCoeff != 0 )
                    \then ( aePseudoRight * aePseudoTargetFactor
                                = aePseudoTargetRight * aePseudoLeftCoeff )
                    \else ( aePseudoTargetLeft = aePseudoTargetRight ) )
     \heuristics ( polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable, notHumanReadable) };

  apply_eq_pseudo_leq {
     \assumes ( aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==> )
     \find ( aePseudoTargetLeft <= aePseudoTargetRight ) \sameUpdateLevel
     \replacewith ( \if ( aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                          & aePseudoLeftCoeff > 0 )
                    \then ( aePseudoRight * aePseudoTargetFactor
                                <= aePseudoTargetRight * aePseudoLeftCoeff )
                    \else ( aePseudoTargetLeft <= aePseudoTargetRight ) )
     \heuristics ( polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable ) };

  apply_eq_pseudo_geq {
     \assumes ( aePseudoLeft * aePseudoLeftCoeff = aePseudoRight ==> )
     \find ( aePseudoTargetLeft >= aePseudoTargetRight ) \sameUpdateLevel
     \replacewith ( \if ( aePseudoTargetLeft = aePseudoLeft * aePseudoTargetFactor
                          & aePseudoLeftCoeff > 0 )
                    \then ( aePseudoRight * aePseudoTargetFactor
                                >= aePseudoTargetRight * aePseudoLeftCoeff )
                    \else ( aePseudoTargetLeft >= aePseudoTargetRight ) )
     \heuristics ( polySimp_leftNonUnit, polySimp_applyEqPseudo, notHumanReadable ) };


  polySimp_critPair { \assumes ( cpLeft1=cpRight1 ==> )
                      \find ( cpLeft2=cpRight2 ==> )
                      \add ( #divideLCRMonomials(cpLeft2, cpLeft1)
                             * ( -1 * cpRight1 + cpLeft1 )
                             +
                             #divideLCRMonomials(cpLeft1, cpLeft2)
                             * ( cpRight2 + -1 * cpLeft2 )
                             = 0 ==> )
                      \heuristics (polySimp_saturate, polySimp_critPair, notHumanReadable) };

}

// ---------------------------------------------------------
// ------------- normalisation of inequations --------------
// ---------------------------------------------------------

\rules{

  inEqSimp_ltRight   { \find (==> i < i0) \replacewith ((-1)*i0 + i >= 0 ==>)
                       \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
  };

  inEqSimp_gtRight   { \find (==> i > i0) \replacewith ((-1)*i0 + i <= 0 ==>)
                       \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable)
  };

  inEqSimp_leqRight  { \find (==> i <= i0) \replacewith ((-1)+(-1)*i0+i >= 0 ==>)
                       \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable) 
  };

  inEqSimp_geqRight  { \find (==> i >= i0) \replacewith (1+(-1)*i0+i <= 0 ==>)
                       \heuristics(inEqSimp_expand, inEqSimp_moveLeft, notHumanReadable) 
  };

  inEqSimp_ltToLeq   { \find (i < i0) \replacewith (1+(-1)*i0+i <= 0)
                       \heuristics(inEqSimp_expand, inEqSimp_makeNonStrict, notHumanReadable) 
  };

  inEqSimp_gtToGeq   { \find (i > i0) \replacewith ((-1)+(-1)*i0+i >= 0)
                       \heuristics(inEqSimp_expand, inEqSimp_makeNonStrict, notHumanReadable) 
  };


  inEqSimp_commuteLeq { \find (commLeft <= commRight)
                        \replacewith (commRight >= commLeft)
                        \heuristics(inEqSimp_expand, inEqSimp_commute)
  };

  inEqSimp_commuteGeq { \find (commLeft >= commRight)
                        \replacewith (commRight <= commLeft)
                        \heuristics(inEqSimp_expand, inEqSimp_commute)
  };

  inEqSimp_homoInEq0  { \find (homoLeft <= homoRight)
                        \replacewith (add(homoRight, mul(homoLeft, -1)) >= 0)
                        \heuristics(inEqSimp_expand, inEqSimp_homo, notHumanReadable)
  };

  inEqSimp_homoInEq1  { \find (homoLeft >= homoRight)
                        \replacewith (add(homoRight, mul(homoLeft, -1)) <= 0)
                        \heuristics(inEqSimp_expand, inEqSimp_homo, notHumanReadable)
  };



  inEqSimp_invertInEq0  { \find ( invertLeft <= invertRight )
                          \replacewith ( invertLeft * (-1) >= invertRight * (-1) )
                          \heuristics (inEqSimp_directInEquations, inEqSimp_normalise, notHumanReadable)
  };

  inEqSimp_invertInEq1  { \find ( invertLeft >= invertRight )
                          \replacewith ( invertLeft * (-1) <= invertRight * (-1) )
                          \heuristics (inEqSimp_directInEquations, inEqSimp_normalise, notHumanReadable) 
  };


  inEqSimp_sepPosMonomial0 {\find (add(sepResidue, sepPosMono) <= 0)
                            \replacewith (sepPosMono <= mul(sepResidue, -1))
                            \heuristics (inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
  };

  inEqSimp_sepNegMonomial0 {\find (add(sepResidue, sepNegMono) <= 0)
                            \replacewith (mul(sepNegMono, -1) >= sepResidue)
                            \heuristics (inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
  };

  inEqSimp_sepPosMonomial1 {\find (add(sepResidue, sepPosMono) >= 0)
                            \replacewith (sepPosMono >= mul(sepResidue, -1))
                            \heuristics (inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
  };

  inEqSimp_sepNegMonomial1 {\find (add(sepResidue, sepNegMono) >= 0)
                            \replacewith (mul(sepNegMono, -1) <= sepResidue)
                            \heuristics (inEqSimp_directInEquations, inEqSimp_balance, notHumanReadable)
  };



  inEqSimp_antiSymm    { \assumes ( i <= i0 ==> ) \find ( i >= i0 ==> )
                         \add ( i = i0 ==> )
                         \heuristics (inEqSimp_saturate, inEqSimp_antiSymm) };

  inEqSimp_exactShadow0 { \assumes ( mul(esLeft, esCoeff1) <= esRight1 ==> )
                          \find ( mul(esLeft, esCoeff2) >= esRight2 ==> )
                          \add (   (esCoeff1 > 0 & esCoeff2 > 0)
                                   ->
                                   (-1) * mul(esCoeff1, esRight2)
                                             + mul(esCoeff2, esRight1) >= 0
                                 ==> )
                          \heuristics (inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable) 
  };

  inEqSimp_exactShadow1 { \assumes ( esLeft <= esRight1 ==> )
                          \find ( mul(esLeft, esCoeff2) >= esRight2 ==> )
                          \add (   (esCoeff2 > 0)
                                   ->
                                   (-1) * esRight2 + mul(esCoeff2, esRight1) >= 0
                                 ==> )
                          \heuristics (inEqSimp_saturate, inEqSimp_exactShadow,notHumanReadable) 
  };

  inEqSimp_exactShadow2 { \assumes ( mul(esLeft, esCoeff1) <= esRight1 ==> )
                          \find ( esLeft >= esRight2 ==> )
                          \add (   (esCoeff1 > 0)
                                   ->
                                   (-1) * mul(esCoeff1, esRight2) + esRight1 >= 0
                                 ==> )
                          \heuristics (inEqSimp_saturate, inEqSimp_exactShadow, notHumanReadable) 
  };

  inEqSimp_exactShadow3 { \assumes ( esLeft <= esRight1 ==> )
                          \find ( esLeft >= esRight2 ==> )
                          \add ( (-1) * esRight2 + esRight1 >= 0 ==> )
                          \heuristics (inEqSimp_saturate, inEqSimp_exactShadow,notHumanReadable) 
  };


  inEqSimp_subsumption0 { \assumes ( subsumLeft <= subsumRightSmaller ==> )
                          \find ( subsumLeft <= subsumRightBigger )
                          \sameUpdateLevel
                          \replacewith ( subsumRightSmaller <= subsumRightBigger |
                                         subsumLeft <= subsumRightBigger )
                          \heuristics (inEqSimp_propagation, inEqSimp_subsumption) };

  inEqSimp_subsumption1 { \assumes ( subsumLeft >= subsumRightBigger ==> )
                          \find ( subsumLeft >= subsumRightSmaller )
                          \sameUpdateLevel
                          \replacewith ( subsumRightSmaller <= subsumRightBigger |
                                         subsumLeft >= subsumRightSmaller )
                          \heuristics (inEqSimp_propagation, inEqSimp_subsumption) };


  inEqSimp_subsumption2 { \assumes ( subsumLeft*subsumCoeffSmaller <= subsumRightSmaller ==> )
                          \find ( subsumLeft*subsumCoeffBigger <= subsumRightBigger )
                          \sameUpdateLevel
                          \replacewith ( ( subsumCoeffSmaller > 0
                                           & subsumCoeffBigger > 0
                                           & subsumCoeffBigger * subsumRightSmaller <=
                                             subsumCoeffSmaller * subsumRightBigger ) |
                                         subsumLeft*subsumCoeffBigger <= subsumRightBigger )
                          \heuristics (inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable) 
  };

  inEqSimp_subsumption4 { \assumes ( subsumLeft <= subsumRightSmaller ==> )
                          \find ( subsumLeft*subsumCoeffBigger <= subsumRightBigger )
                          \sameUpdateLevel
                          \replacewith ( ( subsumCoeffBigger > 0
                                           & subsumCoeffBigger * subsumRightSmaller <=
                                             subsumRightBigger ) |
                                         subsumLeft*subsumCoeffBigger <= subsumRightBigger )
                          \heuristics (inEqSimp_propagation, inEqSimp_subsumption, notHumanReadable) 
  };

  inEqSimp_subsumption5 { \assumes ( subsumLeft*subsumCoeffBigger >= subsumRightBigger ==> )
                          \find ( subsumLeft*subsumCoeffSmaller >= subsumRightSmaller )
                          \sameUpdateLevel
                          \replacewith ( ( subsumCoeffSmaller > 0
                                           & subsumCoeffBigger > 0
                                           & subsumCoeffBigger * subsumRightSmaller <=
                                             subsumCoeffSmaller * subsumRightBigger ) |
                                         subsumLeft*subsumCoeffSmaller >= subsumRightSmaller )
                          \heuristics (inEqSimp_propagation, inEqSimp_subsumption,notHumanReadable) 
  };

  inEqSimp_subsumption6 { \assumes ( subsumLeft >= subsumRightBigger ==> )
                          \find ( subsumLeft*subsumCoeffSmaller >= subsumRightSmaller )
                          \sameUpdateLevel
                          \replacewith ( ( subsumCoeffSmaller > 0
                                           & subsumRightSmaller <=
                                             subsumCoeffSmaller * subsumRightBigger ) |
                                         subsumLeft*subsumCoeffSmaller >= subsumRightSmaller )
                          \heuristics (inEqSimp_propagation, inEqSimp_subsumption,notHumanReadable) 
  };


  inEqSimp_contradInEq0 { \assumes ( contradLeft <= contradRightSmaller ==> )
                          \find ( contradLeft >= contradRightBigger )
                          \sameUpdateLevel
                          \replacewith ( contradRightSmaller >= contradRightBigger &
                                         contradLeft >= contradRightBigger )
                          \heuristics (inEqSimp_propagation, inEqSimp_contradInEqs) };

  inEqSimp_contradInEq1 { \assumes ( contradLeft >= contradRightBigger ==> )
                          \find ( contradLeft <= contradRightSmaller )
                          \sameUpdateLevel
                          \replacewith ( contradRightSmaller >= contradRightBigger &
                                         contradLeft <= contradRightSmaller )
                          \heuristics (inEqSimp_propagation, inEqSimp_contradInEqs) };

  inEqSimp_contradInEq2 { \assumes ( contradLeft*contradCoeffSmaller <= contradRightSmaller ==> )
                          \find ( contradLeft*contradCoeffBigger >= contradRightBigger )
                          \sameUpdateLevel
                          \replacewith ( ( contradCoeffSmaller > 0 ->
                                           contradCoeffBigger > 0 ->
                                           contradCoeffBigger * contradRightSmaller >=
                                           contradCoeffSmaller * contradRightBigger ) &
                                         contradLeft*contradCoeffBigger >= contradRightBigger )
                          \heuristics (inEqSimp_propagation, inEqSimp_contradInEqs,notHumanReadable)
  };

  inEqSimp_contradInEq3 { \assumes ( contradLeft <= contradRightSmaller ==> )
                          \find ( contradLeft*contradCoeffBigger >= contradRightBigger )
                          \sameUpdateLevel
                          \replacewith ( ( contradCoeffBigger > 0 ->
                                           contradCoeffBigger * contradRightSmaller >=
                                           contradRightBigger ) &
                                         contradLeft*contradCoeffBigger >= contradRightBigger )
                          \heuristics (inEqSimp_propagation, inEqSimp_contradInEqs,notHumanReadable) 
  };

  inEqSimp_contradInEq4 { \assumes ( contradLeft*contradCoeffBigger >= contradRightBigger ==> )
                          \find ( contradLeft*contradCoeffSmaller <= contradRightSmaller )
                          \sameUpdateLevel
                          \replacewith ( ( contradCoeffSmaller > 0 ->
                                           contradCoeffBigger > 0 ->
                                           contradCoeffBigger * contradRightSmaller >=
                                           contradCoeffSmaller * contradRightBigger ) &
                                         contradLeft*contradCoeffSmaller <= contradRightSmaller )
                          \heuristics (inEqSimp_propagation, inEqSimp_contradInEqs,notHumanReadable) 
  };

  inEqSimp_contradInEq5 { \assumes ( contradLeft >= contradRightBigger ==> )
                          \find ( contradLeft*contradCoeffSmaller <= contradRightSmaller )
                          \sameUpdateLevel
                          \replacewith ( ( contradCoeffSmaller > 0 ->
                                           contradRightSmaller >=
                                           contradCoeffSmaller * contradRightBigger ) &
                                         contradLeft*contradCoeffSmaller <= contradRightSmaller )
                          \heuristics (inEqSimp_propagation, inEqSimp_contradInEqs,notHumanReadable)
  };


  inEqSimp_strengthen0 { \assumes ( ==> strengthenLeft = strengthenRight )
                         \find ( strengthenLeft <= strengthenRight ==> )
                         \replacewith ( strengthenLeft <= -1 + strengthenRight ==> )
                         \heuristics (inEqSimp_propagation, inEqSimp_strengthen,notHumanReadable)   };

  inEqSimp_strengthen1 { \assumes ( ==> strengthenLeft = strengthenRight )
                         \find ( strengthenLeft >= strengthenRight ==> )
                         \replacewith ( strengthenLeft >= 1 + strengthenRight ==> )
                         \heuristics (inEqSimp_propagation, inEqSimp_strengthen,notHumanReadable) 
  };

  inEqSimp_contradEq3 { \assumes ( contradLeft <= contradRightSmaller ==> )
                        \find ( contradLeft = contradRightBigger )
                        \sameUpdateLevel
                        \replacewith ( contradRightSmaller + (-1)*contradRightBigger >= 0 &
                                       contradLeft = contradRightBigger )
                        \heuristics (inEqSimp_propagation, inEqSimp_contradEqs,notHumanReadable)   };

  inEqSimp_contradEq7 { \assumes ( contradLeft >= contradRightBigger ==> )
                        \find ( contradLeft = contradRightSmaller )
                        \sameUpdateLevel
                        \replacewith ( contradRightBigger + (-1)*contradRightSmaller <= 0 &
                                       contradLeft = contradRightSmaller )
                        \heuristics (inEqSimp_propagation, inEqSimp_contradEqs,notHumanReadable) 
  };
}

// ---------------------------------------------------------------------------
// ------------- formula normalisation ---------------------------------------
// ---------------------------------------------------------------------------

// conjunctions and disjunctions are normalised so that they are left-associative,
// <= is left of >= is left of = (provided that the left sides are equal)

\rules{

  inEqSimp_notLeq    { \find (!(i <= i0)) \replacewith ((-1)+(-1)*i0+i >= 0)
                       \heuristics(inEqSimp_forNormalisation,notHumanReadable)   };

  inEqSimp_notGeq    { \find (!(i >= i0)) \replacewith (1+(-1)*i0+i <= 0)
                       \heuristics(inEqSimp_forNormalisation,notHumanReadable) 
  };



  inEqSimp_and_antiSymm0  { \find ( i <= i0 & i >= i0 )
                            \replacewith ( i = i0 )
                            \heuristics (inEqSimp_forNormalisation) };

  inEqSimp_and_antiSymm1  { \find ( (b & i <= i0) & i >= i0 )
                            \replacewith ( b & i = i0 )
                            \heuristics (inEqSimp_forNormalisation) };

  inEqSimp_and_contradInEq0 { \find ( contradLeft <= contradRightSmaller
                                      & contradLeft >= contradRightBigger )
                              \replacewith ( (contradLeft <= contradRightSmaller
                                              & contradLeft >= contradRightBigger)
                                             & contradRightSmaller >= contradRightBigger )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_and_contradInEqs) };

  inEqSimp_and_contradInEq1 { \find ( (b & contradLeft <= contradRightSmaller)
                                      & contradLeft >= contradRightBigger )
                              \replacewith ( ((b & contradLeft <= contradRightSmaller)
                                              & contradLeft >= contradRightBigger)
                                             & contradRightSmaller >= contradRightBigger )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_and_contradInEqs) };

  inEqSimp_and_strengthen0  { \find ( strengthenLeft <= strengthenRight
                                      & strengthenLeft != strengthenRight )
                              \replacewith ( strengthenLeft <= -1 + strengthenRight )
                              \heuristics (inEqSimp_forNormalisation,notHumanReadable) 

  };

  inEqSimp_and_strengthen1  { \find ( strengthenLeft >= strengthenRight
                                      & strengthenLeft != strengthenRight )
                              \replacewith ( strengthenLeft >= 1 + strengthenRight )
                              \heuristics (inEqSimp_forNormalisation,notHumanReadable) 
  };

  inEqSimp_and_strengthen2  { \find ( (b & strengthenLeft <= strengthenRight)
                                      & strengthenLeft != strengthenRight )
                              \replacewith ( b & strengthenLeft <= -1 + strengthenRight )
                              \heuristics (inEqSimp_forNormalisation,notHumanReadable) 

  };

  inEqSimp_and_strengthen3  { \find ( (b & strengthenLeft >= strengthenRight)
                                      & strengthenLeft != strengthenRight )
                              \replacewith ( b & strengthenLeft >= 1 + strengthenRight )
                              \heuristics (inEqSimp_forNormalisation, notHumanReadable) 
  };

  inEqSimp_and_subsumption0 { \find ( subsumLeft <= subsumRightSmaller
                                      & subsumLeft <= subsumRightBigger )
                              \replacewith ( subsumLeft <= subsumRightSmaller
                                             & (subsumRightSmaller <= subsumRightBigger
                                                | subsumLeft <= subsumRightBigger) )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_andOr_subsumption,notHumanReadable) };

  inEqSimp_and_subsumption1 { \find ( (b & subsumLeft <= subsumRightSmaller)
                                      & subsumLeft <= subsumRightBigger )
                              \replacewith ( (b & subsumLeft <= subsumRightSmaller)
                                             & (subsumRightSmaller <= subsumRightBigger
                                                | subsumLeft <= subsumRightBigger) )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_andOr_subsumption, notHumanReadable) };

  inEqSimp_and_subsumption2 { \find ( subsumLeft >= subsumRightSmaller
                                      & subsumLeft >= subsumRightBigger )
                              \replacewith ( (subsumRightSmaller <= subsumRightBigger
                                              | subsumLeft >= subsumRightSmaller)
                                             & subsumLeft >= subsumRightBigger )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_andOr_subsumption, notHumanReadable) };

  inEqSimp_and_subsumption3 { \find ( (b & subsumLeft >= subsumRightSmaller)
                                      & subsumLeft >= subsumRightBigger )
                              \replacewith ( (b & (subsumRightSmaller <= subsumRightBigger
                                                   | subsumLeft >= subsumRightSmaller))
                                             & subsumLeft >= subsumRightBigger )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_andOr_subsumption, notHumanReadable) };

  inEqSimp_and_subsumption4 { \find ( subsumLeft <= subsumRightSmaller
                                      & subsumLeft != subsumRightBigger )
                              \replacewith ( subsumLeft <= subsumRightSmaller
                                             & (subsumRightSmaller < subsumRightBigger
                                                | subsumLeft != subsumRightBigger) )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_and_subsumptionEq, notHumanReadable) };

  inEqSimp_and_subsumption5 { \find ( (b & subsumLeft <= subsumRightSmaller)
                                      & subsumLeft != subsumRightBigger )
                              \replacewith ( (b & subsumLeft <= subsumRightSmaller)
                                             & (subsumRightSmaller < subsumRightBigger
                                                | subsumLeft != subsumRightBigger) )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_and_subsumptionEq, notHumanReadable) };

  inEqSimp_and_subsumption6 { \find ( subsumLeft >= subsumRightBigger
                                      & subsumLeft != subsumRightSmaller )
                              \replacewith ( subsumLeft >= subsumRightBigger
                                             & (subsumRightSmaller < subsumRightBigger
                                                | subsumLeft != subsumRightSmaller) )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_and_subsumptionEq, notHumanReadable) };

  inEqSimp_and_subsumption7 { \find ( (b & subsumLeft >= subsumRightBigger)
                                      & subsumLeft != subsumRightSmaller )
                              \replacewith ( (b & subsumLeft >= subsumRightBigger)
                                             & (subsumRightSmaller < subsumRightBigger
                                                | subsumLeft != subsumRightSmaller) )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_and_subsumptionEq, notHumanReadable) };

  inEqSimp_or_antiSymm0 { \find ( antiSymmLeft <= antiSymmRightSmaller
                                  | antiSymmLeft >= antiSymmRightBigger )
                          \replacewith ( \if   ( 2 + antiSymmRightSmaller
                                                 = antiSymmRightBigger )
                                         \then ( antiSymmLeft != 1 + antiSymmRightSmaller )
                                         \else ( antiSymmLeft <= antiSymmRightSmaller
                                                 | antiSymmLeft >= antiSymmRightBigger ) )
                          \heuristics (inEqSimp_forNormalisation, inEqSimp_or_antiSymm, notHumanReadable) };

  inEqSimp_or_antiSymm1 { \find ( (b | antiSymmLeft <= antiSymmRightSmaller)
                                  | antiSymmLeft >= antiSymmRightBigger )
                          \replacewith ( b |
                                         \if   ( 2 + antiSymmRightSmaller
                                                 = antiSymmRightBigger )
                                         \then ( antiSymmLeft != 1 + antiSymmRightSmaller )
                                         \else ( antiSymmLeft <= antiSymmRightSmaller
                                                 | antiSymmLeft >= antiSymmRightBigger ) )
                          \heuristics (inEqSimp_forNormalisation, inEqSimp_or_antiSymm, notHumanReadable) };

  inEqSimp_or_tautInEq0 { \find ( tautLeft <= tautRightBigger
                                  | tautLeft >= tautRightSmaller )
                          \replacewith ( (tautLeft <= tautRightBigger
                                          | tautLeft >= tautRightSmaller)
                                         | tautRightBigger >= (-1) + tautRightSmaller )
                          \heuristics (inEqSimp_forNormalisation, inEqSimp_or_tautInEqs,notHumanReadable) };

  inEqSimp_or_tautInEq1 { \find ( (b | tautLeft <= tautRightBigger)
                                  | tautLeft >= tautRightSmaller )
                          \replacewith ( ((b | tautLeft <= tautRightBigger)
                                          | tautLeft >= tautRightSmaller)
                                         | tautRightBigger >= (-1) + tautRightSmaller )
                          \heuristics (inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable) };

  inEqSimp_or_tautInEq2 { \find ( tautLeft >= tautRightSmaller
                                  | tautLeft <= tautRightBigger )
                          \replacewith ( (tautLeft >= tautRightSmaller
                                          | tautLeft <= tautRightBigger)
                                         | tautRightBigger >= (-1) + tautRightSmaller )
                          \heuristics (inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable) };

  inEqSimp_or_tautInEq3 { \find ( (b | tautLeft >= tautRightSmaller)
                                  | tautLeft <= tautRightBigger )
                          \replacewith ( ((b | tautLeft >= tautRightSmaller)
                                          | tautLeft <= tautRightBigger)
                                         | tautRightBigger >= (-1) + tautRightSmaller )
                          \heuristics (inEqSimp_forNormalisation, inEqSimp_or_tautInEqs, notHumanReadable) };

  inEqSimp_or_weaken0  { \find ( weakenLeft <= weakenRightSmaller
                                 | weakenLeft = weakenRightBigger )
                         \replacewith ( \if   (weakenRightBigger = 1 + weakenRightSmaller)
                                        \then (weakenLeft <= weakenRightBigger)
                                        \else (weakenLeft <= weakenRightSmaller
                                               | weakenLeft = weakenRightBigger) )
                         \heuristics (inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable) };

  inEqSimp_or_weaken1  { \find ( weakenLeft = weakenRightSmaller
                                 | weakenLeft >= weakenRightBigger )
                         \replacewith ( \if   (weakenRightBigger = 1 + weakenRightSmaller)
                                        \then (weakenLeft >= weakenRightSmaller)
                                        \else (weakenLeft = weakenRightSmaller
                                               | weakenLeft >= weakenRightBigger) )
                         \heuristics (inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable) };

  inEqSimp_or_weaken2  { \find ( (b | weakenLeft <= weakenRightSmaller)
                                 | weakenLeft = weakenRightBigger )
                         \replacewith ( b |
                                        \if   (weakenRightBigger = 1 + weakenRightSmaller)
                                        \then (weakenLeft <= weakenRightBigger)
                                        \else (weakenLeft <= weakenRightSmaller
                                               | weakenLeft = weakenRightBigger) )
                         \heuristics (inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable) };

  inEqSimp_or_weaken3  { \find ( (b | weakenLeft = weakenRightSmaller)
                                 | weakenLeft >= weakenRightBigger )
                         \replacewith ( b |
                                        \if   (weakenRightBigger = 1 + weakenRightSmaller)
                                        \then (weakenLeft >= weakenRightSmaller)
                                        \else (weakenLeft = weakenRightSmaller
                                               | weakenLeft >= weakenRightBigger) )
                         \heuristics (inEqSimp_forNormalisation, inEqSimp_or_weaken, notHumanReadable) };

  inEqSimp_or_subsumption0  { \find ( subsumLeft <= subsumRightSmaller
                                      | subsumLeft <= subsumRightBigger )
                              \replacewith ( (subsumRightSmaller >= subsumRightBigger
                                              & subsumLeft <= subsumRightSmaller)
                                             | subsumLeft <= subsumRightBigger )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_andOr_subsumption) };

  inEqSimp_or_subsumption1  { \find ( (b | subsumLeft <= subsumRightSmaller)
                                      | subsumLeft <= subsumRightBigger )
                              \replacewith ( (b | (subsumRightSmaller >= subsumRightBigger
                                                   & subsumLeft <= subsumRightSmaller))
                                             | subsumLeft <= subsumRightBigger )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_andOr_subsumption) };

  inEqSimp_or_subsumption2  { \find ( subsumLeft >= subsumRightSmaller
                                      | subsumLeft >= subsumRightBigger )
                              \replacewith ( subsumLeft >= subsumRightSmaller
                                             | (subsumRightSmaller >= subsumRightBigger
                                                & subsumLeft >= subsumRightBigger) )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_andOr_subsumption) };

  inEqSimp_or_subsumption3  { \find ( (b | subsumLeft >= subsumRightSmaller)
                                      | subsumLeft >= subsumRightBigger )
                              \replacewith ( (b | subsumLeft >= subsumRightSmaller)
                                             | (subsumRightSmaller >= subsumRightBigger
                                                & subsumLeft >= subsumRightBigger) )
                              \heuristics (inEqSimp_forNormalisation,
                                           inEqSimp_andOr_subsumption) };

  inEqSimp_or_subsumption4 { \find ( subsumLeft = subsumRightSmaller
                                     | subsumLeft <= subsumRightBigger )
                             \replacewith ( (subsumRightSmaller > subsumRightBigger
                                             & subsumLeft = subsumRightSmaller)
                                            | subsumLeft <= subsumRightBigger )
                             \heuristics (inEqSimp_forNormalisation,
                                          inEqSimp_andOr_subsumption) };

  inEqSimp_or_subsumption5 { \find ( (b | subsumLeft = subsumRightSmaller)
                                     | subsumLeft <= subsumRightBigger )
                             \replacewith ( (b | (subsumRightSmaller > subsumRightBigger
                                                  & subsumLeft = subsumRightSmaller) )
                                            | subsumLeft <= subsumRightBigger )
                             \heuristics (inEqSimp_forNormalisation,
                                          inEqSimp_andOr_subsumption) };

  inEqSimp_or_subsumption6 { \find ( subsumLeft >= subsumRightSmaller
                                     | subsumLeft = subsumRightBigger )
                             \replacewith ( subsumLeft >= subsumRightSmaller
                                            | (subsumRightSmaller > subsumRightBigger
                                               & subsumLeft = subsumRightBigger) )
                             \heuristics (inEqSimp_forNormalisation,
                                          inEqSimp_andOr_subsumption) };

  inEqSimp_or_subsumption7 { \find ( (b | subsumLeft >= subsumRightSmaller)
                                     | subsumLeft = subsumRightBigger )
                             \replacewith ( (b | subsumLeft >= subsumRightSmaller)
                                            | (subsumRightSmaller > subsumRightBigger
                                               & subsumLeft = subsumRightBigger) )
                             \heuristics (inEqSimp_forNormalisation,
                                          inEqSimp_andOr_subsumption) };

  applyEq_and_int0 { \find ( applyEqLeft >= applyEqOther
                             & applyEqLeft = applyEqRight )
                     \replacewith ( applyEqRight >= applyEqOther
                                    & applyEqLeft = applyEqRight )
                     \heuristics(apply_equations_andOr) };

  applyEq_and_int1 { \find ( (b & applyEqLeft >= applyEqOther)
                             & applyEqLeft = applyEqRight )
                     \replacewith ( (b & applyEqRight >= applyEqOther)
                                    & applyEqLeft = applyEqRight )
                     \heuristics(apply_equations_andOr) };

  applyEq_and_int2 { \find ( applyEqLeft <= applyEqOther
                             & applyEqLeft = applyEqRight )
                     \replacewith ( applyEqRight <= applyEqOther
                                    & applyEqLeft = applyEqRight )
                     \heuristics(apply_equations_andOr) };

  applyEq_and_int3 { \find ( (b & applyEqLeft <= applyEqOther)
                             & applyEqLeft = applyEqRight )
                     \replacewith ( (b & applyEqRight <= applyEqOther)
                                    & applyEqLeft = applyEqRight )
                     \heuristics(apply_equations_andOr) };

  applyEq_and_int4 { \find ( applyEqLeft = applyEqRight
                             & applyEqLeft >= applyEqOther )
                     \replacewith ( applyEqLeft = applyEqRight
                                    & applyEqRight >= applyEqOther )
                     \heuristics(apply_equations_andOr) };

  applyEq_and_int5 { \find ( (b & applyEqLeft = applyEqRight)
                             & applyEqLeft >= applyEqOther )
                     \replacewith ( (b & applyEqLeft = applyEqRight)
                                    & applyEqRight >= applyEqOther )
                     \heuristics(apply_equations_andOr) };

  applyEq_and_int6 { \find ( applyEqLeft = applyEqRight
                             & applyEqLeft <= applyEqOther )
                     \replacewith ( applyEqLeft = applyEqRight
                                    & applyEqRight <= applyEqOther )
                     \heuristics(apply_equations_andOr) };

  applyEq_and_int7 { \find ( (b & applyEqLeft = applyEqRight)
                             & applyEqLeft <= applyEqOther )
                     \replacewith ( (b & applyEqLeft = applyEqRight)
                                    & applyEqRight <= applyEqOther )
                     \heuristics(apply_equations_andOr) };

  applyEq_or_int0  { \find ( applyEqLeft >= applyEqOther
                             | applyEqLeft != applyEqRight )
                     \replacewith ( applyEqRight >= applyEqOther
                                    | applyEqLeft != applyEqRight )
                     \heuristics(apply_equations_andOr) };

  applyEq_or_int1  { \find ( (b | applyEqLeft >= applyEqOther)
                             | applyEqLeft != applyEqRight )
                     \replacewith ( (b | applyEqRight >= applyEqOther)
                                    | applyEqLeft != applyEqRight )
                     \heuristics(apply_equations_andOr) };

  applyEq_or_int2  { \find ( applyEqLeft <= applyEqOther
                             | applyEqLeft != applyEqRight )
                     \replacewith ( applyEqRight <= applyEqOther
                                    | applyEqLeft != applyEqRight )
                     \heuristics(apply_equations_andOr) };

  applyEq_or_int3  { \find ( (b | applyEqLeft <= applyEqOther)
                             | applyEqLeft != applyEqRight )
                     \replacewith ( (b | applyEqRight <= applyEqOther)
                                    | applyEqLeft != applyEqRight )
                     \heuristics(apply_equations_andOr) };

  applyEq_or_int4  { \find ( applyEqLeft != applyEqRight
                             | applyEqLeft >= applyEqOther )
                     \replacewith ( applyEqLeft != applyEqRight
                                    | applyEqRight >= applyEqOther )
                     \heuristics(apply_equations_andOr) };

  applyEq_or_int5  { \find ( (b | applyEqLeft != applyEqRight)
                             | applyEqLeft >= applyEqOther )
                     \replacewith ( (b | applyEqLeft != applyEqRight)
                                    | applyEqRight >= applyEqOther )
                     \heuristics(apply_equations_andOr) };

  applyEq_or_int6  { \find ( applyEqLeft != applyEqRight
                             | applyEqLeft <= applyEqOther )
                     \replacewith ( applyEqLeft != applyEqRight
                                    | applyEqRight <= applyEqOther )
                     \heuristics(apply_equations_andOr) };

  applyEq_or_int7  { \find ( (b | applyEqLeft != applyEqRight)
                             | applyEqLeft <= applyEqOther )
                     \replacewith ( (b | applyEqLeft != applyEqRight)
                                    | applyEqRight <= applyEqOther )
                     \heuristics(apply_equations_andOr) };

}


// ---------------------------------------------------------------------------
// ------------- dividing equations and inequations by literals --------------
// ---------------------------------------------------------------------------

\rules(integerSimplificationRules:full){

  divide_equation {
	\find ( elimGcdLeft = elimGcdRight )
	\replacewith ( \if   (elimGcd >= 1
                              & elimGcdLeft % elimGcd = 0
                              & elimGcdRight % elimGcd <= (-1) + elimGcd)
		       \then (elimGcdRight % elimGcd = 0
                              & div(elimGcdLeft, elimGcd)=div(elimGcdRight, elimGcd))
		       \else (elimGcdLeft=elimGcdRight))
  };

  divide_leq {
	\find ( elimGcdLeft <= elimGcdRight )
	\replacewith ( \if (elimGcd >= 1
	                    & elimGcdLeft % elimGcd = 0
                            & elimGcdRight % elimGcd <= (-1) + elimGcd)
                       \then (div(elimGcdLeft, elimGcd) <= div(elimGcdRight, elimGcd))
                       \else (elimGcdLeft <= elimGcdRight) )
  };

  divide_geq {
	\find ( elimGcdLeft >= elimGcdRight )
	\replacewith ( \if (elimGcd >= 1
	                    & elimGcdLeft % elimGcd = 0
                            & elimGcdRight % elimGcd <= (-1) + elimGcd)
                       \then (div(elimGcdLeft, elimGcd) >=
                              1 + div((-1) + elimGcdRight, elimGcd))
                       \else (elimGcdLeft >= elimGcdRight) )
  };


  elimGcdEq {
	\find ( elimGcdLeft = elimGcdRight )
	\replacewith ( \if (  elimGcdLeftDiv * elimGcd = elimGcdLeft
                            & elimGcdRight + ( elimGcd * (-1) ) * elimGcdRightDiv
                              <= (-1) + elimGcd
                            & elimGcdRight + ( elimGcd * (-1) ) * elimGcdRightDiv
                              >= 0 )
                       \then (  elimGcdRight + ( elimGcd * (-1) ) * elimGcdRightDiv = 0
                              & elimGcdLeftDiv = elimGcdRightDiv)
                       \else (elimGcdLeft = elimGcdRight) )
        \heuristics (polySimp_pullOutGcd, notHumanReadable)
  };

  elimGcdLeq {
	\find ( elimGcdLeft <= elimGcdRight )
	\replacewith ( \if (  1 - elimGcd
                              + ( elimGcd * (-1) ) * elimGcdRightDiv + elimGcdRight
                              + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                              <= 0
                            & ( elimGcd * (-1) ) * elimGcdRightDiv + elimGcdRight
                              + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                              >= 0 )
                       \then (elimGcdLeftDiv <= elimGcdRightDiv)
                       \else (elimGcdLeft <= elimGcdRight) )
        \heuristics (inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_leq, notHumanReadable)
  };

  elimGcdGeq {
	\find ( elimGcdLeft >= elimGcdRight )
	\replacewith ( \if (  elimGcd - 1
                              + ( elimGcd * (-1) ) * elimGcdRightDiv + elimGcdRight
                              + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                              >= 0
                            & ( elimGcd * (-1) ) * elimGcdRightDiv + elimGcdRight
                              + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                              <= 0 )
                       \then (elimGcdLeftDiv >= elimGcdRightDiv)
                       \else (elimGcdLeft >= elimGcdRight) )
        \heuristics (inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_geq, notHumanReadable)
  };

  elimGcdLeq_antec {
	\find ( elimGcdLeft <= elimGcdRight ==> )
	\replacewith (   elimGcd <= 0
                       | - elimGcd
                         + ( elimGcd * (-1) ) * elimGcdRightDiv + elimGcdRight
                         + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                         >= 0
                       | elimGcdLeftDiv <= elimGcdRightDiv ==> )
        \heuristics (inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_leq, inEqSimp_pullOutGcd_antec, notHumanReadable)
  };

  elimGcdGeq_antec {
	\find ( elimGcdLeft >= elimGcdRight ==> )
	\replacewith (   elimGcd <= 0
                       | elimGcd
                         + ( elimGcd * (-1) ) * elimGcdRightDiv + elimGcdRight
                         + elimGcdLeftDiv * elimGcd + elimGcdLeft * (-1)
                         <= 0
                       | elimGcdLeftDiv >= elimGcdRightDiv ==> )
        \heuristics (inEqSimp_pullOutGcd, inEqSimp_pullOutGcd_geq, inEqSimp_pullOutGcd_antec, notHumanReadable)
  };

}

// ---------------------------------------------------------------------------
// ------------- case distinctions on the sign of a term ---------------------
// ---------------------------------------------------------------------------

\rules{
  sign_case_distinction { "#signCasesLeft is negative": \add (signCasesLeft <= -1 ==>);
                          "#signCasesLeft is zero": \add (signCasesLeft = 0 ==>);
                          "#signCasesLeft is positive": \add (signCasesLeft >= 1 ==>)
                         \heuristics(inEqSimp_signCases) };

// ---------------------------------------------------------------------------
// ------------- squares are always non-negative -----------------------------
// ---------------------------------------------------------------------------

  add_non_neg_square { \add ( squareFac * squareFac >= 0 ==> )
                       \heuristics(inEqSimp_special_nonLin,
                                   inEqSimp_nonNegSquares) };
}

// ---------------------------------------------------------------------------
// -------- operations defined using polynomials (division, modulo) ----------
// ---------------------------------------------------------------------------

\rules(integerSimplificationRules:full){

  jdiv_axiom_inline { \find (jdiv(divNum,divDenom))
                      \replacewith (\if (divNum>=0)
                                    \then (div(divNum,divDenom))
                                   \else (div(divNum*(-1),divDenom)*(-1)))
                      \heuristics(defOps_jdiv_inline,notHumanReadable ) };

  jdiv_axiom { \find (jdiv(divNum,divDenom)) \sameUpdateLevel
               \add (jdiv(divNum,divDenom) =
                     \if (divNum>=0)
                     \then (div(divNum,divDenom))
                     \else (div(divNum*(-1),divDenom)*(-1)) ==>)
               \heuristics(defOps_jdiv, notHumanReadable) };

//  div_axiom { \find (div(divNum,divDenom)) \sameUpdateLevel
//              \add (divDenom=0 |
//                   (mul(div(divNum,divDenom),divDenom) <= divNum &
//                    \if (divDenom >= 0)
//                    \then (mul(div(divNum,divDenom),divDenom) >=
//                                     1 + divNum + (-1) * divDenom)
//                    \else (mul(div(divNum,divDenom),divDenom) >=
//                                     1 + divNum + divDenom) ) ==> )
//            \heuristics(defOps_div) };

//  div_axiom { \find (div(divNum,divDenom)) \sameUpdateLevel
//              \varcond (\notFreeIn(k, divNum, divDenom))
//              \add (divDenom=0 |
//                     (\exists k; (k=div(divNum,divDenom) &
//                        mul(k,divDenom) <= divNum &
//                        \if (divDenom >= 0)
//                        \then (mul(k,divDenom) >= 1 + divNum + (-1) * divDenom)
//                       \else (mul(k,divDenom) >= 1 + divNum + divDenom) )) ==> )
//            \heuristics(defOps_div) };

  div_axiom { \find (div(divNum,divDenom)) \sameUpdateLevel
              \varcond ( \new(quotient, \dependingOn(divNum)),
                         \new(quotient, \dependingOn(divDenom)) )
              \add (divDenom=0 |
                     (div(divNum,divDenom) = quotient &
                      mul(quotient,divDenom) <= divNum &
                      \if (divDenom >= 0)
                      \then (mul(quotient,divDenom) >= 1 + divNum + (-1) * divDenom)
                      \else (mul(quotient,divDenom) >= 1 + divNum + divDenom) ) ==> )
            \heuristics(defOps_div, polySimp_newSmallSym, notHumanReadable) };

  jmod_axiom { \find (jmod(divNum,divDenom))
               \replacewith (divNum + jdiv(divNum,divDenom)*(-1)*divDenom)
               \heuristics(defOps_mod, notHumanReadable) };

  mod_axiom { \find (mod(divNum,divDenom))
              \replacewith (divNum + (divNum/divDenom)*(-1)*divDenom)
              \heuristics(defOps_mod, notHumanReadable) };


  polyDiv_pullOut {
    \find ( divNum / divDenom )
    \replacewith ( \if   (divDenom = 0)
                   \then (divNum / 0)
                   \else (( divNum + polyDivCoeff * (-1) * divDenom )
                          / divDenom + polyDivCoeff) )
    \heuristics(polyDivision, defOps_divModPullOut, notHumanReadable)
  };

  polyDiv_zero {
    \find ( 0 / divDenom )
    \replacewith ( \if   (divDenom = 0)
                   \then (0 / 0)
                   \else (0))
    \heuristics(polyDivision )
  };

  polyMod_pullOut {
    \find ( divNum % divDenom )
    \replacewith ( ( divNum + polyDivCoeff * (-1) * divDenom )
                   % divDenom )
    \heuristics(polyDivision, defOps_divModPullOut,notHumanReadable)
  };

  polyMod_zero {
    \find ( 0 % divDenom )
    \replacewith ( 0 )
    \heuristics(polyDivision,concrete)
  };

  mod_homoEq {
    \find ( modNumLeft % modDenom = modNumRight % modDenom )
    \replacewith ( (modNumLeft - modNumRight) % modDenom = 0 )
    \heuristics(defOps_modHomoEq, notHumanReadable)
  };

}

// ---------------------------------------------------------------------------
// ------------- introduce new symbols for basis transformations -------------
// ---------------------------------------------------------------------------

\rules(integerSimplificationRules:full){
  newSym_eq  { \find ( newSymLeft*newSymLeftCoeff = newSymRight ==> )
               \varcond ( \new(l, \dependingOn(newSymDef)),
                          \new(l, \dependingOn(newSymLeft)) )
               \add ( newSymLeft = l + newSymDef ==> )
               \heuristics (polySimp_leftNonUnit,
                            polySimp_newSym, polySimp_newSmallSym) };

}

