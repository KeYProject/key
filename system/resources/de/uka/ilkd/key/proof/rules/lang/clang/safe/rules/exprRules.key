\schemaVariables {
	\modalOperator {diamond, box} #allmodal;
	\formula formula;

	\skolemTerm int dummy;

	\program ClangVariable #tvar, #tvar1, #tvar2;

	\program ClangValueType #vtype;
	\program ClangIntegerType #itype;
	\program ClangPointerType #ptype;
	\program ClangScalarType #stype;
	\program ClangObjectType #otype;

	\program ClangMember #member;

	\program ClangVariable #var, #var1, #var2, #var3;
	\program ClangValueVariable #vvar, #vvar1, #vvar2, #vvar3;
	\program ClangObjectVariable #ovar, #ovar1, #ovar2, #ovar3;
	\program ClangIntegerVariable #ivar, #ivar1, #ivar2, #ivar3;
	\program ClangPointerVariable #pvar, #pvar1, #pvar2, #pvar3;

	\program ClangValueSimpleExpression #vsexp, #vsexp1, #vsexp2, #vsexp3;
	\program ClangIntegerSimpleExpression #isexp, #isexp1, #isexp2, #isexp3;
	\program ClangPointerSimpleExpression #psexp, #psexp1, #psexp2, #psexp3;

	// TODO: rules in terms of integer #ivar/#isexp can be rewritten in terms of arithmetic #asexp

	\program ClangExpression #exp, #exp1, #exp2;
	\program ClangObjectExpression #oexp, #oexp1, #oexp2;
	\program ClangValueExpression #vexp, #vexp1, #vexp2;
	\program ClangComplexExpression #cexp, #cexp1, #cexp2;
	\program ClangValueComplexExpression #vcexp, #vcexp1, #vcexp2;
	\program ClangObjectComplexExpression #ocexp, #ocexp1, #ocexp2;
}

\rules {

	/* Assignment */

	/**
	 * Eliminating reference assignment.
	 */
	elimReferenceAssignment_LHS_VariableRHS {
		\find (\modality{#allmodal}.. #ovar1 <- #ovar2; ...\endmodality(formula)) 
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 
		\replacewith ( 
			{ #ovar1 := #ovar2 }
			\modality{#allmodal}.. ...\endmodality(formula))
		\add(isValidPtrSaved(#ovar2, storage(objBlock(#ovar2))) ==>);
		"Valid Value: #ovar2" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidPtr(#ovar2), isValidPtrSaved(#ovar2, storage(objBlock(#ovar2))))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating integer value assignment.
	 */
	elimValueAssignmentInteger_LHS_SimpleExpressionRHS {
		\find (\modality{#allmodal}.. #ivar = #isexp; ...\endmodality(formula)) 
		\sameUpdateLevel		
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 
		\replacewith ( 
			{ #ivar := #isexp }
			\modality{#allmodal}.. ...\endmodality(formula))
		\add(isValidVal(#isexp) ==>);
		"Valid Value: #isexp" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating pointer value assignment.
	 */
	elimValueAssignmentPointer_LHS_SimpleExpressionRHS {
		\find (\modality{#allmodal}.. #pvar = #psexp; ...\endmodality(formula)) 
		\sameUpdateLevel		
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 
		\replacewith ( 
			{ #pvar := #psexp }
			\modality{#allmodal}.. ...\endmodality(formula))
		\add(isValidPtrSaved(#psexp, storage(objBlock(#psexp))) ==>);
		"Valid Value: #psexp" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidPtr(#psexp), isValidPtrSaved(#psexp, storage(objBlock(#psexp))))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating integer value assignment with scalar LHS.
	 */
	elimValueAssignmentInteger_ScalarLHS_RHS {
		\find (\modality{#allmodal}.. @#ovar = #isexp; ...\endmodality(formula)) 
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 
		\replacewith ( 
			#ClangAtomicUpdate(
				#ClangValueAccess(#ovar),
				#isexp,
				\modality{#allmodal}.. ...\endmodality(formula)
				)
		)
		\add(objExistsSaved(#ovar, storage(objBlock(#ovar))), isValidVal(#isexp) ==>);
		"Object Exists: #ovar" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#ovar), objExistsSaved(#ovar, storage(objBlock(#ovar))));
		"Valid Value: #isexp" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp))
		\heuristics(simplify_prog)
	};


	/**
	 * Eliminating pointer value assignment with scalar LHS.
	 */
	elimValueAssignmentPointer_ScalarLHS_RHS {
		\find (\modality{#allmodal}.. @#ovar = #psexp; ...\endmodality(formula)) 
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 
		\replacewith ( 
			#ClangAtomicUpdate(
				#ClangValueAccess(#ovar),
				#psexp,
				\modality{#allmodal}.. ...\endmodality(formula)
				)
		)
		\add(objExistsSaved(#ovar, storage(objBlock(#ovar))), isValidPtrSaved(#psexp, storage(objBlock(#psexp))) ==>);
		"Object Exists: #ovar" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#ovar), objExistsSaved(#ovar, storage(objBlock(#ovar))));
		"Valid Value: #psexp" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidPtr(#psexp), isValidPtrSaved(#psexp, storage(objBlock(#psexp))))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating integer value assignment with scalar RHS.
	 */
	elimValueAssignmentInteger_LHS_ScalarRHS {
		\find (\modality{#allmodal}.. #ivar = @#ovar; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))		
		"Normal Execution" : 
		\replacewith ( 
			{ #ivar := #ClangValueAccess(#ovar) }
			\modality{#allmodal}.. ...\endmodality(formula))
		\add(objExistsSaved(#ovar, storage(objBlock(#ovar))), isValidVal(#ClangValueAccess(#ovar)) ==>);
		"Object Exists: #ovar" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#ovar), objExistsSaved(#ovar, storage(objBlock(#ovar))));
		"Valid Value: #ovar" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#ClangValueAccess(#ovar)))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating pointer value assignment with scalar RHS.
	 */
	elimValueAssignmentPointer_LHS_ScalarRHS {
		\find (\modality{#allmodal}.. #pvar = @#ovar; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))		
		"Normal Execution" : 
		\replacewith ( 
			{ #pvar := #ClangValueAccess(#ovar) }
			\modality{#allmodal}.. ...\endmodality(formula))
		\add(objExistsSaved(#ovar, storage(objBlock(#ovar))), isValidPtrSaved(#ClangValueAccess(#ovar), storage(objBlock(#ClangValueAccess(#ovar)))) ==>);
		"Object Exists: #ovar" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#ovar), objExistsSaved(#ovar, storage(objBlock(#ovar))));
		"Valid Value: #ovar" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidPtr(#ClangValueAccess(#ovar)), isValidPtrSaved(#ClangValueAccess(#ovar), storage(objBlock(#ClangValueAccess(#ovar)))))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating deep value assignment.
	 */
	elimDeepValueAssignmentLHS_VariableRHS {
		\find (\modality{#allmodal}.. #ovar1 = #ovar2; ...\endmodality(formula)) 
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 
		\replacewith ( 
			#ClangDeepUpdate(
				#ovar1,
				#ovar2,
				\modality{#allmodal}.. ...\endmodality(formula))
				)
		\add(objExistsSaved(#ovar1, storage(objBlock(#ovar1))), objExistsSaved(#ovar2, storage(objBlock(#ovar2)))
		// TODO: add
		// 		, #ClangDeepIsValidValueSaved(#ovar2, 
		//			isValidVal(0),
		//			isValidPtrSaved(null, storage(objBlock(null))
		//		)
		 ==>);
		"Object Exists: #ovar1" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#ovar1), objExistsSaved(#ovar1, storage(objBlock(#ovar1))));
		"Object Exists: #ovar2" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#ovar2), objExistsSaved(#ovar2, storage(objBlock(#ovar2))));
		"Valid Value Object: #ovar2" : \replacewith(undefinedBehavior(dummy)) \add(==> #ClangDeepIsValidValue(#ovar2)
			// TODO: add
			// 		, #ClangDeepIsValidValueSaved(#ovar2, 
			//			isValidVal(0),
			//			isValidPtrSaved(null, storage(objBlock(null))
			//		)
		)
		\heuristics(simplify_prog)
	};


	/* Accessors */

	/**
	 * Eliminating reference assignment with member access RHS.
	 */
	elimReferenceAssignment_LHS_MemberAccessRHS {
		\find (\modality{#allmodal}.. #ovar <- #ovar1.#member; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 		
		\replacewith ( 			
				{ #ovar := #ClangMemberAccess(#ovar1, #member) }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(objExistsSaved(#ovar1, storage(objBlock(#ovar1))) ==>);
		"Object Exists: #ovar1" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#ovar1), objExistsSaved(#ovar1, storage(objBlock(#ovar1))))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating reference assignment with member pointer access RHS.
	 */
	elimReferenceAssignment_LHS_MemberPointerAccessRHS {
		\find (\modality{#allmodal}.. #ovar <- #psexp->#member; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 				
		\replacewith ( 			
				{ #ovar := #ClangMemberAccess(#psexp, #member) }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(objExistsSaved(#psexp, storage(objBlock(#psexp))) ==>);
		"Target Exists: #psexp" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#psexp), objExistsSaved(#psexp, storage(objBlock(#psexp))))
		\heuristics(simplify_prog)
	};

	/**
	 * Eliminating reference assignment with array access RHS.
	 */
	elimReferenceAssignment_LHS_ArrayAccessRHS {
		\find (\modality{#allmodal}.. #ovar <- #ovar1[#isexp]; ...\endmodality(formula))
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 
		\replacewith ( 			
				{ #ovar := #ClangElemAccess(#ovar1, #ClangIntegerToInt(#isexp)) }\modality{#allmodal}.. ...\endmodality(formula)
				)
		\add(objExistsSaved(#ovar1, storage(objBlock(#ovar1))), isValidVal(#isexp), isValidIdx(#ovar1, #ClangIntegerToInt(#isexp)) ==>);
		"Array Exists: #ovar1" : \replacewith(undefinedBehavior(dummy)) \add(==> objExists(#ovar1), objExistsSaved(#ovar1, storage(objBlock(#ovar1))));
		"Valid Value: #isexp" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#isexp));
		"Valid Array Index: #ovar1[#isexp]" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidIdx(#ovar1, #ClangIntegerToInt(#isexp)))
		\heuristics(simplify_prog)
	};
	
	/* Conditional */

	/**
	 * Eliminating value assignment with conditional RHS.
	 */
	elimValueAssignment_LHS_Conditional_RHS {
		\find (\modality{#allmodal}.. #var = #ivar ? #exp1 : #exp2; ...\endmodality(formula)) 
		\sameUpdateLevel
		\varcond (\new(dummy, \dependingOn(formula)))
		"Normal Execution" : 
		\replacewith ( 	
				\if (#ClangIntegerToInt(#ivar) = 0) 
				\then 
				(\modality{#allmodal}.. #var = #exp1; ...\endmodality(formula))
				\else
				(\modality{#allmodal}.. #var = #exp2; ...\endmodality(formula))
			)
		\add(isValidVal(#ivar) ==>);
		"Valid Value: #ivar" : \replacewith(undefinedBehavior(dummy)) \add(==> isValidVal(#ivar))
		\heuristics(simplify_prog)
	};	
}