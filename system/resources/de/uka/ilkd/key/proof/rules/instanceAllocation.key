// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


\sorts {
  \generic G;
  \generic H \extends Object;
  \generic J \extends Object;
  \generic K;
  \generic alphaObj \extends Object;
  \generic betaObj \extends Object;
}


\schemaVariables {
  \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal ;
  
  \program MethodName[name=<allocate>] #allocate;
 
  \program SpecialConstructorReference #scr;
 
  \program SimpleInstanceCreation #n;
  \program NonSimpleInstanceCreation #nsn;
  \program ArrayCreation #na;
  \program ArrayInitializer #arrayinitializer;
 
  \program SimpleExpression #len;
   
  \program StaticVariable #staticField;
  \program Variable #v0;
  \program LeftHandSide #lhs;
  \program Type #t, #t2;

  \program ExecutionContext #ex;
  \program ProgramMethod #pm;
 
  \term int idx0, idx1, allocNr;
   
  \variables int iv;
  \variables boolean bv;
  \variables G ov;
  \term G ot;
  \term H const;
  \term J obj;
  \formula post, b;
  
  \term boolean bool;
  \skolemTerm G sk ;
  
  \term J array;
  // attention some strategies rely on the name of the SV if you change it, please adapt
  // the strategies as well
  \term int negLit;
  \term int nonNegLit;
}
 
 
\rules(programRules:Java) {

//----------------------------------------------------------------------------
//-----------                 object creation                      -----------
//----------------------------------------------------------------------------

   instanceCreationUnfoldArguments { 
   	\find (\modality{#allmodal}{.. #nsn ...}\endmodality(post)) 
    	\replacewith (\modality{#allmodal}{.. #evaluate-arguments(#nsn); ...}\endmodality(post))
	\heuristics(simplify_autoname)
   };


   instanceCreationAssignmentUnfoldArguments { 
   	\find (\modality{#allmodal}{.. #lhs = #nsn;  ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#lhs = #nsn); ...}\endmodality(post)) 
    	\heuristics(simplify_autoname)
   };


   instanceCreation { 
   	\find (\modality{#allmodal}{.. #n ...}\endmodality(post)) 
        \varcond(\new(#v0, \typeof(#n)))
        \replacewith (\modality{#allmodal}{.. #typeof(#v0) #v0 = #create-object(#n); 
		          #constructor-call(#v0, #n); 
                          #post-work(#v0); ...}\endmodality(post)) 
	\heuristics(method_expand)
   };
   

   instanceCreationAssignment {
        \schemaVar \modalOperator { diamond, box } #normal; 
   	\find (\modality{#normal}{.. #lhs = #n;  ...}\endmodality(post)) 
        \varcond(\new(#v0, \typeof(#lhs)))
        \replacewith (\modality{#normal}{.. #typeof(#v0) #v0 = #create-object(#n); 
		          #constructor-call(#v0, #n); 
                          #post-work(#v0);
			  #lhs = #v0;
		      ...}\endmodality(post)) 
	\heuristics(method_expand)
   };


   allocateInstance {    
        \find (==> \modality{#allmodal}{.#pm@#t2().. #lhs = #t.#allocate()@#t; ...}\endmodality(post))
	\varcond(\hasSort(#t2, alphaObj))
        \replacewith (==> {heap := create(heap,#lhs)}
	                  \modality{#allmodal}{..  ...}\endmodality(post))
	\add(#lhs != null
	     & (wellFormed(heap) -> boolean::select(heap, #lhs, java.lang.Object::<created>) = FALSE)
	     & alphaObj::exactInstance(#lhs) = TRUE ==>)
	
	\heuristics(method_expand)
   };
   
   
   allocateInstanceWithLength {    
        \find (==> \modality{#allmodal}{.#pm@#t2().. #lhs = #t.#allocate(#len)@#t; ...}\endmodality(post))
	\varcond(\hasSort(#t2, alphaObj))
        \replacewith (==>
           { heap := store(
                        store(
                           create(heap,#lhs),
                           #lhs, java.lang.Object::<transient>, 0),                   
                        #lhs, java.lang.Object::<transactionConditionallyUpdated>,FALSE) }
             \modality{#allmodal}{..  ...}\endmodality(post))
	\add(#lhs != null
	     & (wellFormed(heap) -> (boolean::select(heap, #lhs, java.lang.Object::<created>)  = FALSE 
	                             & length(#lhs) = #len))
	     & alphaObj::exactInstance(#lhs) = TRUE ==>)
	
	\heuristics(method_expand)
   };
   

   special_constructor_call { 
        \find (\modality{#allmodal}{.. #scr ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #special-constructor-call(#scr); ...}\endmodality(post)) 
	\heuristics(method_expand)
   };

   

//----------------------------------------------------------------------------
//-----------                 array creation                      -----------
//----------------------------------------------------------------------------

   
   arrayCreation {
        \schemaVar \modalOperator { diamond, box } #normal;  
        \find (\modality{#normal}{.. #lhs = #na; ...}\endmodality(post)) 	
        \varcond(\new(#v0, \typeof(#na)))	
        \replacewith (\modality{#normal}{.. 	
		#typeof(#na) #v0; 
		#init-array-creation(#v0, #na);
                #lhs = #v0; ...}\endmodality(post)) 
	    \heuristics(simplify_prog)
   };

   arrayCreationWithInitializers { 
        \find (\modality{#allmodal}{.. #lhs = #arrayinitializer; ...}\endmodality(post)) 	
        \varcond(\new(#v0, \typeof(#lhs)))	
        \replacewith (\modality{#allmodal}{.. 	
		#typeof(#lhs) #v0; 
		#init-array-creation(#v0, #arrayinitializer);
                #lhs = #v0; ...}\endmodality(post)) 
	   \heuristics(simplify_prog)
   };


   

//----------------------------------------------------------------------------
//-----------                 exactInstance                      ------------
//----------------------------------------------------------------------------
   /*
   exact_instance_implies_instance_reference { 
         \find (alphaObj::exactInstance(obj) = TRUE ==>)
         \add (alphaObj::instance(obj) = TRUE ==>)
         \heuristics (type_hierarchy_def)
   };   
*/
  exact_instance_definition_int {
         \find(int::exactInstance(idx0) = TRUE)
         \varcond(\notFreeIn(iv, idx0))
         \replacewith (\exists iv; (idx0 = iv))
         \heuristics (simplify)
   };

   exact_instance_definition_boolean {	 
         \find ( boolean::exactInstance(bool) = TRUE)
         \varcond(\notFreeIn(bv, bool))	 
         \replacewith (\exists bv; (bool = bv))
         \heuristics (simplify)	 
   };   
   
    exact_instance_definition_null {	 
         \find ( Null::exactInstance(obj) = TRUE)
         \varcond(\notFreeIn(bv, bool))	 
         \replacewith (obj = null)
         \heuristics (simplify)	 
   };   
      
   exact_instance_for_interfaces_or_abstract_classes {
         \find (G::exactInstance(obj)) 
         \varcond(\isAbstractOrInterface(G))	      
         \replacewith (FALSE)
         \heuristics (simplify)	 
         \displayname "interfaces or abstract classes have no exact instances"	 
   };   
}
