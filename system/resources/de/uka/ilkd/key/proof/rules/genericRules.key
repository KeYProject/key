// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 



// This file contains rules that are applicable for every sort (as they
// use \generic sorts).
// The format is the same as for problem files.

\sorts {
  \generic G, S1, S2, H;
  \generic GSub \extends G;

  \generic C;
  \generic CSub \extends C;
}



// These schema variables are used to write the following rules.
// They will not be visible in later runs of the parser, so you are
// fairly free in choosing their names.
\schemaVariables {
  \term G e,s,t, e0;  
  \term H t1; 
  \term S1 t2; 
  \skolemTerm G sk ;
  \formula b,c;
  \variables G u, e2 ;

  \term G commEqLeft;
  \term H commEqRight;

  \variables GSub r ;

  \term[rigid] G sr;
  \term[rigid] H tr;

  \term G ref1, ref2 ;
  \term S1 ind1, ind2, target ;
  \term S2 else, then ;
  \term numbers iz, jz ;

  \term int i;

}



\rules {

  // Gamma rules
  allLeft { 
  	\find (\forall u; b ==>) 
  	\add ({\subst u; t}(b) ==>) 
  	\heuristics(gamma) 
  };
  exRight { \find (==> \exists u; b) \add (==> {\subst u; t}(b)) 
            \heuristics(gamma) };
  allLeftHide { \find (\forall u; b ==>) \replacewith ({\subst u; t}(b) ==>)
		\addrules ( insert_hidden { \add (\forall u; b ==>) } )
                \heuristics(gamma_destructive) };
  exRightHide { \find (==> \exists u; b) \replacewith (==> {\subst u; t}(b))
		\addrules ( insert_hidden { \add (==> \exists u; b) } )
                \heuristics(gamma_destructive)  };

  instAll { \assumes (\forall u; b ==>) \find (t) \add ({\subst u; t}(b) ==>) };
  instEx  { \assumes (==> \exists u; b) \find (t) \add (==> {\subst u; t}(b)) };

  // delta rules
  allRight { \find (==> \forall u; b) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith (==> {\subst u; sk}b) \heuristics (delta) };
  exLeft { \find (\exists u; b ==>) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith ({\subst u; sk}b ==>) \heuristics (delta) };
  
  // simplification
  all_unused { \find (\forall u; b) \varcond (\notFreeIn(u, b)) 
		 \replacewith (b)
		 \heuristics (elimQuantifier) };
  ex_unused  { \find (\exists u; b) \varcond (\notFreeIn(u, b))
		 \replacewith (b)
		 \heuristics (elimQuantifier) };


  // equality
  eqClose { 
     \find (s = s) \replacewith (true) \heuristics (concrete) 
  };


  eqSymm { \find (commEqLeft = commEqRight)
           \replacewith (commEqRight = commEqLeft)
           \heuristics ( order_terms )
  };

  make_insert_eq { \find (sr = tr ==>)
		   \addrules ( insert_eq { \find (sr) \replacewith (tr) } )
		 };

  make_insert_eq_nonrigid { \find (s = t ==>)
	     \addrules ( insert_eq_nonrigid { \find (s) \sameUpdateLevel
                                              \replacewith (t)
                                              \displayname "insert_eq" } )
                    };
  insert_eq_all  { \find (sr = tr ==>)
		     \replacewith (==>)
		     \addrules ( auto_insert_eq { \find (sr) 
						 \replacewith (tr)
						 \heuristics (simplify) } ) };

// wary substitutions
  apply_subst { \find ({\subst u; t} target)
                // it is enough to rebuild the same term, as substitutions
                // are automatically applied in this situation
                \replacewith ({\subst u; t} target)
                \heuristics (try_apply_subst) };

  apply_subst_for { \schemaVar \formula phi;
                    \find ({\subst u; t} phi)
                    // it is enough to rebuild the same term, as substitutions
                    // are automatically applied in this situation
                    \replacewith ({\subst u; t} phi)
                    \heuristics (try_apply_subst)
                    \displayname "apply_subst" };

  subst_to_eq { \find ({\subst u; t} target) \sameUpdateLevel
                \varcond (\new(sk, \dependingOn(t)))
                \replacewith ({\subst u; sk} target)
                \add (sk = t ==>)
                \heuristics (simplify) };

  subst_to_eq_for { \schemaVar \formula phi;
                    \find ({\subst u; t} phi) \sameUpdateLevel
                    \varcond (\new(sk, \dependingOn(t)))
                    \replacewith ({\subst u; sk} phi)
                    \add (sk = t ==>)
                    \heuristics (simplify)
                    \displayname "subst_to_eq" };



///////////////////////////////////////////////////////////////////////////////


//  rewrite { \find (s) \sameUpdateLevel
//            \replacewith(t) \add (s = t ==>);
//            \add (==> s = t) } ;


 applyEq { 
	\assumes (s = t1 ==>) \find (s) 
	\sameUpdateLevel
	\replacewith ( t1 )
        \heuristics ( apply_equations )
	\displayname "applyEq"
 };

 applyEqRigid { 
	\schemaVar \term[rigid] H tr1;

	\assumes (sr = tr1 ==>) \find (sr)
	\replacewith ( tr1)
        \heuristics ( apply_equations )
	\displayname "applyEq"
 };
}

\rules(programRules:Java){
// --------------- rules for casts in the logic (for programs look e.g. in javaRules.key) ----------

 typeEq {
	\find( s = t1 ==>) \add ( H::instance(s) = TRUE, G::instance(t1) = TRUE ==> )	
        \displayname "typeEq"
 };

 typeEqDerived {
	\assumes( s = t1 ==>) \find ( H::instance(s) ) \sameUpdateLevel \replacewith(TRUE)
	\heuristics (simplify, concrete)
        \displayname "typeEq"	
 };
 
 typeEqDerived2 {
	\assumes( s = t1 ==>) \find ( G::instance(t1) ) \sameUpdateLevel \replacewith(TRUE)	
	\heuristics (simplify, concrete)
        \displayname "typeEq"
 };

 typeStatic {
	// is sameUpdateLevel neccessary? Don't think so as static type cannot be changed
	\find (s) \sameUpdateLevel \add ( G::instance(s) = TRUE ==> )
 };
 
 castAdd {
	\schemaVar \term[strict] C strictCTerm2;

	\assumes (CSub::instance(strictCTerm2) = TRUE ==>)
        \find (strictCTerm2) \sameUpdateLevel
        \replacewith ((CSub)strictCTerm2)
	// in confluence_restricted as if and find part must be disjoint
	// to be confluent
	\displayname "narrow type"
 };
 
 castAdd2 {
	\schemaVar \term C cs;
	\schemaVar \term G gt;

	\assumes (cs = gt ==>)
        \find (gt) \sameUpdateLevel
        \varcond (\strict\sub(C, G))
        \replacewith ((C)gt)
	\displayname "castAdd"
 };

 castDel {
	\schemaVar \term C castedTerm;
	\find ((C)castedTerm)
        \replacewith (castedTerm)
	\displayname "castDel"
	\heuristics (simplify, cast_deletion)
 };

 castDel2 {
	\schemaVar \term CSub cs;
	\schemaVar \term G gt;

	\assumes (cs = gt ==>)
        \find ((C)gt) \sameUpdateLevel
        \replacewith (cs)
	\displayname "castDel"
 };

 
 castType {
	\assumes( H::instance((C)s) = TRUE ==> ) 
	\find( CSub::instance(s) = TRUE ==> ) 
	\replacewith( H::instance(s) = TRUE ==> )
	\heuristics (simplify)
	\displayname "castType"
 };

 castType2 {
	\assumes(  ==> H::instance((C)s) = TRUE ) 
	\find( CSub::instance(s) = TRUE ==> ) 
	\replacewith( ==> H::instance(s) = TRUE)
	\heuristics (simplify)
	\displayname "castType"
 };

}

\rules{

 closeType {
	\assumes (==> G::instance(t1) = TRUE) \find (GSub::instance(t1) = TRUE ==>) \closegoal
	\displayname "closeType"
	\heuristics (closure)

 }; 

 closeTypeSwitched {
	\assumes (GSub::instance(t1) = TRUE ==>) \find (==> G::instance(t1) = TRUE ) \closegoal
	\displayname "closeType"
	\heuristics (closure)
 }; 
 
 pullOut{ \find ( t ) \sameUpdateLevel \varcond ( \new(sk, \dependingOn(t)) )
           \replacewith (sk)
           \add ( t = sk ==>) 
	};

// for the book
 instancePredicateRewrite {
   \find (G::contains(t))
   \replacewith(G::instance(t) = TRUE)
   \heuristics (simplify) 
 };
 
 
 ineffectiveCast {
    \assumes(H::instance(t) = TRUE ==>)
    \find((H)t) \sameUpdateLevel
    \add((H)t = t ==>)
    \heuristics(inReachableStateImplication)
 };

 // there was a completeness hole w/o this rule
 ineffectiveCast3 {
    \assumes(H::exactInstance(t) = TRUE ==>)
    \find((H)t) \sameUpdateLevel
    \add((H)t = t ==>)
    \heuristics(inReachableStateImplication)
 };

 ineffectiveCast2 {
    \schemaVar \term CSub cs;
    \schemaVar \term G gt;

    \assumes(cs = gt ==>)
    \find((C)gt) \sameUpdateLevel
    \add((C)gt = gt ==>)
    \heuristics(inReachableStateImplication)
 }; 

 
 
 
    //--------------------------------------------------------------------------
    //rule for unique function symbols
    //--------------------------------------------------------------------------
    
    equalUnique {
	\schemaVar \term any f, f2;
	\schemaVar \formula result;
   
	\find(f = f2)
	\varcond(\equalUnique(f, f2, result))
	         
	\replacewith(result)
	
	\heuristics(concrete)
    };
    
} 
 
    //--------------------------------------------------------------------------
    //rules for disjointness of sorts
    //--------------------------------------------------------------------------

\rules(programRules:Java){
   
    sortsDisjointModuloNull {
        \schemaVar \term G x;
        \schemaVar \term H y;
    
	\find(x = y)
	\varcond(\strict\sub(Null, G), \strict\sub(Null, H), \disjointModuloNull(G, H))
	
	\replacewith(x = null & y = null)
	\heuristics(simplify)
    };
 
   
    sortsDisjoint1 {
        \schemaVar \term G x;
        \schemaVar \term H y;
    
	\find(x = y)
   	\varcond(\not\sub(Null, G), \disjointModuloNull(G, H))
   	
   	\replacewith(false)
   	\heuristics(concrete)
    };
   
   
    sortsDisjoint2 {
        \schemaVar \term G x;
        \schemaVar \term H y;

	\find(x = y)
	\varcond(\not\sub(Null, H), \disjointModuloNull(G, H))
	
	\replacewith(false)
	\heuristics(concrete)
    }; 
}
