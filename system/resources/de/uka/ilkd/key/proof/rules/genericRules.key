// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 



// This file contains rules that are applicable for every sort (as they
// use \generic sorts).
// The format is the same as for problem files.

\sorts {
  \generic G, S1, S2, H;
  \generic GSub \extends G;

  \generic C;
  \generic CSub \extends C;
}



// These schema variables are used to write the following rules.
// They will not be visible in later runs of the parser, so you are
// fairly free in choosing their names.
\schemaVariables {
  \term G e,s,t, e0;  
  \term H t1; 
  \term S1 t2; 
  \skolemTerm G sk ;
  \formula b,c;
  \variables G u, e2 ;

  \term G commEqLeft;
  \term H commEqRight;

  \variables GSub r ;

  \term[rigid] G sr;
  \term[rigid] H tr;

  \term G ref1, ref2 ;
  \term S1 ind1, ind2, target ;
  \term S2 else, then ;
  \term numbers iz, jz ;

  \term int i;

}

\rules {

  firstOfPair {
    \find( first(pair(t,t1)) )
    \replacewith(t)
    \heuristics(concrete)
  };

  secondOfPair {
    \find( second(pair(t,t1)) )
    \replacewith(t1)
    \heuristics(concrete)
  };

}


\rules(programRules:Java){
// --------------- rules for casts in the logic (for programs look e.g. in javaRules.key) ----------

 typeEq {
	\find( s = t1 ==>) \add ( H::instance(s) = TRUE, G::instance(t1) = TRUE ==> )	
        \displayname "typeEq"
 };

 typeEqDerived {
	\assumes( s = t1 ==>) \find ( H::instance(s) ) \sameUpdateLevel \replacewith(TRUE)
	\heuristics (simplify, concrete)
        \displayname "typeEq"	
 };
 
 typeEqDerived2 {
	\assumes( s = t1 ==>) \find ( G::instance(t1) ) \sameUpdateLevel \replacewith(TRUE)	
	\heuristics (simplify, concrete)
        \displayname "typeEq"
 };

 typeStatic {
	// is sameUpdateLevel neccessary? Don't think so as static type cannot be changed
	\find (s) \sameUpdateLevel \add ( G::instance(s) = TRUE ==> )
 };
 
 castAdd {
	\schemaVar \term[strict] C strictCTerm2;

	\assumes (CSub::instance(strictCTerm2) = TRUE ==>)
        \find (strictCTerm2) \sameUpdateLevel
        \replacewith ((CSub)strictCTerm2)
	// in confluence_restricted as if and find part must be disjoint
	// to be confluent
	\displayname "narrow type"
 };
 
 castAdd2 {
	\schemaVar \term C cs;
	\schemaVar \term G gt;

	\assumes (cs = gt ==>)
        \find (gt) \sameUpdateLevel
        \varcond (\strict\sub(C, G))
        \replacewith ((C)gt)
	\displayname "castAdd"
 };

 castDel {
	\schemaVar \term C castedTerm;
	\find ((C)castedTerm)
        \replacewith (castedTerm)
	\displayname "castDel"
	\heuristics (simplify, cast_deletion)
 };

 castDel2 {
	\schemaVar \term CSub cs;
	\schemaVar \term G gt;

	\assumes (cs = gt ==>)
        \find ((C)gt) \sameUpdateLevel
        \replacewith (cs)
	\displayname "castDel"
 };

 
 castType {
	\assumes( H::instance((C)s) = TRUE ==> ) 
	\find( CSub::instance(s) = TRUE ==> ) 
	\replacewith( H::instance(s) = TRUE ==> )
	\heuristics (simplify)
	\displayname "castType"
 };

 castType2 {
	\assumes(  ==> H::instance((C)s) = TRUE ) 
	\find( CSub::instance(s) = TRUE ==> ) 
	\replacewith( ==> H::instance(s) = TRUE)
	\heuristics (simplify)
	\displayname "castType"
 };

}

\rules{

 closeType {
	\assumes (==> G::instance(t1) = TRUE) \find (GSub::instance(t1) = TRUE ==>) \closegoal
	\displayname "closeType"
	\heuristics (closure)

 }; 

 closeTypeSwitched {
	\assumes (GSub::instance(t1) = TRUE ==>) \find (==> G::instance(t1) = TRUE ) \closegoal
	\displayname "closeType"
	\heuristics (closure)
 }; 

// for the book
 instancePredicateRewrite {
   \find (G::contains(t))
   \replacewith(G::instance(t) = TRUE)
   \heuristics (simplify) 
 };
 
 
 ineffectiveCast {
    \assumes(H::instance(t) = TRUE ==>)
    \find((H)t) \sameUpdateLevel
    \add((H)t = t ==>)
    \heuristics(inReachableStateImplication)
 };

 // there was a completeness hole w/o this rule
 ineffectiveCast3 {
    \assumes(H::exactInstance(t) = TRUE ==>)
    \find((H)t) \sameUpdateLevel
    \add((H)t = t ==>)
    \heuristics(inReachableStateImplication)
 };

 ineffectiveCast2 {
    \schemaVar \term CSub cs;
    \schemaVar \term G gt;

    \assumes(cs = gt ==>)
    \find((C)gt) \sameUpdateLevel
    \add((C)gt = gt ==>)
    \heuristics(inReachableStateImplication)
 }; 

 
    
} 
 
    //--------------------------------------------------------------------------
    //rules for disjointness of sorts
    //--------------------------------------------------------------------------

\rules(programRules:Java){
   
    sortsDisjointModuloNull {
        \schemaVar \term G x;
        \schemaVar \term H y;
    
	\find(x = y)
	\varcond(\strict\sub(Null, G), \strict\sub(Null, H), \disjointModuloNull(G, H))
	
	\replacewith(x = null & y = null)
	\heuristics(simplify)
    };
 
   
    sortsDisjoint1 {
        \schemaVar \term G x;
        \schemaVar \term H y;
    
	\find(x = y)
   	\varcond(\not\sub(Null, G), \disjointModuloNull(G, H))
   	
   	\replacewith(false)
   	\heuristics(concrete)
    };
   
   
    sortsDisjoint2 {
        \schemaVar \term G x;
        \schemaVar \term H y;

	\find(x = y)
	\varcond(\not\sub(Null, H), \disjointModuloNull(G, H))
	
	\replacewith(false)
	\heuristics(concrete)
    }; 
}
