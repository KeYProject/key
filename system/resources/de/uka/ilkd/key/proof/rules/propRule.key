// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


// This file contains rules that should always be present, 
// but do not depend on a sort. In other words, mainly propositional logic.

// These schema variables are used to write the following rules.
// They will not be visible in later runs of the parser, so you are
// fairly free in choosing their names.


\schemaVariables {
  \formula b,c,d;
  \formula cutFormula;
  \formula[rigid] br, cr;
}

\rules {

  // closing goals
  close       { \assumes (b ==>) \find (==> b) \closegoal 
	        \heuristics(closure) 
		\displayname "close"
	      };
  closeAntec { \assumes (==> b) \find (b ==>) \closegoal \displayname "close" };

  closeFalse   { \find (false ==>) \closegoal \heuristics(closure) };
  closeTrue    { \find (==> true) \closegoal \heuristics(closure) };
  

  // simplification rules
  replace_known_left  { \assumes ( b ==> ) \find ( b ) \sameUpdateLevel
                        \replacewith ( true )
			\heuristics(replace_known_left) };
  replace_known_right { \assumes ( ==> b ) \find ( b ) \sameUpdateLevel
                        \replacewith ( false )
			\heuristics(replace_known_right) };


  // junctor rules
  true_left    { \find (true ==>) \replacewith(==>) \heuristics(concrete) };
  false_right  { \find (==> false) \replacewith(==>) \heuristics(concrete) };

  notLeft  { \find (! b ==>) \replacewith(==> b) \heuristics(alpha) };
  notRight { \find (==> ! b) \replacewith(b ==>) \heuristics(alpha) };

  impLeft  { \find (b -> c ==>) 
		\replacewith(==> b); 
                \replacewith(c ==>)
	      \heuristics(beta) };
  impRight { \find (==> b -> c) \replacewith(b ==> c) 
		\heuristics(alpha) };

  andLeft  { \find (b & c ==>) \replacewith(b, c ==>) \heuristics(alpha) };
  andRight { \find (==> b & c) \replacewith(==> b); \replacewith(==> c) 
                    \heuristics(beta) };
  orLeft   { \find (b | c ==>) 
              "#b":\replacewith(b ==>); "#c":\replacewith(c ==>)
              \heuristics(beta) };
  orRight  { \find (==> b | c) \replacewith(==> b, c) \heuristics(alpha) };

  equiv_left   { \find (b <-> c ==>) 
		      \replacewith(b, c ==>); 
                      \replacewith(==> b, c)
                    \heuristics(beta) };
  
  equiv_right  { \find (==> b <-> c) 
		      \replacewith(b ==> c);
                      \replacewith(c ==> b)
                    \heuristics(beta) };

  /* These `recursive' rules are commented out, because this 
     keyword is not yet supported.
  imp_left_rec { \find (b -> c ==>)  \recursive 
		   \replacewith(==> b); 
                   \replacewith(c ==>) };
  and_right_rec { \find (==> b & c)  \recursive 
		    \replacewith(==> b); 
                    \replacewith(==> c) };
  or_left_rec { \find (b | c ==>)  \recursive
		  \replacewith(b ==>); 
                  \replacewith(c ==>) };
  */
  
  split_or_strong { \find (b | c ==>) 
		      \replacewith (b ==>); 
                      \replacewith(c ==> b) };

///////////////////////////////////////////////////////////////////////////////

  rotate_and { \find (b & (c & d)) \replacewith (c & (b & d)) };
  rotate_or  { \find (b | (c | d)) \replacewith (c | (b | d)) };
  
  // equivalence replacement
  insert_eqv_once_lr { \find (br <-> cr ==>) 
			\addrules( insert_eqv{ \find (br) \replacewith (cr)} )
		     };
  insert_eqv_once_rl { \find (br <-> cr ==>) 
		       \addrules( insert_eqv{ \find (cr) \replacewith (br)} )
                     };

  insert_eqv_lr { \find (br <-> cr ==>)
		    \addrules( insert_eqv{ \find (br) \replacewith (cr) 
					  \heuristics(simplify) } ) };
  insert_eqv_rl { \find (br <-> cr ==>)
		    \addrules( insert_eqv{ \find (cr) \replacewith (br) 
					  \heuristics(simplify) } ) };

  // simplification
  double_not { \find ( ! ( ! b)) \replacewith (b) \heuristics(concrete) };

  concrete_not_1  { \find (! true) \replacewith (false) \heuristics(concrete) };
  concrete_not_2  { \find (! false) \replacewith (true) \heuristics(concrete) };

  concrete_impl_1 { \find (true -> b) \replacewith (b) \heuristics(concrete) };
  concrete_impl_2 { \find (false -> b) \replacewith (true) \heuristics(concrete) };
  concrete_impl_3 { \find (b -> false) \replacewith (! b) \heuristics(concrete) };
  concrete_impl_4 { \find (b -> true) \replacewith (true) \heuristics(concrete) };

  concrete_and_1  { \find (true & b) \replacewith (b) \heuristics(concrete) };
  concrete_and_2  { \find (false & b) \replacewith (false) \heuristics(concrete) };
  concrete_and_3  { \find (b & true) \replacewith (b) \heuristics(concrete) };
  concrete_and_4  { \find (b & false) \replacewith (false) \heuristics(concrete) };

  concrete_or_1   { \find (true | b) \replacewith (true) \heuristics(concrete) };
  concrete_or_2   { \find (false | b) \replacewith (b) \heuristics(concrete) };
  concrete_or_3   { \find (b | true) \replacewith (true) \heuristics(concrete) };
  concrete_or_4   { \find (b | false) \replacewith (b) \heuristics(concrete) };
  
  concrete_eq_1   { \find (true <-> b) \replacewith (b) \heuristics(concrete) };
  concrete_eq_2   { \find (false <-> b) \replacewith (! b) \heuristics(concrete) };
  concrete_eq_3   { \find (b <-> true) \replacewith (b) \heuristics(concrete) };
  concrete_eq_4   { \find (b <-> false) \replacewith (! b) \heuristics(concrete) };


  // other
  cut { "CUT: #cutFormula TRUE":\add (cutFormula ==>);
        "CUT: #cutFormula FALSE":\add (==> cutFormula)
        \heuristics(cut) };

  cut_direct { \find ( cutFormula ) \sameUpdateLevel
               "CUT: #cutFormula TRUE":
               \replacewith ( true ) \add (cutFormula ==>);
               "CUT: #cutFormula FALSE":
               \replacewith ( false ) \add (==> cutFormula)
               \heuristics(cut_direct) };

  cut_direct_r { \find (==> b) \replacewith (==> b); \add (b ==>) };
  cut_direct_l { \find (b ==>) \replacewith (b ==>); \add (==> b) };

  // proofobl not parsed yet.
  // rule_cut { \addrules (rule); \add (==> proofobl(rule)) };

  hide_left  { \find (b ==>) \replacewith (==>)
               \addrules( insert_hidden { \add (b ==>) } ) };
  hide_right { \find (==> b) \replacewith (==>)
               \addrules( insert_hidden { \add (==> b) } ) };

  case_distinction_r { \find (==> b)
		       \addrules( to_true  { \find (==> b) 
					      \replacewith(==>true)  
					    \heuristics(simplify)
					    } );
                       \addrules( to_false { \find (==> b) 
					      \replacewith(==>false) 
					    \heuristics(simplify) 
					    } )
                       \displayname "case_distinction"
		     };

  case_distinction_l { \find (b ==>)
		       \addrules( to_true  { \find (b ==>) 
					      \replacewith(true ==>)  
					    \heuristics(simplify)
					   } );
                       \addrules( to_false { \find (b ==>) 
					     \replacewith(false ==>) 
					    \heuristics(simplify) 
					   } )
                       \displayname "case_distinction"
		     };

}
