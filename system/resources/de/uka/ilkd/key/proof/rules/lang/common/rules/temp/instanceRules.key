\sorts {
  \generic G, S1, S2, H;
  \generic GSub \extends G;
  
  \inter(G,H);

  \generic C;
  \generic CSub \extends C;
}

\schemaVariables {
  \term G e,s,t;  
  \term H t1; 
  \term S1 t2; 
  \formula phi,b,c;
  \term G obj ;
}

\rules {
 type_equality_axiom {
	\find( s = t1 ==>) \add ( H::instance(s) = TRUE, G::instance(t1) = TRUE ==> )	
        \displayname "type equality"
 };

 type_equality_derived_1 {
	\assumes( s = t1 ==>) \find ( H::instance(s) ) \sameUpdateLevel \replacewith(TRUE)
	\heuristics (simplify, concrete)
        \displayname "type equality"	
 };
 
 type_equality_derived_2 {
	\assumes( s = t1 ==>) \find ( G::instance(t1) ) \sameUpdateLevel \replacewith(TRUE)	
	\heuristics (simplify, concrete)
        \displayname "type equality"
 };

 insert_static_type {
	// is sameUpdateLevel neccessary? Don't think so as static type cannot be changed
	\find (s) \sameUpdateLevel \add ( G::instance(s) = TRUE ==> )
 };
 
 add_cast {
	\schemaVar \term[strict] C strictCTerm2;

	\assumes (CSub::instance(strictCTerm2) = TRUE ==>)
        \find (strictCTerm2) \sameUpdateLevel
        \replacewith ((CSub)strictCTerm2)
	// in confluence_restricted as if and find part must be disjoint
	// to be confluent
	\displayname "narrow type"
 };
 
 add_cast_2 {
	\schemaVar \term C cs;
	\schemaVar \term G gt;

	\assumes (cs = gt ==>)
        \find (gt) \sameUpdateLevel
        \varcond (\strict\sub(C, G))
        \replacewith ((C)gt)
	\displayname "narrow type"
 };

 del_cast {
	\schemaVar \term C tc2;
	\find ((C)tc2) \sameUpdateLevel \replacewith (tc2)
	\displayname "remove unnecessary cast"
	\heuristics (simplify)
 }; 

 del_cast_2 {
	\schemaVar \term CSub cs;
	\schemaVar \term G gt;

	\assumes (cs = gt ==>)
        \find ((C)gt) \sameUpdateLevel
        \replacewith (cs)
	\displayname "remove cast"
 };

 type_intersection {
	\assumes (G::instance(s) = TRUE ==>)
	\find (H::instance(s) = TRUE ==>) 
        \add(\inter(G,H)::instance(s) = TRUE ==>)
 };


 cast_type {
	\assumes( H::instance((C)s) = TRUE ==> ) 
	\find( CSub::instance(s) = TRUE ==> ) 
	\replacewith( H::instance(s) = TRUE ==> )
	\heuristics (simplify)
	\displayname "cast type"
 };

 cast_type_2 {
	\assumes(  ==> H::instance((C)s) = TRUE ) 
	\find( CSub::instance(s) = TRUE ==> ) 
	\replacewith( ==> H::instance(s) = TRUE)
	\heuristics (simplify)
	\displayname "cast type"
 };

 close_type {
	\assumes (==> G::instance(t1) = TRUE) \find (GSub::instance(t1) = TRUE ==>) \closegoal
	\displayname "close goal (unsatisfiable type constraints)"
	\heuristics (closure)

 }; 

 close_type_switched {
	\assumes (GSub::instance(t1) = TRUE ==>) \find (==> G::instance(t1) = TRUE ) \closegoal
	\displayname "close goal (unsatisfiable type constraints)"
	\heuristics (closure)
 }; 


 // Not strictly neccessary
 instanceof_static_type {
       \find(G::instance(obj))
       \varcond(\sub(\typeof(obj), G))
       \replacewith(TRUE)
       \displayname "instanceof static type is subtype"
       \heuristics(simplify, evaluate_instanceof)
 };
}