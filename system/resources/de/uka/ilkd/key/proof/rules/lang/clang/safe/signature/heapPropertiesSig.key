\sorts {
}

\functions {
	// Root object of the given object. Null is a root object.
	Object rootObj(Object);

	// Tells for root (non-null) objects the lookup index in the repository function.
	int rootObjLookupIdx(Object);	

	// Object's parent of non-root objects.
	Object objParent(Object);

	// Object's index within it's parent's children
	// * For structured parent sort returns the 0-based index of the member
	// * For array parent sort returns the element index
	int objParentIdx(Object);
	
	// Function that converts the first integer value to the dynamic type of 
	// the second value (integer to pointer conversion)
	// NB! This is not a function with correctly defined semantics, but just 
	// a syntactical aid for parametrizing rules with different behavior.
	Object convertIntegerToPointer(Value, Object);
	
	// Function that converts the first object to the dynamic integer type of 
	// the second value (pointer to integer conversion)
	// NB! This is not a function with correctly defined semantics, but just 
	// a syntactical aid for parametrizing rules with different behavior.
	Value convertPointerToInteger(Object, Value);
	
	// Computes a diff of given objects (as pointers)
	// Precondition: isValidObj(Object1) & isValidObj(Object2) & objPtrCanDiff(Object1, Object2)
	// NB! This is not a function with correctly defined semantics, but just 
	// a syntactical aid for parametrizing rules with different behavior.	
	int objPtrDiff(Object, Object);	
}

\predicates {
	// Whether this is a valid object (includes array tails)
	// Null is not a valid object.
	isValidObj(Object);

	// Whether this is a real object (excludes array tails)
	// Null is not a real object.
	isRealObj(Object);

	// Whether the array index is valid (includes array tails)
	// Works in terms of <code>size(Array)</code>
	isValidIdx(Array, int);	

	// Whether the array index is real(excludes array tails)
	// Works in terms of <code>size(Array)</code>
	isRealIdx(Array, int);

	// Whether the second object aliases the first one 
	// (Transitive closure of "Object2 is the first child of Object1")
	objAliased(Object, Object);

	// Whether the first object contains the second object (reflexive)
	objContains(Object, Object);

	// Whether this is a root object
	// Null is a root object.
	isRootObj(Object);

	// Whether this object is an array element
	isArrayElem(Object);

	// Whether this object is a struct member
	isStructMember(Object);
	
	// Function that tells if it is possible to convert the first object 
	// to the dynamic integer type of the second value (pointer to integer conversion)
	// NB! This is just a syntactical aid for parametrizing rules with different behavior.	
	canConvertPointerToInteger(Object, Value);
		
	// Tells if two two objects are equal (in terms of pointer comparison)
	// Can return a fresh skolem symbol
	// Precondition: isValidObj(Object1) & isValidObj(Object2)
	// NB! This is not a predicate with correctly defined semantics, but just 
	// a syntactical aid for parametrizing rules with different behavior.	
	objPtrEq(Object, Object);
	
	// Tells if given objects can be compared as pointers
	// Precondition: isValidObj(Object1) & isValidObject(Object2)
	// NB! This is just a syntactical aid for parametrizing rules with different behavior.	
	objPtrCanCompare(Object, Object);
		
	// Tells if the first object comes earlier than the second(in terms of pointer comparison)
	// Can return a fresh skolem symbol
	// Precondition: isValidObj(Object1) & isValidObj(Object2)	
	// NB! This is not a predicate with correctly defined semantics, but just 
	// a syntactical aid for parametrizing rules with different behavior.	
	objPtrLess(Object, Object);
	
	// Tells if given objects can be diffed as pointers
	// Precondition: isValidObj(Object1) & isValidObject(Object2)
	// NB! This is just a syntactical aid for parametrizing rules with different behavior.	
	objPtrCanDiff(Object, Object);
}
