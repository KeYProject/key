// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 



// This file contains rules for handling java programs


\include assertions;


\optionsDecl{
  initialisation:{disableStaticInitialisation, enableStaticInitialisation};
}

\sorts{
  \generic G;
  \generic H;
  \generic J \extends G;
  \generic GOS \extends Object;
  \generic alphaObj \extends Object;
  \generic betaObj \extends Object;
}

\schemaVariables {
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
 \modalOperator { diamond, diamond_transaction } #diamond;
 \modalOperator { box, box_transaction } #box;


 \formula post, inv, post1;
 \program Type #t, #t2 ;
 \program NonPrimitiveType #npit ;  

 \term G q ;
 \skolemTerm G sk ;

 \program ArrayLength #length ;
 
 \program MultipleVariableDeclaration #multvardecl ;
 \program ArrayPostDeclaration #arraypost ;
 \program SimpleExpression #se, #se0, #se1, #se2 ;
 \program SimpleExpression #src, #dest, #srcOff, #destOff, #arlength;

 \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2 ;
 \program LeftHandSide #attribute ;
 \program Variable #loc ;
 \program StaticVariable #sv, #sv0, #sv1 ;

 \program Variable #v, #v0, #v1, #v2, #boolv, #a, #a0, #a1 ;

 \program ConstantPrimitiveTypeVariable #cv ;   // variables that are compile-time constants
 \program Variable #b0, #ar1 ;
 \program VariableInitializer #vi ;
 \program SimpleExpression #seBool,#seBool0,#seBool1,#seBool2 ;
 \program JavaBooleanExpression #exBool,#exBool0,#exBool1,#exBool2 ;

 \program NonSimpleExpression #nseBool,#nseBool0,#nseBool1,#nseBool2 ;
 \program Statement #s, #s0, #s1 ;
 \program LoopInit #loopInit ;
 \program Guard #guard ;
 \program ForUpdates #forupdates ;
 \program ForLoop #forloop ;
 \program Expression #e, #e0, #e1, #e2 ;
 \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv ;

 \program[list] Statement #slist, #slist1, #slist2, #slist3 ;
 \program[list] Expression #elist ;
 \program[list] SimpleExpression #selist ;
 \program[list] Catch #cs ;

 \program Switch #sw ;
 \program Label #lb, #lb0, #lb1, #innerLabel, #outerLabel;
 \program NonSimpleMethodReference #nsmr;
 \program NonModelMethodBody #mb;
 \program MethodName #mn;

 \program NonPrimitiveType[name=javacard.framework.JCSystem] #jcsystemType;
 \program MethodName[name=nativeKeYBeginTransaction] #beginTransaction;
 \program MethodName[name=nativeKeYCommitTransaction] #commitTransaction;
 \program MethodName[name=nativeKeYAbortTransaction] #abortTransaction;

 \program ExecutionContext #ex, #ex1 ; 
 \program ProgramMethod #pm ; 

 \formula anon1, anon2, anon3;
 
 \formula for1,for2;

 \program NonStringLiteral #lit ;
 \program StringLiteral #slit ;
 
 \variables int iv, iv2, iv3 ;
 \term int idx;

 // generic sorts
 \term G variant ;
 \term GOS array;
 \term H obj ;

 \variables G x ;
 \term H then, else ;
 
 \term G updatedTerm1, updatedTerm2;
}


\rules(programRules:Java,JavaCard:on) {

  getJavaCardTransient {
    \schemaVar \program MethodName[name=nativeKeYGetTransient] #getTransient;
    \find (==> 
      \modality{#allmodal}{.. 
         #lhs = #jcsystemType.#getTransient(#se)@#jcsystemType;
      ...}\endmodality post )
    "Normal Execution":
       \replacewith(==> 
         { #lhs := int::select(heap, #se, java.lang.Object::<transient>) }
           \modality{#allmodal}{.. ...}\endmodality post );
    "#se is not null":
       \replacewith(==> #se != null)
    \heuristics(simplify_prog)
  };

  setJavaCardTransient {
    \schemaVar \program MethodName[name=nativeKeYSetTransient] #setTransient;
    \find (==> 
      \modality{#allmodal}{.. 
         #jcsystemType.#setTransient(#se, #se1)@#jcsystemType;
      ...}\endmodality post )
    "Normal Execution":
      \replacewith(==> 
        { heap := store(heap, #se, java.lang.Object::<transient>, #se1) }
          \modality{#allmodal}{.. ...}\endmodality post );
    "#se is not null":
      \replacewith(==> #se != null)
    \heuristics(simplify_prog)
  };

  beginJavaCardTransactionAPI {
    \find (==>
      \modality{#allmodal}{..
         #jcsystemType.#beginTransaction()@#jcsystemType;
      ...}\endmodality post)
    \replacewith(==>
      \modality{#allmodal}{.. #beginJavaCardTransaction; ...}\endmodality post )
    \heuristics(simplify_prog)
  };

  commitJavaCardTransactionAPI {
    \find (==>
      \modality{#allmodal}{..
         #jcsystemType.#commitTransaction()@#jcsystemType;
      ...}\endmodality post)
    \replacewith(==>
      \modality{#allmodal}{.. #commitJavaCardTransaction; ...}\endmodality post )
    \heuristics(simplify_prog)
  };

  abortJavaCardTransactionAPI {
    \find (==>
      \modality{#allmodal}{..
         #jcsystemType.#abortTransaction()@#jcsystemType;
      ...}\endmodality post)
    \replacewith(==>
      \modality{#allmodal}{.. #abortJavaCardTransaction; ...}\endmodality post )
    \heuristics(simplify_prog)
  };

  beginJavaCardTransactionDiamond {
    \find (==>
      \<{..
         #beginJavaCardTransaction;
      ...}\> post)
    \replacewith(==>
      {savedHeap := heap}\diamond_transaction{.. ...}\endmodality post )
    \heuristics(simplify_prog)
    \displayname "beginJavaCardTransaction"
  };

  beginJavaCardTransactionBox {
    \find (==>
      \[{..
         #beginJavaCardTransaction;
      ...}\] post)
    \replacewith(==>
      {savedHeap := heap}\box_transaction{.. ...}\endmodality post )
    \heuristics(simplify_prog)
    \displayname "beginJavaCardTransaction"
  };

  commitJavaCardTransactionDiamond {
    \find (==>
      \diamond_transaction{..
         #commitJavaCardTransaction;
      ...}\endmodality post)
    \replacewith(==>
      \<{.. ...}\> post)
    \heuristics(simplify_prog)
    \displayname "commitJavaCardTransaction"
  };

  commitJavaCardTransactionBox {
    \find (==>
      \box_transaction{..
         #commitJavaCardTransaction;
      ...}\endmodality post)
    \replacewith(==>
      \[{.. ...}\] post)
    \heuristics(simplify_prog)
    \displayname "commitJavaCardTransaction"
  };

  finishJavaCardTransactionDiamond {
    \find (==>
      \diamond_transaction{..
         #finishJavaCardTransaction;
      ...}\endmodality post)
    \replacewith(==>
      \<{.. ...}\> post)
    \heuristics(simplify_prog)
    \displayname "finishJavaCardTransaction"
  };

  finishJavaCardTransactionBox {
    \find (==>
      \box_transaction{..
         #finishJavaCardTransaction;
      ...}\endmodality post)
    \replacewith(==>
      \[{.. ...}\] post)
    \heuristics(simplify_prog)
    \displayname "finishJavaCardTransaction"
  };

  abortJavaCardTransactionDiamond {
    \find (==>
      \diamond_transaction{..
         #abortJavaCardTransaction;
      ...}\endmodality post)
    \replacewith(==>
      {heap := anon(savedHeap, allObjects(java.lang.Object::<transactionConditionallyUpdated>), heap)}\<{.. ...}\> post)
    \heuristics(simplify_prog)
    \displayname "abortJavaCardTransaction"
  };

  abortJavaCardTransactionBox {
    \find (==>
      \box_transaction{..
         #abortJavaCardTransaction;
      ...}\endmodality post)
    \replacewith(==>
      {heap := anon(savedHeap, allObjects(java.lang.Object::<transactionConditionallyUpdated>), heap)}\[{.. ...}\] post)
    \heuristics(simplify_prog)
    \displayname "abortJavaCardTransaction"
  };

}

\rules(programRules:Java) {

  emptyModality { \schemaVar \modalOperator { diamond, box } #normal;
                  \find (\modality{#normal}{}\endmodality(post)) 
                  \replacewith(post) 
                  \heuristics(simplify_prog) 
                };

  emptyModalityBoxTransaction { 
                  \find (\box_transaction{  }\endmodality(post)) 
                  "Unbalanced Transaction": \replacewith( true )
                  \displayname "emptyModality"  
                  \heuristics(simplify_prog) 
                };

  emptyModalityDiamondTransaction { 
                  \find (\diamond_transaction{  }\endmodality(post)) 
                  "Unbalanced Transaction": \replacewith( false )
                  \displayname "emptyModality"  
                  \heuristics(simplify_prog) 
                };

  returnUnfold { \find (\modality{#allmodal}{.. return #nse; ...}\endmodality(post)) 
       \varcond(\new(#v0, \typeof(#nse))) 	
       \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; return #v0; ...}\endmodality(post)) 
       \heuristics(simplify_prog)
       \displayname "returnUnfold"}; 


//-----------------------------------------------------------------------------------------
//                        some common assignment rules 
//-----------------------------------------------------------------------------------------

  assignment  { \find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
                      \replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post)) 
	              \heuristics(simplify_prog, simplify_prog_subset)};
	
  // skip index check as the case below can only happen in an implicit method
  assignment_write_array_this_access_normalassign{
		\find (\modality{#allmodal}{.#pm@#t(#v).. this[#se]=#se0; ...}\endmodality(post))
	        \replacewith(( lt(#se,length(#v)) & lt(-1,#se)) ->   
			{heap:=store(heap, #v, arr(#se), #se0)}\modality{#allmodal}{.. ...}\endmodality(post))
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment"};


  // skip index check as the case below can only happen in an implicit method
  eval_array_this_access{
		\find (\modality{#allmodal}{.. this[#nse]=#se0; ...}\endmodality(post))
                \varcond(\new(#v0, \typeof(#nse))) 
  		\replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; this[#v0]=#se0; ...}\endmodality(post))
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "eval_array_access"};


//---------- rules for array store ---------------//


   array_self_reference {	 
        \assumes (inReachableState ==> array = null)
	\find (arrayStoreValid(array, G::select(heap, array, arr(idx))))  \sameUpdateLevel 
	\replacewith(true)
	\heuristics(simplify)
   };

   // author: scheben; correctness proven in KeY for G = Object
   array_self_reference_eq {
        \schemaVar \term G EQ;
        \assumes (inReachableState, G::select(heap, array, arr(idx)) = EQ ==> array = null)
	\find (arrayStoreValid(array, EQ))  \sameUpdateLevel
	\replacewith(true)
	\heuristics(simplify)
   };

   null_can_always_be_stored_in_a_reference_type_array {
        \assumes (==> array = null)
	\find (arrayStoreValid(array, null)) \sameUpdateLevel
	\varcond(\isReferenceArray(array))
	\replacewith(true)
	\heuristics(simplify)
   };

   
/*   array_store_known_dynamic_array_type_prim {
	\find (arrayStoreValid(G::<get>(idx), vint_val))	
        \varcond(\isReference(G))
	\replacewith(#arrayBaseInstanceOf(G::<get>(idx), vint_val) = TRUE)
	\heuristics(simplify)
	\displayname "known dynamic array type"
   };
  */ 
   
   array_store_known_dynamic_array_type {
	\assumes (J::exactInstance(array) = TRUE ==>)
	\find (arrayStoreValid(array, obj)) \sameUpdateLevel
	\varcond (\isReference[non_null](J))
	\replacewith(obj = null | 
	    #arrayBaseInstanceOf(J::exactInstance(array), obj) = TRUE)
	\heuristics(simplify)
	\displayname "known dynamic array type"
   };

// ------------ dynamic types ------------------ //

  /*  // will be uncommented soon 
       dynamic_type_for_null {
	  \find (G::exactInstance(null) = TRUE ==>)
	  \varcond(G not Null) // Woj: parser doesn't allow this at the moment
	  \replacewith(false)
	};
   };*/


//--------------- variable declarations --------------------------------------//


  //reviewed 04/19/2004, St.S.
  variableDeclaration { \find (\modality{#allmodal}{.. #t #v0; ...}\endmodality(post)) 
		        \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                        \addprogvars(#v0) 
                        \heuristics(simplify_prog, simplify_prog_subset)
                        \displayname "variableDeclaration"
  };

  variableDeclarationFinal { \find (\modality{#allmodal}{.. final #t #v0; ...}\endmodality(post)) 
		             \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                             \addprogvars(#v0) 
                             \heuristics(simplify_prog, simplify_prog_subset)
                             \displayname "variableDeclaration"
  };
  
  variableDeclarationGhost { \find (\modality{#allmodal}{.. ghost #t #v0; ...}\endmodality(post)) 
		             \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                             \addprogvars(#v0) 
                             \heuristics(simplify_prog, simplify_prog_subset)
                             \displayname "ghostDeclaration"
  };  
  

 variableDeclarationAssign  { \find (\modality{#allmodal}{.. #t #v0 = #vi; ...}\endmodality(post))
                              \replacewith (\modality{#allmodal}{.. #t #v0; #v0 = #vi; ...}\endmodality(post))
                              \heuristics(simplify_prog, simplify_prog_subset)
                              \displayname "variableDeclaration"
  };

 variableDeclarationFinalAssign { \find (\modality{#allmodal}{.. final #t #v0 = #vi; ...}\endmodality(post))
                                  \replacewith (\modality{#allmodal}{.. final #t #v0; #v0 = #vi; ...}\endmodality(post))
                                  \heuristics(simplify_prog, simplify_prog_subset)
                                  \displayname "variableDeclaration"
  };
  
 variableDeclarationGhostAssign { \find (\modality{#allmodal}{.. ghost #t #v0 = #vi; ...}\endmodality(post))
                                  \replacewith (\modality{#allmodal}{.. ghost #t #v0; #v0 = #vi; ...}\endmodality(post))
                                  \heuristics(simplify_prog, simplify_prog_subset)
                                  \displayname "ghostDeclaration"};  
				  				  

 variableDeclarationMult { \find (\modality{#allmodal}{.. #multvardecl ...}\endmodality(post)) 
			   \replacewith (\modality{#allmodal}{.. #resolve-multiple-var-decl(#multvardecl); ...}\endmodality(post)) 
			   \heuristics(simplify_prog, simplify_prog_subset)
                           \displayname "variableDeclaration"
  };

 array_post_declaration { \find (\modality{#allmodal}{.. #arraypost ...}\endmodality(post)) 
				\replacewith (\modality{#allmodal}{.. 
				                         #array-post-declaration(#arraypost);
                                                       ...}\endmodality(post)) 
				\heuristics(simplify_prog,
				simplify_prog_subset)};

//--------------- try-statement ----------------------------------------------//

 throwNull { \find (\modality{#allmodal}{.. throw null; ...}\endmodality(post))
             \replacewith (\modality{#allmodal}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
             \displayname "throwNull"
  };

 throwUnfold   { \find (\modality{#allmodal}{.. throw #nse; ...}\endmodality(post))
	            \varcond(\new(#v0, \typeof(#nse))) 
            	    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0 = #nse; throw #v0; ...}\endmodality(post))
                    \heuristics(simplify_prog) 
 		    \displayname "throwUnfold"
  };

// VERIFY this rule:

throwLabel {
    \find (\modality{#allmodal}{.. #lb: throw #se; ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
};

throwLabelBlock {
    \find (\modality{#allmodal}{.. #lb: { throw #se; #slist } ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
};

throwBox { 
    \find (\modality{#box}{ throw #se; #slist }\endmodality (post))
    \replacewith(true)
    \heuristics(simplify_prog)
};

throwDiamond { 
    \find (\modality{#diamond}{ throw #se; #slist }\endmodality (post))
    \replacewith(false)
    \heuristics(simplify_prog)
};


 tryCatchThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               catch ( #t #v0 ) { #slist1 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                            try { throw new java.lang.NullPointerException (); }
                            catch ( #t #v0 ) { #slist1 }
                      } else if ( #se instanceof #t ) {
                            #t #v0;
                            #v0 = (#t) #se;
                            #slist1
                      } else {
                            throw #se;
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchThrow"
  };

 tryMultipleCatchThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               catch ( #t #v0 ) { #slist1 }
               catch ( #t2 #v1 ) { #slist3 }
               catch #cs ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           try { throw new java.lang.NullPointerException (); }
                           catch ( #t #v0 ) { #slist1 }
                           catch ( #t2 #v1 ) { #slist3 }
                           catch #cs
                      } else if ( #se instanceof #t ) {
                           #t #v0;
                           #v0 = (#t) #se;
                           #slist1
                      } else {
                           try { throw #se; }
                           catch ( #t2 #v1 ) { #slist3 }
                           catch #cs
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchThrow"
  };

 tryCatchFinallyThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist}
               catch ( #t #v0 ) { #slist1 }
               catch #cs
               finally { #slist2 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           try { throw new java.lang.NullPointerException (); }
                           catch ( #t #v0 ) { #slist1 }
                           catch #cs
                           finally { #slist2 }
                      } else if ( #se instanceof #t ) {
                           try {
                              #t #v0;
                              #v0 = (#t) #se;
                              #slist1
                           } finally { #slist2 }
                      } else {
                           try { throw #se; }
                           catch #cs
                           finally { #slist2 }
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchFinallyThrow"
  };

// Note: If an exception is not caught, the finally block is executed first,
// then the exception is propagated. Especially, if null is thrown,
// a new NPE is thrown after the finally block. JLS 3rd ed., Sect. 11.3.
 tryFinallyThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               finally { #slist2 } ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#se)))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           { #slist2 }
                           throw new java.lang.NullPointerException ();
                      } else {
                           #typeof(#se) #v0 = #se;
                           { #slist2 }
                           throw #v0;
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryFinallyThrow"
  };

 tryEmpty   { \find (\modality{#allmodal}{.. try {} #cs ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
  };

 tryFinallyEmpty {
    \find (\modality{#allmodal}{.. try {}
               catch #cs
               finally { #slist2 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. { #slist2 }  ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryEmpty"
  };

 tryBreakLabel {
    \find (\modality{#allmodal}{.. try { break #lb; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. break #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
  };

 tryFinallyBreakLabel {
    \find (\modality{#allmodal}{.. try { break #lb; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } break #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
  };

 tryBreak {
    \find (\modality{#allmodal}{.. try { break; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. break; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
  };

 tryFinallyBreak {
    \find (\modality{#allmodal}{.. try { break; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } break; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
  };

/*
 try_continue_1 {
    \find (\modality{#allmodal}{.. try { continue #lb; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. continue #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_finally_continue_1 {
    \find (\modality{#allmodal}{.. try { continue #lb; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } continue #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_continue_2 {
    \find (\modality{#allmodal}{.. try { continue; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. continue; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_finally_continue_2 {
    \find (\modality{#allmodal}{.. try { continue; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } continue; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };
*/

 tryReturn {
    \find (\modality{#allmodal}{.. try { return #se; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. return #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
  };

 tryFinallyReturn {
    \find (\modality{#allmodal}{.. try { return #se; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#se)))
    \replacewith (\modality{#allmodal}{.. #typeof(#se) #v0 = #se;
                      { #slist2 }
                      return #v0; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
  };

 tryReturnNoValue {
    \find (\modality{#allmodal}{.. try { return; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. return; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
  };

 tryFinallyReturnNoValue {
    \find (\modality{#allmodal}{.. try { return; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } return; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
  };


//------------------------------------------------------------------------
// ----------- Rules for prefix and postfix increment and decrement operators
//------------------------------------------------------------------------

  //reviewed 04/16/2004, St.S.
 preincrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = ++#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1); #lhs0 = #lhs1; 
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = ++#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1); #lhs0=#v.#attribute;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //new 06/12/2008, BW
 preincrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = ++#e[#e0]; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#v[#v0] = (#typeof(#e[#e0]))(#v[#v0]+1); #lhs0=#v[#v0];
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement     { \find (\modality{#allmodal}{.. ++#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement_attribute     { \find (\modality{#allmodal}{.. ++#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};
             
  //new 06/12/2008, BW
 preincrement_array     { \find (\modality{#allmodal}{.. ++#e[#e0]; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
				#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};             

  //reviewed 04/16/2004, St.S.
 predecrement     { \find (\modality{#allmodal}{.. --#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 predecrement_attribute     { \find (\modality{#allmodal}{.. --#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};
             
  //new 06/12/2008, BW
 predecrement_array     { \find (\modality{#allmodal}{.. --#e[#e0]; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
		#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};             
 
  //reviewed 04/16/2004, St.S.
 predecrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = --#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1-1); #lhs0 = #lhs1; ...}\endmodality(post)) 
            \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 predecrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs = --#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1); #lhs = #v.#attribute;
             ...}\endmodality(post)) \heuristics(simplify_expression)};
             
  //new 06/12/2008, BW
 predecrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = --#e[#e0]; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#v[#v0] = (#typeof(#e[#e0]))(#v[#v0]-1); #lhs0 = #v[#v0];
             ...}\endmodality(post)) \heuristics(simplify_expression)};             

  //reviewed 06/23/2005, St.S.
 postincrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = #lhs1++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#lhs0) #v = #lhs1; #lhs1 = (#typeof(#lhs1))(#lhs1+1); #lhs0 = #v;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postincrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = #e.#attribute++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#lhs0) #v1=#v.#attribute; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postincrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = #e[#e0]++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#typeof(#lhs0) #v1=#v[#v0]; #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]+1); #lhs0=#v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement     { \find (\modality{#allmodal}{.. #lhs1++; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement_attribute     { \find (\modality{#allmodal}{.. #e.#attribute++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement_array     { \find (\modality{#allmodal}{.. #e[#e0]++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
				#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement     { \find (\modality{#allmodal}{.. #lhs1--; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))#lhs1-1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement_attribute     { \find (\modality{#allmodal}{.. #e.#attribute--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement_array     { \find (\modality{#allmodal}{.. #e[#e0]--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
		#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = #lhs1--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#lhs0) #v = #lhs1; #lhs1 = (#typeof(#lhs1))(#lhs1-1); #lhs0 = #v; ...}\endmodality(post)) 
            \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = #e.#attribute--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#lhs0) #v1=#v.#attribute; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = #e[#e0]--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#typeof(#lhs0) #v1=#v[#v0]; #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]-1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

// boolean cast
 castToBoolean {
    \find(\modality{#allmodal}{.. #lhs = (boolean) #exBool; ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. #lhs = #exBool; ...}\endmodality(post))
    \heuristics(simplify_prog)
 };



//-----------------------------------------------------------------------------------------//
//--------------- reference type casts  ---------------------------------------------------//
//-----------------------------------------------------------------------------------------//


 // implementation of the rules for type casts defined in the Java language 
 // specification, chapter 5.5. We assume that no compile-time error occurred.
 
 // null can be cast to any type

 compound_reference_cast_expression { \find (\modality{#allmodal}{.. #lhs = (#npit) #nse; ...}\endmodality(post))
                       \varcond (\new(#v, \typeof(#nse)))
                       \replacewith ( \modality{#allmodal}{.. #typeof(#nse) #v = #nse;
		                                   #lhs = (#npit) #v;
                                                ...}\endmodality(post) )
                       \heuristics(simplify_prog)
		       \displayname "cast" };
}

\rules(programRules:Java, runtimeExceptions:allow) {
 reference_type_cast { \find (\modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality(post)) \sameUpdateLevel
 		       \varcond(\hasSort(#npit, G))
    		       "Normal Execution (#se instanceof #npit)":		      
                         \replacewith ({#lhs := #addCast(#se,#lhs)}\modality{#allmodal}{.. ...}\endmodality(post))
                         \add(#se = null | G::instance(#se) = TRUE ==>);
                       "ClassCastException (!(#se instanceof #npit))":		      
                         \replacewith (\modality{#allmodal}{.. throw new java.lang.ClassCastException(); 
                                                            ...}\endmodality(post))
                         \add(==> #se = null | G::instance(#se) = TRUE)
                       \heuristics(simplify_prog) };
}

\rules(programRules:Java, runtimeExceptions:ban) {
 reference_type_cast { \find (==> \modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality(post))
		       \varcond(\hasSort(#npit, G))
    		       "Normal Execution (#se instanceof #npit)":		      
                         \replacewith (==> {#lhs := #addCast(#se,#lhs)}\modality{#allmodal}{.. ...}\endmodality(post))
                         //\add(#se = null | G::instance(#se) = TRUE ==>)
                         ;
                       "ClassCastException (!(#se instanceof #npit))":		      
                         \replacewith (==> false)
                         \add(==> #se = null | G::instance(#se) = TRUE)
                       \heuristics(simplify_prog) };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
 reference_type_cast { 
   \find (\modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality(post))
   \varcond(\hasSort(#npit, G))
   \replacewith ({#lhs := #addCast(#se,#lhs)}\modality{#allmodal}{.. ...}\endmodality(post))
   \heuristics(simplify_prog) };
}


//--------------- methods ----------------------------------------------------//

\rules(programRules:Java, runtimeExceptions:allow) {
  methodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality(post)) \sameUpdateLevel
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null )":
      \replacewith (\modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post)) 
      \add (==> #se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allmodal}{.. throw new java.lang.NullPointerException();
   	  	                  ...}\endmodality(post)) 
      \add (#se = null==>)
    \heuristics(method_expand)
    };
}

\rules(programRules:Java, runtimeExceptions:ban) {
  methodCall { 
    \find (==> \modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality(post))
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null )":
      \replacewith (==> \modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post)) 
      //\add (==> #se = null)
      ;
    "Null Reference (#se = null)":
      \replacewith (==> false) 
      \add (#se = null==>)
    \heuristics(method_expand)
    };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
  methodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality(post))
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    \replacewith (\modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post)) 
    \heuristics(method_expand)
  };
}

\rules(programRules:Java, runtimeExceptions:allow) {
  methodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post))) \sameUpdateLevel
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null)":
      \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
	  	                            #method-call(#v0, #se.#mn(#selist));
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
      \add (==>#se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allmodal}{.. throw new java.lang.NullPointerException();
                                  ...}\endmodality(post))
      \add (#se = null  ==> )
    \heuristics(method_expand)
  };
}

\rules(programRules:Java, runtimeExceptions:ban){
  methodCallWithAssignment { 
    \find (==> \modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post)))
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null)":
      \replacewith (==> \modality{#allmodal}{.. #typeof(#lhs) #v0;
	  	                            #method-call(#v0, #se.#mn(#selist));
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
      //\add (==>#se = null)
      ;
    "Null Reference (#se = null)":
      \replacewith (==> false)
      \add (#se = null  ==> )
    \heuristics(method_expand)
  };
}


\rules(programRules:Java, runtimeExceptions:ignore){
  methodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post)))
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
	  	                            #method-call(#v0, #se.#mn(#selist));
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
    \heuristics(method_expand)
  };
}



\rules(programRules:Java) {

  methodCallUnfoldArguments { 
    \find (\modality{#allmodal}{.. #nsmr ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#nsmr); ...}\endmodality(post))
    \heuristics(simplify_autoname)
  };

  methodCallUnfoldTarget { 
    \find (\modality{#allmodal}{.. #nse.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#nse)))
    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0; 
                               #v0 = #nse; #v0.#mn(#elist); ...}\endmodality(post))
    \heuristics(simplify_autoname)
  };
}


\rules(programRules:Java) {

  // may trigger static initialisation, but the super class has either
  // initialized or during initialisation, but not erroneous. So nothing
  // happens and we do not need to treat static initialisation here
  methodCallSuper { 
    \find (\modality{#allmodal}{.#ex.. super.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #method-call(#ex, super.#mn(#elist)); 
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
  };

  // may trigger static initialisation, but the super class has either
  // initialized or during initialisation, but not erroneous. So nothing
  // happens and we do not need to treat static initialisation here
  methodCallWithAssignmentSuper {
    \find (\modality{#allmodal}{.#ex.. #lhs=super.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, super.#mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \displayname "methodCallSuper"
    \heuristics(simplify_autoname)
  };
  
}


\rules(programRules:Java) {

  methodCallWithAssignmentUnfoldArguments { 
    \find (\modality{#allmodal}{.. #lhs = #nsmr; ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#lhs = #nsmr); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCallUnfoldArguments"
  };

  methodCallWithAssignmentUnfoldTarget { 
    \find (\modality{#allmodal}{.. #lhs = #nse.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#nse)))
    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0; 
                               #v0 = #nse; #lhs = #v0.#mn(#elist); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCallUnfoldTarget"	
  };

  methodCallEmpty { 
    \find (\modality{#allmodal}{.. method-frame(#ex):{} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
  };

  methodCallEmptyReturn { 
     \find (\modality{#allmodal}{.. method-frame(#ex):{return; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
     \displayname "methodCallReturn"
  };

  methodCallReturn { 
     \find (\modality{#allmodal}{.. method-frame(#v0, #ex):{return #se; #slist} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{.. method-frame(#ex):{ #v0 = #se; } ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallReturn"
  };

  methodCallReturnIgnoreResult { 
    \find (\modality{#allmodal}{.. method-frame(#ex):{return #se; #slist} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post))
    \displayname "methodCallReturn"
    \heuristics(simplify_prog) 
  };

  methodBodyExpand { 	
    \find (\modality{#allmodal}{.. #mb ...}\endmodality(post))
    \replacewith (#introAtPreDefs(\modality{#allmodal}{.. #expand-method-body(#mb); ...}\endmodality(post)))
    \heuristics(simplify_prog) 
  };

  blockReturnNoValue { 
     \find (\modality{#allmodal}{.. {return; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn"
  };

  blockReturn { 
     \find (\modality{#allmodal}{.. {return #se; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn"
  };

  blockReturnLabel1 { 
     \find (\modality{#allmodal}{.. #lb: return #se; ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn (remove label)"
  };

  blockReturnLabel2 { 
     \find (\modality{#allmodal}{.. #lb: { return #se; #slist } ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn (remove label)"
  };

  
  methodCallThrow {
     \find (\modality{#allmodal}{.. method-frame(#ex):{throw #se; #slist} ...}\endmodality(post)) 
     \varcond(\isLocalVariable(#se))
     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallThrow"
  };

  methodCallParamThrow { 
     \find (\modality{#allmodal}{.. method-frame(#v0, #ex):{throw #se; #slist} 
                      ...}\endmodality(post)) 
     \varcond(\isLocalVariable(#se))
     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallThrow"
  };


  //throwEvaluate in the book, ignored for consistency reasons
  throwUnfoldMore {
     \find (\modality{#allmodal}{.. throw #se; ...}\endmodality(post)) 
     \varcond(\not\isLocalVariable(#se), \new(#v0, \typeof(#se)))
     \replacewith (\modality{#allmodal}{.. #typeof(#se) #v0 = #se; throw #v0; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "throwUnfold"
  };


  blockThrow { 
    \find (\modality{#allmodal}{.. {throw #e; #slist} ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. throw #e;  ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset) 
    \displayname "blockThrow"
  };


  methodCallEmptyNoreturnBox { 
    \find (\[{.. method-frame(#v0, #ex):{} ...}\](post)) 
    \replacewith (\[{..  ...}\](post)) 
    \displayname "methodCallEmpty"
    \heuristics(simplify_prog) 
  };

//--------------- loops ------------------------------------------------------//

 loopUnwind    { \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
		   \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
	           \replacewith (\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel,
	           					     while(#e) #s); ...}\endmodality(post))
		   \heuristics(loop_expand)
		};



/* deprecated for-loop treatment 
 * (when/if deleting forInitUnfold, also delete meta construct #unpack)
 */
/*  
  forInitUnfold { 
	\find (\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality(post))
	\replacewith 
	   (\modality{#allmodal}{.. 
		#unpack(for(#loopInit; #guard; #forupdates) #s);
            ...}\endmodality(post)) 
        \heuristics(simplify)
 };


forUnwindEmptyInit { 
     \find (\modality{#allmodal}{.. for(; #guard; #forupdates) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
              for(; #guard; #forupdates) #s); ...}\endmodality(post)) 
     \heuristics(loop_expand)

 
 forUnwindEmptyUpdate { 
     \find (\modality{#allmodal}{.. for(#loopInit; #guard;) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
	   for(#loopInit; #guard;) #s); ...}\endmodality(post)) 
     \heuristics(loop_expand) 
   }; 

 
 forUnwindEmptyInitUpdate { 
     \find (\modality{#allmodal}{.. for(; #guard;) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
                   for(; #guard;) #s); ...}\endmodality(post)) 
     \heuristics(loop_expand)
   }; 
*/
 
// for_inv      { \find (\[{.. for(#i; #e; #sel) {#s} ...}\]post) 
//           \varcond(#v new)
//          \replacewith (==> inv);
//          \replacewith (inv ==> \[{.. #unwind-loop (for(#i; #e; #sel)
//           {#s})  ...}\])
//          \replacewith (inv, \<{.. #v = #e; ...}\> #v = false ==>
//           \<{.. boolean #v = #e; ...}\>post) };


  doWhileUnwind {
	\find (\modality{#allmodal}{.. do #s while (#e); ...}\endmodality(post))
 	\varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
	\replacewith (\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel, do #s while(#e);); ...}\endmodality(post))
        // This rule is not only for unwinding, but it transforms
        // a do-while loop into a while loop (plus one body expansion upfront)
	// \heuristics(loop_expand)
        \heuristics(simplify_prog)
  };

  // Make a while loop out of a for loop
  for_to_while {
	\find (\modality{#allmodal}{.. #forloop ...}\endmodality(post))
	\varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
        \replacewith(\modality{#allmodal}{.. #for-to-while(#innerLabel, #outerLabel, #forloop) ...}\endmodality(post))
	\heuristics(simplify_prog)
  };


  arrayInitialisation {
	\find (\modality{#allmodal}{.#pm@#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	        //{\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv] := #lit}
	\replacewith({heap:=memset(heap,
				   arrayRange(#a, #se, length(#a) - 1),
	                           #lit)} \modality{#allmodal}{..  ...}\endmodality(post))
	\heuristics(simplify)
  };




//--------------- if-statements ----------------------------------------------//

  ifUnfold {  \find (\modality{#allmodal}{.. if(#nse) #s0 ...}\endmodality(post))
     \varcond (\new(#boolv, boolean))
     \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 ...}\endmodality(post))
     \heuristics(simplify_autoname)
     \displayname "ifElseUnfold"
  };

  ifElseUnfold { \find (\modality{#allmodal}{.. if(#nse) #s0 else #s1 ...}\endmodality(post)) 
     \varcond (\new(#boolv, boolean))
     \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 else{#s1}
                    ...}\endmodality(post) ) 
     \heuristics(simplify_autoname)
     \displayname "ifElseUnfold"
  };

  if  { \find (\modality{#allmodal}{.. if(#se) #s0  ...}\endmodality(post))
       \replacewith (\if (#se=TRUE) \then (\modality{#allmodal}{.. #s0 ...}\endmodality(post)) 
       \else (\modality{#allmodal}{.. ...}\endmodality(post))) 
       //\heuristics(split_if)
       \displayname "ifElse"
  };

  ifElse  { \find (\modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality(post))
       \replacewith (\if (#se=TRUE) \then (\modality{#allmodal}{.. #s0 ...}\endmodality(post)) 
       \else (\modality{#allmodal}{.. #s1 ...}\endmodality(post))) 
       //\heuristics(split_if)
       \displayname "ifElse"
  };

  ifElseSplit  { \find (==> \modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality(post))
       "if #se true":  \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) \add (#se = TRUE ==>);
       "if #se false": \replacewith (==> \modality{#allmodal}{.. #s1 ...}\endmodality(post)) \add (#se = FALSE ==>)
       \heuristics(split_if)
       \displayname "ifElseSplit"
  };

  ifSplit  { \find (==> \modality{#allmodal}{.. if(#se) #s0  ...}\endmodality(post) )
	"if #se true":  \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) \add (#se = TRUE ==>);
	"if #se false": \replacewith (==> \modality{#allmodal}{..  ...}\endmodality(post)) \add (#se = FALSE ==>)  
	\heuristics(split_if)
	\displayname "ifElseSplit"
  };

  ifElseSplitLeft  { \find ( \modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality(post) ==>)
       \replacewith ( \modality{#allmodal}{.. #s0 ...}\endmodality(post)==>) \add (#se = TRUE ==>);
       \replacewith ( \modality{#allmodal}{.. #s1 ...}\endmodality(post)==>) \add (#se = FALSE ==>)  \heuristics(split_if)
   };

  ifSplitLeft  { \find ( \modality{#allmodal}{.. if(#se) #s0  ...}\endmodality(post) ==>)
       \replacewith ( \modality{#allmodal}{.. #s0 ...}\endmodality(post)==>) \add (#se = TRUE ==>);
       \replacewith ( \modality{#allmodal}{..  ...}\endmodality(post)==>) \add (#se = FALSE ==>)  \heuristics(split_if)
  };

  ifTrue   { \assumes ( #se = TRUE ==>)
       \find (==> \modality{#allmodal}{.. if (#se) #s0 ...}\endmodality(post)) 
       \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post))  
       \heuristics (simplify_prog)
  };


  ifElseTrue { \assumes ( #se = TRUE ==>)
		 \find (==> \modality{#allmodal}{.. if (#se) #s0 else #s1 ...}\endmodality(post))
                 \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) 
		 \heuristics (simplify_prog)
  };

  ifFalse   { \assumes ( #se = FALSE ==>)
       \find (==> \modality{#allmodal}{.. if (#se) #s0 ...}\endmodality(post))        
       \replacewith (==> \modality{#allmodal}{.. ...}\endmodality(post))  
       \heuristics (simplify_prog)
  };

  ifElseFalse { \assumes ( #se = FALSE ==>)
		 \find (==> \modality{#allmodal}{.. if (#se) #s0 else #s1 ...}\endmodality(post)) 
                 \replacewith (==> \modality{#allmodal}{.. #s1 ...}\endmodality(post)) 
                 \heuristics (simplify_prog)
  };


  ifEnterThen { 
	\find (\modality{#allmodal}{.. #loc=true; if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=true; #s0 ...}\endmodality(post))
        \heuristics (simplify)
  };

  ifSkipThen { 
	\find (\modality{#allmodal}{.. #loc=false; if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=false; ...}\endmodality(post)) 
        \heuristics (simplify)
  };

  ifElseSkipElse { 
	\find (\modality{#allmodal}{.. #loc=true; if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=true; #s0 ...}\endmodality(post))
        \heuristics (simplify)
  };

  ifElseSkipThen { 
	\find (\modality{#allmodal}{.. #loc=false; if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=false; #s1 ...}\endmodality(post))
        \heuristics (simplify)
  };


  ifEnterThenConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=true; } if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=true; } #s0 ...}\endmodality(post))
        \heuristics (simplify)
 	\displayname "ifEnterThen"
  };

  ifSkipThenConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=false; } if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=false; } ...}\endmodality(post)) 
        \heuristics (simplify)
	\displayname "ifSkipThen"
  };

  ifElseSkipElseConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=true;} if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=true;} #s0 ...}\endmodality(post))
        \heuristics (simplify)
        \displayname "ifElseSkipElse"
  };

  ifElseSkipThenConditionInBlock { 
       \find (\modality{#allmodal}{.. { #loc=false; } if (#loc) #s0 else #s1 ...}\endmodality(post))
       \replacewith (\modality{#allmodal}{.. { #loc=false; } #s1 ...}\endmodality(post))
       \heuristics (simplify)
       \displayname "ifElseSkipThen"
  };
 
 

//--------------- switch-statements ------------------------------------------//

 
switch { 
    \find (\modality{#allmodal}{.. #sw ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. #switch-to-if(#sw) ...}\endmodality(post)) 
    \heuristics (simplify_prog)
  };


//--------------- labels and blocks ------------------------------------------//


 break { \find (\modality{#allmodal}{.. #lb0: break #lb1;  ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. #do-break(#lb0: break #lb1;); ...}\endmodality(post))
	\heuristics (simplify_prog)};

 blockBreakNoLabel { \find (\modality{#allmodal}{.. { break #lb1; #slist} ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. break #lb1; ...}\endmodality(post))
	\heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockBreakNoLabel"
 };

 blockBreakLabel { \find (\modality{#allmodal}{.. #lb0: {break #lb1; #slist } ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. #do-break(#lb0: break #lb1;); ...}\endmodality(post))
	\heuristics (simplify_prog)
 };

 blockEmptyLabel      { \find (\modality{#allmodal}{.. #lb:{} ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. {}  ...}\endmodality(post)) 
	    \heuristics(simplify_prog, simplify_prog_subset)
            \displayname "blockEmpty"
 };
 
                        
 blockEmpty { 
     \find (\modality{#allmodal}{.. {} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
 };


 unusedLabel {
	\find (\modality{#allmodal}{.. #lb: #s ...}\endmodality(post))
	\varcond(\not\freeLabelIn(#lb,#s))
	\replacewith(\modality{#allmodal}{.. #s ...}\endmodality(post))
	\heuristics(simplify_prog)
 };
 


 emptyStatement { 
     \find (\modality{#allmodal}{.. ; ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
 };



 synchronizedBlockEmpty {
     \find (\modality{#allmodal}{.. synchronized(#e){} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
 };



//----------------------------------------------------------------------------
//-----------                  instanceof 			   -----------
//----------------------------------------------------------------------------

 instanceof_eval { 
       \find(\modality{#allmodal}{.. #v = #nse instanceof #t; ...}\endmodality(post))
       \varcond(\new(#v0, \typeof(#nse))) 
       \replacewith ( \modality{#allmodal}{..#typeof(#nse) #v0=#nse; 
			#v=#v0 instanceof #t;...}\endmodality(post) )
       \heuristics(simplify_autoname)
 };

 instanceof_static_type {
       \schemaVar \term any a;
       \find(G::instance(a))
       \varcond(\sub(\typeof(a), G))
       \replacewith(TRUE)
       \displayname "instanceof static supertype"
       \heuristics(simplify, evaluate_instanceof)
 };
 
 instanceof_static_type_2 { 
       \schemaVar \term any a, a2;   
       \assumes(a2 = a ==>)        
       \find(G::instance(a))  \sameUpdateLevel
       \varcond(\sub(\typeof(a2), G))
       \replacewith(TRUE)
       \displayname "instanceof static supertype"
       \heuristics(simplify, evaluate_instanceof)
 }; 

 instanceof_not_compatible {
       \schemaVar \term any a;
       \find(G::instance(a) = TRUE)
       \varcond(\sub(Null,G),\disjointModuloNull(G, \typeof(a)))
       \replacewith(a = null)
       \displayname "instanceof disjoint type"
       \heuristics(simplify, evaluate_instanceof)
 };

 instanceof_not_compatible_2 {
       \schemaVar \term any a;
       \find(G::instance(a) = FALSE)
       \varcond(\sub(Null,G),\disjointModuloNull(G, \typeof(a)))
       \replacewith(!(a = null))
       \displayname "instanceof disjoint type"
       \heuristics(simplify, evaluate_instanceof)
 };
 
 instanceof_not_compatible_3 {
       \schemaVar \term any a;
       \find(G::instance(a) = TRUE)
       \varcond(\not\sub(Null,G),\disjointModuloNull(G, \typeof(a)))
       \replacewith(false)
       \displayname "instanceof disjoint type"
       \heuristics(simplify, evaluate_instanceof)
 };

 instanceof_not_compatible_4 {
       \schemaVar \term any a;
       \find(G::instance(a) = FALSE)
       \varcond(\not\sub(Null,G),\disjointModuloNull(G, \typeof(a)))
       \replacewith(true)
       \displayname "instanceof disjoint type"
       \heuristics(simplify, evaluate_instanceof)
 };

 instanceof_known_dynamic_type {
       \schemaVar \term any a;
       \assumes(G::exactInstance(a) = TRUE ==>)
       \find(H::instance(a)) \sameUpdateLevel
       \varcond(\sub(G,H))
       \replacewith(TRUE)
       \heuristics(simplify, evaluate_instanceof)
 };
 
 instanceof_known_dynamic_type_2 {
       \schemaVar \term any a;
       \assumes(G::exactInstance(a) = TRUE ==>)
       \find(H::instance(a)) \sameUpdateLevel
       \varcond(\not\sub(G,H))
       \replacewith(FALSE)
       \heuristics(simplify, evaluate_instanceof)
 };
 
 exact_instance_known_dynamic_type {
       \schemaVar \term any a;
       \assumes(G::exactInstance(a) = TRUE ==>)
       \find(H::exactInstance(a)) \sameUpdateLevel
       \varcond(\not\same(G,H))
       \replacewith(FALSE)
       \heuristics(simplify, evaluate_instanceof)
 }; 
 


//----------------------------------------------------------------------------
//-----------            Compile-time constant variables           -----------
//----------------------------------------------------------------------------

 insert_constant_value { \find ( #cv ) 
                         \replacewith ( #constantvalue ( #cv ) )
                         \heuristics(concrete)  
                       };



//------------------------------------------------------------------------
// ------------ Rules for conditional expression
//------------------------------------------------------------------------


 condition { \find (\modality{#allmodal}{.. #lhs = #e0 ? #e1 : #e2; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. if(#e0) {#lhs = #e1;} 
             else {#lhs = #e2;} ...}\endmodality(post)) 
    \heuristics(simplify_prog, split_if)
 };

 condition_not_simple {
   \find (\modality{#allmodal}{.. #lhs = #nse ? #se1 : #se2; ...}\endmodality(post))
   \varcond (\new(#v0, \typeof(#nse)))
   \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0 = #nse; #lhs = #v0 ? #se1 : #se2; ...}\endmodality(post))
   \heuristics(simplify_prog)
   \displayname "condition"
 };

 condition_simple {
   \find (\modality{#allmodal}{.. #lhs = #se0 ? #se1 : #se2; ...}\endmodality(post))
   \replacewith( { #lhs := \if (#se0 = TRUE) \then (#se1) \else (#se2) }
	\modality{#allmodal}{.. ...}\endmodality(post))
   \heuristics(simplify_prog)
   \displayname "condition"
 };


//------------------------------------------------------------------------
// ------------ Rules for comparison operators
//------------------------------------------------------------------------

  equality_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 == #se1; ...}\endmodality(post)) 
    \replacewith ( \if (!#se0=#se1) 
                    \then (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))  
                    \else (\modality{#allmodal}{.. #lhs = true;  ...}\endmodality(post)) )
    \heuristics(obsolete,simplify_prog, split_if)
    \displayname "equality comparison"
  };

 equality_comparison_simple { 
    \find ( \modality{#allmodal}{.. #lhs = #se0 == #se1; ...}\endmodality(post))
    \replacewith ( { #lhs := \if (#se0=#se1) \then (TRUE) \else (FALSE) }
		\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "equality comparison"
  };

  inequality_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 != #se1; ...}\endmodality(post)) 
    \replacewith ( \if (!#se0=#se1) \then (\modality{#allmodal}{.. #lhs = true; ...}\endmodality(post)) 
                                  \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(obsolete,simplify_prog, split_if)
    \displayname "inequality comparison"
  };

  inequality_comparison_simple { 
    \find ( \modality{#allmodal}{.. #lhs = #se0 != #se1; ...}\endmodality(post))
    \replacewith ( {#lhs := \if(#se0=#se1) \then (FALSE) \else (TRUE) }
		\modality{#allmodal}{.. ...}\endmodality(post) )
    \heuristics(simplify_prog)
    \displayname "inequality comparison"
  };

  less_than_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 < #se1; ...}\endmodality(post)) 
    \replacewith ( \if (lt(#se0,#se1)) \then (\modality{#allmodal}{.. #lhs = true;  ...}\endmodality(post)) 
                  		     \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(obsolete,simplify_prog, split_if)
    \displayname "lesser than distinction"
  };

  less_than_comparison_simple { 
    \find ( \modality{#allmodal}{.. #lhs = #se0 < #se1; ...}\endmodality(post)) 
    \replacewith( {#lhs := \if(lt(#se0,#se1)) \then (TRUE) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "lesser than distinction"
  };

  less_equal_than_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 <= #se1; ...}\endmodality(post)) 
    \replacewith ( \if (leq(#se0,#se1)) \then (\modality{#allmodal}{.. #lhs = true; ...}\endmodality(post))  
                                      \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
    \heuristics(obsolete,simplify_prog, split_if)
    \displayname "less-or-equal than distinction"
   };

  less_equal_than_comparison_simple { 
    \find ( \modality{#allmodal}{.. #lhs = #se0 <= #se1; ...}\endmodality(post))
    \replacewith( {#lhs := \if (leq(#se0,#se1)) \then (TRUE) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "less-or-equal than distinction"
   };

  greater_than_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 > #se1; ...}\endmodality(post)) 
    \replacewith ( \if (gt(#se0,#se1)) \then (\modality{#allmodal}{.. #lhs = true;  ...}\endmodality(post)) 
                                     \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
    \heuristics(obsolete,simplify_prog, split_if)
    \displayname "greater than distinction"
   };

  greater_than_comparison_simple { 
    \find ( \modality{#allmodal}{.. #lhs = #se0 > #se1; ...}\endmodality(post)) 
    \replacewith ( {#lhs := \if (gt(#se0,#se1)) \then (TRUE) \else (FALSE)} 
		\modality{#allmodal}{.. ...}\endmodality(post)) 
    \heuristics(simplify_prog)
    \displayname "greater than distinction"
   };

  greater_equal_than_comparison_new { \find ( \modality{#allmodal}{.. #lhs = #se0 >= #se1; ...}\endmodality(post)) 
    \replacewith ( \if (geq(#se0,#se1)) \then (\modality{#allmodal}{.. #lhs = true; ...}\endmodality(post))
		                      \else (\modality{#allmodal}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(obsolete,simplify_prog, split_if)
    \displayname "greater-or-equal than distinction"
   };

  greater_equal_than_comparison_simple { 
    \find ( \modality{#allmodal}{.. #lhs = #se0 >= #se1; ...}\endmodality(post))
    \replacewith ({#lhs := \if(geq(#se0,#se1)) \then (TRUE) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "greater-or-equal than distinction"
   };




//------------------------------------------------------------------------
// ----------- Rules for handling a cast applied to a compound expression
//------------------------------------------------------------------------

  compound_byte_cast_expression { \find (\modality{#allmodal}{.. #lhs = (byte) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (byte) #v;  ...}\endmodality(post))
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_short_cast_expression { \find (\modality{#allmodal}{.. #lhs = (short) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (short) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_int_cast_expression { \find (\modality{#allmodal}{.. #lhs = (int) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (int) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_long_cast_expression { \find (\modality{#allmodal}{.. #lhs = (long) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (long) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

//------------------------------------------------------------------------
// ----------- Rules for expanding compound assignment operators
//------------------------------------------------------------------------

   compound_assignment_op_mul_attr { \find (\modality{#allmodal}{.. #e0.#attribute *= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute * #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mul_array { \find (\modality{#allmodal}{.. #e0[#e] *= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
			#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] * #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_mul { \find (\modality{#allmodal}{.. #v *= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v * (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_div_attr { \find (\modality{#allmodal}{.. #e0.#attribute /= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute / #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_div_array { \find (\modality{#allmodal}{.. #e0[#e] /= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] / #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_div { \find (\modality{#allmodal}{.. #v /= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v / (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod_attr { \find (\modality{#allmodal}{.. #e0.#attribute %= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute % #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod_array { \find (\modality{#allmodal}{.. #e0[#e] %= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] % #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod { \find (\modality{#allmodal}{.. #v %= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v % (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus_attr { \find (\modality{#allmodal}{.. #e0.#attribute += #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute + #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus_array { \find (\modality{#allmodal}{.. #e0[#e] += #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] + #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus { \find (\modality{#allmodal}{.. #v += #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v + (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus_attr { \find (\modality{#allmodal}{.. #e0.#attribute -= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute - #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus_array { \find (\modality{#allmodal}{.. #e0[#e] -= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] - #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus { \find (\modality{#allmodal}{.. #v -= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v - (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft_attr { \find (\modality{#allmodal}{.. #e0.#attribute <<= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute << #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft_array { \find (\modality{#allmodal}{.. #e0[#e] <<= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] << #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft { \find (\modality{#allmodal}{.. #v <<= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v << (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright_attr { \find (\modality{#allmodal}{.. #e0.#attribute >>= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute >> #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright_array { \find (\modality{#allmodal}{.. #e0[#e] >>= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] >> #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright { \find (\modality{#allmodal}{.. #v >>= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v >> (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright_attr { \find (\modality{#allmodal}{.. #e0.#attribute >>>= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute >>> #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright_array { \find (\modality{#allmodal}{.. #e0[#e] >>>= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] >>> #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright { \find (\modality{#allmodal}{.. #v >>>= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v >>> (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_and_attr { \find (\modality{#allmodal}{.. #e0.#attribute &= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute & #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_and_array { \find (\modality{#allmodal}{.. #e0[#e] &= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] & #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_and { \find (\modality{#allmodal}{.. #v &= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v & (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_or_attr { \find (\modality{#allmodal}{.. #e0.#attribute |= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute | #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_or_array { \find (\modality{#allmodal}{.. #e0[#e] |= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] | #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_or { \find (\modality{#allmodal}{.. #v |= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v | (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor_attr { \find (\modality{#allmodal}{.. #e0.#attribute ^= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute ^ #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor_array { \find (\modality{#allmodal}{.. #e0[#e] ^= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] ^ #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor { \find (\modality{#allmodal}{.. #v ^= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v ^ (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  


//------------------------------------------------------------------------
// ----------- Rule for expanding iterated assignments -------------------
//------------------------------------------------------------------------

  eval_order_iterated_assignments_0_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]=#e1; 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_0_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute=#e;
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_0 { \find (\modality{#allmodal}{.. #lhs0=#lhs1=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1=#e; #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_1_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]*=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] * #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_1_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute*=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute * #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_1 { \find (\modality{#allmodal}{.. #lhs0=#lhs1*=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 * #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_2_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]/=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] / #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_2_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute/=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute / #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_2 { \find (\modality{#allmodal}{.. #lhs0=#lhs1/=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 / #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_3_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]%=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] % #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_3_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute%=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute % #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_3 { \find (\modality{#allmodal}{.. #lhs0=#lhs1%=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 % #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_4_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]+=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] + #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_4_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute+=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute + #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_4 { \find (\modality{#allmodal}{.. #lhs0=#lhs1+=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 + #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_5_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]-=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] - #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_5_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute-=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute - #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_5 { \find (\modality{#allmodal}{.. #lhs0=#lhs1-=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 - #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_6_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]<<=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] << #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_6_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute<<=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute << #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_6 { \find (\modality{#allmodal}{.. #lhs0=#lhs1<<=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 << #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_7_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]>>=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] >> #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_7_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute>>=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute >> #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_7 { \find (\modality{#allmodal}{.. #lhs0=#lhs1>>=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 >> #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_8_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]>>>=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] >>> #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_8_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute>>>=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute >>> #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_8 { \find (\modality{#allmodal}{.. #lhs0=#lhs1>>>=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 >>> #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_9_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]&=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] & #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_9_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute&=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute & #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_9 { \find (\modality{#allmodal}{.. #lhs0=#lhs1&=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 & #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_10_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]|=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] | #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_10_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute|=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute | #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_10 { \find (\modality{#allmodal}{.. #lhs0=#lhs1|=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 | #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_11_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]^=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] ^ #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_11_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute^=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute ^ #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_11 { \find (\modality{#allmodal}{.. #lhs0=#lhs1^=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 ^ #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


//------------------------------------------------------------------------
// ----------- Rule for removing redundant braces
//------------------------------------------------------------------------

 elim_double_block { \find (\modality{#allmodal}{{ #slist }}\endmodality(post)) \replacewith (\modality{#allmodal}{ #slist }\endmodality(post)) };

 elim_double_block_2 { \find (\modality{#allmodal}{.. { { #slist } } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. { #slist } ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_3 { \find (\modality{#allmodal}{.. { while ( #e ) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. while ( #e ) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_4 { \find (\modality{#allmodal}{.. { for(#loopInit; #guard; #forupdates) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_5 { \find (\modality{#allmodal}{.. { for(; #guard; #forupdates) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(; #guard; #forupdates) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_6 { \find (\modality{#allmodal}{.. { for(#loopInit; #guard;) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(#loopInit; #guard;) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_7 { \find (\modality{#allmodal}{.. { for(; #guard;) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(; #guard;) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_8 { \find (\modality{#allmodal}{.. { do #s while (#e); } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. do #s while (#e); ...}\endmodality(post))
                       \displayname "elim_double_block" };


//------------------------------------------------------------------------
// ----------- Rule for removing redundant parentheses
//------------------------------------------------------------------------

  remove_parentheses_right  { \find (\modality{#allmodal}{.. #lhs = (#e); ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs = #e; ...}\endmodality(post)) \heuristics(simplify_prog)};

  remove_parentheses_attribute_left  { \find (\modality{#allmodal}{.. (#e.#attribute) = #e0; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #e.#attribute = #e0; ...}\endmodality(post)) \heuristics(simplify_prog)
	\displayname "remove_parentheses"
	};

  remove_parentheses_lhs_left  { \find (\modality{#allmodal}{.. (#lhs) = #e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs = #e; ...}\endmodality(post)) \heuristics(simplify_prog)
	\displayname "remove_parentheses"
	};

//------------------------------------------------------------------------ 
// ----------- Rules for binary arithmetic operators applied to at least one compound expression
//------------------------------------------------------------------------

   compound_multiplication_1 { \find (\modality{#allmodal}{.. #lhs=#nse * #se; ...}\endmodality(post))
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v * #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "multiplication"};

   compound_multiplication_2 { \find (\modality{#allmodal}{.. #lhs=#e * #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 * #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "multiplication"};

   compound_division_1 { \find (\modality{#allmodal}{.. #lhs=#nse / #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v / #se; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "division"};

   compound_division_2 { \find (\modality{#allmodal}{.. #lhs=#e / #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 / #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "division"};

   compound_modulo_1 { \find (\modality{#allmodal}{.. #lhs=#nse % #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v % #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "modulo"};

   compound_modulo_2 { \find (\modality{#allmodal}{.. #lhs=#e % #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 % #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "modulo"};

   compound_addition_1 { \find (\modality{#allmodal}{.. #lhs=#nse + #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v + #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "addition"};

   compound_addition_2 { \find (\modality{#allmodal}{.. #lhs=#e + #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 + #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "addition"};

   compound_binary_AND_1 { \find (\modality{#allmodal}{.. #lhs=#nse & #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v & #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_AND"};

   compound_binary_AND_2 { \find (\modality{#allmodal}{.. #lhs=#e & #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 & #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_AND"};

   compound_binary_OR_1 { \find (\modality{#allmodal}{.. #lhs=#nse | #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v | #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_OR"};

   compound_binary_OR_2 { \find (\modality{#allmodal}{.. #lhs=#e | #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 | #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_OR"};

   compound_binary_XOR_1 { \find (\modality{#allmodal}{.. #lhs=#nse ^ #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v ^ #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_XOR"};

   compound_binary_XOR_2 { \find (\modality{#allmodal}{.. #lhs=#e ^ #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 ^ #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_XOR"};

   compound_invert_bits { \find (\modality{#allmodal}{.. #lhs=~#nse; ...}\endmodality(post)) 
         \varcond (\new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{..  #typeof(#nse) #v1=#nse; #lhs=~#v1 ; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "invert_bits"};

   compound_subtraction_1 { \find (\modality{#allmodal}{.. #lhs=#nse - #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v - #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "subtraction"};

   compound_subtraction_2 { \find (\modality{#allmodal}{.. #lhs=#e - #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 - #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "subtraction"};

   compound_shiftright_1 { \find (\modality{#allmodal}{.. #lhs=#nse >> #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >> #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_shiftright_2 { \find (\modality{#allmodal}{.. #lhs=#e >> #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >> #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_unsigned_shiftright_1 { \find (\modality{#allmodal}{.. #lhs=#nse >>> #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >>> #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_unsigned_shiftright_2 { \find (\modality{#allmodal}{.. #lhs=#e >>> #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >>> #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

  compound_shiftleft_1 { \find (\modality{#allmodal}{.. #lhs=#nse << #se; ...}\endmodality(post)) 
	\varcond (\new(#v, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v << #se; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "shift"};

  compound_shiftleft_2 { \find (\modality{#allmodal}{.. #lhs=#e << #nse; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 << #v1; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "shift"};

  compound_equality_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 == #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 == #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "equality"};

  compound_equality_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e == #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 == #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "equality"};

  compound_inequality_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 != #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 != #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "inequality"};

  compound_inequality_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e != #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 != #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "inequality"};

  compound_less_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 < #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 < #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_than"};

  compound_less_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e < #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 < #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_than"};

  compound_less_equal_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 <= #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 <= #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_or_equal"};

  compound_less_equal_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e <= #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 <= #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_or_equal"};

  compound_greater_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 > #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 > #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_than"};

  compound_greater_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e > #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 > #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_than"};

  compound_greater_equal_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 >= #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 >= #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_or_equal"};

  compound_greater_equal_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e >= #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 >= #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_or_equal"};

//------------------------------------------------------------------------
//---------------------- Rules boolean expressions -----------------------
//------------------------------------------------------------------------


// new rules which do not necessarily lead to proof splits -- DB 09/08/12

  compound_assignment_1_new { \find (\modality{#allmodal}{.. #lhs=!#seBool; ...}\endmodality(post)) 
         \replacewith ({#lhs:= \if(#seBool=TRUE) \then (FALSE) \else (TRUE)}\modality{#allmodal}{.. ...}\endmodality(post))
         \heuristics(simplify_expression)
         \displayname "assignment_negation"};


  compound_assignment_2 { \find (\modality{#allmodal}{.. #lhs=!#nseBool; ...}\endmodality(post))
          \varcond (\new(#v, boolean))
          \replacewith (\modality{#allmodal}{.. boolean #v=#nseBool; #lhs=!#v; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_3_nonsimple { \find (\modality{#allmodal}{.. #lhs=#exBool0 && #nseBool1; ...}\endmodality(post)) 
          \replacewith (\modality{#allmodal}{.. if (!#exBool0) #lhs=false; else #lhs=#nseBool1; ...}\endmodality(post))
          \heuristics(simplify_expression,split_if)
          \displayname "compound_assignment"};

   compound_assignment_3_mixed { 
	\find (\modality{#allmodal}{.. #lhs=#nseBool0 && #seBool1; ...}\endmodality(post)) 
	\varcond (\new(#v0, boolean) )
          \replacewith (\modality{#allmodal}{.. boolean #v0 = #nseBool0; #lhs = #v0 && #seBool1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_3_simple { 
	\find (\modality{#allmodal}{.. #lhs=#seBool0 && #seBool1; ...}\endmodality(post)) 
          \replacewith ({#lhs:= \if (#seBool0=TRUE) \then (\if(#seBool1=TRUE)\then(TRUE)\else(FALSE)) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "assignment_and"};


   compound_assignment_4_nonsimple { 
	\find (\modality{#allmodal}{.. #lhs=#nseBool0 & #exBool1; ...}\endmodality(post))
	\varcond (\new(#v0, boolean), \new(#v1, boolean) )
          \replacewith (\modality{#allmodal}{.. boolean #v0 = #nseBool0;
			boolean #v1 = #exBool1; #lhs= #v0 & #v1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_4_simple { 
	\find (\modality{#allmodal}{.. #lhs=#seBool0 & #seBool1; ...}\endmodality(post))
          \replacewith ({#lhs:= \if (#seBool0=TRUE) \then (\if(#seBool1=TRUE)\then(TRUE)\else(FALSE)) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "assignment_and"};

    compound_assignment_5_nonsimple { 
	\find (\modality{#allmodal}{.. #lhs=#exBool0 || #nseBool1; ...}\endmodality(post)) 
          \replacewith (\modality{#allmodal}{.. if (#exBool0) #lhs=true; else #lhs=#nseBool1; ...}\endmodality(post))
          \heuristics(simplify_expression,split_if)
          \displayname "compound_assignment"};

   compound_assignment_5_mixed { 
	\find (\modality{#allmodal}{.. #lhs=#nseBool0 || #seBool1; ...}\endmodality(post)) 
	\varcond (\new(#v0, boolean) )
          \replacewith (\modality{#allmodal}{.. boolean #v0 = #nseBool0; #lhs = #v0 || #seBool1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

    compound_assignment_5_simple { 
	\find (\modality{#allmodal}{.. #lhs=#seBool0 || #seBool1; ...}\endmodality(post)) 
          \replacewith ( {#lhs:= \if (#seBool0=TRUE) \then (TRUE) \else (\if(#seBool1=TRUE)\then(TRUE)\else(FALSE))}
		\modality{#allmodal}{.. ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "assignment_or"};

   compound_assignment_6_nonsimple { 
	\find (\modality{#allmodal}{.. #lhs=#nseBool0 | #exBool1; ...}\endmodality(post))
	\varcond (\new(#v0, boolean), \new(#v1, boolean) )
          \replacewith (\modality{#allmodal}{.. boolean #v0 = #nseBool0;
			boolean #v1 = #exBool1; #lhs = #v0 | #v1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_6_simple { 
	\find (\modality{#allmodal}{.. #lhs=#seBool0 | #seBool1; ...}\endmodality(post))
          \replacewith ( {#lhs:= \if (#seBool0=TRUE) \then (TRUE) \else (\if(#seBool1=TRUE)\then(TRUE)\else(FALSE))}
			\modality{#allmodal}{.. ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "assignment_or"};

   compound_assignment_xor_nonsimple {
	\find (\modality{#allmodal}{.. #lhs=#nseBool0 ^ #exBool1; ...}\endmodality(post))
	\varcond (\new(#v0, boolean), \new(#v1, boolean) )
          \replacewith (\modality{#allmodal}{.. boolean #v0 = #nseBool0;
			boolean #v1 = #exBool1; #lhs = #v0 ^ #v1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"
   };

   compound_assignment_xor_simple {
	\find (\modality{#allmodal}{.. #lhs=#seBool0 ^ #seBool1; ...}\endmodality(post))
          \replacewith ( {#lhs:= \if (#seBool0=#seBool1) \then (FALSE) \else (TRUE) }
			\modality{#allmodal}{.. ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "assignment_xor"
   };

//------------------------------------------------------------------------
// ----------- Rules for array and attribute expressions 
//------------------------------------------------------------------------

eval_order_array_access1 { 
		\find (\modality{#allmodal}{..#nv[#e]=#e0;...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#nv)) )
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
				#v0[#e]=#e0;
				 ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_array_access2 { 
		\find (\modality{#allmodal}{..#v[#nse]=#e;...}\endmodality(post))
		\varcond (\new(#ar1, \typeof(#v)), \new(#v0, \typeof(#nse)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v) #ar1 = #v;
				#typeof(#nse) #v0=#nse;
				#ar1[#v0]=#e;
					 ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_array_access3 { 
		\find (\modality{#allmodal}{..#v[#se]=#nse;...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)),
            		  \new(#v2, \typeof(#se)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v) #v0=#v;
				#typeof(#se) #v2=#se;
				if(#length-reference(#v)<=#se || #se<0 ) {
				      throw new java.lang.ArrayIndexOutOfBoundsException();
				}
				#typeof(#nse) #v1=#nse;
				#v0[#v2]=#v1; ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentSaveLocation"};


eval_order_array_access4 { 
		\find (\modality{#allmodal}{..#v=#nv[#e];...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#nv)))
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
				#v=#v0[#e];
					...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

eval_order_array_access5 { 
		\find (\modality{#allmodal}{..#v=#v0[#nse];...}\endmodality(post))
		\varcond (\new(#ar1, \typeof(#v0)), \new(#v1, \typeof(#nse)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v0) #ar1 = #v0;
				#typeof(#nse) #v1=#nse;
				#v=#ar1[#v1];
					...}\endmodality(post))
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

eval_order_array_access6 {
		\find (\modality{#allmodal}{..#v=#nv.#length; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#length; ...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

//-----------------------------------------------------------------------


eval_order_access1 {
		\find (\modality{#allmodal}{..#nv.#attribute=#e;...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v0.#attribute=#e;...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_access2 { 
		\find (\modality{#allmodal}{.. #v=#nv.#attribute; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#attribute;...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

}


\rules(programRules:Java, runtimeExceptions:allow) {
  eval_order_access4 {
		\find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)), 
         		\not \static(#a), \not\isThisReference(#v)) 
		\replacewith(\modality{#allmodal}{..if(#v==null){
				throw new java.lang.NullPointerException();
			    }
			    #typeof(#v) #v0=#v;
			    #typeof(#nse) #v1=#nse;
			    #v0.#a=#v1;...}\endmodality(post))
         	\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentSaveLocation"
  };

  eval_order_access4_this {
		\find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
		\varcond(\new(#v1, \typeof(#nse)), 
         		\not \static(#a),\isThisReference(#v)) 
		\replacewith(\modality{#allmodal}{..
			    #typeof(#nse) #v1=#nse;
			    #v.#a=#v1;...}\endmodality(post))
         	\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentSaveLocationThis"
  };

}
  
  
\rules(programRules:Java, runtimeExceptions:ban) {
  eval_order_access4 {
		\find (==> \modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)), 
         		\not \static(#a))
         		
	       "Normal Execution (#v != null)":         		 
		\replacewith(==> \modality{#allmodal}{.. #typeof(#v) #v0=#v;
			                             #typeof(#nse) #v1=#nse;
			                              #v0.#a=#v1;...}\endmodality(post))
    	       //\add(==> #v = null)
    	       ;
			    
    	       "Null Reference (#v = null)":
    	       \replacewith(==> false)
    	       \add(#v = null ==>)
			    
               \heuristics(simplify_prog, simplify_prog_subset)
	       \displayname "assignmentSaveLocation"
  };
}
 
\rules(programRules:Java, runtimeExceptions:ignore) {
  eval_order_access4 {
    \find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)), 
         		\not \static(#a))
         		
    \replacewith(\modality{#allmodal}{.. #typeof(#v) #v0=#v;
			                             #typeof(#nse) #v1=#nse;
			                              #v0.#a=#v1;...}\endmodality(post))
			    
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignmentSaveLocation"
  };
}


\rules(programRules:Java, runtimeExceptions:allow) {
  assignment_to_reference_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (\modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normal}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#normal}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };

}

\rules(programRules:Java, runtimeExceptions:allow, JavaCard:on) {
  assignment_to_reference_array_component_transaction { 
                 \schemaVar \modalOperator { diamond_transaction, box_transaction } #transaction; 
                 \find (\modality{#transaction}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(
                           {heap:=store(heap,#v,arr(#se),#se0)} 
                           {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                                         \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                                         \else(\if(boolean::select(savedHeap, #v,
                                                        java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                              \then(store(savedHeap, #v, arr(#se), #se0))
                                              \else(savedHeap)) }
                           \modality{#transaction}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#transaction}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#transaction}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#transaction}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
                 \displayname "assignment_to_reference_array_component"
  };
}

\rules(programRules:Java, runtimeExceptions:ban) {
  assignment_to_reference_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (==> \modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post))
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>)
			;
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(==> false)
                        \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
  assignment_to_reference_array_component { 
    \schemaVar \modalOperator { diamond, box } #normal; 
    \find (\modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post))
		 \varcond(\isReferenceArray(#v))
    \replacewith({heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ban,JavaCard:on) {
  assignment_to_reference_array_component_transaction { 
                 \schemaVar \modalOperator { diamond_transaction, box_transaction } #transaction; 
                 \find (==> \modality{#transaction}{.. #v[#se]=#se0; ...}\endmodality(post))
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==>
                           {heap:=store(heap,#v,arr(#se),#se0)} 
                           {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                                         \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                                         \else(\if(boolean::select(savedHeap, #v,
                                                        java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                              \then(store(savedHeap, #v, arr(#se), #se0))
                                              \else(savedHeap)) }
                           \modality{#transaction}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>)
			;
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(==> false)
                        \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
                 \displayname "assignment_to_reference_array_component"
  };
}

\rules(programRules:Java, runtimeExceptions:ignore,JavaCard:on) {
  assignment_to_reference_array_component_transaction { 
    \schemaVar \modalOperator { diamond_transaction, box_transaction } #transaction; 
    \find (\modality{#transaction}{.. #v[#se]=#se0; ...}\endmodality(post))
    \varcond(\isReferenceArray(#v))
    \replacewith(
                           {heap:=store(heap,#v,arr(#se),#se0)} 
                           {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                                         \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                                         \else(\if(boolean::select(savedHeap, #v,
                                                        java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                              \then(store(savedHeap, #v, arr(#se), #se0))
                                              \else(savedHeap)) }
                          \modality{#transaction}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignment_to_reference_array_component"
  };
}

\rules(programRules:Java, runtimeExceptions:allow) {
  assignment_to_primitive_array_component {
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normal}{..
			throw new java.lang.NullPointerException(); 
			...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:allow, JavaCard:on) {
  assignment_to_primitive_array_component_transaction {
                 \schemaVar \modalOperator { diamond_transaction, box_transaction } #transaction; 
                 \find (\modality{#transaction}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(
                           {heap:=store(heap,#v,arr(#se),#se0)}
                           {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                                         \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                                         \else(\if(boolean::select(savedHeap, #v,
                                                        java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                              \then(store(savedHeap, #v, arr(#se), #se0))
                                              \else(savedHeap)) }
                           \modality{#transaction}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#transaction}{..
			throw new java.lang.NullPointerException(); 
			...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#transaction}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
                 \displayname "assignment_to_primitive_array_component"
  };
}

\rules(programRules:Java, runtimeExceptions:ban) {
  assignment_to_primitive_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
			;
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
  assignment_to_primitive_array_component { 
    \schemaVar \modalOperator { diamond, box } #normal; 
    \find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
    \varcond(\not \isReferenceArray(#v))
    \replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ban,JavaCard:on) {
  assignment_to_primitive_array_component_transaction { 
                 \schemaVar \modalOperator { diamond_transaction, box_transaction } #transaction; 
                 \find (==> \modality{#transaction}{..#v[#se]=#se0;...}\endmodality(post))
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==>
                           {heap:=store(heap,#v,arr(#se),#se0) }
                           {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                                         \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                                         \else(\if(boolean::select(savedHeap, #v,
                                                        java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                              \then(store(savedHeap, #v, arr(#se), #se0))
                                              \else(savedHeap)) }
                           \modality{#transaction}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
			;
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
                 \displayname "assignment_to_primitive_array_component"
  };

}

\rules(programRules:Java, runtimeExceptions:ignore,JavaCard:on) {
  assignment_to_primitive_array_component_transaction { 
    \schemaVar \modalOperator { diamond_transaction, box_transaction } #transaction; 
    \find (\modality{#transaction}{..#v[#se]=#se0;...}\endmodality(post))
    \varcond(\not \isReferenceArray(#v))
    \replacewith(
                           {heap:=store(heap,#v,arr(#se),#se0) }
                           {savedHeap := \if(int::select(heap, #v, java.lang.Object::<transient>) = 0)
                                         \then(store(savedHeap, #v, java.lang.Object::<transactionConditionallyUpdated>, TRUE))
                                         \else(\if(boolean::select(savedHeap, #v,
                                                        java.lang.Object::<transactionConditionallyUpdated>) = FALSE)
                                              \then(store(savedHeap, #v, arr(#se), #se0))
                                              \else(savedHeap)) }
                           \modality{#transaction}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignment_to_primitive_array_component"
  };

}


		    
\rules(programRules:Java, runtimeExceptions:allow) {
  assignment_array2{\find (\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
                  \varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
		   \add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(\modality{#allmodal}{..
			throw new java.lang.NullPointerException();
			    ...}\endmodality(post))
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(\modality{#allmodal}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ban) {
  assignment_array2{\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
                  \varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		   \replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
		   //\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
		   ; 
		"Null Reference (#v0 = null)":
		   \replacewith(==> false)
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(==> false)
		   \add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore) {
  assignment_array2{
    \find (\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
    \varcond(\hasSort(\elemSort(#v0), G))
    \replacewith({#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:allow) {
  assignment_read_attribute { 
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this {
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
		\find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
		\find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isThisReference(#v))
		"Normal Execution":
		      \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

}

\rules(programRules:Java, runtimeExceptions:ban) {
  assignment_read_attribute { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

}

\rules(programRules:Java, runtimeExceptions:ignore) {
  assignment_read_attribute { 
    \find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
    \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
    \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this { 
    \find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
    \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
    \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
    \find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
    \varcond(\not\isThisReference(#v))
    \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
    \find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
    \varcond(\isThisReference(#v))
    \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };  
}

\rules(programRules:Java, runtimeExceptions:allow) {

  assignment_write_attribute { 
		\find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  

  assignment_write_attribute_this { 
		\find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };  


}

\rules(programRules:Java, runtimeExceptions:ban) {

  assignment_write_attribute { 
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  

  assignment_write_attribute_this { 
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };  

}

\rules(programRules:Java, runtimeExceptions:ignore) {

  assignment_write_attribute { 
    \find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
    \varcond(\not \static(#a), \not\isThisReference(#v))
    \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignment"
  };  

  assignment_write_attribute_this { 
    \find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
    \varcond(\not \static(#a), \isThisReference(#v))
    \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignmentThis"
  };  

}


\rules(programRules:Java) {

//------------------------------------------------------------------------
// ----------- Rules for modal tautologies
//------------------------------------------------------------------------

box_true{ \find (\modality{#box}{.. #s ...}\endmodality true)
	  \replacewith(true)
	  \heuristics(modal_tautology)};

diamond_false{ \find (\modality{#diamond}{.. #s ...}\endmodality false)
	       \replacewith(false)
	       \heuristics(modal_tautology)};

diamond_and_left{ \find (\modality{#diamond}{.. #s ...}\endmodality (post & post1)==>)
		  \replacewith(\modality{#diamond}{.. #s ...}\endmodality post & \modality{#diamond}{.. #s ...}\endmodality post1==>)};

box_and_left{ \find (\modality{#box}{.. #s ...}\endmodality (post & post1) ==>)
	      \replacewith(\modality{#box}{.. #s ...}\endmodality post & \modality{#box}{.. #s ...}\endmodality post1==>)};

diamond_and_right{ 
                 \find (==> \modality{#diamond}{.. #s ...}\endmodality (post & post1))
		 \replacewith(==> \modality{#diamond}{.. #s ...}\endmodality post);
		 \replacewith(==> \modality{#diamond}{.. #s ...}\endmodality post1)};

box_and_right{\find (==> \modality{#box}{.. #s ...}\endmodality (post & post1))
		 \replacewith(==> \modality{#box}{.. #s ...}\endmodality post);  
		 \replacewith(==> \modality{#box}{.. #s ...}\endmodality post1)};

diamond_or_right{\find (==> \modality{#diamond}{.. #s ...}\endmodality(post | post1))
		 \replacewith(==> \modality{#diamond}{.. #s ...}\endmodality post | \modality{#diamond}{.. #s ...}\endmodality post1)};

box_or_right{\find (==> \modality{#box}{.. #s ...}\endmodality (post | post1))
	     \replacewith(==> \modality{#box}{.. #s ...}\endmodality post | \modality{#box}{.. #s ...}\endmodality post1)};

diamond_or_left{\find (\modality{#diamond}{.. #s ...}\endmodality (post | post1)==>)
		 \replacewith(\modality{#diamond}{.. #s ...}\endmodality post | \modality{#diamond}{.. #s ...}\endmodality post1==>)};

box_or_left{\find (\modality{#box}{.. #s ...}\endmodality (post | post1)==>)
	     \replacewith(\modality{#box}{.. #s ...}\endmodality post | \modality{#box}{.. #s ...}\endmodality post1==>)};

/////////////////////////////////////////////////////////////////

same_diamonds_right{ \assumes (==>\<{#s}\> post) 
		    \find (==> \<{#s}\> post1)
		    \add (==> \<{#s}\> (post | post1))};

same_diamonds_left{ \assumes (\<{.. #s ...}\> post ==>)
		    \find (\<{.. #s ...}\> post1 ==>)
		    \add (\<{.. #s ...}\> (post & post1) ==>)};

same_boxes_right{ \assumes (==>\[{.. #s ...}\] post)
		    \find (==> \[{.. #s ...}\] post1)
		    \add (==> \[{.. #s ...}\] (post | post1))};

same_boxes_left{ \assumes (\[{.. #s ...}\] post ==>)
		    \find (\[{.. #s ...}\] post1 ==>)
		    \add (\[{.. #s ...}\] (post & post1) ==>)};

boxToDiamond{\find (\[{.. #s ...}\]post)
	    \replacewith(!\<{.. #s ...}\>!post)
            \heuristics(boxDiamondConv)};

boxToDiamondTransaction
            {\find (\box_transaction{.. #s ...}\endmodality post)
	    \replacewith(!\diamond_transaction{.. #s ...}\endmodality !post)
            \heuristics(boxDiamondConv)
            \displayname "boxToDiamond" };

diamondToBox{\find (\<{.. #s ...}\>post)
	    \replacewith(!\[{.. #s ...}\]!post)
            \heuristics(boxDiamondConv)};

diamondToBoxTransaction{
            \find (\diamond_transaction{.. #s ...}\endmodality post)
	    \replacewith(!\box_transaction{.. #s ...}\endmodality !post)
            \heuristics(boxDiamondConv) 
            \displayname "diamondToBox" };

diamond_split_termination{\find (\<{.. #s ...}\>post)
	    \replacewith(\[{.. #s ...}\]post & \<{.. #s ...}\>true )};


}


\rules(programRules:Java) {
  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any exception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes 
  assignment_write_static_attribute {
	\find (\modality{#allmodal}{.. @(#sv) = #se; ...}\endmodality(post))
	\replacewith({heap := store(heap, null, #memberPVToField(#sv), #se)} \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };

  // constant case cannot occur as no static initialisation handling happens
  assignment_write_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. @(#v.#sv) = #se; ...}\endmodality(post))
	\replacewith({heap := store(heap, #v, #memberPVToField(#sv), #se)} \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
  };


  assignment_read_static_attribute { 
               \find (\modality{#allmodal}{.. #v0 = @(#sv); ...}\endmodality(post)) \sameUpdateLevel
               \varcond(\hasSort(#sv, G))
               \replacewith({#v0 := G::select(heap, null, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
               \heuristics(simplify_prog, simplify_prog_subset)
  };

  // constant case cannot occur as no static initilisation handling happens
  assignment_read_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. #loc = @(#v.#sv); ...}\endmodality(post))
	\varcond(\hasSort(#sv, G))
        \replacewith({#loc := G::select(heap,#v,#memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
	\heuristics(simplify_prog)
        \displayname "assignment"
  };

}



//=====================================================================//
//======================= static method calls    ======================//
//=====================================================================//

\rules(programRules:Java, initialisation:disableStaticInitialisation) {
  staticMethodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
    \replacewith (\modality{#allmodal}{.. 			    
		 #method-call(#v0, #se.#mn(#elist));
		...}\endmodality(post))
    \heuristics(method_expand)
    \displayname "methodCall"
  };

  staticMethodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)), \staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. 
			    #typeof(#lhs) #v0;
	  	            #method-call(#v0, #se.#mn(#elist));
		            #lhs = #v0; 
                  ...}\endmodality(post))
    \heuristics(method_expand)
    \displayname "methodCall"
  };

  staticMethodCallStaticViaTypereference { 
    \find (\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(method_expand)
    \displayname "methodCall"
  };


  staticMethodCallStaticWithAssignmentViaTypereference {
    \find (\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{..  #typeof(#lhs) #v0;
			        #method-call(#v0, #t.#mn(#elist));
			        #lhs = #v0; ...}\endmodality(post)) 
    \heuristics(method_expand)
    \displayname "methodCall"
  };

  methodCallWithAssignmentWithinClass {
    \find (\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, #mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \heuristics(method_expand)
    \displayname "methodCall"
  };

  methodCallWithinClass { 
    \find (\modality{#allmodal}{.. #mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 
	#method-call(#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(method_expand)
    \displayname "methodCall"
  };   
}


\rules(programRules:Java, initialisation:enableStaticInitialisation) {

  staticMethodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
    \replacewith (\modality{#allmodal}{.. 			    
		#static-initialisation(#se.#mn(#elist));
		#method-call(#v0, #se.#mn(#elist));
		...}\endmodality(post))
    \heuristics(method_expand)
    \displayname "methodCall"
  };

  staticMethodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality((post))) 
    \varcond(\new(#v0, \typeof(#lhs)), \staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. 
			    #static-initialisation(#se.#mn(#elist));
			    #typeof(#lhs) #v0;
	  	            #method-call(#v0, #se.#mn(#elist));
		            #lhs = #v0; 
                  ...}\endmodality(post))
    \heuristics(method_expand)
    \displayname "methodCall"
  };

  staticMethodCallStaticViaTypereference { 
    \find (\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  #static-initialisation(#t.#mn(#elist)); 
		                #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(method_expand)
    \displayname "methodCall"
  };


  staticMethodCallStaticWithAssignmentViaTypereference {
    \find (\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{..  #static-initialisation(#t.#mn(#elist));
				#typeof(#lhs) #v0;
			        #method-call(#v0, #t.#mn(#elist));
			        #lhs = #v0; ...}\endmodality(post)) 
    \heuristics(method_expand)
    \displayname "methodCall"
  };

  methodCallWithAssignmentWithinClass {
    \find (\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #static-initialisation(#mn(#elist));
			       #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, #mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \heuristics(method_expand)
    \displayname "methodCall"
  };

  methodCallWithinClass { 
    \find (\modality{#allmodal}{.#ex.. #mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 
	#static-initialisation(#mn(#elist));
	#method-call(#ex, #mn(#elist)); ...}\endmodality(post)) 
    \heuristics(method_expand)
    \displayname "methodCall"
  };

 passiveMethodCallWithinClass { 
   		\find (\modality{#allmodal}{.#ex.. @(#mn(#elist)); ...}\endmodality(post)) 
   		\replacewith (\modality{#allmodal}{.. #method-call(#ex, #mn(#elist)); ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(method_expand)
 };

 passiveMethodCallStatic { 
   		\find (\modality{#allmodal}{.. @(#t.#mn(#elist)); ...}\endmodality(post)) 
   		\replacewith (\modality{#allmodal}{.. #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(method_expand)
 };

 passiveMethodCallWithAssignmentWithinClass {
   		\find (\modality{#allmodal}{.#ex.. #lhs=@(#mn(#elist)); ...}\endmodality(post)) 
   		\varcond(\new(#v0, \typeof(#lhs)))
   		\replacewith(\modality{#allmodal}{.. #typeof(#lhs) #v0;
                                          #method-call(#ex, #v0, #mn(#elist));
                                          #lhs = #v0;
                                     ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(method_expand)
 };

 passiveMethodCallStaticWithAssignment {
		\find (\modality{#allmodal}{.. #lhs = @(#t.#mn(#elist)); ...}\endmodality(post))
   		\varcond(\new(#v0, \typeof(#lhs)))
   		\replacewith(\modality{#allmodal}{..  #typeof(#lhs) #v0;
 		                 #method-call(#v0, #t.#mn(#elist));
		                 #lhs = #v0; 
			   ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(method_expand)
 };


}



//===============================================================//
//============   axioms describing valid jvm states ===========//
//===============================================================//
\rules(programRules:Java) {
 
 class_being_initialized_is_prepared {
	\assumes (boolean::select(heap, null, alphaObj::<classInitializationInProgress>)  = TRUE, inReachableState ==>)  
        \find (boolean::select(heap, null, alphaObj::<classPrepared>)) \sameUpdateLevel
	\replacewith(TRUE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialized classes have been prepared"
  };   
  
 initialized_class_is_prepared {
	\assumes (boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find (boolean::select(heap, null, alphaObj::<classPrepared>)) \sameUpdateLevel
	\replacewith (TRUE)
	\heuristics(confluence_restricted, simplify)
        \displayname "classes being initialized have been prepared"
  };
 
 initialized_class_is_not_erroneous {
	\assumes (boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find (boolean::select(heap, null, alphaObj::<classErroneous>)) \sameUpdateLevel
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialized class is not erroneous"
  };

 class_initialized_excludes_class_init_in_progress {
	\assumes (boolean::select(heap, null, alphaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find (boolean::select(heap, null, alphaObj::<classInitializationInProgress>)) \sameUpdateLevel
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialisation process has already terminated"
  };

 class_erroneous_excludes_class_in_init {
	\assumes (boolean::select(heap, null, alphaObj::<classErroneous>) = TRUE, inReachableState ==>) 
        \find (boolean::select(heap, null, alphaObj::<classInitializationInProgress>)) \sameUpdateLevel
	\replacewith (FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialization process has already terminated (or never begun)"
  };

 erroneous_class_has_no_initialized_sub_class {
        \assumes(boolean::select(heap, null, alphaObj::<classErroneous>) = TRUE, inReachableState ==>)
        \find(boolean::select(heap, null, betaObj::<classInitialized>)) \sameUpdateLevel
	\varcond(\sub(betaObj, alphaObj))
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "erroneous classes have no initialized subclasses"
 };
 
 superclasses_of_initialized_classes_are_initialized {
        \assumes(boolean::select(heap, null, betaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find(boolean::select(heap, null, alphaObj::<classInitialized>)) \sameUpdateLevel
	\varcond(\isReference[non_null](betaObj), \strict \sub(betaObj, alphaObj))
	\replacewith(TRUE)
	\heuristics(simplify)
 };
 
 superclasses_of_initialized_classes_are_prepared {
        \assumes(boolean::select(heap, null, betaObj::<classInitialized>) = TRUE, inReachableState ==>)
        \find(boolean::select(heap, null, alphaObj::<classPrepared>)) \sameUpdateLevel
	\varcond(\sub(betaObj, alphaObj))
	\replacewith(TRUE)
	\heuristics(simplify)
 };
}
