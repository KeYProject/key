// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe Germany
//                           Universitaet Koblenz-Landau, Germany
//                         and Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
// This file contains rules for handling java programs


\include ruleSetsDeclarations;
\include propRule;
\include assertions;


\optionsDecl{
  initialisation:{disableStaticInitialisation, enableStaticInitialisation};
}

\sorts{
  \generic G;
  \generic H;
  \generic J \extends G;
  any;
}

\schemaVariables {
 \modalOperator { diamond, box, throughout,
                             diamond_trc, box_trc, throughout_trc,
                             diamond_tra, box_tra, throughout_tra,
			     diamond_susp, box_susp, throughout_susp } #allmodal;
 \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc } #normalassign;
 \modalOperator { diamond, box, throughout, diamond_trc, box_trc, throughout_trc } #allbuttra;
 \modalOperator { diamond_tra, box_tra, throughout_tra, diamond_susp, box_susp, throughout_susp } #traonly;
 \modalOperator { diamond, diamond_trc, box, box_trc, throughout, throughout_trc } #ignoresusp;
 \modalOperator { box, box_trc, throughout_trc,
                               box_tra, throughout_tra } #allpartial ;
 \modalOperator { diamond, diamond_trc, diamond_tra } #alltotal;
 \modalOperator { diamond, box, throughout} #puremodal;
 \modalOperator { diamond_trc, box_trc, throughout_trc} #trcmodal;
 \modalOperator { diamond_tra, box_tra, throughout_tra} #tramodal;
 // modal SVs for transaction suspension handling
 \modalOperator { diamond, box, diamond_trc, box_trc } #wabase;
 \modalOperator { diamond_tra, box_tra, throughout_tra } #watra;
 \modalOperator { diamond_susp, box_susp } #wasusp;

 \program jvmBeginTransaction #trb ;
 \program jvmCommitTransaction #trc ;
 \program jvmAbortTransaction #tra ;
 \program jvmSuspendTransaction #trsuspend ;
 \program jvmResumeTransaction #trresume ;
 \program ImplicitTraInitialized #traInitializedSV;
 \program ImplicitTransactionCounter #transactionCounterSV;

 \formula post, inv, post1;
 \program Type #t, #t2 ;
 \program NonPrimitiveType #npit ;  

 \term G q;
 \skolemTerm G queryValue ;

 
 \program jvmIsTransient #jvmistransient ;
 \program jvmArrayCopy #jvmarraycopy ;
 \program jvmArrayCompare #jvmarraycompare ;
 \program jvmArrayCopyNonAtomic #jvmarraycopynonatomic ;
 \program jvmArrayFillNonAtomic #jvmarrayfillnonatomic ;
 \program jvmMakeShort #jvmmakeshort;
 \program jvmSetShort #jvmsetshort;
 \program ArrayLength #length ;
 

 \program MultipleVariableDeclaration #multvardecl ;
 \program ArrayPostDeclaration #arraypost ;
 \program SimpleExpression #se, #se0, #se1 ;
 \program SimpleExpression #src, #dest, #srcOff, #destOff, #arlength;

 \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2 ;
 \program LeftHandSide #attribute ;
 \program Variable #loc ;
 \program StaticVariable #sv, #sv0, #sv1 ;

 \program Variable #v, #v0, #v1, #v2, #boolv, #a, #a0, #a1 ;

 \program ImplicitClassInitialized #classInitialized ;
 \program ImplicitClassInitialized #classInitialized2 ;
 \program ImplicitClassErroneous #classErroneous ;
 \program ImplicitClassPrepared #classPrepared ;
 \program ImplicitClassInitializationInProgress #classInitializationInProgress ;

 \program ExplicitVariable #ea ;   // not starting with <
 \program ImplicitVariable #ia ;   // starting with <
 \program ConstantVariable #cv ;   // variables that are compile-time constants
 \program Variable #b0, #ar1 ;
 \program VariableInitializer #vi ;
 \program SimpleExpression #seBool,#seBool0,#seBool1,#seBool2 ;
 \program JavaBooleanExpression #exBool,#exBool0,#exBool1,#exBool2 ;

 \program NonSimpleExpression #nseBool,#nseBool0,#nseBool1,#nseBool2 ;
 \program Statement #s, #s0, #s1 ;
 \program LoopInit #loopInit ;
 \program Guard #guard ;
 \program ForUpdates #forupdates ;
 \program ForLoop #forloop ;
 \program Expression #e, #e0, #e1, #e2 ;
 \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv ;

 \program[list] Statement #slist, #slist1, #slist2, #slist3 ;
 \program[list] Expression #elist ;
 \program[list] SimpleExpression #selist ;
 \program[list] Catch #cs ;

 \program Switch #sw ;
 \program Label #lb, #lb0, #lb1, #innerLabel, #outerLabel;
 \program NonSimpleMethodReference #nsmr ;
 \program NonModelMethodBody #mb;
 \program MethodName #mn;

 \program ExecutionContext #ex, #ex1 ; 

 \location[list] #modifies;
 \formula anon1, anon2, anon3;
 
 \formula for1,for2;

 \program Literal #lit ;

 \variables int iv, iv2, iv3 ;
 \term int idx;

 // generic sorts
 \term G array, variant ;
 \term H obj ;

 \variables G x ;
 \term H then, else ;
 
 \term G updatedTerm1, updatedTerm2;

 \formula inReachableStateSV;
}

\functions(javacard:jcOn){
  jshort jvmMakeShort(jbyte, jbyte);
  jbyte jvmSetShort1(jshort);
  jbyte jvmSetShort2(jshort);  
}

\predicates{   
   arrayStoreValid(any, any);
   \nonRigid[HeapDependent] inReachableState;
}

\rules(programRules:Java) {
	update_close_left {
  		\assumes ( ==> for2 ) \find ( for1 ==> ) \varcond(\isUpdated(for1)) 
  		\add ( ==> #equivUpdates(for2, for1) )
	};

	update_close_right {
  		\assumes ( for2 ==> ) \find ( ==> for1 ) \varcond(\isUpdated(for1)) 
  		\add ( ==> #equivUpdates(for2, for1) )
	};

	update_cut{\find(for1)\sameUpdateLevel \varcond(\isUpdated(for1)) 
		"Main: #for2":\replacewith(for2);
		"Equiv Updates":\add(==>#equivUpdates(for1,for2))
	};

	update_cut_term{\find(updatedTerm1)\sameUpdateLevel
                   \varcond(\isUpdated(updatedTerm1)) 
  		"Main: updatedTerm2":\replacewith(updatedTerm2);
		"Equiv Updates":\add(==>#equivUpdates(updatedTerm1,updatedTerm2))
	};


  inReachableStatePO { \find (==> inReachableStateSV) 
                   \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
                   \replacewith (==> inReachableState & 
                          #createInReachableStatePO(inReachableStateSV) ) 
                   \addrules ( insert_hidden { \add (==> inReachableStateSV) } )
//                   \heuristics ( simplify )
  };  
  
  inReachableStateExpand { \find (inReachableStateSV ==>) 
  		    \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
  		    \replacewith( inReachableState -> 
                              #createInReachableStatePO(inReachableStateSV) ==> ) 
                    \addrules (insert_hidden { \add (inReachableStateSV ==>) })
                    \heuristics ( inReachableStateExpandAntec )
  };  
  
  inReachableStateRewrite { \assumes (inReachableState ==>)
                    \find (inReachableStateSV) \sameUpdateLevel
  		    \varcond(\isInReachableState(inReachableStateSV)) // this varcond is a hack
  		    \replacewith( inReachableStateSV |
                                  #createInReachableStatePO(inReachableStateSV))
                    \heuristics ( inReachableStateExpandRewrite )
  };  
  
  emptyModality { \find (\modality{#puremodal}{}\endmodality(post)) \replacewith(post) \heuristics(simplify_prog) \oldname "empty_modality"};

  returnUnfold { \find (\modality{#allmodal}{.. return #nse; ...}\endmodality(post)) 
       \varcond(\new(#v0, \typeof(#nse))) 	
       \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; return #v0; ...}\endmodality(post)) 
       \heuristics(simplify_prog)
       \displayname "returnUnfold"
       \oldname "eval_return_not_simple"}; 

//-----------------------------------------------------------------------------------------
//                        some common assignment rules 
//-----------------------------------------------------------------------------------------

  assignment  { \find (\modality{#normalassign}{.. #loc = #se; ...}\endmodality(post)) 
                \replacewith ({#loc:= #se}\modality{#normalassign}{.. ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "assignment"
		\oldname "assignment_normalassign"};

  set_assignment  { \find (\modality{#normalassign}{.. #set #loc = #se; ...}\endmodality(post)) 
                \replacewith ({#loc:= #se}\modality{#normalassign}{.. ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "setAssignment"};
	
  // skip index check as the case below can only happen in an implicit method
  assignment_write_array_this_access_normalassign{
		\find (\modality{#normalassign}{.#t(#v).. this[#se]=#se0; ...}\endmodality(post))
		"Normal Execution":
			\replacewith(( lt(#se,#lengthReference(#v)) & lt(-1,#se)) ->   
			{#v[#se]:=#se0}\modality{#normalassign}{.. ...}\endmodality(post))
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};


  // skip index check as the case below can only happen in an implicit method
  eval_array_this_access{
		\find (\modality{#allmodal}{.. this[#nse]=#se0; ...}\endmodality(post))
                \varcond(\new(#v0, \typeof(#nse))) 
  		\replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; this[#v0]=#se0; ...}\endmodality(post))
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "eval_array_access"};


}


\rules(programRules:Java,throughout:toutOn) {

//-----------------------------------------------------------------------------------------
//                                  assignment for special modalities
//-----------------------------------------------------------------------------------------


  assignTout { \find (\throughout{.. #loc = #se; ...}\endmodality(post) ) 
               \replacewith (post & (post ->{#loc:= #se}\throughout{.. ...}\endmodality(post)))
	       \heuristics(simplify_prog, simplify_prog_subset)
               \displayname "assignment"
	       \oldname "assignment_throughout"
  };

// skip index check as the case below can only happen in an implicit method
  assignToutSaveThisArray {
 		\find ( \throughout{.#t(#v).. this[#se]=#se0; ...}\endmodality(post) )
                \replacewith(( lt(#se,#lengthReference(#v)) & lt(-1,#se)) -> 
                               post & (post -> {#v[#se]:=#se0}\throughout{.. ...}\endmodality(post)))
 	        \heuristics(simplify_prog, simplify_prog_subset)
 		\displayname "assignment"
		\oldname "assignment_write_array_this_access_throughout"};

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {

 assignTRA  { \find (\modality{#traonly}{.. #loc = #se; ...}\endmodality(post)) 
              \replacewith ({#shadowed(#loc):= #shadowed(#se)}\modality{#traonly}{.. ...}\endmodality(post)) 
	      \heuristics(simplify_prog, simplify_prog_subset)
              \displayname "assignment"
	      \oldname "assignment_traonly"
 };


// skip index check as the case below can only happen in an implicit method
  assignTRASaveThisArray {
		\find (\modality{#traonly}{.#t(#v).. this[#se]=#se0; ...}\endmodality(post))
		"Normal Execution":
			\replacewith(( lt(#shadowed(#se),#lengthReference(#v)) & lt(-1,#shadowed(#se))) ->   
			{#shadowed(#v[#se]):=#shadowed(#se0)}\modality{#traonly}{.. ...}\endmodality(post))
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
		 \oldname "assignment_write_array_this_access_traonly"
  };

}

\rules(programRules:Java) {
// array casts
  array_narrow_type {
       \find( array[idx]@(H) )
       \varcond(\strict\sub(G, H), \isReference[non_null](G))
       \replacewith(array[idx]@(G))
       \heuristics(simplify)
  };


//---------- rules for array store ---------------//


   array_self_reference {	 
        \assumes (inReachableState ==> array = null)
	\find (arrayStoreValid(array, array[idx]@(G))) 
	\sameUpdateLevel
	\varcond(\isReference(\typeof(array)))
	\replacewith(true)
	\heuristics(simplify)
   };

   null_can_always_be_stored_in_a_reference_type_array {
        \assumes (==> array = null)
	\find (arrayStoreValid(array, null)) \sameUpdateLevel
	\varcond(\isReferenceArray(array))
	\replacewith(true)
	\heuristics(simplify)
   };

   array_store_static_analyse {
	\assumes (==> array = null)
	\find (arrayStoreValid(array, obj)) \sameUpdateLevel
	\replacewith(#arrayStoreStaticAnalyse(arrayStoreValid(array, obj)))
	\heuristics(simplify_instanceof_static) // taken this heuristic as this meta construct is quite similar and may also lead to loops
   };

   array_store_known_dynamic_array_type {
        // no guard necessary as <get> always not null	
	\find (arrayStoreValid(G::<get>(idx), obj))	
	\varcond (\isReference(G))
	\replacewith(#arrayBaseInstanceOf(G::<get>(idx), obj) = TRUE | obj = null)
	\heuristics(simplify)
	\displayname "known dynamic array type"
   };
   
   
/*   array_store_known_dynamic_array_type_prim {
	\find (arrayStoreValid(G::<get>(idx), vint_val))	
        \varcond(\isReference(G))
	\replacewith(#arrayBaseInstanceOf(G::<get>(idx), vint_val) = TRUE)
	\heuristics(simplify)
	\displayname "known dynamic array type"
   };
  */ 
   
   array_store_known_dynamic_array_type_2 {
	\assumes (J::exactInstance(array) = TRUE ==>)
	\find (arrayStoreValid(array, obj)) \sameUpdateLevel
	\varcond (\isReference[non_null](J))
	\replacewith(obj = null | 
	    #arrayBaseInstanceOf(J::exactInstance(array), obj) = TRUE)
	\heuristics(simplify)
	\displayname "known dynamic array type"
   };

// ------------ dynamic types ------------------ //

   // this rule is at more places applicable as the book version
   // a better name for this version would be typeExpand
   typeExpand {
	\find (obj) \sameUpdateLevel
	\varcond (\isReference(\typeof(obj)))
	\add (#expandDynamicType(obj)==>)
	\displayname "typeExpand"
	\oldname "expand_dynamic_types"
	\oldname "typeAbstract"
   };


   typeExpandInstanceof {
	\find (==> G::instance(obj) = TRUE)
	\varcond (\isReference(\typeof(obj)))
	\add (#expandDynamicType(obj)==>)
        \oldname "expand_dynamic_types_2"
        \displayname "typeExpand"
	\heuristics(simplify)
   };


  /*  // will be uncommented soon 
       dynamic_type_for_null {
	  \find (G::exactInstance(null) = TRUE ==>)
	  \varcond(G not Null) // Woj: parser doesn't allow this at the moment
	  \replacewith(false)
	};

        dynamic_type_definition {
	\find (J::exactInstance(array) = TRUE) \sameUpdateLevel
	\varcond (\isReferenceArray(array), \notFreeIn(k, array))
	\replacewith(\exists k; (geq(k,0) & reach[#t.#nextToCreate](#t.#nextFirst, array, k)))
   };*/


//--------------- variable declarations --------------------------------------//

// local_variable_rename   { \find (\<{.. {#t #v0; #s} ...}\>post) 
//              \varcond (#v1 \new)
//              \replacewith( {#v1 #v0}\<{.. {#v0 #v1}{#s} ...}\>post) };

  //reviewed 04/19/2004, St.S.
  variableDeclaration { \find (\modality{#allmodal}{.. #t #v0; ...}\endmodality(post)) 
		        \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                        \addprogvars(#v0) 
                        \heuristics(simplify_prog, simplify_prog_subset)
                        \displayname "variableDeclaration"
			\oldname "eliminate_variable_declaration"
  };

  variableDeclarationFinal { \find (\modality{#allmodal}{.. final #t #v0; ...}\endmodality(post)) 
		             \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                             \addprogvars(#v0) 
                             \heuristics(simplify_prog, simplify_prog_subset)
                             \displayname "variableDeclaration"
			     \oldname "eliminate_variable_declaration_final"
  };
  
  variableDeclarationGhost { \find (\modality{#allmodal}{.. ghost #t #v0; ...}\endmodality(post)) 
		             \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                             \addprogvars(#v0) 
                             \heuristics(simplify_prog, simplify_prog_subset)
                             \displayname "ghostDeclaration"
  };
  

// ATTENTION - may not be right for \throughout{}\endmodality
// St.S.: It is not unsound but incomplete because we can never prove a property
// about #v0 before it is assigned an initial value...
 variableDeclarationAssign  { \find (\modality{#allmodal}{.. #t #v0 = #vi; ...}\endmodality(post))
                              \replacewith (\modality{#allmodal}{.. #t #v0; #v0 = #vi; ...}\endmodality(post))
                              \heuristics(simplify_prog, simplify_prog_subset)
                              \displayname "variableDeclaration"
			      \oldname "variable_declaration_allmodal"};

 variableDeclarationFinalAssign { \find (\modality{#allmodal}{.. final #t #v0 = #vi; ...}\endmodality(post))
                                  \replacewith (\modality{#allmodal}{.. final #t #v0; #v0 = #vi; ...}\endmodality(post))
                                  \heuristics(simplify_prog, simplify_prog_subset)
                                  \displayname "variableDeclaration"
				  \oldname "variable_declaration_allmodal_final"};
				  
 variableDeclarationGhostAssign { \find (\modality{#allmodal}{.. ghost #t #v0 = #vi; ...}\endmodality(post))
                                  \replacewith (\modality{#allmodal}{.. ghost #t #v0; #set #v0 = #vi; ...}\endmodality(post))
                                  \heuristics(simplify_prog, simplify_prog_subset)
                                  \displayname "ghostDeclaration"};
				  

 variableDeclarationMult { \find (\modality{#allmodal}{.. #multvardecl ...}\endmodality(post)) 
			   \replacewith (\modality{#allmodal}{.. #resolve-multiple-var-decl(#multvardecl); ...}\endmodality(post)) 
			   \heuristics(simplify_prog, simplify_prog_subset)
                           \displayname "variableDeclaration"
			   \oldname "multiple_variable_declaration"};

 array_post_declaration { \find (\modality{#allmodal}{.. #arraypost ...}\endmodality(post)) 
				\replacewith (\modality{#allmodal}{.. 
				                         #array-post-declaration(#arraypost);
                                                       ...}\endmodality(post)) 
				\heuristics(simplify_prog,
				simplify_prog_subset)};

//--------------- try-statement ----------------------------------------------//

 throwNull
	   { \find (\modality{#allmodal}{.. throw null; ...}\endmodality(post))
             \replacewith (\modality{#allmodal}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
             \displayname "throwNull"
	     \oldname "throw_evaluate_null"};

 throwUnfold   { \find (\modality{#allmodal}{.. throw #nse; ...}\endmodality(post))
	            \varcond(\new(#v0, \typeof(#nse))) 
            	    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0 = #nse; throw #v0; ...}\endmodality(post))
                    \heuristics(simplify_prog) \noninteractive
 		    \displayname "throwUnfold"
		    \oldname "throw_evaluate_non_simple"};

// VERIFY this rule:

throwLabel {
    \find (\modality{#allmodal}{.. #lb: throw #se; ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \oldname "throw_label"
};

throwLabelBlock {
    \find (\modality{#allmodal}{.. #lb: { throw #se; #slist } ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \oldname "throw_label_block"
};

throwBox { 
    \find (\modality{#allpartial}{ throw #se; #slist }\endmodality(post))
    \replacewith(true)
    \heuristics(simplify_prog)
    \oldname "throw_single_partial"
};

throwDiamond { 
    \find (\modality{#alltotal}{ throw #se; #slist }\endmodality(post))
    \replacewith(false)
    \heuristics(simplify_prog)
    \oldname "throw_single_total"
};

}

\rules(programRules:Java,throughout:toutOn) {

  throwTout { 
      \find (\throughout{ throw #se; #slist }\endmodality(post))
      \replacewith(post)
      \heuristics(simplify_prog)
      \oldname "throw_single_throughout"
  };

}

\rules(programRules:Java) {

 tryCatchThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               catch ( #t #v0 ) { #slist1 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                            try { throw new java.lang.NullPointerException (); }
                            catch ( #t #v0 ) { #slist1 }
                      } else if ( #se instanceof #t ) {
                            #t #v0;
                            #v0 = #se;
                            #slist1
                      } else {
                            throw #se;
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchThrow"
    \oldname "try_throw_single_ignore_trail" };

 tryMultipleCatchThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               catch ( #t #v0 ) { #slist1 }
               catch ( #t2 #v1 ) { #slist3 }
               catch #cs ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           try { throw new java.lang.NullPointerException (); }
                           catch ( #t #v0 ) { #slist1 }
                           catch ( #t2 #v1 ) { #slist3 }
                           catch #cs
                      } else if ( #se instanceof #t ) {
                           #t #v0;
                           #v0 = #se;
                           #slist1
                      } else {
                           try { throw #se; }
                           catch ( #t2 #v1 ) { #slist3 }
                           catch #cs
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchThrow"
    \oldname "try_throw_multiple_ignore_trail" };

 tryCatchFinallyThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist}
               catch ( #t #v0 ) { #slist1 }
               catch #cs
               finally { #slist2 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           try { throw new java.lang.NullPointerException (); }
                           catch ( #t #v0 ) { #slist1 }
                           catch #cs
                           finally { #slist2 }
                      } else if ( #se instanceof #t ) {
                           try {
                              #t #v0;
                              #v0 = #se;
                              #slist1
                           } finally { #slist2 }
                      } else {
                           try { throw #se; }
                           catch #cs
                           finally { #slist2 }
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryCatchFinallyThrow"
    \oldname "try_finally_throw_ignore_trail" };

// Should the NullPointerException be created before executing #slist2 ?
 tryFinallyThrow { 
    \find (\modality{#allmodal}{.. try { throw #se; #slist }
               finally { #slist2 } ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#se)))
    \replacewith (\modality{#allmodal}{.. if ( #se == null ) {
                           { #slist2 }
                           throw new java.lang.NullPointerException ();
                      } else {
                           #typeof(#se) #v0 = #se;
                           { #slist2 }
                           throw #v0;
                      } ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryFinallyThrow"
    \oldname "try_only_finally_throw_ignore_trail" };

 tryEmpty   { \find (\modality{#allmodal}{.. try {} #cs ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \oldname "try_empty" };

 tryFinallyEmpty {
    \find (\modality{#allmodal}{.. try {}
               catch #cs
               finally { #slist2 } ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. { #slist2 }  ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryEmpty"
    \oldname "try_finally_empty" };

 tryBreakLabel {
    \find (\modality{#allmodal}{.. try { break #lb; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. break #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
    \oldname "try_break_1" };

 tryFinallyBreakLabel {
    \find (\modality{#allmodal}{.. try { break #lb; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } break #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
    \oldname "try_finally_break_1" };

 tryBreak {
    \find (\modality{#allmodal}{.. try { break; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. break; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
    \oldname "try_break_2" };

 tryFinallyBreak {
    \find (\modality{#allmodal}{.. try { break; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } break; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryBreak"
    \oldname "try_finally_break_2" };

/*
 try_continue_1 {
    \find (\modality{#allmodal}{.. try { continue #lb; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. continue #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_finally_continue_1 {
    \find (\modality{#allmodal}{.. try { continue #lb; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } continue #lb; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_continue_2 {
    \find (\modality{#allmodal}{.. try { continue; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. continue; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };

 try_finally_continue_2 {
    \find (\modality{#allmodal}{.. try { continue; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } continue; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "try_continue" };
*/

 tryReturn {
    \find (\modality{#allmodal}{.. try { return #se; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. return #se; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
    \oldname "try_return_1" };

 tryFinallyReturn {
    \find (\modality{#allmodal}{.. try { return #se; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#se)))
    \replacewith (\modality{#allmodal}{.. #typeof(#se) #v0 = #se;
                      { #slist2 }
                      return #v0; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
    \oldname "try_finally_return_1" };

 tryReturnNoValue {
    \find (\modality{#allmodal}{.. try { return; #slist }
               catch #cs ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. return; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
    \oldname "try_return_2" };

 tryFinallyReturnNoValue {
    \find (\modality{#allmodal}{.. try { return; #slist }
               catch #cs
               finally { #slist2 } ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. { #slist2 } return; ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "tryReturn"
    \oldname "try_finally_return_2" };


//------------------------------------------------------------------------
// ----------- Rules for prefix and postfix increment and decrement operators
//------------------------------------------------------------------------

  //reviewed 04/16/2004, St.S.
 preincrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = ++#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1); #lhs0 = #lhs1; 
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = ++#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1); #lhs0=#v.#attribute;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement     { \find (\modality{#allmodal}{.. ++#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 preincrement_attribute     { \find (\modality{#allmodal}{.. ++#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 predecrement     { \find (\modality{#allmodal}{.. --#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 predecrement_attribute     { \find (\modality{#allmodal}{.. --#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};
 
  //reviewed 04/16/2004, St.S.
 predecrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = --#lhs1; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1-1); #lhs0 = #lhs1; ...}\endmodality(post)) 
            \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 predecrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs = --#e.#attribute; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1); #lhs = #v.#attribute;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postincrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = #lhs1++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#lhs0) #v = #lhs1; #lhs1 = (#typeof(#lhs1))(#lhs1+1); #lhs0 = #v;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postincrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = #e.#attribute++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#lhs0) #v1=#v.#attribute; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postincrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = #e[#e0]++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#typeof(#lhs0) #v1=#v[#v0]; #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]+1); #lhs0=#v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement     { \find (\modality{#allmodal}{.. #lhs1++; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement_attribute     { \find (\modality{#allmodal}{.. #e.#attribute++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postincrement_array     { \find (\modality{#allmodal}{.. #e[#e0]++; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
				#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement     { \find (\modality{#allmodal}{.. #lhs1--; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))#lhs1-1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement_attribute     { \find (\modality{#allmodal}{.. #e.#attribute--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 04/16/2004, St.S.
 postdecrement_array     { \find (\modality{#allmodal}{.. #e[#e0]--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
		#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment     { \find (\modality{#allmodal}{.. #lhs0 = #lhs1--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#lhs0) #v = #lhs1; #lhs1 = (#typeof(#lhs1))(#lhs1-1); #lhs0 = #v; ...}\endmodality(post)) 
            \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment_attribute     { \find (\modality{#allmodal}{.. #lhs0 = #e.#attribute--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#lhs0) #v1=#v.#attribute; #v.#attribute = (#typeof(#attribute))(#v.#attribute-1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

  //reviewed 06/23/2005, St.S.
 postdecrement_assignment_array  { \find (\modality{#allmodal}{.. #lhs0 = #e[#e0]--; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#e)), \new(#v0, \typeof(#e0)), \new(#v1, \typeof(#lhs0)))
            \replacewith (\modality{#allmodal}{.. #typeof(#e) #v=#e; #typeof(#e0) #v0=#e0; 
			#typeof(#lhs0) #v1=#v[#v0]; #v[#v0] = (#typeof(#e[#e0]))(#v[#v0]-1); #lhs0 = #v1;
             ...}\endmodality(post)) \heuristics(simplify_expression)};

// boolean cast
 castToBoolean {
    \find(\modality{#allmodal}{.. #lhs = (boolean) #exBool; ...}\endmodality(post))
    \replacewith(\modality{#allmodal}{.. #lhs = #exBool; ...}\endmodality(post))
    \heuristics(simplify_prog)
 };



//-----------------------------------------------------------------------------------------//
//--------------- reference type casts  ---------------------------------------------------//
//-----------------------------------------------------------------------------------------//


 // implementation of the rules for type casts defined in the Java language 
 // specification, chapter 5.5. We assume that no compile-time error occurred.
 
 // null can be cast to any type

 compound_reference_cast_expression { \find (\modality{#allmodal}{.. #lhs = (#npit) #nse; ...}\endmodality(post))
                       \varcond (\new(#v, \typeof(#nse)))
                       \replacewith ( \modality{#allmodal}{.. #typeof(#nse) #v = #nse;
		                                   #lhs = (#npit) #v;
                                                ...}\endmodality(post) )
                       \heuristics(simplify_prog)
		       \displayname "cast" };

 // this is a bit fishy, as the assignment #lhs=#se is not a
 // correctly typed Java statement in general
 reference_type_cast { \find (\modality{#allmodal}{.. #lhs = (#npit) #se; ...}\endmodality(post))
                       \replacewith ( \modality{#allmodal}{.. if (#se == null) #lhs = null;
                                                   else if (#se instanceof #npit) #lhs = #se;
				                   else throw new java.lang.ClassCastException();
                                                ...}\endmodality(post) )
                       \heuristics(simplify_prog) };

}

//--------------- methods ----------------------------------------------------//

\rules(programRules:Java, nullPointerPolicy:nullCheck){

  methodCall { 
    \find (\modality{#allbuttra}{.. #se.#mn(#selist); ...}\endmodality(post)) \sameUpdateLevel
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null )":
      \replacewith (\modality{#allbuttra}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post)) 
      \add (==> #se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allbuttra}{.. throw new java.lang.NullPointerException();
   	  	                  ...}\endmodality(post)) \add (#se = null==>)
    \heuristics(simplify_autoname)
    \oldname "method_call"
    };

  methodCallWithAssignment { 
    \find (\modality{#allbuttra}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post))) \sameUpdateLevel
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null)":
      \replacewith (\modality{#allbuttra}{.. #typeof(#lhs) #v0;
	  	                            #method-call(#v0, #se.#mn(#selist));
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
      \add (==>#se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allbuttra}{.. throw new java.lang.NullPointerException();
                                  ...}\endmodality(post))
      \add (#se = null  ==> )
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment"
  };

/*  method_call_subclass_contract { 
    \find (\modality{#allbuttra}{.. #se.#mn(#selist); ...}\endmodality(post)) \sameUpdateLevel
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null )":
      \replacewith (\modality{#allbuttra}{.. #method-call-contract(#se.#mn(#selist)); ...}\endmodality(post)) 
      \add (==> #se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allbuttra}{.. throw new java.lang.NullPointerException();
   	  	                  ...}\endmodality(post)) \add (#se = null==>)
    \heuristics(simplify_autoname)
    };

  method_call_with_assignment_subclass_contract { 
    \find (\modality{#allbuttra}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post))) \sameUpdateLevel
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null)":
      \replacewith (\modality{#allbuttra}{.. #typeof(#lhs) #v0;
	  	                            #method-call-contract(#v0, #se.#mn(#selist));
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
      \add (==>#se = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#allbuttra}{.. throw new java.lang.NullPointerException();
                                  ...}\endmodality(post))
      \add (#se = null  ==> )
    \heuristics(simplify_autoname)
    \displayname "method_call"
  };
*/

}

\rules(programRules:Java,
       nullPointerPolicy:nullCheck,
       transactions:transactionsOn,
       transactionAbort:abortOn,
       javacard:jcOn) {

  methodCallTRA { 
    \find (\modality{#traonly}{.. #se.#mn(#selist); ...}\endmodality(post)) \sameUpdateLevel
    \varcond(\not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null )":
      \replacewith (\modality{#traonly}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post)) 
      \add (==> #shadowed(#se) = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#traonly}{.. throw new java.lang.NullPointerException();
   	  	                  ...}\endmodality(post)) \add (#shadowed(#se) = null==>)
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "traonly_method_call"
    };

  methodCallWithAssignmentTRA { 
    \find (\modality{#traonly}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post))) \sameUpdateLevel
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution (#se != null)":
      \replacewith (\modality{#traonly}{.. #typeof(#lhs) #v0;
	  	                            #method-call(#v0, #se.#mn(#selist));
		                            #lhs = #v0; 
                                            ...}\endmodality(post))
      \add (==>#shadowed(#se) = null);
    "Null Reference (#se = null)":
      \replacewith (\modality{#traonly}{.. throw new java.lang.NullPointerException();
                                  ...}\endmodality(post))
      \add (#shadowed(#se) = null  ==> )
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "traonly_method_call_with_assignment"
  };
}

\rules(programRules:Java, nullPointerPolicy:noNullCheck){

  methodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality(post)) 
    \varcond(\not\staticMethodReference(#se, #mn, #selist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    };

  methodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post))) 
    \varcond(\new(#v0, \typeof(#lhs)), \not \staticMethodReference(#se, #mn, #selist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
	  	                 #method-call(#v0, #se.#mn(#selist));
		                 #lhs = #v0; 
                              ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment"
  };


}

\rules(programRules:Java) {

//--------------- queries ----------------------------------------------------
  resolvequery { \find (q) \sameUpdateLevel
		 \varcond(\isQuery(q), \new(queryValue, \dependingOn(q))) 
                 \replacewith (queryValue)
	         \add (q = queryValue,
                       #ResolveQuery(q, queryValue) ==>)
                 \heuristics (queries)
                 \displayname "query" };

//----------------- normal methods -----------------------------------
  methodCallUnfoldArguments { 
    \find (\modality{#allmodal}{.. #nsmr ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#nsmr); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \oldname "method_call_eval"
  };

  methodCallUnfoldTarget { 
    \find (\modality{#allmodal}{.. #nse.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#nse)))
    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0; 
                               #v0 = #nse; #v0.#mn(#elist); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \oldname "method_call_eval_prefix"
  };


  // may trigger static initialisation, but the super class has either
  // initialized or during initialisation, but not erroneous. So nothing
  // happens and we do not need to treat static initialisation here
  methodCallSuper { 
    \find (\modality{#allmodal}{.#ex.. super.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #method-call(#ex, super.#mn(#elist)); 
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \oldname "method_call_super"
  };

  // may trigger static initialisation, but the super class has either
  // initialized or during initialisation, but not erroneous. So nothing
  // happens and we do not need to treat static initialisation here
  methodCallWithAssignmentSuper {
    \find (\modality{#allmodal}{.#ex.. #lhs=super.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, super.#mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \displayname "methodCallSuper"
    \heuristics(simplify_autoname)
    \oldname "method_call_with_assignment_super"
  };

  methodCallWithAssignmentUnfoldArguments { 
    \find (\modality{#allmodal}{.. #lhs = #nsmr; ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#lhs = #nsmr); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCallUnfoldArguments"
    \oldname "method_call_with_assignment_eval"
  };

  methodCallWithAssignmentUnfoldTarget { 
    \find (\modality{#allmodal}{.. #lhs = #nse.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#nse)))
    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0; 
                               #v0 = #nse; #lhs = #v0.#mn(#elist); ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCallUnfoldTarget"	
    \oldname "method_call_with_assignment_eval_prefix"
  };

  methodCallEmpty { 
    \find (\modality{#allmodal}{.. method-frame(#ex):{} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
    \oldname "method_call_empty"
  };

  methodCallEmptyReturn { 
     \find (\modality{#allmodal}{.. method-frame(#ex):{return; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
     \displayname "methodCallReturn"
     \oldname "method_call_return_void_ignore_trail"
  };

  methodCallReturn { 
     \find (\modality{#allmodal}{.. method-frame(#v0, #ex):{return #se; #slist} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{.. method-frame(#ex):{ #v0 = #se; } ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallReturn"
     \oldname "method_call_return_ignore_trail"
  };

  methodCallReturnIgnoreResult { 
    \find (\modality{#allmodal}{.. method-frame(#ex):{return #se; #slist} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post))
    \displayname "methodCallReturn"
    \heuristics(simplify_prog) 
    \oldname "method_call_return_ignore_result"
  };

  methodBodyExpand { 	
    \find (\modality{#allmodal}{.. #mb ...}\endmodality(post))
    \replacewith (#introAtPreDefs(\modality{#allmodal}{.. #expand-method-body(#mb); ...}\endmodality(post)))
    \heuristics(method_expand) 
    \oldname "method_body_expand"
  };

  blockReturnNoValue { 
     \find (\modality{#allmodal}{.. {return; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn"
     \oldname "return_in_block_ignore_trail"
  };

  blockReturn { 
     \find (\modality{#allmodal}{.. {return #se; #slist} ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn"
     \oldname "return_in_block_simple_ignore_trail"
  };

  blockReturnLabel1 { 
     \find (\modality{#allmodal}{.. #lb: return #se; ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn (remove label)"
     \oldname "return_label_1"
  };

  blockReturnLabel2 { 
     \find (\modality{#allmodal}{.. #lb: { return #se; #slist } ...}\endmodality(post)) 
     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset) 
     \displayname "blockReturn (remove label)"
     \oldname "return_label_2"
  };

  
  methodCallThrow {
     \find (\modality{#allmodal}{.. method-frame(#ex):{throw #se; #slist} ...}\endmodality(post)) 
     \varcond(\isLocalVariable(#se))
     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallThrow"
     \oldname "method_call_throw_ignore_trail"
  };

  methodCallParamThrow { 
     \find (\modality{#allmodal}{.. method-frame(#v0, #ex):{throw #se; #slist} 
                      ...}\endmodality(post)) 
     \varcond(\isLocalVariable(#se))
     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "methodCallThrow"
     \oldname "method_call_throw_with_param_ignore_trail"
  };


  //throwEvaluate in the book, ignored for consistency reasons
  throwUnfoldMore {
     \find (\modality{#allmodal}{.. throw #se; ...}\endmodality(post)) 
     \varcond(\not\isLocalVariable(#se), \new(#v0, \typeof(#se)))
     \replacewith (\modality{#allmodal}{.. #typeof(#se) #v0 = #se; throw #v0; ...}\endmodality(post))
     \heuristics(simplify_prog)
     \displayname "throwUnfold"
     \oldname "throw_eval"
  };


  blockThrow { 
    \find (\modality{#allmodal}{.. {throw #e; #slist} ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. throw #e;  ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset) 
    \displayname "blockThrow"
    \oldname "throw_in_block_ignore_trail"
  };


  methodCallEmptyNoreturnBox { 
    \find (\[{.. method-frame(#v0, #ex):{} ...}\](post)) 
    \replacewith (\[{..  ...}\](post)) 
    \displayname "methodCallEmpty"
    \heuristics(simplify_prog) 
    \oldname "method_call_empty_noreturn_box"
  };

//--------------- loops ------------------------------------------------------//

 loopUnwind    { \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
		   \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
	           \replacewith (\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel,
	           					     while(#e) #s); ...}\endmodality(post))
		   \heuristics(loop_expand)
		   \oldname "unwind_while"};


 whileInvBox { \find (==> \[{.#ex..   while(#e) #s  ...}\]post) 
          \varcond(\new(#v1, boolean),
                   \new(anon1, \dependingOnMod(#modifies)),
          	   \new(anon2, \dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==>  #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
                #whileInvRule(\[{.. while (#e) #s ...}\]post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
         \replacewith (==> #introNewAnonUpdate(#modifies, inv -> 
                          (\[{ method-frame(#ex):{#typeof(#e)  #v1 = #e;} }\]
	                     (#v1=FALSE -> \[{..   ...}\]post)),anon2)) 
         \heuristics (loop_invariant, loop_invariant_proposal)
         \displayname "loopInvariant"
	 \oldname "while_inv_box"}; 


 loopInvariantTout { \find (==> \throughout{.#ex..   while(#e) #s  ...}\endmodality(post)) 
          \varcond(\new(#v1, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
		   \new(anon2,\dependingOnMod(#modifies)), 
		   \new(anon3,\dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)),
                   \new(anon3, \dependingOn(post)),
                   \new(anon3, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==> #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
                #whileInvRule(\[{.. while (#e) #s ...}\]true, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Throughout Property Holds in Body":
          \replacewith (==> #introNewAnonUpdate(#modifies, inv -> 
                (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
                #whileInvRule(\throughout{.. while (#e) #s ...}\endmodality(post), 
                                       post)),anon2));
    "Use Case":
          \replacewith (==> #introNewAnonUpdate(#modifies, inv -> 
                           (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]
	                      (#v1=FALSE -> \throughout{..   ...}\endmodality(post))),anon3)) 
    \heuristics (loop_invariant, loop_invariant_proposal)
    \displayname "loopInvariant"
    \oldname "while_inv_throughout"
    \oldname "whileTout"
  }; 



 whileInvDiamond { \find (==> \<{.#ex..   while(#e) #s  ...}\>post) 
          \varcond(\new(#v1, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
          	   \new(anon2,\dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==>  #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
                #whileInvRule(\[{.. while (#e) #s ...}\]post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
          \replacewith (==> #introNewAnonUpdate(#modifies, inv -> 
                             (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]
	                      (#v1=FALSE -> \[{..   ...}\]post)),anon2));
    "Termination":
          \replacewith (==> \<{..   while(#e) #s  ...}\>true) 
    \heuristics (loop_invariant_proposal)
    \displayname "loopInvariant" 
    \oldname "while_inv_diamond"
  }; 


  whileInvDiamondDec { \find (==> \<{.#ex..  while(#e) #s ...}\>post)
         \varcond(\new(#v1, boolean), \new(#v2, jint),
                  \new(#boolv, boolean),
                  \new(anon1,\dependingOnMod(#modifies)),
          	  \new(anon2,\dependingOnMod(#modifies)),
                  \new(anon3,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)),
                  \new(anon3, \dependingOn(post)),
                  \new(anon3, \dependingOn(inv)),
                  \new(anon3, \dependingOn(variant)))
     "Invariant Initially Valid":
         \replacewith (==> inv & variant >= 0 );

     "Body Preserves Invariant":
         \replacewith (==> #atPreEqs(anon1) ->
	    #introNewAnonUpdate (#modifies, 
		#locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) 
		& inv  ->
               (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
               #whileInvRule(\[{.. while (#e) #s ...}\]post,
               #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),
	       anon1));

     "Use Case":
         \replacewith (==> #introNewAnonUpdate(#modifies, inv & variant >= 0 ->
                            (\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]
                         (#v1=FALSE -> \<{..   ...}\>post)),anon2));
     "Termination":
         \replacewith (==>
                           #introNewAnonUpdate(#modifies,
                           (inv & variant >= 0 ->
                           ((\[{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\]#v1=TRUE ->
                           {#v2:=variant} #whileInvRule(\<{.. while (#e) #s ...}\>true,
                                      variant < #v2 & variant >= 0) ))),anon3))
         \addprogvars(#v2)                                      
    \heuristics (loop_invariant, loop_invariant_proposal)
    \displayname "loopInvariant (with variant)"
    \oldname "while_inv_diamond_dec"
    };
  } 


\rules(programRules:Java,transactions:transactionsOn,javacard:jcOn) {

// While rules for transaction cases, the only difference are the modalities. 
// Unfortunately, here it cannot be solved with schema modal operators. In near future we will also
// have rules for diamond_tra + box_tra

 loopInvariantTRCBox { 
     \schemaVar \modalOperator {box_trc, throughout_trc} #boxtouttrc;
     \find (==> \modality{#boxtouttrc}{.#ex..   while(#e) #s  ...}\endmodality post) 
          \varcond(\new(#v1, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
          	   \new(anon2,\dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==> #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\box{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality #v1=TRUE ->
                #whileInvRule(\modality{#boxtouttrc}{.. while (#e) #s ...}\endmodality post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
          \replacewith (==> #introNewAnonUpdate(#modifies, inv ->
	      (\box{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality
	                      (#v1=FALSE -> \modality{#boxtouttrc}{..   ...}\endmodality post)),anon2))
    \heuristics (loop_invariant, loop_invariant_proposal)
    \displayname "loopInvariant"
    \oldname "while_inv_boxtout_trc"
  }; 


 loopInvariantTRCDia { \find (==> \diamond_trc{.#ex..   while(#e) #s  ...}\endmodality post) 
          \varcond(\new(#v1, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
          	   \new(anon2,\dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==> #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\box{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality #v1=TRUE ->
                #whileInvRule(\box_trc{.. while (#e) #s ...}\endmodality post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
          \replacewith (==> #introNewAnonUpdate(#modifies, inv ->
	      (\box{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality
	                      (#v1=FALSE -> \box_trc{..   ...}\endmodality post)),anon2));
    "Termination":
          \replacewith (==> \diamond_trc{..   while(#e) #s  ...}\endmodality true) 
     \heuristics (loop_invariant_proposal)          
     \displayname "loopInvariant"
     \oldname "while_inv_diamond_trc"
 }; 


 loopInvariantWithVariantDecreasingTRCDia { \find (==> \diamond_trc{.#ex..  while(#e) #s ...}\endmodality post) 
          \varcond(\new(#v1, boolean),
	           \new(#v2, jint), \new(#boolv, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
	           \new(anon2,\dependingOnMod(#modifies)),
                   \new(anon3,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)),
                  \new(anon3, \dependingOn(post)),
                  \new(anon3, \dependingOn(inv)),
                  \new(anon3, \dependingOn(variant)))
    "Invariant Initially Valid":
          \replacewith (==> inv & variant >= 0 );
    "Body Preserves Invariant":
          \replacewith (==> #atPreEqs(anon1) -> #introNewAnonUpdate (#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv  ->
                (\box{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality #v1=TRUE ->
                #whileInvRule(\box_trc{.. while (#e) #s ...}\endmodality post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
          \replacewith (==>#introNewAnonUpdate(#modifies, inv & variant >= 0 ->
	     (\box{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality
	                      (#v1=FALSE -> \diamond_trc{..   ...}\endmodality post)),anon2));
    "Termination":
          \replacewith (==> #introNewAnonUpdate(#modifies,
                            ((inv & variant >= 0 ->
                            (\box{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality #v1=TRUE ->
                            {#v2:=variant} #whileInvRule(\diamond_trc{.. while (#e) #s ...}\endmodality true, 
                                       variant < #v2 & variant >= 0 ) ) ) ),anon3)) 
          \addprogvars(#v2)                                       
     \heuristics (loop_invariant, loop_invariant_proposal)
     \displayname "loopInvariant (with variant)"
     \oldname "while_inv_diamond_dec_trc"
   }; 

}


\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {

 loopInvariantTRABoxTout { 
     \schemaVar \modalOperator {box_tra, throughout_tra} #boxtouttra;
     \find (==> \modality{#boxtouttra}{.#ex..   while(#e) #s  ...}\endmodality post) 
          \varcond(\new(#v1, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
          	   \new(anon2,\dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==> #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\box_tra{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality #v1=TRUE ->
                #whileInvRule(\modality{#boxtouttra}{.. while (#e) #s ...}\endmodality post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
          \replacewith (==> #introNewAnonUpdate(#modifies, inv ->
	      (\box_tra{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality
	                      (#v1=FALSE -> \modality{#boxtouttra}{..   ...}\endmodality post)),anon2))
          \heuristics (loop_invariant, loop_invariant_proposal)
          \displayname "loopInvariant"
	  \oldname "while_inv_boxtout_tra"}; 

 loopInvariantTRADia { \find (==> \diamond_tra{.#ex..   while(#e) #s  ...}\endmodality post) 
          \varcond(\new(#v1, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
          	   \new(anon2,\dependingOnMod(#modifies)),
                   \new(anon1, \dependingOn(post)),
                   \new(anon1, \dependingOn(inv)),
                   \new(anon2, \dependingOn(post)),
                   \new(anon2, \dependingOn(inv)))
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==> #atPreEqs(anon1) -> #introNewAnonUpdate(#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv -> 
                (\box_tra{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality #v1=TRUE ->
                #whileInvRule(\box_tra{.. while (#e) #s ...}\endmodality post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
          \replacewith (==>#introNewAnonUpdate(#modifies, inv ->
	      (\box_tra{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality
	                      (#v1=FALSE -> \box_tra{..   ...}\endmodality post)),anon2));
    "Termination":
          \replacewith (==> \diamond_tra{..   while(#e) #s  ...}\endmodality true) 
    \displayname "loopInvariant"
    \heuristics (loop_invariant_proposal)
    \oldname "while_inv_diamond_tra"
          
    }; 


 loopInvariantWithVariantDecreasingTRADia { \find (==> \diamond_tra{.#ex..  while(#e) #s ...}\endmodality post) 
          \varcond(\new(#v1, boolean), \new(#v2, jint), \new(#boolv, boolean),
                   \new(anon1,\dependingOnMod(#modifies)),
          	   \new(anon2,\dependingOnMod(#modifies)),
                   \new(anon3,\dependingOnMod(#modifies)),
                  \new(anon1, \dependingOn(post)),
                  \new(anon1, \dependingOn(inv)),
                  \new(anon1, \dependingOn(variant)),
                  \new(anon2, \dependingOn(post)),
                  \new(anon2, \dependingOn(inv)),
                  \new(anon2, \dependingOn(variant)),
                  \new(anon3, \dependingOn(post)),
                  \new(anon3, \dependingOn(inv)),
                  \new(anon3, \dependingOn(variant)))
    "Invariant Initially Valid":
          \replacewith (==> inv & variant >= 0);
    "Body Preserves Invariant":
          \replacewith (==> #atPreEqs(anon1) -> #introNewAnonUpdate (#modifies, #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv  ->
                (\box_tra{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality #v1=TRUE ->
                #whileInvRule(\box_tra{.. while (#e) #s ...}\endmodality post, 
                                       #locDepFunc(anon1, \[{.. while (#e) #s ...}\]post) & inv)),anon1));
    "Use Case":
          \replacewith (==> #introNewAnonUpdate(#modifies, inv & variant >= 0 ->
	     (\box_tra{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality
	                      (#v1=FALSE -> \diamond_tra{..   ...}\endmodality post)),anon2));
    "Termination":
          \replacewith (==> #introNewAnonUpdate(#modifies,
                            (inv & variant >= 0 ->
                            ((\box_tra{ method-frame(#ex):{#typeof(#e) #v1 = #e;} }\endmodality #v1=TRUE ->
                            {#v2:=variant} #whileInvRule(\diamond_tra{.. while (#e) #s ...}\endmodality true, 
                                       variant < #v2 & variant >= 0) ))),anon3)) 
          \addprogvars(#v2)                                       
     \heuristics (loop_invariant, loop_invariant_proposal)
     \displayname "loopInvariant (with variant)"
     \oldname "while_inv_diamond_dec_tra"
   }; 

}

\rules(programRules:Java) {


/* deprecated for-loop treatment 
 * (when/if deleting forInitUnfold, also delete meta construct #unpack)
 */
/*  
  forInitUnfold { 
	\find (\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality(post))
	\replacewith 
	   (\modality{#allmodal}{.. 
		#unpack(for(#loopInit; #guard; #forupdates) #s);
            ...}\endmodality(post)) 
        \heuristics(simplify)
	\oldname "eval_for_init_for"
 };


forUnwindEmptyInit { 
     \find (\modality{#allmodal}{.. for(; #guard; #forupdates) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
              for(; #guard; #forupdates) #s); ...}\endmodality(post)) 
\heuristics(loop_expand)
     \oldname "unwind_for_empty_init"};

 
 forUnwindEmptyUpdate { 
     \find (\modality{#allmodal}{.. for(#loopInit; #guard;) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
	   for(#loopInit; #guard;) #s); ...}\endmodality(post)) 
     \heuristics(loop_expand)
     \oldname "unwind_for_empty_update"}; 

 
 forUnwindEmptyInitUpdate { 
     \find (\modality{#allmodal}{.. for(; #guard;) #s ...}\endmodality(post))
     \varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
     \replacewith (\modality{#allmodal}{.. #unwind-loop(#innerLabel, #outerLabel, 
                   for(; #guard;) #s); ...}\endmodality(post)) 
     \heuristics(loop_expand)
     \oldname "unwind_for_empty_init_and_update"}; 
*/
 
// for_inv      { \find (\[{.. for(#i; #e; #sel) {#s} ...}\]post) 
//           \varcond(#v new)
//          \replacewith (==> inv);
//          \replacewith (inv ==> \[{.. #unwind-loop (for(#i; #e; #sel)
//           {#s})  ...}\])
//          \replacewith (inv, \<{.. #v = #e; ...}\> #v = false ==>
//           \<{.. boolean #v = #e; ...}\>post) };


  doWhileUnwind {
	\find (\modality{#allmodal}{.. do #s while (#e); ...}\endmodality(post))
 	\varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
	\replacewith (\modality{#allmodal}{.. #unwind-loop (#innerLabel, #outerLabel, do #s while(#e);); ...}\endmodality(post))
	\heuristics(loop_expand)
	\oldname "unwind_do_while"	
  };

  // Make a while loop out of a for loop
  for_to_while {
	\find (\modality{#allmodal}{.. #forloop ...}\endmodality(post))
	\varcond(\newLabel(#innerLabel), \newLabel(#outerLabel))
        \replacewith(\modality{#allmodal}{.. #for-to-while(#innerLabel, #outerLabel, #forloop) ...}\endmodality(post))
	\heuristics(simplify_prog)
  };

  arrayInitialisation {
	\find (\modality{#normalassign}{.#t(#a).. for (int #v=#se;#v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\replacewith({\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv] := #lit}\modality{#normalassign}{..  ...}\endmodality(post))
	\displayname "arrayInitialisation"
	\heuristics(simplify)
	\oldname "init_array_for_loop_"
  };

  arrayInitialisationTRA {
	\find (\modality{#traonly}{.#t(#a).. for (int #v=#se; #v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\replacewith({\for iv; \if (geq(iv,#se) & lt(iv,#a.#length)) #a[iv]^(#transactionCounter) := #lit}\modality{#traonly}{..  ...}\endmodality(post))
	\heuristics(simplify)	
        \displayname "arrayInitialisation"
	\oldname "init_array_for_loop_tra"
  };

  arrayInitialisationTout {
	\find (\throughout{.#t(#a).. for (int #v=#se; #v<this.#length; #v++) this[#v] = #lit; ...}\endmodality(post))
	\varcond(\notFreeIn(iv2, post))
	\replacewith(
	   \forall iv2; ((iv2 >= #se & iv2 <= #a.#length) -> 
             {\for iv; \if (iv >= #se & iv < iv2) #a[iv] := #lit}post) &
	        {\for iv; \if (geq(iv,#v) & lt(iv,#a.#length)) #a[iv] := #lit}
                   (post -> \throughout{..  ...}\endmodality(post)))
	\heuristics(simplify)	
	\displayname "init_array_for_loop"
  };


//--------------- if-statements ----------------------------------------------//

  ifUnfold {  \find (\modality{#allmodal}{.. if(#nse) #s0 ...}\endmodality(post))
     \varcond (\new(#boolv, boolean))
     \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 ...}\endmodality(post))
     \heuristics(simplify_autoname)
     \displayname "ifElseUnfold"
     \oldname "if_eval"
  };

  ifElseUnfold { \find (\modality{#allmodal}{.. if(#nse) #s0 else #s1 ...}\endmodality(post)) 
     \varcond (\new(#boolv, boolean))
     \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 else{#s1}
                    ...}\endmodality(post) ) 
     \heuristics(simplify_autoname)
     \displayname "ifElseUnfold"
     \oldname "if_else_eval"
  };

  if  { \find (\modality{#allbuttra}{.. if(#se) #s0  ...}\endmodality(post))
       \replacewith (\if (#se=TRUE) \then (\modality{#allbuttra}{.. #s0 ...}\endmodality(post)) 
       \else (\modality{#allbuttra}{.. ...}\endmodality(post))) 
       \heuristics(split_if) 
       \displayname "ifElse"
       \oldname "if_split_imp_new"
  };

  ifElse  { \find (\modality{#allbuttra}{.. if(#se) #s0 else #s1 ...}\endmodality(post))
       \replacewith (\if (#se=TRUE) \then (\modality{#allbuttra}{.. #s0 ...}\endmodality(post)) 
       \else (\modality{#allbuttra}{.. #s1 ...}\endmodality(post))) 
       \heuristics(split_if) 
       \displayname "ifElse"
       \oldname "if_else_split_imp_new"
  };

  ifElseSplit  { \find (==> \modality{#allbuttra}{.. if(#se) #s0 else #s1 ...}\endmodality(post))
       "if #se true":  \replacewith (==> \modality{#allbuttra}{.. #s0 ...}\endmodality(post)) \add (#se = TRUE ==>);
       "if #se false": \replacewith (==> \modality{#allbuttra}{.. #s1 ...}\endmodality(post)) \add (#se = FALSE ==>)
       \heuristics(split_if) 
       \displayname "ifElseSplit"
       \oldname "if_else_split"
  };

  ifSplit  { \find (==> \modality{#allbuttra}{.. if(#se) #s0  ...}\endmodality(post) )
	"if #se true":  \replacewith (==> \modality{#allbuttra}{.. #s0 ...}\endmodality(post)) \add (#se = TRUE ==>);
	"if #se false": \replacewith (==> \modality{#allbuttra}{..  ...}\endmodality(post)) \add (#se = FALSE ==>)  
	\heuristics(split_if)
	\displayname "ifElseSplit"
	\oldname "if_split"
  };

  ifElseSplitLeft  { \find ( \modality{#allbuttra}{.. if(#se) #s0 else #s1 ...}\endmodality(post) ==>)
       \replacewith ( \modality{#allbuttra}{.. #s0 ...}\endmodality(post)==>) \add (#se = TRUE ==>);
       \replacewith ( \modality{#allbuttra}{.. #s1 ...}\endmodality(post)==>) \add (#se = FALSE ==>)  \heuristics(split_if)
       \oldname "if_else_split_left" };

  ifSplitLeft  { \find ( \modality{#allbuttra}{.. if(#se) #s0  ...}\endmodality(post) ==>)
       \replacewith ( \modality{#allbuttra}{.. #s0 ...}\endmodality(post)==>) \add (#se = TRUE ==>);
       \replacewith ( \modality{#allbuttra}{..  ...}\endmodality(post)==>) \add (#se = FALSE ==>)  \heuristics(split_if)
       \oldname "if_split_left" };

  ifTrue   { \assumes ( #se = TRUE ==>)
       \find (==> \modality{#allbuttra}{.. if (#se) #s0 ...}\endmodality(post)) 
       \replacewith (==> \modality{#allbuttra}{.. #s0 ...}\endmodality(post))  
       \heuristics (simplify_prog)
       \oldname "if_true"
  };


  ifElseTrue { \assumes ( #se = TRUE ==>)
		 \find (==> \modality{#allbuttra}{.. if (#se) #s0 else #s1 ...}\endmodality(post))
                 \replacewith (==> \modality{#allbuttra}{.. #s0 ...}\endmodality(post)) 
		 \heuristics (simplify_prog)
		 \oldname "if_else_true"
  };

  ifFalse   { \assumes ( #se = FALSE ==>)
       \find (==> \modality{#allbuttra}{.. if (#se) #s0 ...}\endmodality(post))        
       \replacewith (==> \modality{#allbuttra}{.. ...}\endmodality(post))  
       \heuristics (simplify_prog)
       \oldname "if_false"
  };

  ifElseFalse { \assumes ( #se = FALSE ==>)
		 \find (==> \modality{#allbuttra}{.. if (#se) #s0 else #s1 ...}\endmodality(post)) 
                 \replacewith (==> \modality{#allbuttra}{.. #s1 ...}\endmodality(post)) 
                 \heuristics (simplify_prog)
		 \oldname "if_else_false"
  };

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {

  ifTRA  { \find (\modality{#traonly}{.. if(#se) #s0  ...}\endmodality(post))
       \replacewith (\if (#shadowed(#se)=TRUE) \then (\modality{#traonly}{.. #s0 ...}\endmodality(post))
       \else (\modality{#traonly}{.. ...}\endmodality(post))) 
       \heuristics(split_if) 
       \displayname "if"
       \oldname "traonly_if_split_imp_new"
  };

  ifElseTRA  { \find (\modality{#traonly}{.. if(#se) #s0 else #s1 ...}\endmodality(post))
       \replacewith (\if (#shadowed(#se)=TRUE) \then (\modality{#traonly}{.. #s0 ...}\endmodality(post)) 
       \else (\modality{#traonly}{.. #s1 ...}\endmodality(post))) 
       \heuristics(split_if) 
       \displayname "ifElse"
       \oldname "traonly_if_else_split_imp_new"
  };

  ifElseSplitTRA { \find (==> \modality{#traonly}{.. if(#se) #s0 else #s1 ...}\endmodality(post))
       "if #se true":  \replacewith (==> \modality{#traonly}{.. #s0 ...}\endmodality(post)) \add (#shadowed(#se) = TRUE ==>);
       "if #se false": \replacewith (==> \modality{#traonly}{.. #s1 ...}\endmodality(post)) \add (#shadowed(#se) = FALSE ==>)
       \heuristics(split_if) 
       \displayname "ifElseSplit"
       \oldname "traonly_if_else_split" };

 ifSplitTRA  { \find (==> \modality{#traonly}{.. if(#se) #s0  ...}\endmodality(post) )
       "if #se true":  \replacewith (==> \modality{#traonly}{.. #s0 ...}\endmodality(post)) \add (#shadowed(#se) = TRUE ==>);
       "if #se false": \replacewith (==> \modality{#traonly}{..  ...}\endmodality(post)) \add (#shadowed(#se) = FALSE ==>)  
       \heuristics(split_if) 
       \displayname "ifSplit"
       \oldname "traonly_if_split" };

 ifElseSplitLeftTRA  { \find ( \modality{#traonly}{.. if(#se) #s0 else #s1 ...}\endmodality(post) ==>)
       \replacewith ( \modality{#traonly}{.. #s0 ...}\endmodality(post)==>) \add (#shadowed(#se) = TRUE ==>);
       \replacewith ( \modality{#traonly}{.. #s1 ...}\endmodality(post)==>) \add (#shadowed(#se) = FALSE ==>)
       \heuristics(split_if) 
       \displayname "ifElseSplitLeft"
       \oldname "traonly_if_else_split_left" };

 ifSplitLeftTRA  { \find ( \modality{#traonly}{.. if(#se) #s0  ...}\endmodality(post) ==>)
       \replacewith ( \modality{#traonly}{.. #s0 ...}\endmodality(post)==>) \add (#shadowed(#se) = TRUE ==>);
       \replacewith ( \modality{#traonly}{..  ...}\endmodality(post)==>) \add (#shadowed(#se) = FALSE ==>)
       \heuristics(split_if) 
       \displayname "ifSplitLeft"
       \oldname "traonly_if_split_left" };

 ifTrueTRA { \assumes ( #shadowed(#se) = TRUE ==>)
       \find (==> \modality{#traonly}{.. if (#se) #s0 ...}\endmodality(post)) 
       \replacewith (==> \modality{#traonly}{.. #s0 ...}\endmodality(post))  
       \heuristics (simplify_prog)
       \displayname "ifTrue"
       \oldname "traonly_if_true"
 };


 ifElseTrueTRA { \assumes ( #shadowed(#se) = TRUE ==>)
		 \find (==> \modality{#traonly}{.. if (#se) #s0 else #s1 ...}\endmodality(post))
                 \replacewith (==> \modality{#traonly}{.. #s0 ...}\endmodality(post)) 
		 \heuristics (simplify_prog)
		 \displayname "ifElseTrue"
		 \oldname "traonly_if_else_true"
 };

 ifFalseTRA { \assumes ( #shadowed(#se) = FALSE ==>)
       \find (==> \modality{#traonly}{.. if (#se) #s0 ...}\endmodality(post))        
       \replacewith (==> \modality{#traonly}{.. ...}\endmodality(post))  
       \heuristics (simplify_prog)
       \displayname "if_false"
       \oldname "traonly_if_false"
 };

 ifElseFalseTRA {
                 \assumes ( #shadowed(#se) = FALSE ==>)
		 \find (==> \modality{#traonly}{.. if (#se) #s0 else #s1 ...}\endmodality(post)) 
                 \replacewith (==> \modality{#traonly}{.. #s1 ...}\endmodality(post)) 
                 \heuristics (simplify_prog)
		 \displayname "ifElseFalse"
		 \oldname "traonly_if_else_false"
 };

}

\rules(programRules:Java) {

  ifEnterThen { 
	\find (\modality{#allmodal}{.. #loc=true; if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=true; #s0 ...}\endmodality(post))
        \heuristics (simplify)
	\oldname "if_enter_then"
  };

  ifSkipThen { 
	\find (\modality{#allmodal}{.. #loc=false; if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=false; ...}\endmodality(post)) 
        \heuristics (simplify)
	\oldname "if_skip_then"
  };

  ifElseSkipElse { 
	\find (\modality{#allmodal}{.. #loc=true; if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=true; #s0 ...}\endmodality(post))
        \heuristics (simplify)
	\oldname "if_else_enter_then"
  };

  ifElseSkipThen { 
	\find (\modality{#allmodal}{.. #loc=false; if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. #loc=false; #s1 ...}\endmodality(post))
        \heuristics (simplify)
	\oldname "if_else_enter_else"
  };


  ifEnterThenConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=true; } if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=true; } #s0 ...}\endmodality(post))
        \heuristics (simplify)
 	\displayname "ifEnterThen"
	\oldname "if_enter_then_block"
  };

  ifSkipThenConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=false; } if (#loc) #s0 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=false; } ...}\endmodality(post)) 
        \heuristics (simplify)
	\displayname "ifSkipThen"
	\oldname "if_skip_then_block"

  };

  ifElseSkipElseConditionInBlock { 
	\find (\modality{#allmodal}{.. { #loc=true;} if (#loc) #s0 else #s1 ...}\endmodality(post))
        \replacewith (\modality{#allmodal}{.. { #loc=true;} #s0 ...}\endmodality(post))
        \heuristics (simplify)
        \displayname "ifElseSkipElse"
	\oldname "if_else_enter_then_block"
  };

  ifElseSkipThenConditionInBlock { 
       \find (\modality{#allmodal}{.. { #loc=false; } if (#loc) #s0 else #s1 ...}\endmodality(post))
       \replacewith (\modality{#allmodal}{.. { #loc=false; } #s1 ...}\endmodality(post))
       \heuristics (simplify)
       \displayname "ifElseSkipThen"
       \oldname "if_else_enter_else_block"
  };
 
}

\rules(programRules:Java) {

//--------------- switch-statements ------------------------------------------//

 
switch { 
    \find (\modality{#allmodal}{.. #sw ...}\endmodality(post))
    \replacewith (\modality{#allmodal}{.. #switch-to-if(#sw) ...}\endmodality(post)) 
    \heuristics (simplify_prog)
    \oldname "switch_if"};


//--------------- labels and blocks ------------------------------------------//

// label_matches     { \find (\modality{#allmodal}{.. #break-match(#lb:#s); ...}\endmodality(post))
//            \replacewith (\modality{#allmodal}{.. ...}\endmodality(post)) };

// label_not_match    { \find (\modality{#allmodal}{.. #break-no-match(#lb:#s); ..}\endmodality(post))
//            \replacewith (\modality{#allmodal}{.. #s ..}\endmodality(post)) };  

// label_abrupt     { \find (\modality{#allmodal}{.. #reason-abrupt(#lb:#s); ..}\endmodality(post))
//            \replacewith (\modality{#allmodal}{.. #reason(#s); ...}\endmodality(post)) };


 break { \find (\modality{#allmodal}{.. #lb0: break #lb1;  ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. #do-break(#lb0: break #lb1;); ...}\endmodality(post))
	\heuristics (simplify_prog)};

 blockBreakNoLabel { \find (\modality{#allmodal}{.. { break #lb1; #slist} ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. break #lb1; ...}\endmodality(post))
	\heuristics(simplify_prog, simplify_prog_subset)
        \displayname "blockBreakNoLabel"
	\oldname "break_in_block_ignore_trail"};

 blockBreakLabel { \find (\modality{#allmodal}{.. #lb0: {break #lb1; #slist } ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. #do-break(#lb0: break #lb1;); ...}\endmodality(post))
	\heuristics (simplify_prog)
	\oldname "break_in_labelled_block_ignore_trail"};

 blockEmptyLabel      { \find (\modality{#allmodal}{.. #lb:{} ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. {}  ...}\endmodality(post)) 
	    \heuristics(simplify_prog, simplify_prog_subset)
            \displayname "blockEmpty"
	    \oldname "empty_label"};
 
                        
 blockEmpty { 
     \find (\modality{#allmodal}{.. {} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
     \oldname "empty_block"};


 unusedLabel {
	\find (\modality{#allmodal}{.. #lb: #s ...}\endmodality(post))
	\varcond(\not\freeLabelIn(#lb,#s))
	\replacewith(\modality{#allmodal}{.. #s ...}\endmodality(post))
	\heuristics(simplify_prog)
 };
 


 emptyStatement { 
     \find (\modality{#allmodal}{.. ; ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
     \oldname "empty_statement"};


//  block_abrupt     { \find (\modality{#allmodal}{.. #reason-abrupt(#s); ..}\endmodality(post))
//            \replacewith (\modality{#allmodal}{.. #reason(#s); ...}\endmodality(post)) };
            


 synchronizedBlockEmpty      {
     \find (\modality{#allmodal}{.. synchronized(#e){} ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
     \heuristics(simplify_prog, simplify_prog_subset)
     \oldname "empty_synchronized"};

}

\rules(programRules:Java,javacard:jcOn) {


 unfoldKeYJCSystem_jvmIsTransient { 
        \schemaVar \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc, diamond_tra, box_tra, throughout_tra}
	   #allbuttout;
        \find (\modality{#allbuttout}{..
  	  de.uka.ilkd.key.javacard.KeYJCSystem(#lhs)::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmistransient(#se); ...}\endmodality(post)) 	
        \replacewith (
	  {#lhs := #transient(#se)}
	    \modality{#allbuttout}{..  ...}\endmodality(post)) 
	\heuristics(method_expand)
	\displayname " unfoldKeYJCSystem.jvmIsTransient"
	\oldname "execute_KeYJCSystem_jvmIsTransient"
 };

 unfoldKeYJCSystem_jvmMakeShort { 
        \schemaVar \modalOperator { diamond, box, diamond_trc, box_trc, throughout_trc, diamond_tra, box_tra, throughout_tra}
	   #allbuttout;
        \find (\modality{#allbuttout}{..
  	   de.uka.ilkd.key.javacard.KeYJCSystem(#lhs)::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmmakeshort(#se0,#se1); ...}\endmodality(post)) 	
        \replacewith (
	  {#lhs := jvmMakeShort(#se0,#se1)}
	    \modality{#allbuttout}{..  ...}\endmodality(post)) 
	\heuristics(method_expand)
	\displayname " unfoldKeYJCSystem.jvmMakeShort"
	\oldname "execute_KeYJCSystem_jvmMakeShort"
 };

 unfoldKeYJCSystem_jvmArrayCompare { 
        \schemaVar \modalOperator { diamond, box, throughout, diamond_trc, box_trc, throughout_trc} #acmpmodal;
        \find (\modality{#acmpmodal}{..
             de.uka.ilkd.key.javacard.KeYJCSystem(#lhs)::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarraycompare(#src,#srcOff,#dest,#destOff,#arlength);
           ...}\endmodality(post))
        \sameUpdateLevel
        "Arrays #src and #dest same":
        \replacewith (
	  {#lhs := 0} \modality{#acmpmodal}{..  ...}\endmodality(post))
	\add( \forall iv; (iv >= 0 & iv < #arlength ->
	                    #dest[#destOff + iv] = #src[#srcOff + iv]) ==> );
        "Array #src is less than array #dest":
        \replacewith (
	  {#lhs := -1} \modality{#acmpmodal}{..  ...}\endmodality(post))
	\add( \exists iv2; (iv2 >= 0 & iv2 < #arlength & 
	        #dest[#destOff + iv2] > #src[#srcOff + iv2] &
	\forall iv; (iv >= 0 & iv < iv2 ->
	                    #dest[#destOff + iv] = #src[#srcOff + iv])) ==> );
        "Array #src is greater than array #dest":
        \replacewith (
	  {#lhs := 1} \modality{#acmpmodal}{..  ...}\endmodality(post))
	\add( \exists iv2; (iv2 >= 0 & iv2 < #arlength & 
	        #dest[#destOff + iv2] < #src[#srcOff + iv2] &
	\forall iv; (iv >= 0 & iv < iv2 ->
	                    #dest[#destOff + iv] = #src[#srcOff + iv])) ==> )
	\heuristics(method_expand)
	\displayname " unfoldKeYJCSystem.jvmArrayCompare"
	\oldname "execute_KeYJCSystem_jvmArrayCompare"

 };

 unfoldKeYJCSystem_jvmArrayCopy { 
        \find (\modality{#normalassign}{..
                  de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarraycopy(#src,#srcOff,#dest,#destOff,#arlength);
           ...}\endmodality(post)) 	
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #src[#srcOff + iv]}
	    \modality{#normalassign}{..  ...}\endmodality(post)) 
	\heuristics(method_expand)
	\displayname " unfoldKeYJCSystem.jvmArrayCopy"
	\oldname "execute_KeYJCSystem_jvmArrayCopy"
 };

 unfoldKeYJCSystem_jvmSetShort { 
        \find (\modality{#normalassign}{..
                 de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmsetshort(#dest,#destOff,#se);
           ...}\endmodality(post)) 	
        \replacewith (
	  {#dest[#destOff] := jvmSetShort1(#se) || #dest[#destOff + 1] := jvmSetShort2(#se)}
	    \modality{#normalassign}{..  ...}\endmodality(post)) 
	\heuristics(method_expand)
	\displayname " unfoldKeYJCSystem.jvmSetShort"
	\oldname "execute_KeYJCSystem_jvmSetShort"
 };


 unfoldKeYJCSystem_jvmArrayCopyNonAtomic { 
        \find (\modality{#normalassign}{..
            de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarraycopynonatomic(#src,#srcOff,#dest,#destOff,#arlength);
           ...}\endmodality(post)) 	
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #src[#srcOff + iv]}
	    \modality{#normalassign}{..  ...}\endmodality(post)) 
	\heuristics(method_expand)
	\displayname " unfoldKeYJCSystem.jvmArrayCopyNonAtomic"
	\oldname "execute_KeYJCSystem_jvmArrayCopyNonAtomic"
 };

 unfoldKeYJCSystem_jvmArrayFillNonAtomic { 
        \find (\modality{#normalassign}{..
            de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarrayfillnonatomic(#dest,#destOff,#arlength,#se);
           ...}\endmodality(post)) 	
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #se}
	    \modality{#normalassign}{..  ...}\endmodality(post)) 
	\heuristics(method_expand)
	\displayname " unfoldKeYJCSystem.jvmArrayFillNonAtomic"
	\oldname "execute_KeYJCSystem_jvmArrayFillNonAtomic"
 };

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {

 unfoldKeYJCSystem_jvmArrayCopy_tra { 
        \find (\modality{#tramodal}{..
                  de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarraycopy(#src,#srcOff,#dest,#destOff,#arlength);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
       "Destination array #dest transient":
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #src[#srcOff + iv]^(#transactionCounter)}
	    \modality{#tramodal}{..  ...}\endmodality(post)) 
	\add(#transient(#dest) > 0 ==>);
       "Destination array #dest persistent":
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv]^(#transactionCounter) :=
	       #src[#srcOff + iv]^(#transactionCounter) ||
           \for iv2; \if (iv2 >= 0 & iv2 < #arlength)
	       #traInitialized(#dest)[#destOff + iv2]^(#transactionCounter) := TRUE }
	    \modality{#tramodal}{..  ...}\endmodality(post)) 
	\add(#transient(#dest) = 0 ==>)
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmArrayCopy"
	\oldname "execute_KeYJCSystem_jvmArrayCopy_tra"
 };

 unfoldKeYJCSystem_jvmSetShort_tra { 
        \find (\modality{#tramodal}{..
                 de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmsetshort(#dest,#destOff,#se);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
       "Destination array #dest transient":
        \replacewith (
	  {#dest[#destOff] := jvmSetShort1(#se) || #dest[#destOff + 1] := jvmSetShort2(#se) }
	    \modality{#tramodal}{..  ...}\endmodality(post)) 
	\add(#transient(#dest) > 0 ==>);
       "Destination array #dest persistent":
        \replacewith (
	  {#dest[#destOff]^(#transactionCounter) := jvmSetShort1(#se) ||
	   #dest[#destOff + 1]^(#transactionCounter) := jvmSetShort2(#se) ||
           #traInitialized(#dest)[#destOff]^(#transactionCounter) := TRUE ||
	   #traInitialized(#dest)[#destOff + 1]^(#transactionCounter) := TRUE}
	    \modality{#tramodal}{..  ...}\endmodality(post)) 
	\add(#transient(#dest) = 0 ==>)
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmSetShort"
	\oldname "execute_KeYJCSystem_jvmSetShort_tra"
 };


 unfoldKeYJCSystem_jvmArrayCompare_tra { 
        \find (\modality{#tramodal}{..
             de.uka.ilkd.key.javacard.KeYJCSystem(#lhs)::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarraycompare(#src,#srcOff,#dest,#destOff,#arlength);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
        "Arrays #src and #dest same":
        \replacewith (
	  {#lhs := 0} \modality{#tramodal}{..  ...}\endmodality(post))
	\add( \forall iv; (iv >= 0 & iv < #arlength ->
	                    #dest[#destOff + iv]^(#transactionCounter) = #src[#srcOff + iv]^(#transactionCounter)) ==> );
        "Array #src is less than array #dest":
        \replacewith (
	  {#lhs := -1} \modality{#tramodal}{..  ...}\endmodality(post))
	\add( \exists iv2; (iv2 >= 0 & iv2 < #arlength & 
	        #dest[#destOff + iv2]^(#transactionCounter) > #src[#srcOff + iv2]^(#transactionCounter) &
	\forall iv; (iv >= 0 & iv < iv2 ->
	                    #dest[#destOff + iv]^(#transactionCounter) = #src[#srcOff + iv]^(#transactionCounter))) ==> );
        "Array #src is greater than array #dest":
        \replacewith (
	  {#lhs := 1} \modality{#tramodal}{..  ...}\endmodality(post))
	\add( \exists iv2; (iv2 >= 0 & iv2 < #arlength & 
	        #dest[#destOff + iv2]^(#transactionCounter) < #src[#srcOff + iv2]^(#transactionCounter) &
	\forall iv; (iv >= 0 & iv < iv2 ->
	                    #dest[#destOff + iv]^(#transactionCounter) = #src[#srcOff + iv]^(#transactionCounter))) ==> )
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmArrayCompare"
	\oldname "execute_KeYJCSystem_jvmArrayCompare_tra"
 };


 unfoldKeYJCSystem_jvmArrayCopyNonAtomic_tra { 
        \schemaVar \modalOperator { diamond_tra, box_tra} #acnamodal;
        \find (\modality{#acnamodal}{..
           de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarraycopynonatomic(#src,#srcOff,#dest,#destOff,#arlength);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
       "Destination array #dest transient":
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #src[#srcOff + iv]^(#transactionCounter)}
	    \modality{#acnamodal}{..  ...}\endmodality(post)) 
	\add(#transient(#dest) > 0 ==>);
       "Destination array #dest persistent":
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength &
	       #traInitialized(#dest)[#destOff +
	       iv]^(#transactionCounter) = TRUE) 
	     #dest[#destOff + iv]^(#transactionCounter) :=
	       #src[#srcOff + iv]^(#transactionCounter) ||
           \for iv2; \if (iv2 >= 0 & iv2 < #arlength &
	       #traInitialized(#dest)[#destOff +
	       iv2]^(#transactionCounter) = FALSE) 
	     #dest[#destOff + iv2] :=
	       #src[#srcOff + iv2]^(#transactionCounter) }
	    \modality{#acnamodal}{..  ...}\endmodality(post)) 
	\add(#transient(#dest) = 0 ==>)
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmArrayCopyNonAtomic"
	\oldname "execute_KeYJCSystem_jvmArrayCopyNonAtomic_tra"
 };

 unfoldKeYJCSystem_jvmArrayFillNonAtomic_tra { 
        \schemaVar \modalOperator { diamond_tra, box_tra} #acnamodal;
        \find (\modality{#acnamodal}{..
             de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarrayfillnonatomic(#dest,#destOff,#arlength,#se);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
       "Destination array #dest transient":
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #se}
	    \modality{#acnamodal}{..  ...}\endmodality(post)) 
	\add(#transient(#dest) > 0 ==>);
       "Destination array #dest persistent":
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength &
	       #traInitialized(#dest)[#destOff +
	       iv]^(#transactionCounter) = TRUE) 
	     #dest[#destOff + iv]^(#transactionCounter) := #se ||
           \for iv2; \if (iv2 >= 0 & iv2 < #arlength &
	       #traInitialized(#dest)[#destOff +
	       iv2]^(#transactionCounter) = FALSE) 
	     #dest[#destOff + iv2] := #se }
	    \modality{#acnamodal}{..  ...}\endmodality(post)) 
	\add(#transient(#dest) = 0 ==>)
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmArrayFillNonAtomic"
	\oldname "execute_KeYJCSystem_jvmArrayFillNonAtomic_tra"
 };

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,throughout:toutOn,javacard:jcOn) {

 unfoldKeYJCSystem_jvmArrayCopyNonAtomic_tout_tra { 
        \find (\throughout_tra{..
            de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarraycopynonatomic(#src,#srcOff,#dest,#destOff,#arlength);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
       	\varcond(\notFreeIn(iv3, post))
       "Destination array #dest transient":
        \replacewith (
	  post & 
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #src[#srcOff + iv]^(#transactionCounter)}
	    \throughout_tra{..  ...}\endmodality(post)) 
	\add(#transient(#dest) > 0 ==>);
       "Destination array #dest persistent":
        \replacewith (
	    \forall iv3; (iv3 >= 0 & iv3 <= #arlength ->
	    {\for iv; \if (iv >= 0 & iv < iv3
	       & #traInitialized(#dest)[#destOff + iv]^(#transactionCounter) = FALSE)
  	       #dest[#destOff + iv] := #src[#srcOff + iv]^(#transactionCounter)}post)
	  & {\for iv; \if (iv >= 0 & iv < #arlength &
	       #traInitialized(#dest)[#destOff + iv]^(#transactionCounter) = TRUE)
	     #dest[#destOff + iv]^(#transactionCounter) := #src[#srcOff + iv]^(#transactionCounter) ||
	     \for iv2; \if (iv2 >= 0 & iv2 < #arlength &
	       #traInitialized(#dest)[#destOff + iv2]^(#transactionCounter) = FALSE)
	     #dest[#destOff + iv2] := #src[#srcOff + iv2]^(#transactionCounter)}
	    \throughout_tra{..  ...}\endmodality(post)) 
	\add(#transient(#dest) = 0 ==>)
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmArrayCopyNonAtomic"
	\oldname "execute_KeYJCSystem_jvmArrayCopyNonAtomic_tout_tra"
 };

 unfoldKeYJCSystem_jvmArrayFillNonAtomic_tout_tra { 
        \find (\throughout_tra{..
             de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarrayfillnonatomic(#dest,#destOff,#arlength,#se);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
       	\varcond(\notFreeIn(iv3, post))
       "Destination array #dest transient":
        \replacewith (
	  {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #se}
	    \throughout_tra{..  ...}\endmodality(post)) 
	\add(#transient(#dest) > 0 ==>);
       "Destination array #dest persistent":
        \replacewith (
	    \forall iv3; (iv3 >= 0 & iv3 <= #arlength ->
	    {\for iv; \if (iv >= 0 & iv < iv3 
	       & #traInitialized(#dest)[#destOff + iv]^(#transactionCounter) = FALSE)
  	       #dest[#destOff + iv] := #se}post)
	  & {\for iv; \if (iv >= 0 & iv < #arlength &
	       #traInitialized(#dest)[#destOff + iv]^(#transactionCounter) = TRUE)
	     #dest[#destOff + iv]^(#transactionCounter) := #se ||
	     \for iv2; \if (iv2 >= 0 & iv2 < #arlength &
	       #traInitialized(#dest)[#destOff + iv2]^(#transactionCounter) = FALSE)
	     #dest[#destOff + iv2] := #se}
	    \throughout_tra{..  ...}\endmodality(post)) 
	\add(#transient(#dest) = 0 ==>)
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmArrayFillNonAtomic"
	\oldname "execute_KeYJCSystem_jvmArrayFillNonAtomic_tout_tra"
 };

}

\rules(programRules:Java,throughout:toutOn,javacard:jcOn) {

 unfoldKeYJCSystem_jvmIsTransient_tout { 
        \find (\throughout{..
  	  de.uka.ilkd.key.javacard.KeYJCSystem(#lhs)::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmistransient(#se); ...}\endmodality(post)) 	
        \replacewith (
	  post & ( post -> {#lhs := #transient(#se)} \throughout{..  ...}\endmodality(post)))
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmIsTransient"
	\oldname "execute_KeYJCSystem_jvmIsTransient_tout"
 };

 unfoldKeYJCSystem_jvmMakeShort_tout { 
        \find (\throughout{..
  	   de.uka.ilkd.key.javacard.KeYJCSystem(#lhs)::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmmakeshort(#se0,#se1); ...}\endmodality(post)) 	
        \replacewith (
	  post & ( post -> {#lhs := jvmMakeShort(#se0,#se1)} \throughout{..  ...}\endmodality(post)))
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmMakeShort"
	\oldname "execute_KeYJCSystem_jvmMakeShort_tout"
 };

 unfoldKeYJCSystem_jvmArrayCopyNonAtomic_tout { 
        \find (\throughout{..
            de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarraycopynonatomic(#src,#srcOff,#dest,#destOff,#arlength);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
       	\varcond(\notFreeIn(iv3, post))
        \replacewith (
	    \forall iv3; (iv3 >= 0 & iv3 <= #arlength ->
	    {\for iv; \if (iv >= 0 & iv < iv3)
  	       #dest[#destOff + iv] := #src[#srcOff + iv]}post)
	  & {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #src[#srcOff + iv]}
	    \throughout{..  ...}\endmodality(post)) 
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmArrayCopyNonAtomic"
	\oldname "execute_KeYJCSystem_jvmArrayCopyNonAtomic_tout"
 };

 unfoldKeYJCSystem_jvmArrayFillNonAtomic_tout { 
        \find (\throughout{..
           de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#jvmarrayfillnonatomic(#dest,#destOff,#arlength,#se);
           ...}\endmodality(post)) 	
        \sameUpdateLevel
       	\varcond(\notFreeIn(iv3, post))
        \replacewith (
	    \forall iv3; (iv3 >= 0 & iv3 <= #arlength ->
	    {\for iv; \if (iv >= 0 & iv < iv3 )
  	       #dest[#destOff + iv] := #se}post)
	  & {\for iv; \if (iv >= 0 & iv < #arlength)
	     #dest[#destOff + iv] := #se}
	    \throughout{..  ...}\endmodality(post)) 
	\heuristics(method_expand)
	\displayname "unfoldKeYJCSystem.jvmArrayFillNonAtomic"
	\oldname "execute_KeYJCSystem_jvmArrayFillNonAtomic_tout"
 };

}

\rules(programRules:Java) {


//----------------------------------------------------------------------------
//-----------                  instanceof 			   -----------
//----------------------------------------------------------------------------

 instanceof_eval { \find (\modality{#allmodal}{.. #v = #nse instanceof #t; ...}\endmodality(post))
	           \varcond(\new(#v0, \typeof(#nse))) 
		   \replacewith ( \modality{#allmodal}{..#typeof(#nse) #v0=#nse; 
				#v=#v0 instanceof #t;...}\endmodality(post) )
	           \heuristics(simplify_autoname)
 };

 instanceof_to_exist_true { \find (G::instance(obj)=TRUE) 
	\varcond (\notFreeIn(x, obj)) 
	\replacewith (\exists x; obj=x)
	\heuristics(instanceof_to_exists)
 };

 instanceof_to_exist_false { \find (G::instance(obj)=FALSE) 
	\varcond (\notFreeIn(x, obj)) 
	\replacewith (!\exists x; obj=x)
 };
 
 instanceof_known_dynamic_type { 
        \find (G::instance(H::<get>(idx)))
        \varcond(\sub(H, G))  
	\replacewith (TRUE)
	\displayname "subtypes are instances of supertypes"
	\heuristics(evaluate_instanceof)
 };
 
  instanceof_known_dynamic_type_2 { 
        \assumes(H::<get>(idx) = obj ==>) 
        \find (G::instance(obj)) \sameUpdateLevel
        \varcond(\sub(H, G))  
	\replacewith (TRUE)
	\displayname "subtypes are instances of supertypes"
	\heuristics(evaluate_instanceof)
 };
 
 instanceof_known_dynamic_type_no_sub { 
        \find (G::instance(H::<get>(idx)))
        \varcond(\not\sub(H, G))  
	\replacewith (FALSE)
        \displayname "exact type no sub or equal type"
	\heuristics(evaluate_instanceof)
 };
 
 instanceof_known_dynamic_type_no_sub_2 {
        \assumes (H::<get>(idx) = obj ==>) 
        \find (G::instance(obj)) \sameUpdateLevel
        \varcond(\not\sub(H, G))  
	\replacewith (FALSE)
        \displayname "exact type no sub or equal type"
	\heuristics(evaluate_instanceof)
 };

 instanceof_static_type {
       \find(G::instance(obj))
       \varcond(\sub(\typeof(obj), G))
       \replacewith(TRUE)
       \displayname "instanceof static type is subtype"
       \heuristics(simplify, evaluate_instanceof)
 };

 instanceof_not_compatible {
       \find(G::instance(obj) = TRUE)
       \varcond(\not\compatible(G, \typeof(obj)), 
                \isReference(\typeof(obj)),
                \not\isAbstractOrInterface(\typeof(obj)),
		\not\isAbstractOrInterface(G))
       \replacewith(obj = null)
       \displayname "instanceof not compatible types"
       \heuristics(simplify, evaluate_instanceof)
 };

 instanceof_not_compatible_1 {
       \find(G::instance(obj) = FALSE)
       \varcond(\not\compatible(G, \typeof(obj)), 
                \isReference(\typeof(obj)),
                \not\isAbstractOrInterface(\typeof(obj)),
		\not\isAbstractOrInterface(G))
       \replacewith(!(obj = null))
       \displayname "instanceof not compatible types"
       \heuristics(simplify, evaluate_instanceof)
 };


//----------------------------------------------------------------------------
//-----------            Compile-time constant variables           -----------
//----------------------------------------------------------------------------

 insert_constant_value { \find ( #cv ) \replacewith ( #constantvalue ( #cv ) )
                         \heuristics(concrete)  };



//------------------------------------------------------------------------
// ------------ Rules for conditional expression
//------------------------------------------------------------------------

 condition { \find (\modality{#allmodal}{.. #lhs = #e0 ? #e1 : #e2; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{.. if(#e0) {#lhs = #e1;} 
             else {#lhs = #e2;} ...}\endmodality(post)) 
            \heuristics(simplify_prog)};

//------------------------------------------------------------------------
// ------------ Rules for comparison operators
//------------------------------------------------------------------------

  equality_comparison_new { \find ( \modality{#allbuttra}{.. #lhs = #se0 == #se1; ...}\endmodality(post)) 
    \replacewith ( \if (!#se0=#se1) 
                    \then (\modality{#allbuttra}{.. #lhs = false; ...}\endmodality(post))  
                    \else (\modality{#allbuttra}{.. #lhs = true;  ...}\endmodality(post)) )
    \heuristics(simplify_prog, split_if)
    \displayname "equality comparison"
  };

  inequality_comparison_new { \find ( \modality{#allbuttra}{.. #lhs = #se0 != #se1; ...}\endmodality(post)) 
    \replacewith ( \if (!#se0=#se1) \then (\modality{#allbuttra}{.. #lhs = true; ...}\endmodality(post)) 
                                  \else (\modality{#allbuttra}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "inequality comparison"
  };

  less_than_comparison_new { \find ( \modality{#allbuttra}{.. #lhs = #se0 < #se1; ...}\endmodality(post)) 
    \replacewith ( \if (lt(#se0,#se1)) \then (\modality{#allbuttra}{.. #lhs = true;  ...}\endmodality(post)) 
                  		     \else (\modality{#allbuttra}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "lesser than distinction"
  };

  less_equal_than_comparison_new { \find ( \modality{#allbuttra}{.. #lhs = #se0 <= #se1; ...}\endmodality(post)) 
    \replacewith ( \if (leq(#se0,#se1)) \then (\modality{#allbuttra}{.. #lhs = true; ...}\endmodality(post))  
                                      \else (\modality{#allbuttra}{.. #lhs = false; ...}\endmodality(post))) 
    \heuristics(simplify_prog, split_if)
    \displayname "less-or-equal than distinction"
   };

  greater_than_comparison_new { \find ( \modality{#allbuttra}{.. #lhs = #se0 > #se1; ...}\endmodality(post)) 
    \replacewith ( \if (gt(#se0,#se1)) \then (\modality{#allbuttra}{.. #lhs = true;  ...}\endmodality(post)) 
                                     \else (\modality{#allbuttra}{.. #lhs = false; ...}\endmodality(post))) 
    \heuristics(simplify_prog, split_if)
    \displayname "greater than distinction"
   };

  greater_equal_than_comparison_new { \find ( \modality{#allbuttra}{.. #lhs = #se0 >= #se1; ...}\endmodality(post)) 
    \replacewith ( \if (geq(#se0,#se1)) \then (\modality{#allbuttra}{.. #lhs = true; ...}\endmodality(post))
		                      \else (\modality{#allbuttra}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "greater-or-equal than distinction"
   };

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {

  traonly_equality_comparison_new { \find ( \modality{#traonly}{.. #lhs = #se0 == #se1; ...}\endmodality(post)) 
    \replacewith ( \if (!#shadowed(#se0)=#shadowed(#se1)) 
                    \then (\modality{#traonly}{.. #lhs = false; ...}\endmodality(post))  
                    \else (\modality{#traonly}{.. #lhs = true;  ...}\endmodality(post)) )
    \heuristics(simplify_prog, split_if)
    \displayname "equality comparison"
  };

  traonly_inequality_comparison_new { \find ( \modality{#traonly}{.. #lhs = #se0 != #se1; ...}\endmodality(post)) 
    \replacewith ( \if (!#shadowed(#se0)=#shadowed(#se1)) \then (\modality{#traonly}{.. #lhs = true; ...}\endmodality(post)) 
                                  \else (\modality{#traonly}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "inequality comparison"
  };

  traonly_less_than_comparison_new { \find ( \modality{#traonly}{.. #lhs = #se0 < #se1; ...}\endmodality(post)) 
    \replacewith ( \if (lt(#shadowed(#se0),#shadowed(#se1))) \then (\modality{#traonly}{.. #lhs = true;  ...}\endmodality(post)) 
                  		     \else (\modality{#traonly}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "lesser than distinction"
  };

  traonly_less_equal_than_comparison_new { \find ( \modality{#traonly}{.. #lhs = #se0 <= #se1; ...}\endmodality(post)) 
    \replacewith ( \if (leq(#shadowed(#se0),#shadowed(#se1))) \then (\modality{#traonly}{.. #lhs = true; ...}\endmodality(post))  
                                      \else (\modality{#traonly}{.. #lhs = false; ...}\endmodality(post))) 
    \heuristics(simplify_prog, split_if)
    \displayname "less-or-equal than distinction"
   };

  traonly_greater_than_comparison_new { \find ( \modality{#traonly}{.. #lhs = #se0 > #se1; ...}\endmodality(post)) 
    \replacewith ( \if (gt(#shadowed(#se0),#shadowed(#se1))) \then (\modality{#traonly}{.. #lhs = true;  ...}\endmodality(post)) 
                                     \else (\modality{#traonly}{.. #lhs = false; ...}\endmodality(post))) 
    \heuristics(simplify_prog, split_if)
    \displayname "greater than distinction"
   };

  traonly_greater_equal_than_comparison_new { \find ( \modality{#traonly}{.. #lhs = #se0 >= #se1; ...}\endmodality(post)) 
    \replacewith ( \if (geq(#shadowed(#se0),#shadowed(#se1))) \then (\modality{#traonly}{.. #lhs = true; ...}\endmodality(post))
		                      \else (\modality{#traonly}{.. #lhs = false; ...}\endmodality(post)) ) 
    \heuristics(simplify_prog, split_if)
    \displayname "greater-or-equal than distinction"
   };

}

\rules(programRules:Java) {

//------------------------------------------------------------------------
// ----------- Rules for handling a cast applied to a compound expression
//------------------------------------------------------------------------

  compound_byte_cast_expression { \find (\modality{#allmodal}{.. #lhs = (byte) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (byte) #v;  ...}\endmodality(post))
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_short_cast_expression { \find (\modality{#allmodal}{.. #lhs = (short) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (short) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_int_cast_expression { \find (\modality{#allmodal}{.. #lhs = (int) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (int) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

  compound_long_cast_expression { \find (\modality{#allmodal}{.. #lhs = (long) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (long) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast" };

//------------------------------------------------------------------------
// ----------- Rules for expanding compound assignment operators
//------------------------------------------------------------------------

   compound_assignment_op_mul_attr { \find (\modality{#allmodal}{.. #e0.#attribute *= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute * #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mul_array { \find (\modality{#allmodal}{.. #e0[#e] *= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
			#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] * #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_mul { \find (\modality{#allmodal}{.. #v *= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v * (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_div_attr { \find (\modality{#allmodal}{.. #e0.#attribute /= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute / #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_div_array { \find (\modality{#allmodal}{.. #e0[#e] /= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; #v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] / #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_div { \find (\modality{#allmodal}{.. #v /= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v / (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod_attr { \find (\modality{#allmodal}{.. #e0.#attribute %= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute % #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod_array { \find (\modality{#allmodal}{.. #e0[#e] %= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] % #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_mod { \find (\modality{#allmodal}{.. #v %= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v % (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus_attr { \find (\modality{#allmodal}{.. #e0.#attribute += #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute + #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus_array { \find (\modality{#allmodal}{.. #e0[#e] += #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] + #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_plus { \find (\modality{#allmodal}{.. #v += #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v + (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus_attr { \find (\modality{#allmodal}{.. #e0.#attribute -= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute - #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus_array { \find (\modality{#allmodal}{.. #e0[#e] -= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] - #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_minus { \find (\modality{#allmodal}{.. #v -= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v - (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft_attr { \find (\modality{#allmodal}{.. #e0.#attribute <<= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute << #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft_array { \find (\modality{#allmodal}{.. #e0[#e] <<= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] << #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftleft { \find (\modality{#allmodal}{.. #v <<= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v << (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright_attr { \find (\modality{#allmodal}{.. #e0.#attribute >>= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute >> #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright_array { \find (\modality{#allmodal}{.. #e0[#e] >>= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] >> #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_shiftright { \find (\modality{#allmodal}{.. #v >>= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v >> (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright_attr { \find (\modality{#allmodal}{.. #e0.#attribute >>>= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute >>> #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright_array { \find (\modality{#allmodal}{.. #e0[#e] >>>= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] >>> #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_unsigned_shiftright { \find (\modality{#allmodal}{.. #v >>>= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v >>> (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_and_attr { \find (\modality{#allmodal}{.. #e0.#attribute &= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute & #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_and_array { \find (\modality{#allmodal}{.. #e0[#e] &= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] & #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_and { \find (\modality{#allmodal}{.. #v &= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v & (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_or_attr { \find (\modality{#allmodal}{.. #e0.#attribute |= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute | #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_or_array { \find (\modality{#allmodal}{.. #e0[#e] |= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] | #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_or { \find (\modality{#allmodal}{.. #v |= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v | (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor_attr { \find (\modality{#allmodal}{.. #e0.#attribute ^= #e; ...}\endmodality(post)) 
        \varcond (\new(#v, \typeof(#e0)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v=#e0; #v.#attribute = (#typeof(#attribute))(#v.#attribute ^ #e); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor_array { \find (\modality{#allmodal}{.. #e0[#e] ^= #e1; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e0)), \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; #typeof(#e) #v1=#e; 
		#v0[#v1] = (#typeof(#e0[#e]))(#v0[#v1] ^ #e1); ...}\endmodality(post))
        \heuristics(simplify_prog)};  

   compound_assignment_op_xor { \find (\modality{#allmodal}{.. #v ^= #e; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. #v = (#typeof(#v))(#v ^ (#e)); ...}\endmodality(post)) 
        \heuristics(simplify_prog)};  


//------------------------------------------------------------------------
// ----------- Rule for expanding iterated assignments -------------------
//------------------------------------------------------------------------

  eval_order_iterated_assignments_0_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]=#e1; 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_0_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute=#e;
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_0 { \find (\modality{#allmodal}{.. #lhs0=#lhs1=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1=#e; #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_1_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]*=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] * #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_1_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute*=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute * #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_1 { \find (\modality{#allmodal}{.. #lhs0=#lhs1*=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 * #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_2_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]/=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] / #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_2_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute/=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute / #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_2 { \find (\modality{#allmodal}{.. #lhs0=#lhs1/=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 / #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_3_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]%=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] % #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_3_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute%=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute % #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_3 { \find (\modality{#allmodal}{.. #lhs0=#lhs1%=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 % #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_4_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]+=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] + #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_4_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute+=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute + #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_4 { \find (\modality{#allmodal}{.. #lhs0=#lhs1+=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 + #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_5_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]-=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] - #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_5_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute-=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute - #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_5 { \find (\modality{#allmodal}{.. #lhs0=#lhs1-=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 - #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_6_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]<<=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] << #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_6_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute<<=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute << #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_6 { \find (\modality{#allmodal}{.. #lhs0=#lhs1<<=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 << #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_7_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]>>=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] >> #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_7_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute>>=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute >> #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_7 { \find (\modality{#allmodal}{.. #lhs0=#lhs1>>=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 >> #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_8_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]>>>=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] >>> #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_8_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute>>>=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute >>> #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_8 { \find (\modality{#allmodal}{.. #lhs0=#lhs1>>>=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 >>> #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_9_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]&=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] & #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_9_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute&=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute & #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_9 { \find (\modality{#allmodal}{.. #lhs0=#lhs1&=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 & #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_10_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]|=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] | #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_10_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute|=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute | #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_10 { \find (\modality{#allmodal}{.. #lhs0=#lhs1|=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 | #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

  eval_order_iterated_assignments_11_0 { \find (\modality{#allmodal}{.. #lhs0=#e0[#e]^=#e1; ...}\endmodality(post)) 
 	\varcond (\new(#v0, \typeof(#e0)),
                  \new(#v1, \typeof(#e)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #typeof(#e) #v1=#e;  
                                              #v0[#v1]= (#typeof(#e0[#e]))(#v0[#v1] ^ #e1); 
                                              #lhs0=#v0[#v1];  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  eval_order_iterated_assignments_11_1 { \find (\modality{#allmodal}{.. #lhs0=#e0.#attribute^=#e; ...}\endmodality(post)) 
	\varcond(\new(#v0, \typeof(#e0))) 
        \replacewith (\modality{#allmodal}{.. #typeof(#e0) #v0=#e0; 
                                              #v0.#attribute = (#typeof(#attribute))(#v0.#attribute ^ #e);
                                              #lhs0=#v0.#attribute;  ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};


  iterated_assignments_11 { \find (\modality{#allmodal}{.. #lhs0=#lhs1^=#e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs1 = (#typeof(#lhs1))(#lhs1 ^ #e); #lhs0=#lhs1; ...}\endmodality(post)) 
	\heuristics (simplify_prog)
        \displayname "eval_order_iterated_assignments"};

//------------------------------------------------------------------------
// ------------ Rules for lazy evaluation
//------------------------------------------------------------------------

 evaluate_lazy_and { \find (\modality{#allmodal}{.. #b0 = #e1 && #e2; ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. if (!(#e1)) {#b0 = false;}  else {#b0 = #e2;} ...}\endmodality(post)) 
	\heuristics(simplify_prog)};

 evaluate_lazy_or { \find (\modality{#allmodal}{.. #b0 = #e1 || #e2; ...}\endmodality(post)) 
	\replacewith (\modality{#allmodal}{.. if (#e1) {#b0 = true;} else {#b0 = #e2;} ...}\endmodality(post)) 
	\heuristics(simplify_prog)};

//------------------------------------------------------------------------
// ----------- Rule for removing redundant braces
//------------------------------------------------------------------------

 elim_double_block { \find (\modality{#allmodal}{{ #slist }}\endmodality(post)) \replacewith (\modality{#allmodal}{ #slist }\endmodality(post)) };

 elim_double_block_2 { \find (\modality{#allmodal}{.. { { #slist } } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. { #slist } ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_3 { \find (\modality{#allmodal}{.. { while ( #e ) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. while ( #e ) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_4 { \find (\modality{#allmodal}{.. { for(#loopInit; #guard; #forupdates) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(#loopInit; #guard; #forupdates) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_5 { \find (\modality{#allmodal}{.. { for(; #guard; #forupdates) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(; #guard; #forupdates) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_6 { \find (\modality{#allmodal}{.. { for(#loopInit; #guard;) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(#loopInit; #guard;) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_7 { \find (\modality{#allmodal}{.. { for(; #guard;) #s } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. for(; #guard;) #s ...}\endmodality(post))
                       \displayname "elim_double_block" };

 elim_double_block_8 { \find (\modality{#allmodal}{.. { do #s while (#e); } ...}\endmodality(post))
                       \replacewith (\modality{#allmodal}{.. do #s while (#e); ...}\endmodality(post))
                       \displayname "elim_double_block" };


//------------------------------------------------------------------------
// ----------- Rule for removing redundant parentheses
//------------------------------------------------------------------------

  remove_parentheses_right  { \find (\modality{#allmodal}{.. #lhs = (#e); ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs = #e; ...}\endmodality(post)) \heuristics(simplify_prog)};

  remove_parentheses_attribute_left  { \find (\modality{#allmodal}{.. (#e.#attribute) = #e0; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #e.#attribute = #e0; ...}\endmodality(post)) \heuristics(simplify_prog)
	\displayname "remove_parentheses"
	};

  remove_parentheses_lhs_left  { \find (\modality{#allmodal}{.. (#lhs) = #e; ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs = #e; ...}\endmodality(post)) \heuristics(simplify_prog)
	\displayname "remove_parentheses"
	};

//------------------------------------------------------------------------ 
// ----------- Rules for binary arithmetic operators applied to at least one compound expression
//------------------------------------------------------------------------

   compound_multiplication_1 { \find (\modality{#allmodal}{.. #lhs=#nse * #se; ...}\endmodality(post))
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v * #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "multiplication"};

   compound_multiplication_2 { \find (\modality{#allmodal}{.. #lhs=#e * #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 * #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "multiplication"};

   compound_division_1 { \find (\modality{#allmodal}{.. #lhs=#nse / #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v / #se; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "division"};

   compound_division_2 { \find (\modality{#allmodal}{.. #lhs=#e / #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 / #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "division"};

   compound_modulo_1 { \find (\modality{#allmodal}{.. #lhs=#nse % #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v % #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "modulo"};

   compound_modulo_2 { \find (\modality{#allmodal}{.. #lhs=#e % #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 % #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "modulo"};

   compound_addition_1 { \find (\modality{#allmodal}{.. #lhs=#nse + #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v + #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "addition"};

   compound_addition_2 { \find (\modality{#allmodal}{.. #lhs=#e + #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 + #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "addition"};

   compound_binary_AND_1 { \find (\modality{#allmodal}{.. #lhs=#nse & #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v & #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_AND"};

   compound_binary_AND_2 { \find (\modality{#allmodal}{.. #lhs=#e & #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 & #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_AND"};

   compound_binary_OR_1 { \find (\modality{#allmodal}{.. #lhs=#nse | #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v | #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_OR"};

   compound_binary_OR_2 { \find (\modality{#allmodal}{.. #lhs=#e | #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 | #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_OR"};

   compound_binary_XOR_1 { \find (\modality{#allmodal}{.. #lhs=#nse ^ #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v ^ #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_XOR"};

   compound_binary_XOR_2 { \find (\modality{#allmodal}{.. #lhs=#e ^ #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 ^ #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "binary_XOR"};

   compound_invert_bits { \find (\modality{#allmodal}{.. #lhs=~#nse; ...}\endmodality(post)) 
         \varcond (\new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{..  #typeof(#nse) #v1=#nse; #lhs=~#v1 ; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "invert_bits"};

   compound_subtraction_1 { \find (\modality{#allmodal}{.. #lhs=#nse - #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v - #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "subtraction"};

   compound_subtraction_2 { \find (\modality{#allmodal}{.. #lhs=#e - #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 - #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "subtraction"};

   compound_shiftright_1 { \find (\modality{#allmodal}{.. #lhs=#nse >> #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >> #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_shiftright_2 { \find (\modality{#allmodal}{.. #lhs=#e >> #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >> #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_unsigned_shiftright_1 { \find (\modality{#allmodal}{.. #lhs=#nse >>> #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >>> #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_unsigned_shiftright_2 { \find (\modality{#allmodal}{.. #lhs=#e >>> #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >>> #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

  compound_shiftleft_1 { \find (\modality{#allmodal}{.. #lhs=#nse << #se; ...}\endmodality(post)) 
	\varcond (\new(#v, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v << #se; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "shift"};

  compound_shiftleft_2 { \find (\modality{#allmodal}{.. #lhs=#e << #nse; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 << #v1; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "shift"};

  compound_equality_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 == #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 == #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "equality"};

  compound_equality_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e == #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 == #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "equality"};

  compound_inequality_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 != #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 != #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "inequality"};

  compound_inequality_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e != #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 != #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "inequality"};

  compound_less_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 < #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 < #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_than"};

  compound_less_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e < #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 < #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_than"};

  compound_less_equal_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 <= #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 <= #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_or_equal"};

  compound_less_equal_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e <= #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 <= #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_or_equal"};

  compound_greater_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 > #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 > #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_than"};

  compound_greater_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e > #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 > #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_than"};

  compound_greater_equal_than_comparison_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 >= #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 >= #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_or_equal"};

  compound_greater_equal_than_comparison_2 { \find ( \modality{#allmodal}{.. #lhs = #e >= #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 >= #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_or_equal"};

//------------------------------------------------------------------------
//---------------------- Rules boolean expressions -----------------------
//------------------------------------------------------------------------


  compound_assignment_1 { \find (\modality{#allmodal}{.. #lhs=!#seBool; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. if (#seBool) #lhs=false; else #lhs=true; ...}\endmodality(post))
         \heuristics(simplify_expression)
         \displayname "compound_assignment"};  

  compound_assignment_2 { \find (\modality{#allmodal}{.. #lhs=!#nseBool; ...}\endmodality(post))
          \varcond (\new(#v, boolean))
          \replacewith (\modality{#allmodal}{.. boolean #v=#nseBool; #lhs=!#v; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_3 { \find (\modality{#allmodal}{.. #lhs=#exBool0 && #exBool1; ...}\endmodality(post)) 
          \replacewith (\modality{#allmodal}{.. if (!#exBool0) #lhs=false; else #lhs=#exBool1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_4 { \find (\modality{#allmodal}{.. #lhs=#exBool0 & #exBool1; ...}\endmodality(post))
          \replacewith (\modality{#allmodal}{.. #lhs=#exBool0; 
                            if (!#exBool1) #lhs=false; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

    compound_assignment_5 { \find (\modality{#allmodal}{.. #lhs=#exBool0 || #exBool1; ...}\endmodality(post)) 
          \replacewith (\modality{#allmodal}{.. if (#exBool0) #lhs=true; else #lhs=#exBool1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_6 { \find (\modality{#allmodal}{.. #lhs=#exBool0 | #exBool1; ...}\endmodality(post))
          \replacewith (\modality{#allmodal}{.. #lhs=#exBool0;
                            if (#exBool1) #lhs=true; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

//------------------------------------------------------------------------
// ----------- Rules for array and attribute expressions 
//------------------------------------------------------------------------

eval_order_array_access1 { 
		\find (\modality{#allmodal}{..#nv[#e]=#e0;...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#nv)) )
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
				#v0[#e]=#e0;
				 ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_array_access2 { 
		\find (\modality{#allmodal}{..#v[#nse]=#e;...}\endmodality(post))
		\varcond (\new(#ar1, \typeof(#v)), \new(#v0, \typeof(#nse)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v) #ar1 = #v;
				#typeof(#nse) #v0=#nse;
				#ar1[#v0]=#e;
					 ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_array_access3 { 
		\find (\modality{#allmodal}{..#v[#se]=#nse;...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)),
            		  \new(#v2, \typeof(#se)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v) #v0=#v;
				#typeof(#se) #v2=#se;
				if(#length-reference(#v)<=#se || #se<0 ) {
				      throw new java.lang.ArrayIndexOutOfBoundsException();
				}
				#typeof(#nse) #v1=#nse;
				#v0[#v2]=#v1; ...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentSaveLocation"};


eval_order_array_access4 { 
		\find (\modality{#allmodal}{..#v=#nv[#e];...}\endmodality(post))
		\varcond (\new(#v0, \typeof(#nv)))
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
				#v=#v0[#e];
					...}\endmodality(post)) 
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

eval_order_array_access5 { 
		\find (\modality{#allmodal}{..#v=#v0[#nse];...}\endmodality(post))
		\varcond (\new(#ar1, \typeof(#v0)), \new(#v1, \typeof(#nse)) )
		\replacewith(\modality{#allmodal}{..#typeof(#v0) #ar1 = #v0;
				#typeof(#nse) #v1=#nse;
				#v=#ar1[#v1];
					...}\endmodality(post))
	        \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

eval_order_array_access6 {
		\find (\modality{#allmodal}{..#v=#nv.#length; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#length; ...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

//-----------------------------------------------------------------------


eval_order_access1 {
		\find (\modality{#allmodal}{..#nv.#attribute=#e;...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v0.#attribute=#e;...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldLeft"};

eval_order_access2 { 
		\find (\modality{#allmodal}{.. #v=#nv.#attribute; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#nv))) 
		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#attribute;...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentUnfoldRight"};

}

\rules(programRules:Java,transactions:transactionsOn,javacard:jcOn) {

  default_value_transactionCounter { 
	\find ( #transactionCounterSV ) \inSequentState \replacewith ( 1 ) 
        \heuristics (simplify)
  };

  default_value_traInitialized {
        \find(#nv.#traInitializedSV[#se]@(G)) \inSequentState
	\varcond(\hasSort(#traInitializedSV, G))
        \replacewith(FALSE)
        \heuristics (simplify)
  };

}

\rules(programRules:Java, nullPointerPolicy:nullCheck){


eval_order_access4 {
		\find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
		\varcond(\new(#v0, \typeof(#v)), \new(#v1, \typeof(#nse)), 
         		\not \static(#a)) 
		\replacewith(\modality{#allmodal}{..if(#v==null){
				throw new java.lang.NullPointerException();
			    }
			    #typeof(#v) #v0=#v;
			    #typeof(#nse) #v1=#nse;
			    #v0.#a=#v1;...}\endmodality(post))
         	\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignmentSaveLocation"};


assignment_to_reference_array_component { 
                 \find (\modality{#normalassign}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({#v[#se]:=#se0} \modality{#normalassign}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normalassign}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normalassign}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#normalassign}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
};

assignment_to_primitive_array_component { 
                 \find (\modality{#wabase}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({#v[#se]:=#se0}\modality{#wabase}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#wabase}{..
			throw new java.lang.NullPointerException(); 
			...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#wabase}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
};

}

\rules(programRules:Java, nullPointerPolicy:nullCheck,
       transactions:transactionsOn, transactionAbort:abortOn, throughout:toutOn, javacard:jcOn){

// This rule is exactly the same as the one above, but for this
// modality has to be limited to abortOn cases (if abort is off this
// rule is not sound).

assignToutTRC { 
                 \find (\modality{throughout_trc}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({#v[#se]:=#se0}\modality{throughout_trc}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se,0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{throughout_trc}{..
			throw new java.lang.NullPointerException(); 
			...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{throughout_trc}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
		 \oldname "assignment_to_primitive_array_component_tout_trc"
};

}

\rules(programRules:Java, nullPointerPolicy:nullCheck){

		    
assignment_array2{\find (\modality{#normalassign}{.. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=#v0[#se]}\modality{#normalassign}{.. ...}\endmodality(post))
		   \add (==>(#v0=null) | leq(#lengthReference(#v0), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(\modality{#normalassign}{..
			throw new java.lang.NullPointerException();
			    ...}\endmodality(post))
	           \add (#v0=null ==>);	

		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(\modality{#normalassign}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(#lengthReference(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};



assignment_read_attribute { 
		\find (\modality{#normalassign}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
 	        \varcond(\not \static(#a))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 :=#v.#a}\modality{#normalassign}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#normalassign}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

assignment_write_attribute { 
		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a))
		"Normal Execution (#v != null)":
		      \replacewith({#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#normalassign}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};
    
}

\rules(programRules:Java, nullPointerPolicy:nullCheck,throughout:toutOn){

// Assignments for throughout

assignment_write_to_reference_array_tout {
	\find (\throughout{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond(\isReferenceArray(#v))
		"Normal Execution (#v != null)":
		   \replacewith(post & (post ->{#v[#se]:=#se0}\throughout{.. ...}\endmodality(post)))
		   \add (!(#v=null) & lt(#se, #lengthReference(#v)) & geq(#se, 0) & arrayStoreValid(#v, #se0) ==>);
		"Null Reference (#v = null)":
		   \replacewith(\throughout{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
      	           \add (#v=null ==>);
		"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		   \replacewith(\throughout{.. throw new java.lang.ArrayIndexOutOfBoundsException();...}\endmodality(post))
		   \add (!(#v=null) & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                   \replacewith(\throughout{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                   \add (!(#v=null) & lt(#se, #lengthReference(#v))& geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	\heuristics(simplify_prog, simplify_prog_subset)
	\displayname "assignment"
};

assignment_write_to_primitive_array_tout {
	\find (\throughout{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond(\not \isReferenceArray(#v))
  		"Normal Execution (#v != null)":
		   \replacewith(post & (post ->{#v[#se]:=#se0}\throughout{.. ...}\endmodality(post)))
		   \add (==>(#v=null) | leq(#lengthReference(#v), #se) | lt(#se,0));
		"Null Reference (#v = null)":
		   \replacewith(\throughout{..
			throw new java.lang.NullPointerException();
		    ...}\endmodality(post))
		      \add (#v=null ==>);
		"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		   \replacewith(\throughout{.. throw new java.lang.ArrayIndexOutOfBoundsException();...}\endmodality(post))
		   \add (!(#v=null) & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>)
         \heuristics(simplify_prog, simplify_prog_subset)
	 \displayname "assignment"
};

}

\rules(programRules:Java, nullPointerPolicy:nullCheck,throughout:toutOn,
       transactions:transactionsOn, transactionAbort:abortOn, javacard:jcOn){

assignment_write_to_primitive_array_tout_susp {
	\find (\throughout_susp{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond(\not \isReferenceArray(#v))
  		"Normal Execution Uninitialized Persistent (#v != null)":
		  \replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}(post &
                                                   \throughout_susp{.. ...}\endmodality(post)))
		   \add ( ==> gt(#transient(#shadowed(#v)),0) |
		   #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = TRUE | 
			 (#v=null) | leq(#lengthReference(#v), #se) | lt(#se,0));
  		"Normal Execution Uninitialized Transient (#v != null)":
		  \replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}
		     \throughout_susp{.. ...}\endmodality(post))
		   \add (==> #transient(#shadowed(#v)) = 0 | 
		         #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = TRUE | 
			 (#v=null) | leq(#lengthReference(#v), #se) | lt(#se,0));
  		"Normal Execution Initialized (#v != null)":
		   \replacewith({#shadowed(#v[#se]):=#shadowed(#se0)}\throughout_susp{.. ...}\endmodality(post))
		   \add (==> #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = FALSE | 
		        (#v=null) | leq(#lengthReference(#v), #se) | lt(#se,0));
		"Null Reference (#v = null)":
		   \replacewith(\throughout_susp{..
			throw new java.lang.NullPointerException();
		    ...}\endmodality(post))
		      \add (#v=null ==>);
		"Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		   \replacewith(\throughout_susp{.. throw new java.lang.ArrayIndexOutOfBoundsException();...}\endmodality(post))
		   \add (!(#v=null) & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>)
         \heuristics(simplify_prog, simplify_prog_subset)
	 \displayname "assignment"
};

}

\rules(programRules:Java, nullPointerPolicy:nullCheck,throughout:toutOn){
		    
assignment_read_array_tout{
	\find (\throughout{..#v= #v0[#se];...}\endmodality(post)) \sameUpdateLevel
		"Normal Execution (#v0 != null)":
		   \replacewith(post & (post-> {#v:=#v0[#se]}\throughout{.. ...}\endmodality(post)))
		   \add (==>(#v0=null) | leq(#lengthReference(#v0), #se) | lt(#se,0));  
		 "Null Reference (#v = null)":
		   \replacewith(\throughout{..
			throw new java.lang.NullPointerException();
		      ...}\endmodality(post))
		   \add (#v0=null ==>);
		 "Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
		   \replacewith(\throughout{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(#lengthReference(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_read_attribute_tout_explicit{\find (\throughout{..#v0=#v.#ea;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#ea))
		"Normal Execution (#v != null)":
		      \replacewith(post & (post -> {#v0 :=#v.#ea}\throughout{.. ...}\endmodality(post)))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\throughout{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add ((#v=null) ==>)
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

assignment_write_attribute_tout_explicit{\find (\throughout{..#v.#ea=#se;...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#ea))
		"Normal Execution (#v != null)":
		      \replacewith(post & (post -> {#v.#ea :=#se}\throughout{.. ...}\endmodality(post)))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\throughout{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add ((#v=null) ==>)
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

// xxx Why is there no check for "post" in the pre-state? Do we assume that we "throughout" does not
// talk about intermediate states during initialisation?
// Wojtek: it does not really matter, because the initialisation is done on a local
// variable which is then assigned to the real variable - the throughout
// property will never refer to the local variable _var??, so it does not
// matter if you check the condition in the intermadiate states or not.
// It only starts to matter when after the initialised local variable is
// bound to the real variable with "realvar = _var??;". Checking the
// condition during initialisation only makes the proof messier.
// Woj on the other hand it might be safer to include the prestate.

assignment_read_attribute_tout_implicit{
		\find (\throughout{..#v0= #v.#ia;...}\endmodality(post)) \sameUpdateLevel
  	        \varcond(\not \static(#ia))
		"Normal Execution (#v != null)":
		      \replacewith(post & (post -> {#v0 :=#v.#ia}\throughout{.. ...}\endmodality(post)))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\throughout{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add ((#v=null) ==>)
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

assignment_write_attribute_tout_implicit{
		\find (\throughout{..#v.#ia=#se;...}\endmodality(post)) \sameUpdateLevel
		\varcond(\not \static(#ia))
		"Normal Execution (#v != null)":
		      \replacewith(post & (post -> {#v.#ia :=#se}\throughout{.. ...}\endmodality(post)))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\throughout{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add ((#v=null) ==>)
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};
}

\rules(programRules:Java, nullPointerPolicy:nullCheck,
       transactions:transactionsOn, transactionAbort:abortOn,javacard:jcOn){

// rules for #traonly


assignment_write_to_reference_array_traonly{
	\find (\modality{#traonly}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond(\isReferenceArray(#v))
	    "normal persistent (#v != null)":
		 \replacewith({#shadowed(#v[#se]):=#shadowed(#se0)}\modality{#traonly}{.. ...}\endmodality(post)) 
		 \add ((!(#shadowed(#v)=null) & lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se))
                     & (#transient(#shadowed(#v)) = 0) & arrayStoreValid(#shadowed(#v), #shadowed(#se0)) ) ==> );
	    "normal transient (#v != null)":
		 \replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}\modality{#traonly}{.. ...}\endmodality(post))
		 \add (!(#shadowed(#v)=null) & lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se)) &
		    gt(#transient(#shadowed(#v)),0 )
		        & arrayStoreValid(#shadowed(#v), #shadowed(#se0)) ==>);
	    "Null Reference (#v = null)":
		 \replacewith(\modality{#traonly}{..
			throw new java.lang.NullPointerException();
		    ...}\endmodality(post))
		 \add ((#shadowed(#v)=null) ==>);
	    "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		 \replacewith(\modality{#traonly}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		 \add ((!(#shadowed(#v)=null) & (leq(#lengthReference(#shadowed(#v)), #shadowed(#se)) | lt(#shadowed(#se),0))) ==>);
            "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                 \replacewith(\modality{#traonly}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                 \add (!(#shadowed(#v)=null) & lt(#shadowed(#se), #lengthReference(#shadowed(#v))) & geq(#shadowed(#se),0) & !arrayStoreValid(#shadowed(#v), #shadowed(#se0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_write_to_primitve_array_traonly{
	\find (\modality{#watra}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	    \varcond(\not \isReferenceArray(#v))
	    "normal persistent (#v != null)":
		 \replacewith({#shadowed(#v[#se]):=#shadowed(#se0) ||            
                               #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) := TRUE}
		    \modality{#watra}{.. ...}\endmodality(post)) 
		 \add ((!(#shadowed(#v)=null) & lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se))
                     & (#transient(#shadowed(#v)) = 0) ) ==> );
	    "normal transient (#v != null)":
		 \replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}\modality{#watra}{.. ...}\endmodality(post))
		 \add ( !(#shadowed(#v)=null) & lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se)) &
		    gt(#transient(#shadowed(#v)),0)==>);
	    "Null Reference (#v = null)":
		 \replacewith(\modality{#watra}{..
			throw new java.lang.NullPointerException();
		    ...}\endmodality(post))
		 \add ((#shadowed(#v)=null) ==>);
	    "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		 \replacewith(\modality{#watra}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		 \add ((!(#shadowed(#v)=null) & (leq(#lengthReference(#shadowed(#v)), #shadowed(#se)) | 
		   lt(#shadowed(#se),0))) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_write_to_primitve_array_susp{
	\find (\modality{#wasusp}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	    \varcond(\not \isReferenceArray(#v))
	    "normal persistent/initialized (#v != null)":
		 \replacewith({#shadowed(#v[#se]):=#shadowed(#se0)}
		    \modality{#wasusp}{.. ...}\endmodality(post)) 
		 \add ((!(#shadowed(#v)=null) & lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se))
                     & (#transient(#shadowed(#v)) = 0) & 
		        #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = TRUE) ==> );
	    "normal transient/uninitialized (#v != null)":
		 \replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}\modality{#wasusp}{.. ...}\endmodality(post))
		 \add ( !(#shadowed(#v)=null) & lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se)) &
		    (gt(#transient(#shadowed(#v)),0) |                     
                     #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = FALSE)==>);
	    "Null Reference (#v = null)":
		 \replacewith(\modality{#wasusp}{..
			throw new java.lang.NullPointerException();
		    ...}\endmodality(post))
		 \add ((#shadowed(#v)=null) ==>);
	    "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		 \replacewith(\modality{#wasusp}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		 \add ((!(#shadowed(#v)=null) & (leq(#lengthReference(#shadowed(#v)), #shadowed(#se)) | 
		   lt(#shadowed(#se),0))) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};
		    
assignment_read_array_traonly{
	\find (\modality{#traonly}{..#v= #v0[#se];...}\endmodality(post)) \sameUpdateLevel
	    "normal persistent (#v0 != null)":
		 \replacewith({#shadowed(#v):=#shadowed(#v0[#se])}\modality{#traonly}{.. ...}\endmodality(post))
		 \add (( !(#shadowed(#v0)=null) & lt(#shadowed(#se),#lengthReference(#shadowed(#v0))) & 
		  lt(-1,#shadowed(#se)) & (#transient(#shadowed(#v0)) = 0)) ==>);
	    "normal transient (#v0 != null)":
		 \replacewith({#shadowed(#v):=#shadowed(#v0)[#shadowed(#se)]}\modality{#traonly}{.. ...}\endmodality(post))
		 \add ((!(#shadowed(#v0)=null) & lt(#shadowed(#se),#lengthReference(#shadowed(#v0))) & 
		   lt(-1,#shadowed(#se)) & gt(#transient(#shadowed(#v0)) ,0)) ==>);  
	    "Null Reference (#v0 = null)":
		 \replacewith(\modality{#traonly}{..
			throw new java.lang.NullPointerException();
		    ...}\endmodality(post))
		 \add ((#shadowed(#v0)=null) ==>);
	    "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
		 \replacewith(\modality{#traonly}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		 \add ((!(#shadowed(#v0)=null) & (leq(#lengthReference(#shadowed(#v0)), #shadowed(#se)) | 
		   lt(#shadowed(#se),0))) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_read_attribute_traonly{
	\find (\modality{#traonly}{..#v0= #v.#a;...}\endmodality(post)) \sameUpdateLevel
	 \varcond(\not \static(#a))
		"Normal Execution (#v != null)":
		      \replacewith({#shadowed(#v0) := #shadowed(#v.#a)}\modality{#traonly}{.. ...}\endmodality(post))
		      \add (==> (#shadowed(#v)=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#traonly}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add ((#shadowed(#v)=null) ==>)
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

assignment_write_attribute_traonly{
	\find (\modality{#traonly}{..#v.#a=#se;...}\endmodality(post)) \sameUpdateLevel
        \varcond(\not \static(#a))
		"Normal Execution (#v != null)":
		      \replacewith({#shadowed(#v.#a) := #shadowed(#se)}\modality{#traonly}{.. ...}\endmodality(post))
		      \add (==> (#shadowed(#v)=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#traonly}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add ((#shadowed(#v)=null) ==>)
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

}

\rules(programRules:Java, nullPointerPolicy:noNullCheck){

eval_order_access3{
		\find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
		\varcond(\not \static(#a), \new(#v0, \typeof(#v)), 
      		         \new(#v1, \typeof(#nse))) 
		\replacewith(\modality{#allmodal}{..
			   #typeof(#v) #v0=#v;
			   #typeof(#nse) #v1=#nse;
			   #v0.#a=#v1;...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "eval_order_access"};



assignment_write_to_reference_array {
	\find (\modality{#normalassign}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond( \isReferenceArray(#v))
		 "Normal Execution":
			\replacewith({#v[#se]:=#se0}\modality{#normalassign}{.. ...}\endmodality(post)) 
			\add ( arrayStoreValid(#v, #se0) & lt(#se,#lengthReference(#v)) & lt(-1,#se) ==>);
		 "Index Out of Bounds (#se Out of Bounds!)":
			\replacewith(\modality{#normalassign}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
	                \add ((leq(#lengthReference(#v), #se) | lt(#se,0)) ==>);
		"Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#normalassign}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (lt(#se, #lengthReference(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)	    
	    	\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment"};


assignment_write_to_primitive_array {
	\find (\modality{#wabase}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond( \not \isReferenceArray(#v))
		 "Normal Execution":
			\replacewith({#v[#se]:=#se0}\modality{#wabase}{.. ...}\endmodality(post)) 
			\add ( lt(#se,#lengthReference(#v)) & lt(-1,#se) ==>);
		 "Index Out of Bounds (#se Out of Bounds!)":
			\replacewith(\modality{#wabase}{..
			    throw new java.lang.ArrayIndexOutOfBoundsException();
		          ...}\endmodality(post))
	         \add ((leq(#lengthReference(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
};

}

\rules(programRules:Java, nullPointerPolicy:noNullCheck,
       throughout:toutOn, transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn){

// This rule is exactly the same as the one above, but for this
// modality has to be limited to abortOn cases (if abort is off this
// rule is not sound).

assignment_write_to_primitive_array_tout_trc {
	\find (\modality{throughout_trc}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond( \not \isReferenceArray(#v))
		 "Normal Execution":
			\replacewith({#v[#se]:=#se0}\modality{throughout_trc}{.. ...}\endmodality(post)) 
			\add ( lt(#se,#lengthReference(#v)) & lt(-1,#se) ==>);
		 "Index Out of Bounds (#se Out of Bounds!)":
			\replacewith(\modality{throughout_trc}{..
			    throw new java.lang.ArrayIndexOutOfBoundsException();
		          ...}\endmodality(post))
	         \add ((leq(#lengthReference(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"
};

}

\rules(programRules:Java, nullPointerPolicy:noNullCheck){
		    
assignment_read_array_component{
	\find (\modality{#normalassign}{..#v = #v0[#se];...}\endmodality(post)) \sameUpdateLevel
		"Normal Execution":
		   \replacewith({#v:=#v0[#se]}\modality{#normalassign}{.. ...}\endmodality(post))
		   \add (( lt(#se,#lengthReference(#v0)) & lt(-1,#se)) ==>); 
		"Index Out of Bounds (#se Out of Bounds!)":
	  	   \replacewith(\modality{#normalassign}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add ((!(#v0=null) & (leq(#lengthReference(#v0), #se) | lt(#se,0))) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};



assignment_read_attribute{
		\find (\modality{#normalassign}{..#v0 = #v.#a;...}\endmodality(post))
		\varcond(\not \static(#a))
		"Normal Execution (value assigned to #v0)":
		      \replacewith( {#v0 := #v.#a}\modality{#normalassign}{.. ...}\endmodality(post))
		 \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment"};

assignment_write_attribute {
		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post))
	        \varcond(\not \static(#a))
		"Normal Execution (assign value from #se)":
		      \replacewith( {#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
		\heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment"
};

}

\rules(programRules:Java, nullPointerPolicy:noNullCheck,throughout:toutOn){

// Assignments for throughout

assignment_write_to_reference_array_tout { 
		\find (\throughout{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isReferenceArray(#v))
		"Normal Execution":
		   \replacewith(post & (post -> {#v[#se]:=#se0}\throughout{.. ...}\endmodality(post)))
		   \add (lt(#se,#lengthReference(#v)) & lt(-1,#se) & arrayStoreValid(#v, #se0) ==>);
		"Index Out of Bounds (#se Out of Bounds!)":
		   \replacewith(\throughout{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add ((#v!=null & (leq(#lengthReference(#v), #se) | lt(#se,0))) ==>);
		"Array Store Exception (incompatible dynamic element type of #v and #se0)":
                   \replacewith(\throughout{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                   \add (lt(#se, #lengthReference(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_write_to_primitive_array_tout { 
		\find (\throughout{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		\varcond(\not\isReferenceArray(#v))
		"Normal Execution":
		   \replacewith(post & (post -> {#v[#se]:=#se0}\throughout{.. ...}\endmodality(post)))
		   \add (lt(#se,#lengthReference(#v)) & lt(-1,#se) ==>);
		"Index Out of Bounds (#se Out of Bounds!)":
		   \replacewith(\throughout{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add(#v != null & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};
}

\rules(programRules:Java, nullPointerPolicy:noNullCheck,throughout:toutOn,
       transactions:transactionsOn, transactionAbort:abortOn,javacard:jcOn){

  assignment_write_to_primitive_array_tout_susp { 
		\find (\throughout_susp{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		\varcond(\not\isReferenceArray(#v))
		"Normal Execution Uninitialized Persistent":
                    \replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}(post &
                                              \throughout_susp{.. ...}\endmodality(post)))
                   \add(#traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = FALSE &
                        lt(#se,#lengthReference(#v)) & lt(-1,#se) &
			#transient(#shadowed(#v)) = 0 ==>);
		"Normal Execution Uninitialized Transient":
                    \replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}
                          \throughout_susp{.. ...}\endmodality(post))
                   \add(#traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = FALSE &
                        lt(#se,#lengthReference(#v)) & lt(-1,#se) &
			gt(#transient(#shadowed(#v)),0) ==>);
		"Normal Execution Initialized":
		   \replacewith({#shadowed(#v[#se]):=#shadowed(#se0)}\throughout_susp{.. ...}\endmodality(post))
		    \add(#traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = TRUE &
		         lt(#se,#lengthReference(#v)) & lt(-1,#se) ==>);
		"Index Out of Bounds (#se Out of Bounds!)":
		   \replacewith(\throughout_susp{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (#v!=null & (leq(#lengthReference(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};


}

\rules(programRules:Java, nullPointerPolicy:noNullCheck,throughout:toutOn){

assignment_read_array_tout{\find (\throughout{..#v= #v0[#se];...}\endmodality(post)) \sameUpdateLevel
		"Normal Execution":
		   \replacewith(post & (post -> {#v:=#v0[#se]}\throughout{.. ...}\endmodality(post)))
 		   \add (( lt(#se,#lengthReference(#v0)) & lt(-1,#se)) ==>);
		 "Index Out of Bounds (#se Out of Bounds!)":
		   \replacewith(\throughout{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (#v0!=null & (leq(#lengthReference(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_read_attribute_tout_explicit{\find (\throughout{..#v0=#v.#ea;...}\endmodality(post))
		\varcond(\not \static(#ea))
		"Normal Execution (assign value to #v0 )":
		      \replacewith( post & (post -> {#v0 := #v.#ea}\throughout{.. ...}\endmodality(post)))
	        \heuristics(simplify_prog, simplify_prog_subset)
 		\displayname "assignment"};

assignment_write_attribute_tout_explicit{\find (\throughout{..#v.#ea=#se;...}\endmodality(post))
		\varcond(\not \static(#ea))
		"Normal Execution (assign value from #se )":
		      \replacewith( post & (post -> {#v.#ea := #se}\throughout{.. ...}\endmodality(post)))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

assignment_read_attribute_tout_implicit{
		\find (\throughout{..#v0= #v.#ia;...}\endmodality(post))
		\varcond(\not \static(#ia))
		"Normal Execution (assign value to #v0 )":
		      \replacewith(post & (post -> {#v0 := #v.#ia}\throughout{.. ...}\endmodality(post)))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

assignment_write_attribute_tout_implicit{
		\find (\throughout{..#v.#ia=#se;...}\endmodality(post))
		\varcond(\not \static(#ia))
		"Normal Execution (assign value from #se )":
		      \replacewith( post & (post -> {#v.#ia := #se}\throughout{.. ...}\endmodality(post)))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

}

\rules(programRules:Java, nullPointerPolicy:noNullCheck,
       transactions:transactionsOn, transactionAbort:abortOn,javacard:jcOn){

// rules for #traonly

assignment_write_to_reference_array_traonly{
	\find (\modality{#traonly}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond(\isReferenceArray(#v))
	    "normal persistent":
	 	\replacewith( {#shadowed(#v[#se]):=#shadowed(#se0)}\modality{#traonly}{.. ...}\endmodality(post)) 
		\add (( lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se))
                     & (#transient(#shadowed(#v)) = 0) & arrayStoreValid(#shadowed(#v), #shadowed(#se0))) ==>);
	    "normal transient":
		\replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}\modality{#traonly}{.. ...}\endmodality(post)) 
		\add (lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se)) & 
		    gt(#transient(#shadowed(#v)),0) & arrayStoreValid(#shadowed(#v), #shadowed(#se0)) ==> );
	    "Index Out of Bounds (#se Out of Bounds!)":
		\replacewith(\modality{#traonly}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		\add ((!(#shadowed(#v)=null) & (leq(#lengthReference(#shadowed(#v)), #shadowed(#se)) | lt(#shadowed(#se),0))) ==>);
            "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                \replacewith(\modality{#traonly}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                \add (lt(#shadowed(#se), #lengthReference(#shadowed(#v))) & geq(#shadowed(#se),0) &
		       !arrayStoreValid(#shadowed(#v), #shadowed(#se0)) ==>)
             \heuristics(simplify_prog, simplify_prog_subset)
	     \displayname "assignment"
};

assignment_write_to_primitive_array_traonly{
	\find (\modality{#watra}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond(\not \isReferenceArray(#v))
	    "normal persistent":
	 	\replacewith( {#shadowed(#v[#se]):=#shadowed(#se0) ||
		               #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) := TRUE}
			       \modality{#watra}{.. ...}\endmodality(post)) 
		\add (( lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se))
                     & (#transient(#shadowed(#v)) = 0) ) ==>);
	    "normal transient":
		\replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}\modality{#watra}{.. ...}\endmodality(post)) 
		\add (lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se)) & 
		  gt(#transient(#shadowed(#v)),0) ==> );
	    "Index Out of Bounds (#se Out of Bounds!)":
		\replacewith(\modality{#watra}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
	        \add ((!(#shadowed(#v)=null) & (leq(#lengthReference(#shadowed(#v)), #shadowed(#se)) | lt(#shadowed(#se),0))) ==>)
             \heuristics(simplify_prog, simplify_prog_subset)
	     \displayname "assignment"
};

assignment_write_to_primitive_array_susp{
	\find (\modality{#wasusp}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
	\varcond(\not \isReferenceArray(#v))
	    "normal persistent/initialized":
	 	\replacewith( {#shadowed(#v[#se]):=#shadowed(#se0)}
			       \modality{#wasusp}{.. ...}\endmodality(post)) 
		\add (( lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se))
                     & (#transient(#shadowed(#v)) = 0) & 
		       #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = TRUE) ==>);
	    "normal transient/uninitialized":
		\replacewith({#shadowed(#v)[#shadowed(#se)]:=#shadowed(#se0)}\modality{#wasusp}{.. ...}\endmodality(post)) 
		\add (lt(#shadowed(#se),#lengthReference(#shadowed(#v))) & lt(-1,#shadowed(#se)) & 
		  (gt(#transient(#shadowed(#v)),0) | 		      
                   #traInitialized(#shadowed(#v))[#shadowed(#se)]^(#transactionCounter) = FALSE)==> );
	    "Index Out of Bounds (#se Out of Bounds!)":
		\replacewith(\modality{#wasusp}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
	        \add ((!(#shadowed(#v)=null) & (leq(#lengthReference(#shadowed(#v)), #shadowed(#se)) | lt(#shadowed(#se),0))) ==>)
             \heuristics(simplify_prog, simplify_prog_subset)
	     \displayname "assignment"
};
		    
assignment_read_array_traonly{\find (\modality{#traonly}{..#v= #v0[#se];...}\endmodality(post)) \sameUpdateLevel
	    "normal persistent":
		 \replacewith({#shadowed(#v):=#shadowed(#v0[#se])}\modality{#traonly}{.. ...}\endmodality(post))
		 \add (( lt(#shadowed(#se),#lengthReference(#shadowed(#v0))) & lt(-1,#shadowed(#se)) & 
		   (#transient(#shadowed(#v0)) = 0)) ==>) ;  
	    "normal transient":
		 \replacewith({#shadowed(#v):= #shadowed(#v0)[#shadowed(#se)]}\modality{#traonly}{.. ...}\endmodality(post))
		 \add (( lt(#shadowed(#se),#lengthReference(#shadowed(#v0))) & lt(-1,#shadowed(#se)) &
		  gt(#transient(#shadowed(#v0)) ,0)) ==>);  
	    "Index Out of Bounds":
		 \replacewith(\modality{#traonly}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		 \add ((!(#shadowed(#v0)=null) & (leq(#lengthReference(#shadowed(#v0)), #shadowed(#se)) | lt(#shadowed(#se),0))) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
		 \displayname "assignment"};

assignment_read_attribute_traonly{\find (\modality{#traonly}{..#v0= #v.#a;...}\endmodality(post))
		\varcond(\not \static(#a))
		"Normal Execution":
		      \replacewith( {#shadowed(#v0) := #shadowed(#v.#a)}\modality{#traonly}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"};

assignTRAObject {
      \find (\modality{#traonly}{.. #v.#a=#se; ...}\endmodality(post))
      \varcond(\not \static(#a))
      "Normal Execution":
	  \replacewith( {#shadowed(#v.#a) := #shadowed(#se)}\modality{#traonly}{.. ...}\endmodality(post))
      \heuristics(simplify_prog, simplify_prog_subset)
      \displayname "assignment"
      \oldname "assignment_write_attribute_traonly"};
}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {

emptyTRAModality {
  \find (\modality{#tramodal}{}\endmodality(post))
  \replacewith(post)
  \heuristics(simplify_prog)
  \displayname "emptyTransactionAbortModality"
  \oldname "empty_modality_tra"
};

emptyTRCModality {
  \find (\modality{#trcmodal}{}\endmodality(post))
  \replacewith(true)
  \heuristics(simplify_prog)
  \displayname "emptyTransactionCommitModality"
  \oldname "empty_modality_trc"
};

//------------------------------------------------------------------------
//------------ Rules for Java Card transactions (enter/leave)
//------------ Accounts for the possibility of an abort
//------------------------------------------------------------------------

// DIAMOND

beginTransactionDia {
    \find (==> \diamond{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trb(); ...}\endmodality(post))
  "Aborted":
    \replacewith(==> 
	\diamond_tra{.. ...}\endmodality(post));
  "Commited":
    \replacewith(==>  
	  \diamond_trc{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "beginTransaction"
    \oldname "dia_transaction_begin"
};

commitTransExpDia {
    \find (\diamond_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \replacewith({#transactionCounter:=#transactionCounter + 1}\diamond{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "commitTransExp"
    \oldname "dia_transaction_commit1"
};

commitTransUnexpDia {
    \find (==> \diamond_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \closegoal
    \heuristics(simplify_prog)
    \displayname "commitTransUnexp"
    \oldname "dia_transaction_commit2"
};

abortTransExpDia {
    \find (\diamond_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#tra(); ...}\endmodality(post))
    \replacewith({#transactionCounter:=#transactionCounter + 1}\diamond{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "abortTransExp"
    \oldname "dia_transaction_abort1"
};

abortTransUnexpDia {
    \find (==> \diamond_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#tra(); ...}\endmodality(post))
    \closegoal
    \heuristics(simplify_prog)
    \displayname "abortTransUnexp"
    \oldname "dia_transaction_abort2"
};

// BOX

beginTransactionBox {
    \find (==> \box{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trb(); ...}\endmodality(post))
  "Aborted":  
    \replacewith(==> \box_tra{.. ...}\endmodality(post));
  "Commited":
    \replacewith(==> \box_trc{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "beginTransaction"
    \oldname "box_transaction_begin"
};

commitTransExpBox {
    \find (\box_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \replacewith({#transactionCounter:=#transactionCounter + 1} \box{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "commitTransExp"
    \oldname "box_transaction_commit1"
};

commitTransUnexpBox {
    \find (==> \box_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \closegoal
    \heuristics(simplify_prog)
    \displayname "commitTransUnexp"
    \oldname "box_transaction_commit2"
};

abortTransExpBox {
    \find (\box_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#tra(); ...}\endmodality(post))
    \replacewith({#transactionCounter:=#transactionCounter + 1} \box{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "abortTransExp"
    \oldname "box_transaction_abort1"
};

abortTransUnexpBox {
    \find (==> \box_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#tra(); ...}\endmodality(post))
    \closegoal
    \heuristics(simplify_prog)
    \displayname "abortTransUnexp"
    \oldname "box_transaction_abort2"
};

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn,
       throughout:toutOn) {

// THROUGHOUT

beginTransactionTout {
    \find (==> \throughout{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trb(); ...}\endmodality(post))
  "Pre-State":
    \replacewith(==> post);
  "Will Abort":
    \replacewith(==> \throughout_tra{.. ...}\endmodality(post));
  "Will Commit":
    \replacewith(==> \throughout_trc{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "beginTransaction"
    \oldname "tout_transaction_begin"
};

commitTransExpTout {
    \find (\throughout_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \replacewith({#transactionCounter:=#transactionCounter + 1} \throughout{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "commitTransExp"
    \oldname "tout_transaction_commit1"
};

commitTransUnexpTout {
    \find (==> \throughout_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \closegoal
    \heuristics(simplify_prog)
    \displayname "commitTransUnexp"
    \oldname "tout_transaction_commit2"
};

abortTransExpTout {
    \find (\throughout_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#tra(); ...}\endmodality(post))
    \replacewith({#transactionCounter:=#transactionCounter + 1}\throughout{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "abortTransExp"
    \oldname "tout_transaction_abort1"
};

abortTransUnexpTout {
    \find (==> \throughout_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#tra(); ...}\endmodality(post))
    \closegoal
    \heuristics(simplify_prog)
    \displayname "abortTransUnexp"
    \oldname "tout_transaction_abort2"
};

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {


suspendTrans {
    \find (\modality{#ignoresusp}{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trsuspend(); ...}\endmodality(post))
    \replacewith(\modality{#ignoresusp}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \oldname "transaction_suspend_ignore"
};

resumeTrans {
    \find (\modality{#ignoresusp}{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trresume(); ...}\endmodality(post))
    \replacewith(\modality{#ignoresusp}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \oldname "transaction_resume_ignore"
};

suspendTransTRADia {
    \find (\diamond_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trsuspend(); ...}\endmodality(post))
    \replacewith(\diamond_susp{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "suspendTransTRA"
    \oldname "diamond_transaction_suspend"
};

resumeTransTRADia {
    \find (\diamond_susp{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trresume(); ...}\endmodality(post))
    \replacewith(\diamond_tra{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "resumeTransTRA"
    \oldname "diamond_transaction_resume"
};

suspendTransTRABox {
    \find (\box_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trsuspend(); ...}\endmodality(post))
    \replacewith(\box_susp{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "suspendTransTRA"
    \oldname "box_transaction_suspend"
};

resumeTransTRABox {
    \find (\box_susp{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trresume(); ...}\endmodality(post))
    \replacewith(\box_tra{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "resumeTransTRA"
    \oldname "box_transaction_resume"
};

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn,
       throughout:toutOn) {

suspendTransTRATout {
    \find (\throughout_tra{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trsuspend(); ...}\endmodality(post))
    \replacewith(\throughout_susp{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "suspendTransTRA"
    \oldname "throughout_transaction_suspend_tra"
};

resumeTransTRATout {
    \find (\throughout_susp{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trresume(); ...}\endmodality(post))
    \replacewith(\throughout_tra{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "resumeTransTRA"
    \oldname "throughout_transaction_resume_tra"
};

}

\rules(programRules:Java,transactions:transactionsOn,transactionAbort:abortOff,javacard:jcOn) {

//------------------------------------------------------------------------
//------------ Rules for Java Card transactions (enter/leave)
//------------ The possibility of an abort is not considered
//------------ In case there is an abort the proof will not be closable
//------------------------------------------------------------------------

// DIAMOND

beginTransactionDia {
    \find (==> \diamond{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trb(); ...}\endmodality(post))
  "Commited":
    \replacewith(==> \diamond_trc{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "beginTransaction"
    \oldname "dia_transaction_begin"
};

commitTransExpDia {
    \find (\diamond_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \replacewith({#transactionCounter:=#transactionCounter + 1} \diamond{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "commitTransExp"
    \oldname "dia_transaction_commit1"
};

// BOX

beginTransactionBox {
    \find (==> \box{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trb(); ...}\endmodality(post))
  "Commited":
    \replacewith(==> \box_trc{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "beginTransaction"
    \oldname "box_transaction_begin"
};

commitTransExpBox {
    \find (\box_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \replacewith( {#transactionCounter:=#transactionCounter + 1} \box{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "commitTransExp"
    \oldname "box_transaction_commit1"
};

}

\rules(programRules:Java,transactions:transactionsOn,javacard:jcOn,
       transactionAbort:abortOff,throughout:toutOn) {

// THROUGHOUT

beginTransactionTout {
    \find (==> \throughout{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trb(); ...}\endmodality(post))
  "Pre-State":
    \replacewith(==> post);
  "Will Commit":
    \replacewith(==> \throughout_trc{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "beginTransaction"
    \oldname "tout_transaction_begin"
};

commitTransExpTout {
    \find (\throughout_trc{.. de.uka.ilkd.key.javacard.KeYJCSystem()::de.uka.ilkd.key.javacard.KeYJCSystem.#trc(); ...}\endmodality(post))
    \replacewith({#transactionCounter:=#transactionCounter + 1}\throughout{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
    \displayname "commitTransExp"
    \oldname "tout_transaction_commit1"
};

}

\rules(programRules:Java) {

//------------------------------------------------------------------------
// ----------- Rules for modal tautologies
//------------------------------------------------------------------------

box_true{ \find (\[{.. #s ...}\]true)
	  \replacewith(true)
	  \heuristics(modal_tautology)};

tout_true{ \find (\throughout{.. #s ...}\endmodality(true))
	  \replacewith(true)
	  \heuristics(modal_tautology)};

diamond_false{ \find (\<{.. #s ...}\>false)
	       \replacewith(false)
	       \heuristics(modal_tautology)};

diamond_and_left{\find (\<{.. #s ...}\>(post & post1)==>)
		 \replacewith(\<{.. #s ...}\>post & \<{.. #s ...}\>post1==>)};

box_and_left{\find (\[{.. #s ...}\](post & post1) ==>)
		 \replacewith(\[{.. #s ...}\]post & \[{.. #s ...}\]post1==>)};

diamond_and_right{\find (==> \<{.. #s ...}\>(post & post1))
		 \replacewith(==> \<{.. #s ...}\>post);
		 \replacewith(==> \<{.. #s ...}\>post1)};

box_and_right{\find (==> \[{.. #s ...}\](post & post1))
		 \replacewith(==> \[{.. #s ...}\]post);  
		 \replacewith(==> \[{.. #s ...}\]post1)};

diamond_or_right{\find (==> \<{.. #s ...}\>(post | post1))
		 \replacewith(==> \<{.. #s ...}\>post | \<{.. #s ...}\>post1)};

box_or_right{\find (==> \[{.. #s ...}\](post | post1))
	     \replacewith(==> \[{.. #s ...}\]post | \[{.. #s ...}\]post1)};

diamond_or_left{\find (\<{.. #s ...}\>(post | post1)==>)
		 \replacewith(\<{.. #s ...}\>post | \<{.. #s ...}\>post1==>)};

box_or_left{\find (\[{.. #s ...}\](post | post1)==>)
	     \replacewith(\[{.. #s ...}\]post | \[{.. #s ...}\]post1==>)};

/////////////////////////////////////////////////////////////////
// for taclet proof obligations

box_imp_left{\find (\[{.. #s ...}\](post -> post1)==>)
	     \replacewith(\<{.. #s ...}\>post -> \[{.. #s ...}\]post1==>)};

diamond_imp_left{\find (\<{.. #s ...}\>(post -> post1)==>)
	     \replacewith(\[{.. #s ...}\]post -> \<{.. #s ...}\>post1==>)};

box_imp_right{\find (==>\[{.. #s ...}\](post -> post1))
	     \replacewith(==>\<{.. #s ...}\>post -> \[{.. #s ...}\]post1)};

diamond_imp_right{\find (==>\<{.. #s ...}\>(post -> post1))
	     \replacewith(==>\[{.. #s ...}\]post -> \<{.. #s ...}\>post1)};

/////////////////////////////////////////////////////////////////

same_diamonds_right{ \assumes (==>\<{#s}\>post) 
		    \find (==> \<{#s}\>post1)
		    \add (==> \<{#s}\>(post | post1))};

same_diamonds_left{ \assumes (\<{.. #s ...}\>post ==>)
		    \find (\<{.. #s ...}\>post1 ==>)
		    \add (\<{.. #s ...}\>(post & post1) ==>)};

same_boxes_right{ \assumes (==>\[{.. #s ...}\]post)
		    \find (==> \[{.. #s ...}\]post1)
		    \add (==> \[{.. #s ...}\](post | post1))};

same_boxes_left{ \assumes (\[{.. #s ...}\]post ==>)
		    \find (\[{.. #s ...}\]post1 ==>)
		    \add (\[{.. #s ...}\](post & post1) ==>)};

boxToDiamond{\find (\[{.. #s ...}\]post)
	    \replacewith(!\<{.. #s ...}\>!post)
            \heuristics(boxDiamondConv)
	    \oldname "box2diamond"};


diamondToBox{\find (\<{.. #s ...}\>post)
	    \replacewith(!\[{.. #s ...}\]!post)
            \heuristics(boxDiamondConv)
	    \oldname "diamond2box"};

diamond_split_termination{\find (\<{.. #s ...}\>post)
	    \replacewith(\[{.. #s ...}\]post & \<{.. #s ...}\>true )};


}

\rules(programRules:Java,javacard:jcOn) {
  
  // Helper rules for jvmMakeShort and jvmSetShort
 
 jvmSetShort1_intro {
   \schemaVar \term jbyte #byte1, #byte2;
   \find(jvmMakeShort(#byte1, #byte2))\sameUpdateLevel
   \add(jvmSetShort1(jvmMakeShort(#byte1, #byte2)) = moduloByte(#byte1) ==>)
   \displayname "jvmSetShort1 intro"
 };

 jvmSetShort2_intro {
   \schemaVar \term jbyte #byte1, #byte2;
   \find(jvmMakeShort(#byte1, #byte2))\sameUpdateLevel
   \add(jvmSetShort2(jvmMakeShort(#byte1, #byte2)) = moduloByte(#byte2) ==>)
   \displayname "jvmSetShort2 intro"
 };

 jvmMakeShort_intro {
   \schemaVar \term jshort #sval;
   \schemaVar \term jbyte #byte1, #byte2;
   \assumes(jvmSetShort1(#sval) = #byte1, jvmSetShort2(#sval) = #byte2 ==>)
   \find(#sval) \sameUpdateLevel
   \add(jvmMakeShort(#byte1, #byte2) = moduloShort(#sval) ==>)
   \displayname "jvmMakeShort intro"
   \heuristics(simplify)
 };

 jvmMakeShort_simplify1 {
   \schemaVar \term jshort #sval;
   \schemaVar \term jbyte #byte1, #byte2;
   \assumes(jvmSetShort1(#sval) = #byte1, jvmSetShort2(#sval) = #byte2 ==>)
   \find(jvmMakeShort(#byte1, #byte2))\sameUpdateLevel
   \replacewith(moduloShort(#sval))
   \displayname "jvmMakeShort simplify"
   \heuristics(simplify)
 };

 jvmMakeShort_simplify2 {
   \schemaVar \term jshort #sval;
   \find(jvmMakeShort(jvmSetShort1(#sval), jvmSetShort2(#sval)))
   \replacewith(moduloShort(#sval))
   \displayname "jvmMakeShort simplify"
   \heuristics(simplify)
 };

 // The actual arithmetic definitions:
 
 jvmSetShort1_def {
   \schemaVar \term jshort #sval;
   \find(jvmSetShort1(#sval))
   \replacewith(moduloByte(#sval / 256))
   \displayname "jvmSetShort1"
 };

 jvmSetShort2_def {
   \schemaVar \term jshort #sval;
   \find(jvmSetShort2(#sval))
   \replacewith(moduloByte(#sval))
   \displayname "jvmSetShort2"
 };

 jvmMakeShort_def {
   \schemaVar \term jbyte #byte1, #byte2;
   \find(jvmMakeShort(#byte1, #byte2))
   \replacewith(moduloByte(#byte1) * 256 + (#byte2 % 256))
   \displayname "jvmMakeShort"
 };

}

\rules(programRules:Java) {
  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any acception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes 
  assignment_write_static_attribute {
	\find (\modality{#normalassign}{.. @(#sv) = #se; ...}\endmodality(post))
	\replacewith({#sv := #se} \modality{#normalassign}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };

}

\rules(programRules:Java, throughout:toutOn) {

  assignment_write_explicit_static_attribute_tout_explicit { 
	\find (\throughout{..@(#ea)=#se;...}\endmodality(post))
	\varcond(\static(#ea))
	\replacewith(post & (post -> {#ea := #se}\throughout{.. ...}\endmodality(post)))
        \heuristics(simplify_prog, simplify_prog_subset)
	\displayname "assignment"
  };

  assignment_write_implicit_static_attribute_tout {
	\find (\throughout{.. @(#ia)=#se; ...}\endmodality(post))
	\varcond(\static(#ia))
	\replacewith(post & (post -> {#ia := #se}\throughout{.. ...}\endmodality(post)))
        \heuristics(simplify_prog, simplify_prog_subset)
	\displayname "assignment"
  };

}

\rules(programRules:Java, transactions:transactionsOn,transactionAbort:abortOn,javacard:jcOn) {

  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any acception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes 
  assignment_write_static_attribute_traonly { 
	\find (\modality{#traonly}{.. @(#sv) = #se; ...}\endmodality(post)) 
	\replacewith ({#shadowed(#sv):= #shadowed(#se)}\modality{#traonly}{.. ...}\endmodality(post)) 
	\heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };

  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any acception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes 
  assignment_read_static_attribute_traonly { 
	\find (\modality{#traonly}{.. #loc = @(#sv); ...}\endmodality(post)) 
	\replacewith ({#shadowed(#loc):= #shadowed(#sv)}\modality{#traonly}{.. ...}\endmodality(post)) 
	\heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };

  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any acception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes 
  assignment_read_static_attribute_tout {
	\find (\throughout{..#v0= @(#sv);...}\endmodality(post))
	\replacewith(post & (post -> {#v0 := #sv}\throughout{.. ...}\endmodality(post)))
        \heuristics(simplify_prog, simplify_prog_subset)
	\displayname "assignment"};

  assignment_read_static_explicit_attribute_tout {
	\find (\throughout{..#v0= @(#ea);...}\endmodality(post))
        \varcond(\static(#ea))
	\replacewith(post & (post -> {#v0 := #ea}\throughout{.. ...}\endmodality(post)))
        \heuristics(simplify_prog, simplify_prog_subset)
	\displayname "assignment"};

  assignment_read_static_implicit_attribute_tout { 
	      \find (\throughout{.. #v0 = @(#ia); ...}\endmodality(post))
	      \varcond(\static(#ia))
	      \replacewith(post & (post -> {#v0 := #ia} \throughout{.. ...}\endmodality(post)))
 	      \heuristics(simplify_prog, simplify_prog_subset)
	      \displayname "assignment"
  };

}


\rules(programRules:Java) {
  // constant case cannot occur as no static initilisation handling happens
  assignment_write_static_attribute_with_variable_prefix {
	\find (\modality{#normalassign}{.. @(#v.#sv) = #se; ...}\endmodality(post))
	\replacewith({#sv := #se} \modality{#normalassign}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
  };

  // constant case cannot occur as no static initilisation handling happens
  assignment_read_static_attribute_with_variable_prefix {
	\find (\modality{#normalassign}{.. #loc = @(#v.#sv); ...}\endmodality(post))
        \replacewith({#loc := #v.#sv}\modality{#normalassign}{.. ...}\endmodality(post))
	\heuristics(simplify_prog)
        \displayname "assignment"
  };

}


\rules(programRules:Java, transactions:transactionsOn, transactionAbort:abortOn,javacard:jcOn) {

  // constant case cannot occur as no static initilisation handling happens
  assignment_write_static_attribute_with_variable_prefix_traonly { 
	\find (\modality{#traonly}{.. @(#sv) = #se; ...}\endmodality(post)) 
	\replacewith ({#shadowed(#sv):= #shadowed(#se)}\modality{#traonly}{.. ...}\endmodality(post)) 
	\heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };
}


\rules(programRules:Java, throughout:toutOn) {

  assignment_write_explicit_static_attribute_with_variable_prefix_tout { 
	\find (\throughout{..@(#v.#ea)=#se;...}\endmodality(post))
	\varcond(\static(#ea))
	\replacewith(post & (post -> {#v.#ea := #se}\throughout{.. ...}\endmodality(post)))
        \heuristics(simplify_prog, simplify_prog_subset)
	\displayname "assignment"
  };

  assignment_write_implicit_static_attribute_with_variable_prefix_tout {
	\find (\throughout{.. @(#v.#ia)=#se; ...}\endmodality(post))
	\varcond(\static(#ia))
	\replacewith(post & (post -> {#v.#ia := #se}\throughout{.. ...}\endmodality(post)))
        \heuristics(simplify_prog, simplify_prog_subset)
	\displayname "assignment"
  };

}



\rules(programRules:Java, throughout:toutOn) {

  assignment_read_static_explicit_attribute_with_variable_prefix_tout{
	\find (\throughout{..#v0= @(#v.#ea);...}\endmodality(post))
        \varcond(\static(#ea))
	\replacewith(post & (post -> {#v0 := #v.#ea}\throughout{.. ...}\endmodality(post)))
        \heuristics(simplify_prog, simplify_prog_subset)
	\displayname "assignment"};

   assignment_read_static_implicit_attribute_with_variable_prefix_tout { 
	      \find (\throughout{.. #v0 = @(#v.#ia); ...}\endmodality(post))
	      \varcond(\static(#ia))
	      \replacewith(post & (post -> {#v0 := #v.#ia} \throughout{.. ...}\endmodality(post)))
 	      \heuristics(simplify_prog, simplify_prog_subset)
	      \displayname "assignment"
   };

}


\rules(programRules:Java, transactions:transactionsOn, transactionAbort:abortOn,javacard:jcOn) {
  // constant case cannot occur as no static initilisation handling happens
  assignment_read_static_attribute_with_variable_prefix_traonly { 
	\find (\modality{#traonly}{.. #v0 = @(#v.#sv); ...}\endmodality(post)) 
	\replacewith ({#shadowed(#v0):= #shadowed(#v.#sv)}\modality{#traonly}{.. ...}\endmodality(post)) 
	\heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };
 
}

//=====================================================================//
//======================= static method calls    ======================//
//=====================================================================//

\rules(programRules:Java, initialisation:disableStaticInitialisation) {
  staticMethodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
    \replacewith (\modality{#allmodal}{.. 			    
		 #method-call(#v0, #se.#mn(#elist));
		...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call"
  };

  staticMethodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)), \staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. 
			    #typeof(#lhs) #v0;
	  	            #method-call(#v0, #se.#mn(#elist));
		            #lhs = #v0; 
                  ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_with_assignment"
  };

  staticMethodCallStaticViaTypereference { 
    \find (\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_via_typereference"
  };


  staticMethodCallStaticWithAssignmentViaTypereference {
    \find (\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{..  #typeof(#lhs) #v0;
			        #method-call(#v0, #t.#mn(#elist));
			        #lhs = #v0; ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_with_assignment_via_typereference"
  };

  methodCallWithAssignmentWithinClass {
    \find (\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, #mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment_within_class"
  };

  methodCallWithinClass { 
    \find (\modality{#allmodal}{.. #mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 
	#method-call(#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_within_class"
  };   
}


\rules(programRules:Java, initialisation:enableStaticInitialisation) {

  staticMethodCall { 
    \find (\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
    \replacewith (\modality{#allmodal}{.. 			    
		#static-initialisation(#se.#mn(#elist));
		#method-call(#v0, #se.#mn(#elist));
		...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call"
  };

  staticMethodCallWithAssignment { 
    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality((post))) 
    \varcond(\new(#v0, \typeof(#lhs)), \staticMethodReference(#se, #mn, #elist))
    "Normal Execution":
      \replacewith (\modality{#allmodal}{.. 
			    #static-initialisation(#se.#mn(#elist));
			    #typeof(#lhs) #v0;
	  	            #method-call(#v0, #se.#mn(#elist));
		            #lhs = #v0; 
                  ...}\endmodality(post))
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_with_assignment"
  };

  staticMethodCallStaticViaTypereference { 
    \find (\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  #static-initialisation(#t.#mn(#elist)); 
		                #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_via_typereference"
  };


  staticMethodCallStaticWithAssignmentViaTypereference {
    \find (\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality(post))
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{..  #static-initialisation(#t.#mn(#elist));
				#typeof(#lhs) #v0;
			        #method-call(#v0, #t.#mn(#elist));
			        #lhs = #v0; ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "static_method_call_static_with_assignment_via_typereference"
  };

  methodCallWithAssignmentWithinClass {
    \find (\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#lhs)))
    \replacewith (\modality{#allmodal}{.. #static-initialisation(#mn(#elist));
			       #typeof(#lhs) #v0;
                               #method-call(#ex, #v0, #mn(#elist));
                               #lhs = #v0;
                            ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_with_assignment_within_class"
  };

  methodCallWithinClass { 
    \find (\modality{#allmodal}{.#ex.. #mn(#elist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 
	#static-initialisation(#mn(#elist));
	#method-call(#ex, #mn(#elist)); ...}\endmodality(post)) 
    \heuristics(simplify_autoname)
    \displayname "methodCall"
    \oldname "method_call_within_class"
  };

 passiveMethodCallWithinClass { 
   		\find (\modality{#allmodal}{.#ex.. @(#mn(#elist)); ...}\endmodality(post)) 
   		\replacewith (\modality{#allmodal}{.. #method-call(#ex, #mn(#elist)); ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(simplify_autoname)
		\oldname "passive_method_call_within_class"
 };

 passiveMethodCallStatic { 
   		\find (\modality{#allmodal}{.. @(#t.#mn(#elist)); ...}\endmodality(post)) 
   		\replacewith (\modality{#allmodal}{.. #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(simplify_autoname)
		\oldname "passive_method_call_static"
 };

 passiveMethodCallWithAssignmentWithinClass {
   		\find (\modality{#allmodal}{.#ex.. #lhs=@(#mn(#elist)); ...}\endmodality(post)) 
   		\varcond(\new(#v0, \typeof(#lhs)))
   		\replacewith(\modality{#allmodal}{.. #typeof(#lhs) #v0;
                                          #method-call(#ex, #v0, #mn(#elist));
                                          #lhs = #v0;
                                     ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(simplify_autoname)
		\oldname "passive_method_call_with_assignment_within_class"
 };

 passiveMethodCallStaticWithAssignment {
		\find (\modality{#allmodal}{.. #lhs = @(#t.#mn(#elist)); ...}\endmodality(post))
   		\varcond(\new(#v0, \typeof(#lhs)))
   		\replacewith(\modality{#allmodal}{..  #typeof(#lhs) #v0;
 		                 #method-call(#v0, #t.#mn(#elist));
		                 #lhs = #v0; 
			   ...}\endmodality(post)) 
		\displayname "methodCall"
   		\heuristics(simplify_autoname)
		\oldname "passive_method_call_static_with_assignment"
 };



}



//===============================================================//
//============   axioms describing valid jvm states ===========//
//===============================================================//
\rules(programRules:Java) {
 
 class_being_initialized_is_prepared {
	\assumes (#classInitializationInProgress  = TRUE, inReachableState ==>)  
        \find (#classPrepared) \sameUpdateLevel
	\varcond(\same(\containerType(#classPrepared), \containerType(#classInitializationInProgress)))
	\replacewith(TRUE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialized classes have been prepared"
  };   
  
 initialized_class_is_prepared {
	\assumes (#classInitialized = TRUE, inReachableState ==>)
        \find (#classPrepared) \sameUpdateLevel
        \varcond(\same(\containerType(#classPrepared), \containerType(#classInitialized)))
	\replacewith (TRUE)
	\heuristics(confluence_restricted, simplify)
        \displayname "classes being initialized have been prepared"
  };
 
 initialized_class_is_not_erroneous {
	\assumes (#classInitialized = TRUE, inReachableState ==>)
        \find (#classErroneous) \sameUpdateLevel
        \varcond(\same(\containerType(#classErroneous), \containerType(#classInitialized)))
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialized class is not erroneous"
  };

 class_initialized_excludes_class_init_in_progress {
	\assumes (#classInitialized = TRUE, inReachableState ==>)
        \find (#classInitializationInProgress) \sameUpdateLevel
        \varcond(\same(\containerType(#classInitializationInProgress), \containerType(#classInitialized)))
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialisation process has already terminated"
  };

 class_erroneous_excludes_class_in_init {
	\assumes (#classErroneous = TRUE, inReachableState ==>) 
        \find (#classInitializationInProgress) \sameUpdateLevel
	\varcond(\same(\containerType(#classInitializationInProgress), \containerType(#classErroneous)))
	\replacewith (FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "initialization process has already terminated (or never begun)"
  };

 erroneous_class_has_no_initialized_sub_class {
        \assumes(#classErroneous = TRUE, inReachableState ==>)
        \find(#classInitialized) \sameUpdateLevel
	\varcond(\sub(\containerType(#classInitialized), \containerType(#classErroneous)))
	\replacewith(FALSE)
	\heuristics(confluence_restricted, simplify)
        \displayname "erroneous classes have no initialized subclasses"
 };
 
 superclasses_of_initialized_classes_are_initialized {
        \assumes(#classInitialized = TRUE, inReachableState ==>)
        \find(#classInitialized2) \sameUpdateLevel
	\varcond(\strict\sub(\containerType(#classInitialized), \containerType(#classInitialized2)))
	\replacewith(TRUE)
	\heuristics(simplify)
        \displayname "initialied classes have only initialized subclasses"
 };
 
 superclasses_of_initialized_classes_are_initialized_2 {
        \assumes(#classInitialized = TRUE, inReachableState ==>)
        \find(#classPrepared) \sameUpdateLevel
	\varcond(\sub(\containerType(#classInitialized), \containerType(#classPrepared)))
	\replacewith(TRUE)
	\heuristics(simplify)
        \displayname "initialied classes have only prepared subclasses"
 };
 
}	

