\sorts {
	\generic Integer, Integer1, Integer2 \oneof{CHAR, SCHAR, UCHAR, SSHRT, USHRT, SINT, UINT, SLONG, ULONG, SLLONG, ULLONG};

	\generic Generic, Generic1, Generic2;
}

\schemaVariables {
	\term int schemaInt, schemaInt1, schemaInt2;

	\term Integer schemaInteger;
	\term Integer1 schemaInteger1;
	\term Integer2 schemaInteger2;
	\term Object schemaObj, schemaObj1, schemaObj2, schemaObj3;
	\term Array schemaArr, schemaArr1, schemaArr2;
	\term StorageMode schemaStorageMode, schemaStorageMode1, schemaStorageMode2;

	\skolemTerm int dummy;

	\variables Generic schemaVarGeneric;

	\variables Object schemaVarObj, schemaVarObj1, schemaVarObj2;

	\modalOperator {diamond, box} #allmodal;
	\formula formula;
}

\rules {
	/* Equality */
	tryElimObjEq {
		\find (schemaObj1 = schemaObj2)
		\replacewith (#ClangTryObjEq(schemaObj1 = schemaObj2))
		\heuristics(simplify_heap_try)
	};

	/* Array Size */

	tryElimSizedArraySize {
		\find(size(schemaArr))
		\replacewith(
			#ClangTrySizedArraySize(size(schemaArr))
		)
		\heuristics(simplify_heap_try)		
	};

	tryElimArrayRepositorySize {
		\find(size(schemaArr))
		\replacewith(
			#ClangTryArrayRepositorySize(size(schemaArr))
		)
		\heuristics(simplify_heap_try)		
	};

	/* Heap structure */
	elimIsValidPtr {
		\find (isValidPtr(schemaObj))
		\replacewith ( schemaObj = null | isValidObj(schemaObj) & storage(objBlock(schemaObj)) != ST_TRAP )
		\heuristics(simplify_heap)
	};

	elimObjExists {
		\find (objExists(schemaObj))
		// TODO: we do not need "schemaObj != null" as null is not real
		\replacewith ( schemaObj != null & isRealObj(schemaObj) & storage(objBlock(schemaObj)) != ST_TRAP )
		\heuristics(simplify_heap)
	};

	elimIsValidIdx {
		\find (isValidIdx(schemaObj, schemaInt))
		\replacewith (0 <= schemaInt & schemaInt <= size(schemaObj))
		\heuristics(simplify_heap)
	};

	elimIsRealIdx {
		\find (isRealIdx(schemaObj, schemaInt))
		\replacewith (0 <= schemaInt & schemaInt < size(schemaObj))
		\heuristics(simplify_heap)
	};

	trySimplifyIsValidObj {
		\find (isValidObj(schemaObj))
		\replacewith (#ClangTryIsValidObj(isValidObj(schemaObj), isRealObj(null), isValidIdx(null, 0)))
		\heuristics(simplify_heap_try)
	};

	trySimplifyIsRealObj {
		\find (isRealObj(schemaObj))
		\replacewith (#ClangTryIsRealObj(isRealObj(schemaObj), isRealIdx(null, 0)))
		\heuristics(simplify_heap_try)
	};

	trySimplifyRootObj {
		\find (rootObj(schemaObj))
		\replacewith (#ClangTryRootObj(rootObj(schemaObj)))
		\heuristics(simplify_heap_try)		
	};

	trySimplifyIsRootObj {
		\find (isRootObj(schemaObj))
		\replacewith (#ClangTryIsRootObj(isRootObj(schemaObj)))
		\heuristics(simplify_heap_try)		
	};

	elimDoubleRootObj {
		\find (rootObj(rootObj(schemaObj)))
		\replacewith (rootObj(schemaObj))
		\heuristics(simplify_heap)
	};

	elimIsRootRootObj {
		\find (isRootObj(rootObj(schemaObj)))
		\replacewith (true)
		\heuristics(simplify_heap)
	};
	
	inferIsRootObj_RootObjEq_L {
		\find (rootObj(schemaObj1) = schemaObj2 ==> )
		\add (isRootObj(schemaObj2) ==> )
		\heuristics(infer_heap)
	};
	
	inferIsRootObj_RootObjEq_R {
		\find (schemaObj1 = rootObj(schemaObj2) ==> )
		\add (isRootObj(schemaObj1) ==> )
		\heuristics(infer_heap)
	};
	
	simplifyRootObj_IsRootObj {
		\assumes(isRootObj(schemaObj) ==> )
		\find (rootObj(schemaObj))
		\replacewith(schemaObj)
		\heuristics(simplify_heap)
	};

	simplifyIsValidObj_IsRootObj {
		\assumes( isRootObj(schemaObj) ==> )
		\find( isValidObj(schemaObj) )
		\sameUpdateLevel
		\replacewith ( schemaObj != null)
		\heuristics(simplify_heap)
	};

	cutIsValidObj_IsRootObj {
		\find ( isValidObj(schemaObj) )
		\sameUpdateLevel		
		\add (isRootObj(schemaObj) ==>);
		\add (==> isRootObj(schemaObj))
	};

	simplifyIsRealObj_IsRootObj {
		\assumes(isRootObj(schemaObj) ==> )
		\find( isRealObj(schemaObj) )
		\sameUpdateLevel
		\replacewith ( schemaObj != null)
		\heuristics(simplify_heap)		
	};

	cutIsRealObj_IsRootObj {
		\find ( isRealObj(schemaObj) )
		\sameUpdateLevel		
		\add ( isRootObj(schemaObj) ==> );
		\add ( ==> isRootObj(schemaObj) )
	};
	
	inferIsValidObj_IsRealObj {
		\find ( isRealObj(schemaObj) ==> )
		\add ( isValidObj(schemaObj) ==> )
		\heuristics(infer_heap)
	};
		
	cutIsValidObj_IsRealObj {
		\find (isValidObj(schemaObj))
		\sameUpdateLevel		
		\add ( isRealObj(schemaObj) ==> );
		\add ( ==> isRealObj(schemaObj) )
	};
	
	cutIsRealObj_IsValidObj {
		\find ( isRealObj(schemaObj) )
		\sameUpdateLevel		
		\add ( ==> isValidObj(schemaObj) );
		\add ( isValidObj(schemaObj) ==> )
	};	

	/* Containment */

	tryElimObjContains {
		\find (objContains(schemaObj1, schemaObj2))
		\replacewith (#ClangTryObjContains(objContains(schemaObj1, schemaObj2)))
		\heuristics(simplify_heap_try)
	};

	elimObjContains_Reflexivity {
		\find (objContains(schemaObj, schemaObj))
		\replacewith (true)
		\heuristics(simplify_heap)
	};
	
	inferObjContains_Transitivity {
		\assumes (objContains(schemaObj1, schemaObj2), objContains(schemaObj2, schemaObj3) ==>)
		\add (objContains(schemaObj1, schemaObj3) ==> )
		\heuristics(infer_heap)
	};
	
	closeObjContains_Transitivity {
		\assumes (objContains(schemaObj1, schemaObj2), objContains(schemaObj2, schemaObj3) ==> objContains(schemaObj1, schemaObj3))
		\closegoal
		\heuristics(simplify_heap)
	};
	
	inferObjContains_Antisymmetry {
		\assumes (objContains(schemaObj1, schemaObj2), objContains(schemaObj2, schemaObj1) ==>)
		\add (schemaObj1 = schemaObj2 ==> )
		\heuristics(infer_heap)
	};
	
	closeObjContains_Antisymmetry {
		\assumes (objContains(schemaObj1, schemaObj2), objContains(schemaObj2, schemaObj1) ==> schemaObj1 = schemaObj2)
		\closegoal
		\heuristics(simplify_heap)
	};
	
	/* Aliasing */

	// NB! Doesn't work with unions!

	trySimplifyObjAliased {
		\find (objAliased(schemaObj1, schemaObj2))
		\replacewith (#ClangTryObjAliased(objAliased(schemaObj1, schemaObj2)))
		\heuristics(simplify_heap_try)		
	};

	elimObjAliased_IdenticalArgs {
		\find (objAliased(schemaObj, schemaObj))
		\replacewith (true)
		\heuristics(simplify_heap)
	};

	inferObjAliased_Transitivity_1 {
		\assumes (objAliased(schemaObj1, schemaObj2), objAliased(schemaObj2, schemaObj3) ==>)
		\add (objAliased(schemaObj1, schemaObj3) ==> )
		\heuristics(infer_heap)
	};

	inferObjAliased_Transitivity_2 {
		\assumes (objAliased(schemaObj2, schemaObj1), objAliased(schemaObj2, schemaObj3) ==>)
		\add (objAliased(schemaObj1, schemaObj3) ==> )
		\heuristics(infer_heap)
	};

	inferObjAliased_Transitivity_3 {
		\assumes (objAliased(schemaObj1, schemaObj2), objAliased(schemaObj3, schemaObj2) ==>)
		\add (objAliased(schemaObj1, schemaObj3) ==> )
		\heuristics(infer_heap)
	};

	inferObjAliased_Antisymmetry {
		\assumes (objAliased(schemaObj1, schemaObj2), objAliased(schemaObj2, schemaObj1) ==>)
		\add (schemaObj1 = schemaObj2 ==>)
		\heuristics(infer_heap)
	};
	
	closeObjAliased_Antisymmetry {
		\assumes (objAliased(schemaObj1, schemaObj2), objAliased(schemaObj2, schemaObj1) ==>schemaObj1 = schemaObj2)
		\closegoal
		\heuristics(simplify_heap)
	};

	
	/* Blocks */

	trySimplifyObjBlock {
		\find(objBlock(schemaObj))
		\replacewith(objBlock(#ClangTryRemoveObjAccessor(schemaObj)))
		\heuristics(simplify_heap_try)		
	};	

	simplfyObjBlock_RootObj {
		\find(objBlock(rootObj(schemaObj)))
		\replacewith(objBlock(schemaObj))
		\heuristics(simplify_heap)		
	};	

	inferObjBlockEq_RootObj {
		\find(objBlock(schemaObj1) = objBlock(schemaObj2) ==>)
		\add(rootObj(schemaObj1) = rootObj(schemaObj2) ==>)
		\heuristics(infer_heap)
	};
	
	inferRootObjEq_ObjBlock_L {
		\find(rootObj(schemaObj1) = schemaObj2 ==>)
		\add(objBlock(schemaObj1) = objBlock(schemaObj2) ==>)
		\heuristics(infer_heap)
	};

	inferRootObjEq_ObjBlock_R {
		\find(schemaObj1 = rootObj(schemaObj2) ==>)
		\add(objBlock(schemaObj1) = objBlock(schemaObj2) ==>)
		\heuristics(infer_heap)
	};
		
	cutStorageObjBlock_Eq {
		\assumes(storage(objBlock(schemaObj1)) = schemaStorageMode ==>)
		\find(storage(objBlock(schemaObj2)) = schemaStorageMode)
		\sameUpdateLevel
		\replacewith(true)
		\add(rootObj(schemaObj1) = rootObj(schemaObj2) ==>);
		\add(==> rootObj(schemaObj1) = rootObj(schemaObj2))
	};

	/* Structure */

	trySimplifyIsStructMemberObj {
		\find(isStructMember(schemaObj))
		\replacewith(#ClangTryIsStructMember(isStructMember(schemaObj)))
		\heuristics(simplify_heap_try)
	};	

	trySimplifyIsArrayElemObj {
		\find(isArrayElem(schemaObj))
		\replacewith(#ClangTryIsArrayElem(isArrayElem(schemaObj)))
		\heuristics(simplify_heap_try)
	};	

	trySimplifyRootObjLookupIdx {
		\find(rootObjLookupIdx(schemaObj))
		\replacewith(#ClangTryRootObjLookupIdx(rootObjLookupIdx(schemaObj)))
		\heuristics(simplify_heap_try)
	};

	trySimplifyObjParent {
		\find(objParent(schemaObj))
		\replacewith(#ClangTryObjParent(objParent(schemaObj)))
		\heuristics(simplify_heap_try)
	};	

	trySimplifyObjParentIdx {
		\find(objParentIdx(schemaObj))
		\replacewith(#ClangTryObjParentIdx(objParentIdx(schemaObj)))
		\heuristics(simplify_heap_try)
	};
	
	/* Conversion */
	
	elimConvertIntegerToPointer {
		\find(convertIntegerToPointer(schemaInteger, schemaObj))
		\replacewith(
			\if (#ClangIntegerToInt(schemaInteger) = 0)
			\then (null)
			\else (undecidableObject(dummy))
			)
		\heuristics(simplify_heap)
	};

	elimCanConvertPointerToInteger {
		\find(canConvertPointerToInteger(schemaObj, schemaInteger))
		\replacewith(
			schemaObj = null
			)
		\heuristics(simplify_heap)
	};

	elimConvertPointerToInteger {
		\find(convertPointerToInteger(schemaObj, schemaInteger))
		\replacewith(#ClangIntegerFromInt(0, schemaInteger))
		\heuristics(simplify_heap)
	};

	/* Object pointers */

	// NB! Doesn't work with unions! Not complete with valid, but not real objects!
	elimObjPtrEq {
		\find(objPtrEq(schemaObj1, schemaObj2))
		\replacewith(
			\if (schemaObj1 = null | schemaObj2 = null)
			\then (schemaObj1 = schemaObj2)
			\else (
				\if (isRealObj(schemaObj1) & isRealObj(schemaObj2))
				\then (objAliased(schemaObj1, schemaObj2) | objAliased(schemaObj2, schemaObj1))
				\else (
					\if (isArrayElem(schemaObj1) & isArrayElem(schemaObj1) & objParent(schemaObj1) = objParent(schemaObj2))
					\then (objParentIdx(schemaObj1) = objParentIdx(schemaObj2))
					\else (undecidablePredicate(dummy))
					)
				)
			)
		\heuristics(simplify_heap)
	};

	elimObjPtrCanCompare {
		\find(objPtrCanCompare(schemaObj1, schemaObj2))
		\replacewith(
			objParent(schemaObj1) = objParent(schemaObj2) 
			& 
			(
				isArrayElem(schemaObj1) | isStructMember(schemaObj1)
			)
		)
		\heuristics(simplify_heap)
	};
	
	elimObjPtrLess {
		\find(objPtrLess(schemaObj1, schemaObj2))
		\replacewith(
			objParentIdx(schemaObj1) < objParentIdx(schemaObj2)
		)
		\heuristics(simplify_heap)
	};

	elimObjPtrCanDiff {
		\find(objPtrCanDiff(schemaObj1, schemaObj2))
		\replacewith(
			objParent(schemaObj1) = objParent(schemaObj2) & isArrayElem(schemaObj1) & PTRDIFF_T_MIN <= objParentIdx(schemaObj1) - objParentIdx(schemaObj2) & objParentIdx(schemaObj1) - objParentIdx(schemaObj2) <= PTRDIFF_T_MAX
			)
		\heuristics(simplify_heap)
	};

	elimObjPtrDiff {
		\find(objPtrDiff(schemaObj1, schemaObj2))
		\replacewith(
			objParentIdx(schemaObj1) - objParentIdx(schemaObj2)
			)
		\heuristics(simplify_heap)
	};

	/* Reachable state */

	expandReachableState {
		\find(inReachableState ==>)
		\add(
			\forall schemaVarObj; (rootObjLookupIdx(rootObj(schemaVarObj)) >= next -> storage(objBlock(schemaVarObj)) = ST_TRAP)
			==> )
	};
	
	applyInReachableState_TRAP {
		\assumes( inReachableState ==> storage(objBlock(schemaObj)) = ST_TRAP )
		\add(rootObjLookupIdx(rootObj(schemaObj)) < next ==>)
		\heuristics(infer_heap)
	};
	
	applyInReachableState_ALLOCATED {
		\assumes( inReachableState, storage(objBlock(schemaObj)) = ST_ALLOCATED ==> )
		\add(rootObjLookupIdx(rootObj(schemaObj)) < next ==>)
		\heuristics(infer_heap)
	};	
	
	applyInReachableState_AUTOMATIC {
		\assumes( inReachableState, storage(objBlock(schemaObj)) = ST_AUTOMATIC ==> )
		\add(rootObjLookupIdx(rootObj(schemaObj)) < next ==>)
		\heuristics(infer_heap)
	};	
	
	applyInReachableState_STATIC {
		\assumes( inReachableState, storage(objBlock(schemaObj)) = ST_AUTOMATIC ==> )
		\add(rootObjLookupIdx(rootObj(schemaObj)) < next ==>)
		\heuristics(infer_heap)
	};	
}
