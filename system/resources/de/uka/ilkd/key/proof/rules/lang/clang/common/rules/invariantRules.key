\schemaVariables {
	\term int schemaInt, schemaInt1, schemaInt2;

	\skolemTerm int variantPrev;

	\modalOperator {diamond, box} #allmodal;
	\formula formula;

	\formula invariant;
	\term int variant;
	
	\location[list] #modifies;
	\formula anon1, anon2, anon3;

	\program ClangVariable #tvar, #tvar1, #tvar2;

	\program ClangValueType #vtype;
	\program ClangIntegerType #itype;
	\program ClangPointerType #ptype;
	\program ClangScalarType #stype;
	\program ClangObjectType #otype;

	\program ClangMember #member;

	\program ClangIntegerLiteral #ilit;

	\program ClangVariable #var, #var1, #var2, #var3;
	\program ClangValueVariable #vvar, #vvar1, #vvar2, #vvar3;
	\program ClangObjectVariable #ovar, #ovar1, #ovar2, #ovar3;
	\program ClangIntegerVariable #ivar, #ivar1, #ivar2, #ivar3;
	\program ClangPointerVariable #pvar, #pvar1, #pvar2, #pvar3;

	\program ClangValueSimpleExpression #vsexp, #vsexp1, #vsexp2, #vsexp3;
	\program ClangIntegerSimpleExpression #isexp, #isexp1, #isexp2, #isexp3;
	\program ClangPointerSimpleExpression #psexp, #psexp1, #psexp2, #psexp3;

	\program ClangExpression #exp, #exp1, #exp2;
	\program ClangObjectExpression #oexp, #oexp1, #oexp2;
	\program ClangValueExpression #vexp, #vexp1, #vexp2;
	\program ClangIntegerExpression #iexp, #iexp1, #iexp2;
	\program ClangPointerExpression #pexp, #pexp1, #pexp2;
	\program ClangComplexExpression #cexp, #cexp1, #cexp2;
	\program ClangValueComplexExpression #vcexp, #vcexp1, #vcexp2;
	\program ClangObjectComplexExpression #ocexp, #ocexp1, #ocexp2;

	\program ClangStatement #stmnt, #stmnt1, #stmnt2;
}

\rules {

	whileInvariant_Box { 
		\find ( ==> \[..   while(#iexp) #stmnt  ...\]formula)
		\varcond( 
			\new(#tvar, \typeof(#iexp)),
			\new(anon1,\dependingOnMod(#modifies)),
			\new(anon2,\dependingOnMod(#modifies)),
			\new(anon3,\dependingOnMod(#modifies)),
	                \new(anon1, \dependingOn(formula)),
        	        \new(anon1, \dependingOn(invariant)),			
	                \new(anon2, \dependingOn(formula)),
        	        \new(anon2, \dependingOn(invariant)),
        	        \new(anon3, \dependingOn(formula)),
        	        \new(anon3, \dependingOn(invariant))
			)

		"Invariant Initially Valid":
			\replacewith ( ==> invariant );
			
		"Body Preserves Invariant":
			\replacewith ( ==> 
				#introNewAnonUpdate(
					#modifies, 
					invariant ->
						\[ #tvar = #iexp; \]
						(
							(#ClangIntegerToInt(#tvar) != 0)
							->
							(
								\[ #stmnt \]
								invariant
							)
						),
					anon1
				)
			)
		\addprogvars(#tvar);

		"Use Case":
			\replacewith ( ==>
				#introNewAnonUpdate(#modifies, 
					invariant ->
						\[ #tvar = #iexp; \]
						(
							(#ClangIntegerToInt(#tvar) = 0)
							->
							(
								\[.. ...\]
								formula
							)
						),
					anon2
				)
			)
		\addprogvars(#tvar);
		
		"Condition Is Valid: #iexp":
			\replacewith ( ==> 
				#introNewAnonUpdate(
					#modifies, 
					invariant -> \[ #tvar = #iexp; \] isValidVal(#tvar),
					anon3
				)
			)
		\addprogvars(#tvar)
	};

	whileInvariant_Diamond { 
		\find ( ==> \<..   while(#iexp) #stmnt  ...\>formula)
		\varcond( 
			\new(#tvar, \typeof(#iexp)),
			\new(anon1,\dependingOnMod(#modifies)),
			\new(anon2,\dependingOnMod(#modifies)),
	                \new(anon1, \dependingOn(formula)),
        	        \new(anon1, \dependingOn(invariant)),			
	                \new(anon2, \dependingOn(formula)),
        	        \new(anon2, \dependingOn(invariant))
			)

		"Invariant Initially Valid":
			\replacewith ( ==> invariant );

		"Body Preserves Invariant":
			\replacewith ( ==> 
				#introNewAnonUpdate(
					#modifies, 
					invariant ->
						\[ #tvar = #iexp; \]
						(
							(#ClangIntegerToInt(#tvar) != 0)
							->
							(
								\[ #stmnt \]
								invariant
							)
						),
					anon1
				)
			)
		\addprogvars(#tvar);

		"Use Case":
			\replacewith ( ==>
				#introNewAnonUpdate(
					#modifies, 
					invariant ->
						\[ #tvar = #iexp; \]
						(
							(#ClangIntegerToInt(#tvar) = 0)
							->
							(
								\<.. ...\>
								formula
							)
						),
					anon2
				)
			)
		\addprogvars(#tvar);

		"Termination:":
			\replacewith ( ==> \< while(#iexp) #stmnt \>true )

	};

	whileInvariantVariant_Diamond { 
		\find ( ==> \<..   while(#iexp) #stmnt  ...\>formula)
		\varcond(
			\new(#tvar, \typeof(#iexp)),
			\new(anon1,\dependingOnMod(#modifies)),
			\new(anon2,\dependingOnMod(#modifies)),
			\new(anon3,\dependingOnMod(#modifies)),
	                \new(anon1, \dependingOn(formula)),
        	        \new(anon1, \dependingOn(invariant)),			
	                \new(anon2, \dependingOn(formula)),
        	        \new(anon2, \dependingOn(invariant)),
        	        \new(anon3, \dependingOn(formula)),
        	        \new(anon3, \dependingOn(invariant))
			)

		"Invariant Initially Valid":
			\replacewith ( ==> invariant & variant >= 0 );

		"Body Preserves Invariant":
			\replacewith ( ==> 
				#introNewAnonUpdate(
					#modifies, 
					invariant ->
						\[ #tvar = #iexp; \]
						(
							(#ClangIntegerToInt(#tvar) != 0)
							->
							(
								\[ #stmnt \]
								invariant
							)
						),
					anon1
				)
			)
		\addprogvars(#tvar);

		"Use Case":
			\replacewith ( ==>
				#introNewAnonUpdate(
					#modifies, 
					invariant ->					
					\[ #tvar = #iexp; \]
					(
						(#ClangIntegerToInt(#tvar) = 0)
						->
						(
							\<.. ...\>
							formula
						)
					),
					anon2
				)
			)
		\addprogvars(#tvar);

		"Termination":
			\replacewith ( ==> 
				#introNewAnonUpdate(
					#modifies, 
					invariant & variant >= 0 & variant = variantPrev ->
						\< #tvar = #iexp; \>
						(
							(#ClangIntegerToInt(#tvar) != 0)
							->
							(
								\< #stmnt \>
								variant < variantPrev & variant >= 0
							)
						),
					anon3
				)
			)
		\addprogvars(#tvar)
	};
}