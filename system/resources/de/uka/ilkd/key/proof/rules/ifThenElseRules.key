// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2009 Universitaet Karlsruhe Germany
//                         Universitaet Koblenz-Landau, Germany
//                         and Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
//

// This file contains rules that are applicable for every sort (as they
// use \generic sorts).
// The format is the same as for problem files.

\sorts {
  \generic INT \extends int;
  \generic G, G2, G3, G4;
}

// These schema variables are used to write the following rules.
// They will not be visible in later runs of the parser, so you are
// fairly free in choosing their names.
\schemaVariables {
  \term G2  else, then ; 
  \term G t ;
  \formula phi,b,c;
  \variables G u ;
  \variables G3 v ;
  \variables G4 w ;

  \variables INT intVar ;
  \skolemTerm INT intSk ;
  \term int intT1, intT2;
  \term int intValue ;
}



\rules {

// ------------- handling the if-then-else-operator ----------------------

  ifthenelse_true { \find ( \if (true) \then (then) \else (else) )
                    \replacewith ( then )
                    \heuristics (concrete) };

  ifthenelse_true_for { \find ( \if (true) \then (b) \else (c) )
                        \replacewith ( b )
                        \heuristics (concrete)
                        \displayname "ifthenelse_true" };

  ifthenelse_false { \find ( \if (false) \then (then) \else (else) )
                     \replacewith ( else )
                     \heuristics (concrete) };

  ifthenelse_false_for { \find ( \if (false) \then (b) \else (c) )
                         \replacewith ( c )
                         \heuristics (concrete)
                         \displayname "ifthenelse_false" };

  ifthenelse_negated { \find ( \if (!phi) \then (then) \else (else) )
                       \replacewith ( \if (phi) \then (else) \else (then) )
                       \heuristics (simplify) };

  ifthenelse_negated_for { \find ( \if (!phi) \then (b) \else (c) )
                           \replacewith ( \if (phi) \then (c) \else (b) )
                           \heuristics (simplify)
                           \displayname "ifthenelse_negated" };

  ifthenelse_same_branches { \find ( \if (phi) \then (then) \else (then) )
                             \replacewith ( then )
                             \heuristics (concrete) };

  ifthenelse_same_branches_for { \find ( \if (phi) \then (b) \else (b) )
                                 \replacewith ( b )
                                 \heuristics (concrete)
                                 \displayname "ifthenelse_same_branches" };

  ifthenelse_split { \find ( \if (phi) \then (then) \else (else) ) \sameUpdateLevel
                     "#phi TRUE":  \replacewith ( then ) \add ( phi ==> );
                     "#phi FALSE": \replacewith ( else ) \add ( ==> phi )
                     \heuristics (split_cond) };

  ifthenelse_split_for { \find ( \if (phi) \then (b) \else (c) ) \sameUpdateLevel
                         "#phi TRUE":  \replacewith ( b ) \add ( phi ==> );
                         "#phi FALSE": \replacewith ( c ) \add ( ==> phi )
                         \heuristics (split_cond)
                         \displayname "ifthenelse_split" };
}
