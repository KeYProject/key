\javaSource "program.c";

\sorts {
	\generic Integer, Integer1, Integer2 \oneof{CHAR, SCHAR, UCHAR, SSHRT, USHRT, SINT, UINT, SLONG, ULONG, SLLONG, ULLONG};

	\generic Generic, Generic1, Generic2;
}

\schemaVariables {
	\term int schemaInt, schemaInt1, schemaInt2;

	\term Integer schemaInteger;
	\term Integer1 schemaInteger1;
	\term Integer2 schemaInteger2;
	\term Object schemaObj, schemaObj1, schemaObj2;
	\term Array schemaArr, schemaArr1, schemaArr2;

	\term %{$Node} schemaNode;

	\skolemTerm boolean dummy;

	\skolemTerm boolean skolemBoolean;

	// Generic
	\skolemTerm Value tempValue;
	\skolemTerm Array tempArray;

	\skolemTerm int variantPrev;

	\skolemTerm Value skolemValue;
	\skolemTerm Object skolemObject;

	\variables Generic schemaVarGeneric;

	\variables Object schemaVarObj, schemaVarObj1, schemaVarObj2;
	\variables int schemaVarInt, schemaVarInt1, schemaVarInt2, schemaVarInt3, schemaVarInt4, schemaVarInt5;

	\modalOperator {diamond, box} #allmodal;
	\formula formula;

	\formula invariant;
	\term int variant;

	\program Variable #tvar, #tvar1, #tvar2;

	\program ClangValueType #vtype;
	\program ClangIntegerType #itype;
	\program ClangPointerType #ptype;
	\program ClangScalarType #stype;
	\program ClangObjectType #otype;

	\program ClangMember #member;

	\program ClangIntegerLiteral #ilit;

	\program ClangVariable #var, #var1, #var2, #var3;
	\program ClangValueVariable #vvar, #vvar1, #vvar2, #vvar3;
	\program ClangObjectVariable #ovar, #ovar1, #ovar2, #ovar3;
	\program ClangIntegerVariable #ivar, #ivar1, #ivar2, #ivar3;
	\program ClangPointerVariable #pvar, #pvar1, #pvar2, #pvar3;

	\program ClangValueSimpleExpression #vsexp, #vsexp1, #vsexp2, #vsexp3;
	\program ClangIntegerSimpleExpression #isexp, #isexp1, #isexp2, #isexp3;
	\program ClangPointerSimpleExpression #psexp, #psexp1, #psexp2, #psexp3;

	\program ClangExpression #exp, #exp1, #exp2;
	\program ClangObjectExpression #oexp, #oexp1, #oexp2;
	\program ClangValueExpression #vexp, #vexp1, #vexp2;
	\program ClangIntegerExpression #iexp, #iexp1, #iexp2;
	\program ClangPointerExpression #pexp, #pexp1, #pexp2;
	\program ClangComplexExpression #cexp, #cexp1, #cexp2;
	\program ClangValueComplexExpression #vcexp, #vcexp1, #vcexp2;
	\program ClangObjectComplexExpression #ocexp, #ocexp1, #ocexp2;

	\program ClangValueNonAssignmentExpression #vnaexp;
	\program ClangObjectNonAssignmentExpression #onaexp;

	\program ClangStatement #stmnt, #stmnt1, #stmnt2;

	\program ClangNonEmptyCompoundStatement #NonEmptyCompoundStatement;
	\program ClangBlockFrameVarDecl #BlockFrameVarDecl;
	\program ClangUnwindingBlockFrame #UnwindingBlockFrame;
	\program ClangEmptyBlockFrame #EmptyBlockFrame;
}

\functions {
	// Example
	int len;
	%{$Node} list(int);

	int next_Saved;
	SINT listElem_Saved(int);
}

\rules {
	typingRule_Node_SINT_Obj {
		\find ( objBlock(schemaNode) = objBlock(%{SINT@::<lookup>}(schemaInt)))
		\replacewith (false)
		\heuristics(simplify)
	};
	typingRule_Node_SINT_Obj_array {
		\find ( objBlock(schemaNode) = objBlock(%{SINT@[]::<lookup>}(schemaInt1, schemaInt2)))
		\replacewith (false)
		\heuristics(simplify)
	};
}

\problem {
inReachableState ->
\<
	register struct Node* ifirst;
	register int* ocount;
	register int** oarr;
\>
(
	next = next_Saved
	&
	// Linked list properties
	ifirst = list(0) 
	& 
	0 <= len & len <= SINT::MAX 
	&
	list(len) = null
	&
	\forall int i; ((0 <= i) & (i < len) -> 
		// Allocation
		list(i) != null
		&
		storage(objBlock(list(i))) = ST_ALLOCATED
		&
		isRootObj(list(i))
		&
		// Non-aliasing
		\forall int j; (0 <= j & j < len -> (list(i) = list(j) -> i = j))
		&
		rootObj(list(i)) != rootObj(ocount)
		&
		rootObj(list(i)) != rootObj(oarr)
		&
		// Values
		%{$Node@}::value(%{$Node}::next(list(i))) = list(i+1)
		&
		isValidVal(%{SINT@}::value(%{$Node}::elem(list(i))))
		&
		// Saved values
		listElem_Saved(i) = %{SINT@}::value(%{$Node}::elem(list(i)))
	)
	&
	objExists(ocount) 
	&
	objExists(oarr)

	->

	(
		\<
			{
				int count = 0;
				register struct Node* ptr = ifirst;

				/*
				Modifies: {%{SINT@::value}(count), ptr}

				Invariant: 
0 <= SINT::toInt(%{SINT@}::value(count))
&
SINT::toInt(%{SINT@}::value(count)) <= len
&
list(SINT::toInt(%{SINT@}::value(count))) = ptr

				Variant: len - SINT::toInt(%{SINT@}::value(count))
				*/
				while (ptr != (struct Node*)0) {
					count++;
					ptr = ptr->next;
				}

				register int* arr = (int*)0;

				if (count > 0) {
					arr = (int*)calloc(count, sizeof(int));
					
					if (arr != (int*)0) {
						register struct Node* nptr = ifirst;
						register int index = 0;

				/*
				Modifies:
{
nptr, 
index,
\for (int i) \if (0 <= i & i < len) %{SINT@::value}(%{SINT@[]::elem}((%{SINT@[]})objParent(arr), i)),
\for (int i) \if (0 <= i & i < len) storage(objBlock(list(i)))
}

				Invariant: 
0 <= SINT::toInt(index)
&
SINT::toInt(index) <= len
&
list(SINT::toInt(index)) = nptr
&
\forall int i; (0 <= i & i < SINT::toInt(index) -> %{SINT@}::value( %{SINT@[]}::%{elem}((%{SINT@[]})objParent(arr), i) ) = listElem_Saved(i))
&
\forall int i; (0 <= i & i < SINT::toInt(index) -> storage(objBlock(list(i))) = ST_TRAP)
&
\forall int i; (SINT::toInt(index) <= i & i < len -> storage(objBlock(list(i))) = ST_ALLOCATED)

				Variant: len-SINT::toInt(index)
				*/
						while (index < count) {
							arr[index] = nptr->elem;
							register struct Node* oldPtr = nptr;
							nptr = nptr->next;
							free(oldPtr);
							index++;
						}
					}
				}

				*ocount = count;
				*oarr = arr;
			}
		\>
		(
		/* Value of "ocount" is the linked list length */
		SINT::toInt(%{SINT@}::value(ocount)) = len
		&
		/* Properties of "oarr" value. "oarr" can be null (either empty list or 
		   failed memory allocation. */
		%{SINT@@}::value(oarr) != null ->
		{\subst %{SINT@} elem0; %{SINT@@}::value(oarr)} (
			/* The length of the linked list is positive */
			len > 0
			&
			\exists %{SINT@[]} arr;(
				/* "*oarr" points to the first element of the array */
				elem0 = %{SINT@[]}::elem(arr, 0)

				&
				/* "*oarr"'s parent array consists of the elements 
				   of the linked list */
				size(arr) = len
				&
				\forall int i; ((0 <= i) & (i < len) -> listElem_Saved(i) = %{SINT@}::value(%{SINT@[]}::%{elem}(arr, i)))

				&
				/* "*oarr" was freshly allocated */
				isRootObj(arr)
				&
				rootObjLookupIdx(arr) >= next_Saved
				&
				storage(objBlock(arr)) = ST_ALLOCATED
			)

			&
			/* Deleted objects */
			\forall int i; ((0 <= i) & (i < len) -> storage(objBlock(list(i))) = ST_TRAP)
		)

		&
		/* Preserved objects */
		objExists(ocount)
		&
		objExists(oarr)

		&
		/* Add modification frame here */
		true
		)
	)
)
}
