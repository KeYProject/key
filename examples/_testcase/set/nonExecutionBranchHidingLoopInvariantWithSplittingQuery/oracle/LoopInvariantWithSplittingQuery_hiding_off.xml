<?xml version="1.0" encoding="UTF-8"?>
<start name="&lt;start&gt;" pathCondition="true" pathConditionChanged="false">
   <methodCall name="&lt;call LoopInvariantWithSplittingQuery.main(x)&gt;" pathCondition="true" pathConditionChanged="false">
      <loopInvariant name="invariant: magic(x) &gt;= 0;
variant: magic(x)
mod: false" pathCondition="true" pathConditionChanged="false" initiallyValid="true">
         <branchCondition name="update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathCondition="update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="true" branchCondition="update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" mergedBranchCondition="false" isBranchConditionComputed="true" additionalBranchLabel="Body Preserves Invariant">
            <branchCondition name="gt(x_0,Z(neglit(1(#))))" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="true" branchCondition="gt(x_0,Z(neglit(1(#))))" mergedBranchCondition="false" isBranchConditionComputed="true">
               <methodCall name="&lt;call LoopInvariantWithSplittingQuery.magic(x_33)&gt;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                  <branchStatement name="if (x_33&gt;=0)" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                     <statement name="return x_33;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                        <methodReturn name="&lt;return of magic&gt;" signature="&lt;return of LoopInvariantWithSplittingQuery.magic(x_33)&gt;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" nameIncludingReturnValue="&lt;return magic_sk_1 as result of magic&gt;" signatureIncludingReturnValue="&lt;return magic_sk_1 as result of LoopInvariantWithSplittingQuery.magic(x_33)&gt;" isReturnValueComputed="true" methodReturnCondition="true">
                           <methodReturnValue name="magic_sk_1" returnValueString="magic_sk_1" hasCondition="false">
                           </methodReturnValue>
                           <statement name="x--;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                              <termination name="&lt;loop body end&gt;" pathCondition="not(or(leq(x_0,Z(neglit(1(#)))),not(imp(geq(x_0,Z(0(#))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" terminationKind="LOOP_BODY" branchVerified="true">
                              </termination>
                           </statement>
                        </methodReturn>
                     </statement>
                  </branchStatement>
                  <methodReturnEntry path="/0/0/0/0/0/0/0/0"/>
               </methodCall>
            </branchCondition>
            <branchCondition name="lt(x_0,Z(0(#)))" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="true" branchCondition="lt(x_0,Z(0(#)))" mergedBranchCondition="false" isBranchConditionComputed="true">
               <methodCall name="&lt;call LoopInvariantWithSplittingQuery.magic(x_24)&gt;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                  <branchStatement name="if (x_24&gt;=0)" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                     <statement name="return -x_24;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                        <methodReturn name="&lt;return of magic&gt;" signature="&lt;return of LoopInvariantWithSplittingQuery.magic(x_24)&gt;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" nameIncludingReturnValue="&lt;return magic_sk_1 as result of magic&gt;" signatureIncludingReturnValue="&lt;return magic_sk_1 as result of LoopInvariantWithSplittingQuery.magic(x_24)&gt;" isReturnValueComputed="true" methodReturnCondition="true">
                           <methodReturnValue name="magic_sk_1" returnValueString="magic_sk_1" hasCondition="false">
                           </methodReturnValue>
                           <statement name="x--;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false">
                              <termination name="&lt;loop body end&gt;" pathCondition="not(or(geq(x_0,Z(0(#))),not(imp(leq(x_0,Z(neglit(1(#)))),update-application(elem-update(x)(x_0),\[{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\] (and(equals(b_5,TRUE),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))))))" pathConditionChanged="false" terminationKind="LOOP_BODY" branchVerified="false">
                              </termination>
                           </statement>
                        </methodReturn>
                     </statement>
                  </branchStatement>
                  <methodReturnEntry path="/0/0/0/1/0/0/0/0"/>
               </methodCall>
            </branchCondition>
         </branchCondition>
         <branchCondition name="update-application(elem-update(x)(x_0),\&lt;{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\&gt; (and(not(equals(b_5,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathCondition="update-application(elem-update(x)(x_0),\&lt;{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\&gt; (and(not(equals(b_5,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="true" branchCondition="update-application(elem-update(x)(x_0),\&lt;{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\&gt; (and(not(equals(b_5,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" mergedBranchCondition="false" isBranchConditionComputed="true" additionalBranchLabel="Use Case">
            <statement name="return x;" pathCondition="update-application(elem-update(x)(x_0),\&lt;{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\&gt; (and(not(equals(b_5,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="false">
               <methodReturn name="&lt;return of main&gt;" signature="&lt;return of LoopInvariantWithSplittingQuery.main(x)&gt;" pathCondition="update-application(elem-update(x)(x_0),\&lt;{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\&gt; (and(not(equals(b_5,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="false" nameIncludingReturnValue="&lt;return Z(0(#)) as result of main&gt;" signatureIncludingReturnValue="&lt;return Z(0(#)) as result of LoopInvariantWithSplittingQuery.main(x)&gt;" isReturnValueComputed="true" methodReturnCondition="update-application(elem-update(x)(x_0),\&lt;{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\&gt; (and(not(equals(b_5,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))">
                  <methodReturnValue name="Z(0(#))" returnValueString="Z(0(#))" hasCondition="false">
                  </methodReturnValue>
                  <termination name="&lt;end&gt;" pathCondition="update-application(elem-update(x)(x_0),\&lt;{method-frame(source=main(int)@LoopInvariantWithSplittingQuery): {
    x_50=magic(x);
    b_5=x_50&gt;0;
  }
}\&gt; (and(not(equals(b_5,TRUE)),geq(LoopInvariantWithSplittingQuery::magic(heap,x),Z(0(#))))))" pathConditionChanged="false" terminationKind="NORMAL" branchVerified="true">
                  </termination>
               </methodReturn>
            </statement>
         </branchCondition>
      </loopInvariant>
      <methodReturnEntry path="/0/0/1/0/0"/>
   </methodCall>
   <terminationEntry path="/0/0/0/0/0/0/0/0/0/0"/>
   <terminationEntry path="/0/0/0/1/0/0/0/0/0/0"/>
   <terminationEntry path="/0/0/1/0/0/0"/>
</start>
