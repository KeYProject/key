// In this example, the abstract polymorphic data type list is defined. The ADT has
// the constructors "nil" and "cons".  The proof obligations states that
// a function "rev" really has the intended behaviour, namely to revert a
// list. To succesfully finish the proof several lemmata have to be proven
// as subgoals (currently the lemmata have to be introduced by cuts):

// 1. \forall List<[E]> l1;\forall List<[E]> l2;( rev<[E]>(app<[E]>(l1,l2))=app<[E]>(rev<[E]>(l2),rev<[E]>(l1)) )
// 2. \forall List<[E]> l;( app<[E]>(l,nil<[E]>)=l  )
// 3. \forall List<[E]> l1;\forall List<[E]> l2;\forall List<[E]> l3;( app<[E]>(l1,app<[E]>(l2,l3))=app<[E]>(app<[E]>(l1,l2),l3) )

// This example is taken from an introduction to Isabelle/HOL. You can
// find the relevant pages describing the proof in file isabelleTutorial.ps.gz.
// Take a look at it if you get stuck in the proof.

\heuristicsDecl {
	LIST;
}

\sorts {
    \generic E;
    \generic F;
    S;
}

\datatypes {
	List<[E]> = Nil | Cons(E head, List<[E]> tail);
}

\predicates {
   contains<[E]>(E, List<[E]>);
}

\functions{
	// append to lists
	List<[E]> app<[E]>(List<[E]>, List<[E]>);
	// revert a list
	List<[E]> rev<[E]>(List<[E]>);
}

\schemaVariables {
    \term List<[E]> list, list1;
    \term E e;
    \variables List<[E]> nv;
    \variables E el;
    \formula b;
}

\rules {
	// axioms
	concat_base{
        \find (app<[E]>(Nil<[E]>, list))
        \replacewith (list)
        \heuristics (LIST)
    };
	concat_step{
            \find( app<[E]>(Cons<[E]>(e, list1), list) )
	        \replacewith (Cons<[E]>(e, app<[E]>(list1,list) ))
		    \heuristics (LIST)};

	// definition of revert
	revert_base {\find (rev<[E]>(Nil<[E]>)) \replacewith(Nil<[E]>) };
	revert_step {\find (rev<[E]>(Cons<[E]>(e,list))) \replacewith (app<[E]>(rev<[E]>(list),Cons<[E]>(e,Nil<[E]>)))};
}

\problem {
	\forall List<[S]> l;( app<[S]>(l,Nil<[S]>)=l  )
}